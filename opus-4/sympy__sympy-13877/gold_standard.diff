From 341bfb15d02aa73a7b152e76073e0df1f2de0ed3 Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Tue, 9 Jan 2018 20:40:24 -0500
Subject: [PATCH 1/9] Numeric check for pivot being zero in Bareiss determinant
 method

Fixes #13835

Currently, the default determinant computation method, Bareiss,
accepts as a pivot any entry `!= 0`. This leads to "nan" output when
the pivot is a symbolic expression that simplifies to zero.
The added check to `_find_pivot` tests it for `== 0` after
substituting random rational numbers for any variables.
This has no noticeable impact on speed, and prevents zero pivot
choices in practice.
---
 sympy/matrices/matrices.py            | 15 +++++++++++++--
 sympy/matrices/tests/test_matrices.py |  8 ++++++++
 2 files changed, 21 insertions(+), 2 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 44b37f90b219..07a4f392d5f0 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -1,6 +1,7 @@
 from __future__ import print_function, division
 
 import collections
+import random
 from sympy.assumptions.refine import refine
 from sympy.core.add import Add
 from sympy.core.basic import Basic, Atom
@@ -8,7 +9,7 @@
 from sympy.core.power import Pow
 from sympy.core.symbol import (Symbol, Dummy, symbols,
     _uniquely_named_symbol)
-from sympy.core.numbers import Integer, ilcm, Float
+from sympy.core.numbers import Integer, ilcm, Float, Rational
 from sympy.core.singleton import S
 from sympy.core.sympify import sympify
 from sympy.functions.elementary.miscellaneous import sqrt, Max, Min
@@ -174,9 +175,19 @@ def _eval_det_bareiss(self):
         """
 
         # XXX included as a workaround for issue #12362.  Should use `_find_reasonable_pivot` instead
+        # As of 2018-01-09, `_find_reasonable_pivot` could be used but it slows down the computation,
+        # by the factor of 2.5 in one test. The issue #10279 is relevant.
+        # As a compromise, check for the value being nonzero at a random rational point
         def _find_pivot(l):
-            for pos,val in enumerate(l):
+            for pos, val in enumerate(l):
                 if val:
+                    variables = val.free_symbols
+                    if len(variables) > 0:
+                        substitutions = {v: Rational(random.choice((-1, 1)) * \
+                            random.randint(100, 200), random.randint(201, 300)) \
+                            for v in variables}
+                        if val.xreplace(substitutions) == 0:
+                            continue
                     return (pos, val, None, None)
             return (None, None, None, None)
 
diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py
index ed4924b7333a..ce347fdd2a53 100644
--- a/sympy/matrices/tests/test_matrices.py
+++ b/sympy/matrices/tests/test_matrices.py
@@ -402,6 +402,14 @@ def test_determinant():
     assert M.det(method="bareiss") == z**2 - x*y
     assert M.det(method="berkowitz") == z**2 - x*y
 
+    # issue 13835
+    a = symbols('a')
+    M = lambda n: Matrix([[i + a*j for i in range(n)] \
+        for j in range(n)])
+    assert M(5).det() == 0
+    assert M(6).det() == 0
+    assert M(7).det() == 0
+
 
 def test_det_LU_decomposition():
 

From 9c5fc6d9291fc6270a9dfd2c4057992da1061493 Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Wed, 10 Jan 2018 05:09:19 +0000
Subject: [PATCH 2/9] Test at multiple points to avoid erroneous rejection of
 good pivot

The number of points to try is negotiable, with five I still see only
minimal (2-3%) slowdown of .det method.
---
 sympy/matrices/matrices.py | 18 +++++++++++-------
 1 file changed, 11 insertions(+), 7 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 07a4f392d5f0..eae74c06332e 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -177,18 +177,22 @@ def _eval_det_bareiss(self):
         # XXX included as a workaround for issue #12362.  Should use `_find_reasonable_pivot` instead
         # As of 2018-01-09, `_find_reasonable_pivot` could be used but it slows down the computation,
         # by the factor of 2.5 in one test. The issue #10279 is relevant.
-        # As a compromise, check for the value being nonzero at a random rational point
+        # As a compromise, check for the value being nonzero at several random rational points
         def _find_pivot(l):
             for pos, val in enumerate(l):
                 if val:
                     variables = val.free_symbols
+                    good_pivot = True
                     if len(variables) > 0:
-                        substitutions = {v: Rational(random.choice((-1, 1)) * \
-                            random.randint(100, 200), random.randint(201, 300)) \
-                            for v in variables}
-                        if val.xreplace(substitutions) == 0:
-                            continue
-                    return (pos, val, None, None)
+                        for _ in range(5):
+                            substitutions = {v: random.randint(-10, 10) + Rational(
+                                random.randint(100, 200), random.randint(201, 300)) \
+                                for v in variables}
+                            if val.xreplace(substitutions) == 0:
+                                good_pivot = False
+                                break
+                    if good_pivot:
+                        return (pos, val, None, None)
             return (None, None, None, None)
 
 

From 40172a8b9783fcbc2d7df5c1a18baca15d05e29e Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Thu, 11 Jan 2018 06:30:22 +0000
Subject: [PATCH 3/9] Isolate the random-testing logic into an iszerofunc

The _find_reasonable_pivot function takes iszerofunc as a parameter.
Passing this new iszerofunc allows for much quicker, though less
reliable, determination of whether something is zero or not.
Works best for polynomials, but polynomials are the case that is
most likely to arise when computing determinants.
---
 sympy/matrices/matrices.py | 51 ++++++++++++++++++++------------------
 1 file changed, 27 insertions(+), 24 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index eae74c06332e..24980000d5b2 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -39,6 +39,28 @@ def _iszero(x):
         return None
 
 
+def _is_probably_zero(x):
+    """Returns True if x is probably zero, False if it is probably not,
+       None if undecided"""
+    try:
+        is_zero = x.is_zero
+    except AttributeError:
+        is_zero = None
+    if is_zero is None:
+        variables = x.free_symbols
+        if isinstance(variables, set) and len(variables) > 0:
+            for _ in range(5):
+                substitutions = {v: random.randint(-10, 10) + \
+                    + Rational(random.randint(100, 200), random.randint(201, 300)) \
+                    for v in variables}
+                if x.xreplace(substitutions) != 0:
+                    is_zero = False
+                    break
+            if is_zero is None:
+                is_zero = True
+    return is_zero
+
+
 class DeferredVector(Symbol, NotIterable):
     """A vector whose components are deferred (e.g. for use with lambdify)
 
@@ -174,28 +196,6 @@ def _eval_det_bareiss(self):
         http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.
         """
 
-        # XXX included as a workaround for issue #12362.  Should use `_find_reasonable_pivot` instead
-        # As of 2018-01-09, `_find_reasonable_pivot` could be used but it slows down the computation,
-        # by the factor of 2.5 in one test. The issue #10279 is relevant.
-        # As a compromise, check for the value being nonzero at several random rational points
-        def _find_pivot(l):
-            for pos, val in enumerate(l):
-                if val:
-                    variables = val.free_symbols
-                    good_pivot = True
-                    if len(variables) > 0:
-                        for _ in range(5):
-                            substitutions = {v: random.randint(-10, 10) + Rational(
-                                random.randint(100, 200), random.randint(201, 300)) \
-                                for v in variables}
-                            if val.xreplace(substitutions) == 0:
-                                good_pivot = False
-                                break
-                    if good_pivot:
-                        return (pos, val, None, None)
-            return (None, None, None, None)
-
-
         # Recursively implemented Bareiss' algorithm as per Deanna Richelle Leggett's
         # thesis http://www.math.usm.edu/perry/Research/Thesis_DRL.pdf
         def bareiss(mat, cumm=1):
@@ -205,8 +205,11 @@ def bareiss(mat, cumm=1):
                 return mat[0, 0]
 
             # find a pivot and extract the remaining matrix
-            # XXX should use `_find_reasonable_pivot`.  Blocked by issue #12362
-            pivot_pos, pivot_val, _, _ = _find_pivot(mat[:, 0])
+            # Wuth the default iszerofunc,  _find_reasonable_pivot slows down
+            # the compotation by the factor of 2.5 in one test.
+            # Relevant issues #10279 and #13877.
+            pivot_pos, pivot_val, _, _ = _find_reasonable_pivot(mat[:, 0],
+                                         iszerofunc=_is_probably_zero)
             if pivot_pos == None:
                 return S.Zero
 

From b534771222a98661c14f9119c71dea17fe4eea4b Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Tue, 16 Jan 2018 20:41:28 +0000
Subject: [PATCH 4/9] Moved the generation of rational numbers to randtest.py

Added tolerance parameter to random_complex_number so it can generates
rationals with controlled size of denominator. Expanded the docstring
of _is_probably_zero to explain how it works.
---
 sympy/matrices/matrices.py  | 15 +++++++++------
 sympy/utilities/randtest.py |  8 ++++++--
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 24980000d5b2..2818ff49b808 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -1,7 +1,6 @@
 from __future__ import print_function, division
 
 import collections
-import random
 from sympy.assumptions.refine import refine
 from sympy.core.add import Add
 from sympy.core.basic import Basic, Atom
@@ -19,6 +18,7 @@
 from sympy.simplify import simplify as _simplify, signsimp, nsimplify
 from sympy.core.compatibility import reduce, as_int, string_types
 
+from sympy.utilities.randtest import random_complex_number
 from sympy.utilities.iterables import flatten, numbered_symbols
 from sympy.core.decorators import call_highest_priority
 from sympy.core.compatibility import is_sequence, default_sort_key, range, \
@@ -40,8 +40,12 @@ def _iszero(x):
 
 
 def _is_probably_zero(x):
-    """Returns True if x is probably zero, False if it is probably not,
-       None if undecided"""
+    """Tests by plugging in random rational numbers. Returns True if several
+    substitution resulted in zero, otherwise returns False. Does not attempt
+    floating point evaluation or any symbolic simplification, thus returns
+    quickly. Suitable for polynomials and rational functions because, for
+    example, ``x*(x+1) - x - x**2`` evaluates to zero when any rational number
+    is plugged in."""
     try:
         is_zero = x.is_zero
     except AttributeError:
@@ -50,9 +54,8 @@ def _is_probably_zero(x):
         variables = x.free_symbols
         if isinstance(variables, set) and len(variables) > 0:
             for _ in range(5):
-                substitutions = {v: random.randint(-10, 10) + \
-                    + Rational(random.randint(100, 200), random.randint(201, 300)) \
-                    for v in variables}
+                substitutions = {v: random_complex_number(-5, 0, 5, 0, rational=True,
+                    tolerance=0.001) for v in variables}
                 if x.xreplace(substitutions) != 0:
                     is_zero = False
                     break
diff --git a/sympy/utilities/randtest.py b/sympy/utilities/randtest.py
index f5d350e21bb5..3791fe8de27c 100644
--- a/sympy/utilities/randtest.py
+++ b/sympy/utilities/randtest.py
@@ -13,17 +13,21 @@
 from sympy.core.compatibility import is_sequence, as_int
 
 
-def random_complex_number(a=2, b=-1, c=3, d=1, rational=False):
+def random_complex_number(a=2, b=-1, c=3, d=1, rational=False, tolerance=None):
     """
     Return a random complex number.
 
     To reduce chance of hitting branch cuts or anything, we guarantee
     b <= Im z <= d, a <= Re z <= c
+
+    When rational is True, a rational approximation to a random number
+    is obtained within specified tolerance, if any.
     """
     A, B = uniform(a, c), uniform(b, d)
     if not rational:
         return A + I*B
-    return nsimplify(A, rational=True) + I*nsimplify(B, rational=True)
+    return (nsimplify(A, rational=True, tolerance=tolerance) +
+        I*nsimplify(B, rational=True, tolerance=tolerance))
 
 
 def verify_numerically(f, g, z=None, tol=1.0e-6, a=2, b=-1, c=3, d=1):

From d454518d7d804ed6acfd3f35b8dd086c6b0a1ae8 Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Wed, 17 Jan 2018 19:14:39 +0000
Subject: [PATCH 5/9] Remove unused import

---
 sympy/matrices/matrices.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 2818ff49b808..c6d3294b86fe 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -8,7 +8,7 @@
 from sympy.core.power import Pow
 from sympy.core.symbol import (Symbol, Dummy, symbols,
     _uniquely_named_symbol)
-from sympy.core.numbers import Integer, ilcm, Float, Rational
+from sympy.core.numbers import Integer, ilcm, Float
 from sympy.core.singleton import S
 from sympy.core.sympify import sympify
 from sympy.functions.elementary.miscellaneous import sqrt, Max, Min

From 6004168149321090da0ac4d81fbde5a49db89f39 Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Wed, 17 Jan 2018 19:57:13 -0500
Subject: [PATCH 6/9] Typos in a comment

---
 sympy/matrices/matrices.py | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index c6d3294b86fe..70fc5b41065e 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -208,9 +208,9 @@ def bareiss(mat, cumm=1):
                 return mat[0, 0]
 
             # find a pivot and extract the remaining matrix
-            # Wuth the default iszerofunc,  _find_reasonable_pivot slows down
-            # the compotation by the factor of 2.5 in one test.
-            # Relevant issues #10279 and #13877.
+            # With the default iszerofunc, _find_reasonable_pivot slows down
+            # the computation by the factor of 2.5 in one test.
+            # Relevant issues: #10279 and #13877.
             pivot_pos, pivot_val, _, _ = _find_reasonable_pivot(mat[:, 0],
                                          iszerofunc=_is_probably_zero)
             if pivot_pos == None:

From e93223b35688cf508fc8aa81333344133e6a675b Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Wed, 24 Jan 2018 23:26:13 -0500
Subject: [PATCH 7/9] Move test_at_rationals function to randtest

Isolated the testing logic to randtest. Added
randomize flag, so that testing can be made non-random.
Used non-random testing in pivot search, to make
the computation of a determinant deterministic.
---
 sympy/matrices/matrices.py            | 27 +++-----------
 sympy/matrices/tests/test_matrices.py |  4 +--
 sympy/utilities/randtest.py           | 51 +++++++++++++++++++++++++++
 3 files changed, 57 insertions(+), 25 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 70fc5b41065e..395e16e403de 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -18,7 +18,7 @@
 from sympy.simplify import simplify as _simplify, signsimp, nsimplify
 from sympy.core.compatibility import reduce, as_int, string_types
 
-from sympy.utilities.randtest import random_complex_number
+from sympy.utilities.randtest import test_at_rationals
 from sympy.utilities.iterables import flatten, numbered_symbols
 from sympy.core.decorators import call_highest_priority
 from sympy.core.compatibility import is_sequence, default_sort_key, range, \
@@ -40,28 +40,9 @@ def _iszero(x):
 
 
 def _is_probably_zero(x):
-    """Tests by plugging in random rational numbers. Returns True if several
-    substitution resulted in zero, otherwise returns False. Does not attempt
-    floating point evaluation or any symbolic simplification, thus returns
-    quickly. Suitable for polynomials and rational functions because, for
-    example, ``x*(x+1) - x - x**2`` evaluates to zero when any rational number
-    is plugged in."""
-    try:
-        is_zero = x.is_zero
-    except AttributeError:
-        is_zero = None
-    if is_zero is None:
-        variables = x.free_symbols
-        if isinstance(variables, set) and len(variables) > 0:
-            for _ in range(5):
-                substitutions = {v: random_complex_number(-5, 0, 5, 0, rational=True,
-                    tolerance=0.001) for v in variables}
-                if x.xreplace(substitutions) != 0:
-                    is_zero = False
-                    break
-            if is_zero is None:
-                is_zero = True
-    return is_zero
+    """Tests by plugging in several rational numbers. Returns True if all
+    substitutions resulted in zero, otherwise returns False."""
+    return test_at_rationals(x, 0, attempts=5, a=-5, b=5, digits=3, randomize=False)
 
 
 class DeferredVector(Symbol, NotIterable):
diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py
index ce347fdd2a53..995ee33b474c 100644
--- a/sympy/matrices/tests/test_matrices.py
+++ b/sympy/matrices/tests/test_matrices.py
@@ -404,8 +404,8 @@ def test_determinant():
 
     # issue 13835
     a = symbols('a')
-    M = lambda n: Matrix([[i + a*j for i in range(n)] \
-        for j in range(n)])
+    M = lambda n: Matrix([[i + a*j for i in range(n)]
+                          for j in range(n)])
     assert M(5).det() == 0
     assert M(6).det() == 0
     assert M(7).det() == 0
diff --git a/sympy/utilities/randtest.py b/sympy/utilities/randtest.py
index 3791fe8de27c..8038282ac8b2 100644
--- a/sympy/utilities/randtest.py
+++ b/sympy/utilities/randtest.py
@@ -11,6 +11,7 @@
 from sympy.core.numbers import comp
 from sympy.core.symbol import Symbol
 from sympy.core.compatibility import is_sequence, as_int
+from sympy.functions.elementary.miscellaneous import sqrt
 
 
 def random_complex_number(a=2, b=-1, c=3, d=1, rational=False, tolerance=None):
@@ -56,6 +57,56 @@ def verify_numerically(f, g, z=None, tol=1.0e-6, a=2, b=-1, c=3, d=1):
     return comp(z1, z2, tol)
 
 
+def test_at_rationals(f, g, z=None, attempts=5, a=-5, b=5, digits=3,
+        randomize=True):
+    """
+    Tests whether f and g yield exactly the same expression when symbol
+    z is replaced by a rational number. Does not attempt floating point
+    evaluation or any symbolic simplification, thus returns quickly.
+    Suitable for polynomials with rational coefficients because, for
+    example, ``x*(x+1) - x - x**2`` evaluates to zero when any rational
+    number is plugged in.
+
+    If z is None, all symbols will be tested. The test consists of n
+    substitutions of rational numbers, which are taken from interval
+    [a, b]. The parameter digits prescribes the approximate number of
+    digits in the denominator.
+
+    Examples
+    ========
+
+    >>> from sympy.abc import x
+    >>> from sympy.utilities.randtest import test_at_rationals
+    >>> test_at_rationals(x*(x + 1), x + x**2)
+    True
+    """
+    f, g, z = Tuple(f, g, z)
+    h = f - g
+    z = {z} if isinstance(z, Symbol) else h.free_symbols
+    if not z:
+        return h == 0
+    tol = 10**(-digits)
+    if randomize:   # use random rational numbers
+        for _ in range(attempts):
+            substitutions = {v: random_complex_number(a, 0, b, 0, rational=True,
+                tolerance=tol) for v in z}
+            if h.xreplace(substitutions) != 0:
+                return False
+    else:  # use cyclic shifts by golden ratio within [a, b]
+        counter = 0
+        golden_ratio = ((sqrt(5) + 1)/2).n(digits + 1)
+        z = sorted(list(z), key=lambda v: v.name)
+        for _ in range(attempts):
+            substitutions = {}
+            for v in z:
+                counter += 1
+                x = a + (counter*golden_ratio % 1)*(b - a)
+                substitutions[v] = nsimplify(x, rational=True, tolerance=tol)
+            if h.xreplace(substitutions) != 0:
+                return False
+    return True
+
+
 def test_derivative_numerically(f, z, tol=1.0e-6, a=2, b=-1, c=3, d=1):
     """
     Test numerically that the symbolically computed derivative of f

From 51b9c82e2eef9961825a62fd703a7ca6964df55e Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Thu, 25 Jan 2018 10:48:38 -0500
Subject: [PATCH 8/9] Test by expand_mul instead of random rationals

Might be slightly slower - 88s vs 84 seconds in my test of 10 M.det()
calculations with M being
Matrix([[i + a*j + S(1)/(i+j+1) for i in range(7)] for j in range(7)])
But this is likely to have fewer incorrect results than the previous
testing method.
---
 sympy/matrices/matrices.py | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/sympy/matrices/matrices.py b/sympy/matrices/matrices.py
index 395e16e403de..2eaf29e4beb4 100644
--- a/sympy/matrices/matrices.py
+++ b/sympy/matrices/matrices.py
@@ -5,6 +5,7 @@
 from sympy.core.add import Add
 from sympy.core.basic import Basic, Atom
 from sympy.core.expr import Expr
+from sympy.core.function import expand_mul
 from sympy.core.power import Pow
 from sympy.core.symbol import (Symbol, Dummy, symbols,
     _uniquely_named_symbol)
@@ -18,11 +19,10 @@
 from sympy.simplify import simplify as _simplify, signsimp, nsimplify
 from sympy.core.compatibility import reduce, as_int, string_types
 
-from sympy.utilities.randtest import test_at_rationals
 from sympy.utilities.iterables import flatten, numbered_symbols
 from sympy.core.decorators import call_highest_priority
-from sympy.core.compatibility import is_sequence, default_sort_key, range, \
-    NotIterable
+from sympy.core.compatibility import (is_sequence, default_sort_key, range,
+    NotIterable)
 
 
 from types import FunctionType
@@ -39,10 +39,10 @@ def _iszero(x):
         return None
 
 
-def _is_probably_zero(x):
-    """Tests by plugging in several rational numbers. Returns True if all
-    substitutions resulted in zero, otherwise returns False."""
-    return test_at_rationals(x, 0, attempts=5, a=-5, b=5, digits=3, randomize=False)
+def _is_zero_after_expand_mul(x):
+    """Tests by expand_mul only, suitable for polynomials and rational
+    functions."""
+    return expand_mul(x) == 0
 
 
 class DeferredVector(Symbol, NotIterable):
@@ -193,7 +193,7 @@ def bareiss(mat, cumm=1):
             # the computation by the factor of 2.5 in one test.
             # Relevant issues: #10279 and #13877.
             pivot_pos, pivot_val, _, _ = _find_reasonable_pivot(mat[:, 0],
-                                         iszerofunc=_is_probably_zero)
+                                         iszerofunc=_is_zero_after_expand_mul)
             if pivot_pos == None:
                 return S.Zero
 

From a8cea3a2045d31e11f5757d2f9e9e858fa0a8407 Mon Sep 17 00:00:00 2001
From: Leonid Kovalev <normalhuman@users.noreply.github.com>
Date: Sat, 27 Jan 2018 12:34:27 -0500
Subject: [PATCH 9/9] Remove the random rational test from utilities

It was not in use anymore.
---
 sympy/utilities/randtest.py | 51 -------------------------------------
 1 file changed, 51 deletions(-)

diff --git a/sympy/utilities/randtest.py b/sympy/utilities/randtest.py
index 8038282ac8b2..3791fe8de27c 100644
--- a/sympy/utilities/randtest.py
+++ b/sympy/utilities/randtest.py
@@ -11,7 +11,6 @@
 from sympy.core.numbers import comp
 from sympy.core.symbol import Symbol
 from sympy.core.compatibility import is_sequence, as_int
-from sympy.functions.elementary.miscellaneous import sqrt
 
 
 def random_complex_number(a=2, b=-1, c=3, d=1, rational=False, tolerance=None):
@@ -57,56 +56,6 @@ def verify_numerically(f, g, z=None, tol=1.0e-6, a=2, b=-1, c=3, d=1):
     return comp(z1, z2, tol)
 
 
-def test_at_rationals(f, g, z=None, attempts=5, a=-5, b=5, digits=3,
-        randomize=True):
-    """
-    Tests whether f and g yield exactly the same expression when symbol
-    z is replaced by a rational number. Does not attempt floating point
-    evaluation or any symbolic simplification, thus returns quickly.
-    Suitable for polynomials with rational coefficients because, for
-    example, ``x*(x+1) - x - x**2`` evaluates to zero when any rational
-    number is plugged in.
-
-    If z is None, all symbols will be tested. The test consists of n
-    substitutions of rational numbers, which are taken from interval
-    [a, b]. The parameter digits prescribes the approximate number of
-    digits in the denominator.
-
-    Examples
-    ========
-
-    >>> from sympy.abc import x
-    >>> from sympy.utilities.randtest import test_at_rationals
-    >>> test_at_rationals(x*(x + 1), x + x**2)
-    True
-    """
-    f, g, z = Tuple(f, g, z)
-    h = f - g
-    z = {z} if isinstance(z, Symbol) else h.free_symbols
-    if not z:
-        return h == 0
-    tol = 10**(-digits)
-    if randomize:   # use random rational numbers
-        for _ in range(attempts):
-            substitutions = {v: random_complex_number(a, 0, b, 0, rational=True,
-                tolerance=tol) for v in z}
-            if h.xreplace(substitutions) != 0:
-                return False
-    else:  # use cyclic shifts by golden ratio within [a, b]
-        counter = 0
-        golden_ratio = ((sqrt(5) + 1)/2).n(digits + 1)
-        z = sorted(list(z), key=lambda v: v.name)
-        for _ in range(attempts):
-            substitutions = {}
-            for v in z:
-                counter += 1
-                x = a + (counter*golden_ratio % 1)*(b - a)
-                substitutions[v] = nsimplify(x, rational=True, tolerance=tol)
-            if h.xreplace(substitutions) != 0:
-                return False
-    return True
-
-
 def test_derivative_numerically(f, z, tol=1.0e-6, a=2, b=-1, c=3, d=1):
     """
     Test numerically that the symbolically computed derivative of f
