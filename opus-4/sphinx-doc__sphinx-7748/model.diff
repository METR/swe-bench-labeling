diff --git a/fix_multiple_signatures.py b/fix_multiple_signatures.py
new file mode 100644
index 000000000..1ddc24cfd
--- /dev/null
+++ b/fix_multiple_signatures.py
@@ -0,0 +1,82 @@
+"""
+This script shows the proposed fix for handling multiple overloaded signatures
+in docstrings when using autodoc_docstring_signature.
+"""
+
+import re
+from typing import List, Tuple, Optional
+
+# The regex from sphinx autodoc
+py_ext_sig_re = re.compile(
+    r'''^ ([\w.]+::)?            # explicit module name
+          ([\w.]+\.)?            # module and/or class name(s)
+          (\w+)  \s*             # thing name
+          (?: \((.*)\)           # optional: arguments
+           (?:\s* -> \s* (.*))?  #           return annotation
+          )? $                   # and nothing more
+          ''', re.VERBOSE)
+
+
+def find_all_signatures(doclines: List[str], valid_names: List[str]) -> List[Tuple[str, str]]:
+    """
+    Find all consecutive signature lines at the beginning of a docstring.
+    
+    Returns a list of (args, retann) tuples for each found signature.
+    """
+    signatures = []
+    
+    for i, line in enumerate(doclines):
+        # Try to match the line (with leading/trailing whitespace stripped)
+        match = py_ext_sig_re.match(line.strip())
+        if not match:
+            # Stop at the first non-signature line
+            break
+            
+        exmod, path, base, args, retann = match.groups()
+        
+        # Check if the base name is valid
+        if base in valid_names:
+            signatures.append((args, retann))
+    
+    return signatures
+
+
+def format_multiple_signatures(signatures: List[Tuple[str, str]], sep: str = "\n") -> str:
+    """
+    Format multiple signatures into a single string.
+    
+    Each signature is formatted as (args) -> retann or just (args) if no retann.
+    """
+    formatted = []
+    for args, retann in signatures:
+        if args is not None:
+            sig = "(%s)" % args
+            if retann:
+                sig += " -> %s" % retann
+            formatted.append(sig)
+    
+    return sep.join(formatted)
+
+
+# Test the implementation
+if __name__ == "__main__":
+    # Test docstring with multiple signatures
+    docstring = """overloaded_method(self) -> None
+        overloaded_method(self, x: int) -> int
+        overloaded_method(self, x: int, y: int) -> int
+        
+        This method has multiple overloaded signatures.
+        This is common in SWIG-wrapped C++ code.
+        """
+    
+    lines = docstring.strip().split('\n')
+    valid_names = ['overloaded_method']
+    
+    signatures = find_all_signatures(lines, valid_names)
+    
+    print("Found signatures:")
+    for args, retann in signatures:
+        print(f"  args: {args}, retann: {retann}")
+    
+    print("\nFormatted signatures:")
+    print(format_multiple_signatures(signatures))
diff --git a/setup.py b/setup.py
index 5e822fe9b..77b63df38 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.12',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index f8e4be999..e2d66903a 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -1037,39 +1037,61 @@ class DocstringSignatureMixin:
     feature of reading the signature from the docstring.
     """
 
-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
-        if encoding is not None:
-            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
-                          "deprecated." % self.__class__.__name__,
-                          RemovedInSphinx40Warning, stacklevel=2)
+    def _find_signatures(self) -> List[Tuple[str, str]]:
+        """Find all signatures from the beginning of the docstring."""
         docstrings = self.get_doc()
         self._new_docstrings = docstrings[:]
-        result = None
+        signatures = []
+        
         for i, doclines in enumerate(docstrings):
             # no lines in docstring, no match
             if not doclines:
                 continue
-            # match first line of docstring against signature RE
-            match = py_ext_sig_re.match(doclines[0])
-            if not match:
-                continue
-            exmod, path, base, args, retann = match.groups()
+                
             # the base name must match ours
             valid_names = [self.objpath[-1]]  # type: ignore
             if isinstance(self, ClassDocumenter):
                 valid_names.append('__init__')
                 if hasattr(self.object, '__mro__'):
                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)
-            if base not in valid_names:
-                continue
-            # re-prepare docstring to ignore more leading indentation
-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore
-            self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
-                                                        tabsize=tab_width)
-            result = args, retann
-            # don't look any further
-            break
-        return result
+            
+            # Look for consecutive signatures at the beginning
+            last_sig_line = -1
+            for j, line in enumerate(doclines):
+                # match line against signature RE (strip whitespace first)
+                match = py_ext_sig_re.match(line.strip())
+                if not match:
+                    # Stop at first non-signature line
+                    break
+                    
+                exmod, path, base, args, retann = match.groups()
+                if base in valid_names:
+                    signatures.append((args, retann))
+                    last_sig_line = j
+            
+            if signatures:
+                # re-prepare docstring to ignore the signature lines
+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore
+                self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[last_sig_line + 1:]),
+                                                            tabsize=tab_width)
+                # don't look any further
+                break
+                
+        return signatures
+    
+    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
+        if encoding is not None:
+            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
+                          "deprecated." % self.__class__.__name__,
+                          RemovedInSphinx40Warning, stacklevel=2)
+        
+        # Find all signatures
+        signatures = self._find_signatures()
+        
+        # For backward compatibility, return only the first signature
+        if signatures:
+            return signatures[0]
+        return None
 
     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
         if encoding is not None:
@@ -1085,9 +1107,25 @@ class DocstringSignatureMixin:
         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
             # only act if a signature is not explicitly given already, and if
             # the feature is enabled
-            result = self._find_signature()
-            if result is not None:
-                self.args, self.retann = result
+            signatures = self._find_signatures()
+            if signatures:
+                if len(signatures) == 1:
+                    # Single signature, use the normal flow
+                    self.args, self.retann = signatures[0]
+                else:
+                    # Multiple signatures, format each one separately
+                    sig_strs = []
+                    for args, retann in signatures:
+                        if args is not None:
+                            sig = "(%s)" % args
+                            if retann:
+                                sig += " -> %s" % retann
+                            sig_strs.append(sig)
+                    
+                    if sig_strs:
+                        # Return multiple signatures separated by newlines
+                        return '\n'.join(sig_strs)
+        
         return super().format_signature(**kwargs)  # type: ignore
 
 
diff --git a/test_current_behavior.py b/test_current_behavior.py
new file mode 100644
index 000000000..198679eba
--- /dev/null
+++ b/test_current_behavior.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python3
+"""Test current behavior of autodoc with overloaded signatures."""
+
+import os
+import sys
+sys.path.insert(0, os.path.abspath('.'))
+
+# Create a test module
+with open('test_module.py', 'w') as f:
+    f.write('''
+class TestClass:
+    def overloaded_method(self):
+        """overloaded_method(self) -> None
+        overloaded_method(self, x: int) -> int  
+        overloaded_method(self, x: int, y: int) -> int
+        
+        This method has multiple overloaded signatures.
+        This is common in SWIG-wrapped C++ code.
+        """
+        pass
+''')
+
+# Create a simple Sphinx test
+from sphinx.testing.path import path
+from sphinx.testing.util import SphinxTestApp
+from tempfile import TemporaryDirectory
+
+with TemporaryDirectory() as tmpdir:
+    srcdir = path(tmpdir) / 'src'
+    srcdir.makedirs()
+    
+    # Create conf.py
+    (srcdir / 'conf.py').write_text('''
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+    
+    # Create index.rst
+    (srcdir / 'index.rst').write_text('''
+.. autoclass:: test_module.TestClass
+   :members:
+''')
+    
+    # Copy test module
+    import shutil
+    shutil.copy('test_module.py', str(srcdir))
+    
+    # Build docs
+    app = SphinxTestApp('text', srcdir=srcdir)
+    app.build()
+    
+    # Check output
+    output_file = app.outdir / 'index.txt'
+    if output_file.exists():
+        print("Generated documentation:")
+        print(output_file.read_text())
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 000000000..c2bc5ae82
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python3
+"""Test the fix for overloaded method signatures."""
+
+import sys
+import os
+sys.path.insert(0, os.path.abspath('.'))
+
+# Create test target module
+test_code = '''
+class OverloadedClass:
+    def overloaded_method(self):
+        """overloaded_method(self) -> None
+        overloaded_method(self, x: int) -> int
+        overloaded_method(self, x: int, y: int) -> int
+        
+        This method has multiple overloaded signatures.
+        This is common in SWIG-wrapped C++ code.
+        """
+        pass
+    
+    def single_sig_method(self):
+        """single_sig_method(self, arg: str) -> bool
+        
+        This has only one signature line.
+        """
+        pass
+    
+    def no_sig_method(self):
+        """This method has no signature in docstring."""
+        pass
+'''
+
+# Write test module
+with open('test_overloaded.py', 'w') as f:
+    f.write(test_code)
+
+# Test the updated autodoc
+from sphinx.ext.autodoc import ModuleLevelDocumenter, FunctionDocumenter, MethodDocumenter
+from sphinx.testing.fixtures import make_app
+from sphinx.testing.path import path
+from sphinx.util.docutils import SphinxDirective
+from docutils.statemachine import StringList
+from docutils.parsers.rst import directives
+
+import tempfile
+import shutil
+
+with tempfile.TemporaryDirectory() as tmpdir:
+    srcdir = path(tmpdir) / 'src' 
+    srcdir.makedirs()
+    
+    # Copy test module
+    shutil.copy('test_overloaded.py', str(srcdir))
+    
+    # Create minimal conf.py
+    (srcdir / 'conf.py').write_text('''
+import sys
+sys.path.insert(0, '.')
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+    
+    # Create minimal index.rst
+    (srcdir / 'index.rst').write_text('''
+Test
+====
+
+.. automodule:: test_overloaded
+   :members:
+   :undoc-members:
+''')
+    
+    # Build with text builder to see output
+    from sphinx.cmd.build import build_main
+    argv = ['-b', 'text', str(srcdir), str(srcdir / '_build')]
+    build_main(argv)
+    
+    # Check output
+    output_file = srcdir / '_build' / 'index.txt'
+    if output_file.exists():
+        print("Generated documentation:")
+        print("=" * 60)
+        print(output_file.read_text())
+        print("=" * 60)
diff --git a/test_overloaded.py b/test_overloaded.py
new file mode 100644
index 000000000..1ccc2dbf0
--- /dev/null
+++ b/test_overloaded.py
@@ -0,0 +1,22 @@
+
+class OverloadedClass:
+    def overloaded_method(self):
+        """overloaded_method(self) -> None
+        overloaded_method(self, x: int) -> int
+        overloaded_method(self, x: int, y: int) -> int
+        
+        This method has multiple overloaded signatures.
+        This is common in SWIG-wrapped C++ code.
+        """
+        pass
+    
+    def single_sig_method(self):
+        """single_sig_method(self, arg: str) -> bool
+        
+        This has only one signature line.
+        """
+        pass
+    
+    def no_sig_method(self):
+        """This method has no signature in docstring."""
+        pass
diff --git a/test_overloaded_autodoc.py b/test_overloaded_autodoc.py
new file mode 100644
index 000000000..e5ff7b0f2
--- /dev/null
+++ b/test_overloaded_autodoc.py
@@ -0,0 +1,77 @@
+"""Test autodoc with overloaded method signatures."""
+
+import pytest
+
+@pytest.mark.sphinx('html', testroot='ext-autodoc')  
+def test_autodoc_overloaded_signatures(app):
+    # Create a test module with overloaded signatures
+    test_py = app.srcdir / 'target' / 'overloaded.py'
+    test_py.write_text('''
+class OverloadedMethods:
+    def overloaded(self):
+        """overloaded(self) -> None
+        overloaded(self, x: int) -> int
+        overloaded(self, x: int, y: int) -> int
+        
+        Method with multiple overloaded signatures.
+        """
+        pass
+    
+    def single_sig(self):
+        """single_sig(self, arg: str) -> bool
+        
+        Method with single signature.
+        """
+        pass
+''')
+    
+    # Test with autodoc
+    from test_ext_autodoc import do_autodoc
+    
+    # Test class with overloaded methods
+    options = {"members": None}
+    actual = do_autodoc(app, 'class', 'target.overloaded.OverloadedMethods', options)
+    
+    # Convert to list for easier checking
+    lines = list(actual)
+    
+    # Find the overloaded method signature lines
+    overloaded_idx = None
+    for i, line in enumerate(lines):
+        if 'overloaded(self) -> None' in line:
+            overloaded_idx = i
+            break
+    
+    assert overloaded_idx is not None, "First signature not found"
+    
+    # Check that all three signatures are present on consecutive lines
+    assert 'overloaded(self) -> None' in lines[overloaded_idx]
+    assert 'overloaded(self, x: int) -> int' in lines[overloaded_idx + 1]
+    assert 'overloaded(self, x: int, y: int) -> int' in lines[overloaded_idx + 2]
+    
+    # Check that the docstring content follows after signatures
+    found_docstring = False
+    for i in range(overloaded_idx + 3, len(lines)):
+        if 'Method with multiple overloaded signatures' in lines[i]:
+            found_docstring = True
+            break
+    assert found_docstring, "Docstring content not found after signatures"
+    
+    # Check single signature method works as before
+    single_idx = None
+    for i, line in enumerate(lines):
+        if 'single_sig(self, arg: str) -> bool' in line:
+            single_idx = i
+            break
+    
+    assert single_idx is not None, "Single signature method not found"
+    
+    # The single signature should not have extra lines
+    assert 'Method with single signature' in lines[single_idx + 3]
+
+
+if __name__ == '__main__':
+    import sys
+    import os
+    sys.path.insert(0, os.path.dirname(__file__))
+    pytest.main([__file__, '-xvs'])
diff --git a/test_overloaded_signatures.py b/test_overloaded_signatures.py
new file mode 100644
index 000000000..c320a9fee
--- /dev/null
+++ b/test_overloaded_signatures.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python3
+"""Test case to demonstrate the issue with overloaded method signatures."""
+
+class OverloadedClass:
+    def overloaded_method(self):
+        """overloaded_method(self) -> None
+        overloaded_method(self, x: int) -> int
+        overloaded_method(self, x: int, y: int) -> int
+        
+        This method has multiple overloaded signatures.
+        This is common in SWIG-wrapped C++ code.
+        """
+        pass
+
+# Test that we can see the issue
+if __name__ == "__main__":
+    import re
+    
+    # The regex from sphinx autodoc
+    py_ext_sig_re = re.compile(
+        r'''^ ([\w.]+::)?            # explicit module name
+              ([\w.]+\.)?            # module and/or class name(s)
+              (\w+)  \s*             # thing name
+              (?: \((.*)\)           # optional: arguments
+               (?:\s* -> \s* (.*))?  #           return annotation
+              )? $                   # and nothing more
+              ''', re.VERBOSE)
+    
+    docstring = OverloadedClass.overloaded_method.__doc__
+    lines = docstring.strip().split('\n')
+    
+    print("Docstring lines:")
+    for i, line in enumerate(lines):
+        print(f"  {i}: {line}")
+    
+    print("\nMatching signatures:")
+    for i, line in enumerate(lines):
+        match = py_ext_sig_re.match(line)
+        if match:
+            print(f"  Line {i}: {line}")
+            print(f"    Groups: {match.groups()}")
diff --git a/tests/test_overloaded_autodoc.py b/tests/test_overloaded_autodoc.py
new file mode 100644
index 000000000..e5ff7b0f2
--- /dev/null
+++ b/tests/test_overloaded_autodoc.py
@@ -0,0 +1,77 @@
+"""Test autodoc with overloaded method signatures."""
+
+import pytest
+
+@pytest.mark.sphinx('html', testroot='ext-autodoc')  
+def test_autodoc_overloaded_signatures(app):
+    # Create a test module with overloaded signatures
+    test_py = app.srcdir / 'target' / 'overloaded.py'
+    test_py.write_text('''
+class OverloadedMethods:
+    def overloaded(self):
+        """overloaded(self) -> None
+        overloaded(self, x: int) -> int
+        overloaded(self, x: int, y: int) -> int
+        
+        Method with multiple overloaded signatures.
+        """
+        pass
+    
+    def single_sig(self):
+        """single_sig(self, arg: str) -> bool
+        
+        Method with single signature.
+        """
+        pass
+''')
+    
+    # Test with autodoc
+    from test_ext_autodoc import do_autodoc
+    
+    # Test class with overloaded methods
+    options = {"members": None}
+    actual = do_autodoc(app, 'class', 'target.overloaded.OverloadedMethods', options)
+    
+    # Convert to list for easier checking
+    lines = list(actual)
+    
+    # Find the overloaded method signature lines
+    overloaded_idx = None
+    for i, line in enumerate(lines):
+        if 'overloaded(self) -> None' in line:
+            overloaded_idx = i
+            break
+    
+    assert overloaded_idx is not None, "First signature not found"
+    
+    # Check that all three signatures are present on consecutive lines
+    assert 'overloaded(self) -> None' in lines[overloaded_idx]
+    assert 'overloaded(self, x: int) -> int' in lines[overloaded_idx + 1]
+    assert 'overloaded(self, x: int, y: int) -> int' in lines[overloaded_idx + 2]
+    
+    # Check that the docstring content follows after signatures
+    found_docstring = False
+    for i in range(overloaded_idx + 3, len(lines)):
+        if 'Method with multiple overloaded signatures' in lines[i]:
+            found_docstring = True
+            break
+    assert found_docstring, "Docstring content not found after signatures"
+    
+    # Check single signature method works as before
+    single_idx = None
+    for i, line in enumerate(lines):
+        if 'single_sig(self, arg: str) -> bool' in line:
+            single_idx = i
+            break
+    
+    assert single_idx is not None, "Single signature method not found"
+    
+    # The single signature should not have extra lines
+    assert 'Method with single signature' in lines[single_idx + 3]
+
+
+if __name__ == '__main__':
+    import sys
+    import os
+    sys.path.insert(0, os.path.dirname(__file__))
+    pytest.main([__file__, '-xvs'])
diff --git a/tox.ini b/tox.ini
index d9f040544..bf39854b6 100644
--- a/tox.ini
+++ b/tox.ini
@@ -28,7 +28,7 @@ extras =
 setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils
 commands=
-    pytest --durations 25 {posargs}
+    pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3
