{"instance_id": "django__django-15732", "score": "I", "diff": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df9..3f41864d77 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -568,6 +568,20 @@ class BaseDatabaseSchemaEditor:\n             exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs,\n         )\n+        # When deleting unique constraints, if we find multiple constraints,\n+        # it might be because one is a primary key constraint and one is a\n+        # unique_together constraint. Filter out primary key constraints.\n+        if len(constraint_names) > 1 and constraint_kwargs.get(\"unique\"):\n+            # Get all constraint info to filter out primary keys\n+            with self.connection.cursor() as cursor:\n+                constraints = self.connection.introspection.get_constraints(\n+                    cursor, model._meta.db_table\n+                )\n+            # Filter out primary key constraints\n+            constraint_names = [\n+                name for name in constraint_names\n+                if not constraints.get(name, {}).get(\"primary_key\", False)\n+            ]\n         if len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..e470a0227b\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,139 @@\n+#!/usr/bin/env python\n+\"\"\"Test the fix for unique_together constraint on primary key\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django with minimal settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+\n+# Define a test model with unique_together on primary key\n+class TestModel(models.Model):\n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_unique_together_pk'\n+        unique_together = [['id']]  # This is the problematic constraint\n+    \n+    name = models.CharField(max_length=100)\n+\n+# Test _delete_composed_index directly\n+from django.db.backends.base import schema\n+\n+# Mock the necessary methods for testing\n+class MockSchemaEditor(schema.BaseDatabaseSchemaEditor):\n+    def __init__(self):\n+        self.connection = connection\n+        self.collected_sql = []\n+        \n+    def execute(self, sql, params=None):\n+        # Just collect the SQL, don't execute it\n+        self.collected_sql.append(sql)\n+        \n+    def _constraint_names(self, model, column_names=None, unique=None, \n+                         primary_key=None, index=None, foreign_key=None, \n+                         check=None, type_=None, exclude=None):\n+        \"\"\"Mock _constraint_names to simulate PostgreSQL behavior with two constraints on id\"\"\"\n+        result = []\n+        \n+        # If we're looking for unique constraints on 'id' column\n+        if column_names == ['id'] and unique is True:\n+            # Simulate having both a primary key constraint and unique_together constraint\n+            if primary_key is None:\n+                # When primary_key is not specified, return both\n+                result.append('test_unique_together_pk_pkey')  # Primary key constraint\n+                result.append('test_unique_together_pk_id_1c3b3088c74c3b17_uniq')  # unique_together\n+            elif primary_key is False:\n+                # When explicitly excluding primary keys, only return unique_together\n+                result.append('test_unique_together_pk_id_1c3b3088c74c3b17_uniq')\n+                \n+        if exclude:\n+            result = [name for name in result if name not in exclude]\n+        \n+        return result\n+    \n+    def _delete_constraint_sql(self, sql, model, name):\n+        return f\"DROP CONSTRAINT {name}\"\n+\n+# Test the fix\n+editor = MockSchemaEditor()\n+\n+print(\"Testing _delete_composed_index with unique_together on primary key field...\")\n+print(\"\\nBefore fix: Looking for unique constraints would find both primary key and unique_together\")\n+print(\"This would cause 'Found wrong number (2) of constraints' error\")\n+\n+try:\n+    # This should work with our fix\n+    editor._delete_composed_index(\n+        TestModel,\n+        ['id'],  # fields  \n+        {\"unique\": True},  # constraint_kwargs\n+        \"DROP INDEX\"  # sql template\n+    )\n+    print(\"\\nAfter fix: Successfully found only the unique_together constraint!\")\n+    print(\"Collected SQL:\", editor.collected_sql)\n+    print(\"\\nSUCCESS: The fix correctly excludes primary key constraints when deleting unique_together!\")\n+except ValueError as e:\n+    print(f\"\\nERROR: {e}\")\n+    print(\"The fix did not work as expected.\")\n+    \n+# Also test that other operations still work correctly\n+print(\"\\n\" + \"=\"*60)\n+print(\"Testing that the fix doesn't break other constraint lookups...\")\n+\n+# Reset collected SQL\n+editor.collected_sql = []\n+\n+# Mock different scenarios\n+class TestModel2(models.Model):\n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_normal_unique'\n+        unique_together = [['name', 'email']]\n+    \n+    name = models.CharField(max_length=100)\n+    email = models.EmailField()\n+\n+# Override _constraint_names for this test\n+def mock_normal_constraint_names(self, model, column_names=None, unique=None, \n+                               primary_key=None, index=None, foreign_key=None, \n+                               check=None, type_=None, exclude=None):\n+    \"\"\"Mock for normal unique_together (not on primary key)\"\"\"\n+    result = []\n+    \n+    if column_names == ['name', 'email'] and unique is True:\n+        # Normal case: only one unique constraint\n+        result.append('test_normal_unique_name_email_uniq')\n+        \n+    return result\n+\n+editor._constraint_names = mock_normal_constraint_names\n+\n+try:\n+    editor._delete_composed_index(\n+        TestModel2,\n+        ['name', 'email'],\n+        {\"unique\": True},\n+        \"DROP INDEX\"\n+    )\n+    print(\"Normal unique_together deletion still works correctly!\")\n+    print(\"Collected SQL:\", editor.collected_sql)\n+except ValueError as e:\n+    print(f\"ERROR: Normal case broken: {e}\")\ndiff --git a/test_fix_v2.py b/test_fix_v2.py\nnew file mode 100644\nindex 0000000000..591fcddf51\n--- /dev/null\n+++ b/test_fix_v2.py\n@@ -0,0 +1,185 @@\n+#!/usr/bin/env python\n+\"\"\"Test the fix for unique_together constraint on primary key\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django with minimal settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.backends.base import schema\n+\n+# Define a test model with unique_together on primary key\n+class TestModel(models.Model):\n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_unique_together_pk'\n+        unique_together = [['id']]  # This is the problematic constraint\n+    \n+    name = models.CharField(max_length=100)\n+\n+# Mock connection and introspection\n+class MockCursor:\n+    def execute(self, sql, params=None):\n+        pass\n+    def fetchall(self):\n+        return []\n+    def __enter__(self):\n+        return self\n+    def __exit__(self, *args):\n+        pass\n+\n+class MockIntrospection:\n+    def get_constraints(self, cursor, table_name):\n+        if table_name == 'test_unique_together_pk':\n+            # Simulate PostgreSQL with both primary key and unique_together on id\n+            return {\n+                'test_unique_together_pk_pkey': {\n+                    'columns': ['id'],\n+                    'primary_key': True,\n+                    'unique': True,\n+                    'index': True,\n+                    'check': False,\n+                    'foreign_key': None,\n+                },\n+                'test_unique_together_pk_id_1c3b3088c74c3b17_uniq': {\n+                    'columns': ['id'], \n+                    'primary_key': False,\n+                    'unique': True,\n+                    'index': True,\n+                    'check': False,\n+                    'foreign_key': None,\n+                }\n+            }\n+        else:\n+            # Normal unique constraint \n+            return {\n+                'test_normal_unique_name_email_uniq': {\n+                    'columns': ['name', 'email'],\n+                    'primary_key': False,\n+                    'unique': True,\n+                    'index': True,\n+                    'check': False,\n+                    'foreign_key': None,\n+                }\n+            }\n+    \n+    def identifier_converter(self, name):\n+        return name\n+\n+class MockConnection:\n+    def __init__(self):\n+        self.introspection = MockIntrospection()\n+        \n+    def cursor(self):\n+        return MockCursor()\n+\n+# Mock schema editor\n+class MockSchemaEditor(schema.BaseDatabaseSchemaEditor):\n+    def __init__(self):\n+        self.connection = MockConnection()\n+        self.collected_sql = []\n+        \n+    def execute(self, sql, params=None):\n+        # Just collect the SQL, don't execute it\n+        self.collected_sql.append(sql)\n+        \n+    def _constraint_names(self, model, column_names=None, unique=None, \n+                         primary_key=None, index=None, foreign_key=None, \n+                         check=None, type_=None, exclude=None):\n+        \"\"\"Use real implementation but with mocked introspection\"\"\"\n+        if column_names is not None:\n+            column_names = [\n+                self.connection.introspection.identifier_converter(name)\n+                for name in column_names\n+            ]\n+        with self.connection.cursor() as cursor:\n+            constraints = self.connection.introspection.get_constraints(\n+                cursor, model._meta.db_table\n+            )\n+        result = []\n+        for name, infodict in constraints.items():\n+            if column_names is None or column_names == infodict[\"columns\"]:\n+                if unique is not None and infodict[\"unique\"] != unique:\n+                    continue\n+                if primary_key is not None and infodict[\"primary_key\"] != primary_key:\n+                    continue\n+                if index is not None and infodict[\"index\"] != index:\n+                    continue\n+                if check is not None and infodict[\"check\"] != check:\n+                    continue\n+                if foreign_key is not None and not infodict[\"foreign_key\"]:\n+                    continue\n+                if not exclude or name not in exclude:\n+                    result.append(name)\n+        return result\n+    \n+    def _delete_constraint_sql(self, sql, model, name):\n+        return f\"DROP CONSTRAINT {name}\"\n+\n+# Test the fix\n+editor = MockSchemaEditor()\n+\n+print(\"Testing _delete_composed_index with unique_together on primary key field...\")\n+print(\"\\nScenario: Table has both primary key constraint and unique_together constraint on 'id'\")\n+\n+try:\n+    # This should work with our fix\n+    editor._delete_composed_index(\n+        TestModel,\n+        ['id'],  # fields  \n+        {\"unique\": True},  # constraint_kwargs\n+        \"DROP INDEX\"  # sql template\n+    )\n+    print(\"\\nSUCCESS: The fix works! Found only the unique_together constraint!\")\n+    print(\"Collected SQL:\", editor.collected_sql)\n+    print(\"The primary key constraint was correctly excluded.\")\n+except ValueError as e:\n+    print(f\"\\nERROR: {e}\")\n+    print(\"The fix did not work as expected.\")\n+    \n+# Also test that other operations still work correctly\n+print(\"\\n\" + \"=\"*60)\n+print(\"Testing that the fix doesn't break normal unique_together constraints...\")\n+\n+# Reset collected SQL\n+editor.collected_sql = []\n+\n+# Test normal unique_together (not on primary key)\n+class TestModel2(models.Model):\n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_normal_unique'\n+        unique_together = [['name', 'email']]\n+    \n+    name = models.CharField(max_length=100)\n+    email = models.EmailField()\n+\n+try:\n+    editor._delete_composed_index(\n+        TestModel2,\n+        ['name', 'email'],\n+        {\"unique\": True},\n+        \"DROP INDEX\"\n+    )\n+    print(\"SUCCESS: Normal unique_together deletion still works correctly!\")\n+    print(\"Collected SQL:\", editor.collected_sql)\n+except ValueError as e:\n+    print(f\"ERROR: Normal case broken: {e}\")\ndiff --git a/test_unique_together_primary_key.py b/test_unique_together_primary_key.py\nnew file mode 100644\nindex 0000000000..a21551bf18\n--- /dev/null\n+++ b/test_unique_together_primary_key.py\n@@ -0,0 +1,67 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django with minimal settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations import Migration\n+from django.db.migrations.operations import AlterUniqueTogether\n+\n+# Define a test model\n+class TestModel(models.Model):\n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_unique_together_pk'\n+        unique_together = [['id']]  # This is the problematic constraint\n+    \n+    name = models.CharField(max_length=100)\n+\n+# Create the model in the database\n+with connection.schema_editor() as schema_editor:\n+    # First create the table\n+    schema_editor.create_model(TestModel)\n+    \n+    # Check existing constraints\n+    with connection.cursor() as cursor:\n+        constraints = connection.introspection.get_constraints(\n+            cursor, TestModel._meta.db_table\n+        )\n+        print(\"Initial constraints:\")\n+        for name, info in constraints.items():\n+            if info.get('unique') or info.get('primary_key'):\n+                print(f\"  {name}: columns={info['columns']}, unique={info.get('unique')}, primary_key={info.get('primary_key')}\")\n+    \n+    # Now try to remove the unique_together constraint\n+    print(\"\\nAttempting to remove unique_together constraint...\")\n+    try:\n+        schema_editor.alter_unique_together(\n+            TestModel,\n+            old_unique_together=[['id']],\n+            new_unique_together=[]\n+        )\n+        print(\"SUCCESS: unique_together constraint removed!\")\n+    except ValueError as e:\n+        print(f\"ERROR: {e}\")\n+    \n+    # Clean up\n+    schema_editor.delete_model(TestModel)\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex f3c4ea8ffe..4ab0aae66f 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -2809,6 +2809,45 @@ class OperationTests(OperationTestBase):\n             operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n         )\n \n+    def test_alter_unique_together_primary_key(self):\n+        \"\"\"\n+        Test removing unique_together constraint that includes primary key.\n+        This addresses the issue where a model has unique_together on its\n+        primary key field, resulting in two unique constraints.\n+        \"\"\"\n+        # Create a test app and model\n+        app_label = \"test_alunto_pk\"\n+        project_state = ProjectState()\n+        \n+        # Create model with unique_together on primary key\n+        model_state = ModelState(\n+            app_label,\n+            \"Pony\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"name\", models.CharField(max_length=100)),\n+            ],\n+            {\"unique_together\": [[\"id\"]]},\n+        )\n+        project_state.add_model(model_state)\n+        \n+        # Create the table\n+        with connection.schema_editor() as editor:\n+            editor.create_model(project_state.apps.get_model(app_label, \"Pony\"))\n+        \n+        # Remove the unique_together constraint\n+        operation = migrations.AlterUniqueTogether(\"Pony\", [])\n+        new_state = project_state.clone()\n+        operation.state_forwards(app_label, new_state)\n+        \n+        # This should not raise ValueError about finding wrong number of constraints\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        \n+        # Clean up\n+        with connection.schema_editor() as editor:\n+            editor.delete_model(project_state.apps.get_model(app_label, \"Pony\"))\n+\n     def test_add_index(self):\n         \"\"\"\n         Test the AddIndex operation.\n", "gold_standard_diff": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex f2ca8c8df945..03f0f1150765 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -528,7 +528,10 @@ def alter_unique_together(self, model, old_unique_together, new_unique_together)\n         # Deleted uniques\n         for fields in olds.difference(news):\n             self._delete_composed_index(\n-                model, fields, {\"unique\": True}, self.sql_delete_unique\n+                model,\n+                fields,\n+                {\"unique\": True, \"primary_key\": False},\n+                self.sql_delete_unique,\n             )\n         # Created uniques\n         for field_names in news.difference(olds):\n@@ -568,6 +571,17 @@ def _delete_composed_index(self, model, fields, constraint_kwargs, sql):\n             exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs,\n         )\n+        if (\n+            constraint_kwargs.get(\"unique\") is True\n+            and constraint_names\n+            and self.connection.features.allows_multiple_constraints_on_same_fields\n+        ):\n+            # Constraint matching the unique_together name.\n+            default_name = str(\n+                self._unique_constraint_name(model._meta.db_table, columns, quote=False)\n+            )\n+            if default_name in constraint_names:\n+                constraint_names = [default_name]\n         if len(constraint_names) != 1:\n             raise ValueError(\n                 \"Found wrong number (%s) of constraints for %s(%s)\"\n@@ -1560,16 +1574,13 @@ def _create_unique_sql(\n         ):\n             return None\n \n-        def create_unique_name(*args, **kwargs):\n-            return self.quote_name(self._create_index_name(*args, **kwargs))\n-\n         compiler = Query(model, alias_cols=False).get_compiler(\n             connection=self.connection\n         )\n         table = model._meta.db_table\n         columns = [field.column for field in fields]\n         if name is None:\n-            name = IndexName(table, columns, \"_uniq\", create_unique_name)\n+            name = self._unique_constraint_name(table, columns, quote=True)\n         else:\n             name = self.quote_name(name)\n         if condition or include or opclasses or expressions:\n@@ -1592,6 +1603,17 @@ def create_unique_name(*args, **kwargs):\n             include=self._index_include_sql(model, include),\n         )\n \n+    def _unique_constraint_name(self, table, columns, quote=True):\n+        if quote:\n+\n+            def create_unique_name(*args, **kwargs):\n+                return self.quote_name(self._create_index_name(*args, **kwargs))\n+\n+        else:\n+            create_unique_name = self._create_index_name\n+\n+        return IndexName(table, columns, \"_uniq\", create_unique_name)\n+\n     def _delete_unique_sql(\n         self,\n         model,\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex f3c4ea8ffe2b..2373ef34696d 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -2809,6 +2809,69 @@ def test_alter_unique_together_remove(self):\n             operation.describe(), \"Alter unique_together for Pony (0 constraint(s))\"\n         )\n \n+    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n+    def test_remove_unique_together_on_pk_field(self):\n+        app_label = \"test_rutopkf\"\n+        project_state = self.apply_operations(\n+            app_label,\n+            ProjectState(),\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Pony\",\n+                    fields=[(\"id\", models.AutoField(primary_key=True))],\n+                    options={\"unique_together\": {(\"id\",)}},\n+                ),\n+            ],\n+        )\n+        table_name = f\"{app_label}_pony\"\n+        pk_constraint_name = f\"{table_name}_pkey\"\n+        unique_together_constraint_name = f\"{table_name}_id_fb61f881_uniq\"\n+        self.assertConstraintExists(table_name, pk_constraint_name, value=False)\n+        self.assertConstraintExists(\n+            table_name, unique_together_constraint_name, value=False\n+        )\n+\n+        new_state = project_state.clone()\n+        operation = migrations.AlterUniqueTogether(\"Pony\", set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertConstraintExists(table_name, pk_constraint_name, value=False)\n+        self.assertConstraintNotExists(table_name, unique_together_constraint_name)\n+\n+    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n+    def test_remove_unique_together_on_unique_field(self):\n+        app_label = \"test_rutouf\"\n+        project_state = self.apply_operations(\n+            app_label,\n+            ProjectState(),\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Pony\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                        (\"name\", models.CharField(max_length=30, unique=True)),\n+                    ],\n+                    options={\"unique_together\": {(\"name\",)}},\n+                ),\n+            ],\n+        )\n+        table_name = f\"{app_label}_pony\"\n+        unique_constraint_name = f\"{table_name}_name_key\"\n+        unique_together_constraint_name = f\"{table_name}_name_694f3b9f_uniq\"\n+        self.assertConstraintExists(table_name, unique_constraint_name, value=False)\n+        self.assertConstraintExists(\n+            table_name, unique_together_constraint_name, value=False\n+        )\n+\n+        new_state = project_state.clone()\n+        operation = migrations.AlterUniqueTogether(\"Pony\", set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertConstraintExists(table_name, unique_constraint_name, value=False)\n+        self.assertConstraintNotExists(table_name, unique_together_constraint_name)\n+\n     def test_add_index(self):\n         \"\"\"\n         Test the AddIndex operation.\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15732"}