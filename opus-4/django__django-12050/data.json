{"instance_id": "django__django-12050", "score": "C", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b..3bdab8ea15 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1073,7 +1073,8 @@ class Query(BaseExpression):\n                         ))\n                 else:\n                     resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            # Preserve the original type of the iterable\n+            value = type(value)(resolved_values)\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/test_comprehensive_resolve_lookup.py b/test_comprehensive_resolve_lookup.py\nnew file mode 100644\nindex 0000000000..50ea7c4e86\n--- /dev/null\n+++ b/test_comprehensive_resolve_lookup.py\n@@ -0,0 +1,91 @@\n+\"\"\"Comprehensive test for resolve_lookup_value type preservation.\"\"\"\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.db.models import F, Value, Q\n+from django.db.models.sql.query import Query\n+from django.test import TestCase\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+django.setup()\n+\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    value = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+\n+def test_resolve_lookup_value_type_preservation():\n+    \"\"\"Test that resolve_lookup_value preserves the input iterable type.\"\"\"\n+    query = Query(TestModel)\n+    \n+    # Test case 1: Simple list\n+    input_list = [1, 2, 3]\n+    result = query.resolve_lookup_value(input_list, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == list, f\"Expected list, got {type(result)}\"\n+    assert result == [1, 2, 3], f\"Expected [1, 2, 3], got {result}\"\n+    \n+    # Test case 2: Simple tuple\n+    input_tuple = (1, 2, 3)\n+    result = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == tuple, f\"Expected tuple, got {type(result)}\"\n+    assert result == (1, 2, 3), f\"Expected (1, 2, 3), got {result}\"\n+    \n+    # Test case 3: List with expressions\n+    input_list_expr = [Value(1), Value(2), 3]\n+    result = query.resolve_lookup_value(input_list_expr, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == list, f\"Expected list, got {type(result)}\"\n+    assert len(result) == 3, f\"Expected length 3, got {len(result)}\"\n+    assert isinstance(result[0], Value), f\"Expected Value instance, got {type(result[0])}\"\n+    \n+    # Test case 4: Tuple with expressions\n+    input_tuple_expr = (Value(1), Value(2), 3)\n+    result = query.resolve_lookup_value(input_tuple_expr, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == tuple, f\"Expected tuple, got {type(result)}\"\n+    assert len(result) == 3, f\"Expected length 3, got {len(result)}\"\n+    assert isinstance(result[0], Value), f\"Expected Value instance, got {type(result[0])}\"\n+    \n+    # Test case 5: Empty list\n+    input_empty_list = []\n+    result = query.resolve_lookup_value(input_empty_list, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == list, f\"Expected list, got {type(result)}\"\n+    assert result == [], f\"Expected [], got {result}\"\n+    \n+    # Test case 6: Empty tuple\n+    input_empty_tuple = ()\n+    result = query.resolve_lookup_value(input_empty_tuple, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert type(result) == tuple, f\"Expected tuple, got {type(result)}\"\n+    assert result == (), f\"Expected (), got {result}\"\n+    \n+    # Test case 7: Non-iterable value (should pass through unchanged)\n+    input_value = 42\n+    result = query.resolve_lookup_value(input_value, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert result == 42, f\"Expected 42, got {result}\"\n+    \n+    # Test case 8: Expression value (should be resolved)\n+    input_expr = Value(42)\n+    result = query.resolve_lookup_value(input_expr, can_reuse=None, allow_joins=True, simple_col=False)\n+    assert isinstance(result, Value), f\"Expected Value instance, got {type(result)}\"\n+    \n+    print(\"All tests passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_resolve_lookup_value_type_preservation()\ndiff --git a/test_pickled_field_simulation.py b/test_pickled_field_simulation.py\nnew file mode 100644\nindex 0000000000..fcba37bfe7\n--- /dev/null\n+++ b/test_pickled_field_simulation.py\n@@ -0,0 +1,123 @@\n+\"\"\"Test case simulating PickledField issue with exact type matching.\"\"\"\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.models.sql.query import Query\n+import pickle\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+django.setup()\n+\n+\n+# Simulate a custom field that depends on exact type matching (like PickledField)\n+class TypeSensitiveField(models.Field):\n+    \"\"\"A field that requires exact type matching for lookups.\"\"\"\n+    \n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+    \n+    def get_lookup(self, lookup_name):\n+        if lookup_name == 'exact':\n+            return TypeSensitiveLookup\n+        return super().get_lookup(lookup_name)\n+    \n+    def get_internal_type(self):\n+        return \"TextField\"\n+    \n+    def to_python(self, value):\n+        return value\n+    \n+    def get_prep_value(self, value):\n+        # This simulates a field that stores the type information\n+        # along with the value (like PickledField would do)\n+        return f\"{type(value).__name__}:{repr(value)}\"\n+    \n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return value\n+        # Parse the type and value\n+        type_name, repr_value = value.split(':', 1)\n+        if type_name == 'list':\n+            return eval(repr_value)\n+        elif type_name == 'tuple':\n+            return eval(repr_value)\n+        return value\n+\n+\n+class TypeSensitiveLookup(models.Lookup):\n+    \"\"\"A lookup that requires exact type matching.\"\"\"\n+    lookup_name = 'exact'\n+    \n+    def as_sql(self, compiler, connection):\n+        lhs, lhs_params = self.process_lhs(compiler, connection)\n+        rhs, rhs_params = self.process_rhs(compiler, connection)\n+        \n+        # In a real PickledField, the type would matter for serialization\n+        # Here we simulate that by including type info\n+        params = lhs_params + rhs_params\n+        return '%s = %s' % (lhs, rhs), params\n+\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    data = TypeSensitiveField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+\n+def test_type_preservation_in_queries():\n+    \"\"\"Test that type preservation works correctly in queries.\"\"\"\n+    from django.db import connection\n+    \n+    # Create the table\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(TestModel)\n+    \n+    # Test with list values\n+    test_list = [1, 2, 3]\n+    obj1 = TestModel.objects.create(name='test1', data=test_list)\n+    \n+    # Before our fix, this would fail because the list would be converted to tuple\n+    # Let's verify our fix preserves the list type\n+    query = TestModel.objects.filter(data__exact=test_list).query\n+    \n+    # Get the resolved lookup value\n+    lookup_value = query.resolve_lookup_value(test_list, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"Original value type: {type(test_list)}\")\n+    print(f\"Resolved value type: {type(lookup_value)}\")\n+    print(f\"Types match: {type(test_list) == type(lookup_value)}\")\n+    \n+    # Test with tuple values\n+    test_tuple = (4, 5, 6)\n+    obj2 = TestModel.objects.create(name='test2', data=test_tuple)\n+    \n+    query_tuple = TestModel.objects.filter(data__exact=test_tuple).query\n+    lookup_value_tuple = query_tuple.resolve_lookup_value(test_tuple, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"\\nOriginal tuple type: {type(test_tuple)}\")\n+    print(f\"Resolved tuple type: {type(lookup_value_tuple)}\")\n+    print(f\"Tuple types match: {type(test_tuple) == type(lookup_value_tuple)}\")\n+    \n+    # In a real scenario with PickledField, this type preservation would be\n+    # crucial for proper serialization/deserialization\n+    print(\"\\nTest passed: Type preservation works correctly!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_type_preservation_in_queries()\ndiff --git a/test_resolve_lookup_value.py b/test_resolve_lookup_value.py\nnew file mode 100644\nindex 0000000000..d76d02f7ef\n--- /dev/null\n+++ b/test_resolve_lookup_value.py\n@@ -0,0 +1,56 @@\n+\"\"\"Test for resolve_lookup_value preserving input types.\"\"\"\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.db.models.sql.query import Query\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+django.setup()\n+\n+\n+def test_resolve_lookup_value_preserves_list_type():\n+    \"\"\"Test that resolve_lookup_value preserves list type instead of converting to tuple.\"\"\"\n+    # Create a simple model for testing\n+    class TestModel(models.Model):\n+        class Meta:\n+            app_label = 'test'\n+    \n+    query = Query(TestModel)\n+    \n+    # Test with a list\n+    input_list = [1, 2, 3]\n+    result = query.resolve_lookup_value(input_list, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"Input type: {type(input_list)}\")\n+    print(f\"Input value: {input_list}\")\n+    print(f\"Result type: {type(result)}\")\n+    print(f\"Result value: {result}\")\n+    print(f\"Types match: {type(input_list) == type(result)}\")\n+    print(f\"Expected type preservation: {'PASS' if type(input_list) == type(result) else 'FAIL'}\")\n+    \n+    # Test with a tuple\n+    input_tuple = (1, 2, 3)\n+    result_tuple = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"\\nTuple input type: {type(input_tuple)}\")\n+    print(f\"Tuple result type: {type(result_tuple)}\")\n+    print(f\"Tuple types match: {type(input_tuple) == type(result_tuple)}\")\n+    print(f\"Expected type preservation: {'PASS' if type(input_tuple) == type(result_tuple) else 'FAIL'}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_resolve_lookup_value_preserves_list_type()\ndiff --git a/test_resolve_lookup_with_expressions.py b/test_resolve_lookup_with_expressions.py\nnew file mode 100644\nindex 0000000000..f21bb98af3\n--- /dev/null\n+++ b/test_resolve_lookup_with_expressions.py\n@@ -0,0 +1,79 @@\n+\"\"\"Test for resolve_lookup_value with expressions.\"\"\"\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.db.models import F, Value\n+from django.db.models.sql.query import Query\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+django.setup()\n+\n+\n+def test_resolve_lookup_value_with_expressions():\n+    \"\"\"Test that resolve_lookup_value handles expressions in lists/tuples correctly.\"\"\"\n+    # Create a test model\n+    class TestModel(models.Model):\n+        name = models.CharField(max_length=100)\n+        value = models.IntegerField()\n+        \n+        class Meta:\n+            app_label = 'test'\n+    \n+    query = Query(TestModel)\n+    \n+    # Test with expressions in a list\n+    input_list = [Value(1), Value(2), 3]\n+    result = query.resolve_lookup_value(input_list, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"List with expressions:\")\n+    print(f\"  Input type: {type(input_list)}\")\n+    print(f\"  Result type: {type(result)}\")\n+    print(f\"  Types match: {type(input_list) == type(result)}\")\n+    print(f\"  Result length: {len(result)}\")\n+    print(f\"  First item type: {type(result[0])}\")\n+    \n+    # Test with expressions in a tuple\n+    input_tuple = (Value(1), Value(2), 3)\n+    result_tuple = query.resolve_lookup_value(input_tuple, can_reuse=None, allow_joins=True, simple_col=False)\n+    \n+    print(f\"\\nTuple with expressions:\")\n+    print(f\"  Input type: {type(input_tuple)}\")\n+    print(f\"  Result type: {type(result_tuple)}\")\n+    print(f\"  Types match: {type(input_tuple) == type(result_tuple)}\")\n+    print(f\"  Result length: {len(result_tuple)}\")\n+    print(f\"  First item type: {type(result_tuple[0])}\")\n+    \n+    # Test with F objects in list (which requires special handling)\n+    input_list_f = [F('name'), F('value'), 'test']\n+    # We'll just check type preservation, not resolve F objects since that requires more setup\n+    result_f = []\n+    for item in input_list_f:\n+        if hasattr(item, 'resolve_expression') and isinstance(item, F):\n+            # For this test, we'll just append the F object as is\n+            result_f.append(item)\n+        else:\n+            result_f.append(item)\n+    result_f = type(input_list_f)(result_f)\n+    \n+    print(f\"\\nList with F objects (type check only):\")\n+    print(f\"  Input type: {type(input_list_f)}\")\n+    print(f\"  Result type: {type(result_f)}\")\n+    print(f\"  Types match: {type(input_list_f) == type(result_f)}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_resolve_lookup_value_with_expressions()\n", "gold_standard_diff": "From 8be79984dce7d819879a6e594ca69c5f95a08378 Mon Sep 17 00:00:00 2001\nFrom: George Marshall <george@georgemarshall.name>\nDate: Sun, 10 Nov 2019 00:48:36 -0800\nSubject: [PATCH] Fixed #30971 -- Prevented Query.resolve_lookup_value() from\n coercing list values to tuples.\n\nRegression in 8a281aa7fe76a9da2284f943964a9413697cff1f.\n---\n django/db/models/sql/query.py | 19 ++++---------------\n tests/queries/test_query.py   |  7 +++++++\n 2 files changed, 11 insertions(+), 15 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex ea51912e8b6c..dd5889625f02 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1059,21 +1059,10 @@ def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            resolved_values = []\n-            for sub_value in value:\n-                if hasattr(sub_value, 'resolve_expression'):\n-                    if isinstance(sub_value, F):\n-                        resolved_values.append(sub_value.resolve_expression(\n-                            self, reuse=can_reuse, allow_joins=allow_joins,\n-                            simple_col=simple_col,\n-                        ))\n-                    else:\n-                        resolved_values.append(sub_value.resolve_expression(\n-                            self, reuse=can_reuse, allow_joins=allow_joins,\n-                        ))\n-                else:\n-                    resolved_values.append(sub_value)\n-            value = tuple(resolved_values)\n+            return type(value)(\n+                self.resolve_lookup_value(sub_value, can_reuse, allow_joins, simple_col)\n+                for sub_value in value\n+            )\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\nindex f0d3a6260a12..012d56a02f54 100644\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -113,3 +113,10 @@ def test_clone_select_related(self):\n         clone = query.clone()\n         clone.add_select_related(['note', 'creator__extra'])\n         self.assertEqual(query.select_related, {'creator': {}})\n+\n+    def test_iterable_lookup_value(self):\n+        query = Query(Item)\n+        where = query.build_where(Q(name=['a', 'b']))\n+        name_exact = where.children[0]\n+        self.assertIsInstance(name_exact, Exact)\n+        self.assertEqual(name_exact.rhs, \"['a', 'b']\")\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12050"}