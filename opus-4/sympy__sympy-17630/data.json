{"instance_id": "sympy__sympy-17630", "score": "I", "diff": "diff --git a/check_result.py b/check_result.py\nnew file mode 100644\nindex 0000000000..5685b0e5e2\n--- /dev/null\n+++ b/check_result.py\n@@ -0,0 +1,15 @@\n+from sympy import MatrixSymbol, ZeroMatrix, BlockMatrix, block_collapse\n+\n+a = MatrixSymbol(\"a\", 2, 2)\n+z = ZeroMatrix(2, 2)\n+b = BlockMatrix([[a, z], [z, z]])\n+\n+result1 = block_collapse(b * b)\n+print(\"Type of result1:\", type(result1))\n+print(\"result1:\", result1)\n+print(\"Has blocks?\", hasattr(result1, 'blocks'))\n+\n+if hasattr(result1, 'blocks'):\n+    print(\"result1.blocks:\", result1.blocks)\n+else:\n+    print(\"result1 as Matrix:\", result1.as_explicit())\ndiff --git a/sympy/matrices/expressions/blockmatrix.py b/sympy/matrices/expressions/blockmatrix.py\nindex 95302a05ca..979b0f546d 100644\n--- a/sympy/matrices/expressions/blockmatrix.py\n+++ b/sympy/matrices/expressions/blockmatrix.py\n@@ -164,7 +164,25 @@ def structurally_equal(self, other):\n     def _blockmul(self, other):\n         if (isinstance(other, BlockMatrix) and\n                 self.colblocksizes == other.rowblocksizes):\n-            return BlockMatrix(self.blocks*other.blocks)\n+            # Perform matrix multiplication of blocks\n+            result_blocks = self.blocks*other.blocks\n+            \n+            # Convert any Zero objects to ZeroMatrix objects with appropriate dimensions\n+            from sympy.core.numbers import Zero\n+            converted = []\n+            for i in range(result_blocks.rows):\n+                row = []\n+                for j in range(result_blocks.cols):\n+                    elem = result_blocks[i, j]\n+                    if isinstance(elem, Zero):\n+                        # Determine the shape based on the row/col block sizes\n+                        rows = self.rowblocksizes[i]\n+                        cols = other.colblocksizes[j]\n+                        elem = ZeroMatrix(rows, cols)\n+                    row.append(elem)\n+                converted.append(row)\n+            \n+            return BlockMatrix(converted)\n \n         return self * other\n \ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..93f9384855\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,49 @@\n+from sympy import *\n+\n+# Test various block matrix multiplication scenarios\n+a = MatrixSymbol(\"a\", 2, 2)\n+b = MatrixSymbol(\"b\", 2, 2)\n+c = MatrixSymbol(\"c\", 3, 3)\n+z22 = ZeroMatrix(2, 2)\n+z23 = ZeroMatrix(2, 3)\n+z32 = ZeroMatrix(3, 2)\n+z33 = ZeroMatrix(3, 3)\n+I2 = Identity(2)\n+I3 = Identity(3)\n+\n+# Test 1: Basic multiplication with zeros\n+B1 = BlockMatrix([[a, z22], [z22, b]])\n+print(\"Test 1 - Basic multiplication with zeros:\")\n+print(\"B1 * B1 =\", block_collapse(B1 * B1))\n+\n+# Test 2: Mixed size blocks with zeros (skip incompatible test)\n+# B2 = BlockMatrix([[a, z23], [z32, c]])\n+# B3 = BlockMatrix([[b, z22], [z33, c]])\n+print(\"\\nTest 2 - Mixed size blocks: (skipped due to dimension mismatch)\")\n+\n+# Test 3: Identity and zeros\n+B4 = BlockMatrix([[I2, z22], [z22, I2]])\n+print(\"\\nTest 3 - Identity and zeros:\")\n+print(\"B4 * B1 =\", block_collapse(B4 * B1))\n+\n+# Test 4: More than 2x2 blocks\n+B5 = BlockMatrix([[a, z22, z22], [z22, b, z22], [z22, z22, a]])\n+print(\"\\nTest 4 - 3x3 block matrix:\")\n+print(\"B5 * B5 =\", block_collapse(B5 * B5))\n+\n+# Test 5: The problematic triple multiplication\n+B6 = BlockMatrix([[a, z22], [z22, z22]])\n+print(\"\\nTest 5 - Triple multiplication (original issue):\")\n+try:\n+    result = block_collapse(B6 * B6 * B6)\n+    print(\"B6 * B6 * B6 =\", result)\n+    print(\"SUCCESS!\")\n+except Exception as e:\n+    print(\"ERROR:\", e)\n+\n+# Test 6: Check block properties are preserved\n+print(\"\\nTest 6 - Block properties:\")\n+result = B1._blockmul(B1)\n+print(\"Result blockshape:\", result.blockshape)\n+print(\"Result rowblocksizes:\", result.rowblocksizes)\n+print(\"Result colblocksizes:\", result.colblocksizes)\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..e8c212b4a9\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,24 @@\n+from sympy import *\n+\n+# Test case from the issue\n+a = MatrixSymbol(\"a\", 2, 2)\n+z = ZeroMatrix(2, 2)\n+b = BlockMatrix([[a, z], [z, z]])\n+\n+print(\"Testing b * b:\")\n+result1 = block_collapse(b * b)\n+print(\"Result:\", result1)\n+\n+print(\"\\nTesting b * b * b:\")\n+result2 = block_collapse(b * b * b)\n+print(\"Result:\", result2)\n+\n+print(\"\\nTesting b._blockmul(b):\")\n+result3 = b._blockmul(b)\n+print(\"Result:\", result3)\n+print(\"Block (0,1) type:\", type(result3.blocks[0, 1]))\n+print(\"Block (0,1) value:\", result3.blocks[0, 1])\n+\n+print(\"\\nTesting b._blockmul(b)._blockmul(b):\")\n+result4 = b._blockmul(b)._blockmul(b) \n+print(\"Result:\", result4)\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..aff0cf8a5d\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,32 @@\n+from sympy import *\n+from sympy.matrices import Matrix as SympyMatrix\n+from sympy.core.numbers import Zero\n+\n+# Reproduce the issue\n+a = MatrixSymbol(\"a\", 2, 2)\n+z = ZeroMatrix(2, 2)\n+b = BlockMatrix([[a, z], [z, z]])\n+\n+print(\"b.blocks:\")\n+print(b.blocks)\n+print(\"\\nb.blocks type:\", type(b.blocks))\n+\n+# Direct matrix multiplication to see what happens\n+print(\"\\nDirect matrix mult of blocks:\")\n+mult_result = b.blocks * b.blocks\n+print(\"b.blocks * b.blocks =\")\n+print(mult_result)\n+print(\"\\nChecking elements in multiplication result:\")\n+for i in range(mult_result.rows):\n+    for j in range(mult_result.cols):\n+        elem = mult_result[i, j]\n+        print(f\"Element ({i},{j}): {elem}, type: {type(elem)}\")\n+\n+# Check what ZeroMatrix * ZeroMatrix gives\n+print(\"\\nChecking ZeroMatrix multiplication:\")\n+print(\"z * z =\", z * z)\n+print(\"Type:\", type(z * z))\n+\n+# Check if Zero is an instance of sympy.core.numbers.Zero\n+print(\"\\nIs mult_result[0,1] a Zero?\", isinstance(mult_result[0, 1], Zero))\n+print(\"Does it have 'cols' attribute?\", hasattr(mult_result[0, 1], 'cols'))\ndiff --git a/test_issue_fix.py b/test_issue_fix.py\nnew file mode 100644\nindex 0000000000..1ee698813b\n--- /dev/null\n+++ b/test_issue_fix.py\n@@ -0,0 +1,45 @@\n+\"\"\"\n+Test for the fix to the issue with BlockMatrix containing ZeroMatrix blocks\n+\"\"\"\n+from sympy import MatrixSymbol, ZeroMatrix, BlockMatrix, block_collapse\n+\n+def test_blockmatrix_zero_blocks_multiplication():\n+    \"\"\"Test that BlockMatrix multiplication with ZeroMatrix blocks works correctly\"\"\"\n+    a = MatrixSymbol(\"a\", 2, 2)\n+    z = ZeroMatrix(2, 2)\n+    b = BlockMatrix([[a, z], [z, z]])\n+    \n+    # Test single multiplication\n+    result1 = block_collapse(b * b)\n+    # block_collapse returns a matrix expression, need to check blocks\n+    assert result1.blocks[0, 0] == a**2\n+    from sympy import Zero\n+    assert isinstance(result1.blocks[0, 1], (Zero, ZeroMatrix)) or result1.blocks[0, 1] == 0\n+    assert isinstance(result1.blocks[1, 0], (Zero, ZeroMatrix)) or result1.blocks[1, 0] == 0\n+    assert isinstance(result1.blocks[1, 1], (Zero, ZeroMatrix)) or result1.blocks[1, 1] == 0\n+    \n+    # Test double multiplication (the problematic case)\n+    result2 = block_collapse(b * b * b)\n+    assert result2.blocks[0, 0] == a**3\n+    assert isinstance(result2.blocks[0, 1], (Zero, ZeroMatrix)) or result2.blocks[0, 1] == 0\n+    assert isinstance(result2.blocks[1, 0], (Zero, ZeroMatrix)) or result2.blocks[1, 0] == 0\n+    assert isinstance(result2.blocks[1, 1], (Zero, ZeroMatrix)) or result2.blocks[1, 1] == 0\n+    \n+    # Test _blockmul directly\n+    result3 = b._blockmul(b)\n+    assert result3.blocks[0, 0] == a**2\n+    assert result3.blocks[0, 1].is_ZeroMatrix\n+    assert result3.blocks[1, 0].is_ZeroMatrix\n+    assert result3.blocks[1, 1].is_ZeroMatrix\n+    \n+    # Test double _blockmul\n+    result4 = b._blockmul(b)._blockmul(b)\n+    assert result4.blocks[0, 0] == a**3\n+    assert result4.blocks[0, 1].is_ZeroMatrix\n+    assert result4.blocks[1, 0].is_ZeroMatrix\n+    assert result4.blocks[1, 1].is_ZeroMatrix\n+    \n+    print(\"All tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_blockmatrix_zero_blocks_multiplication()\n", "gold_standard_diff": "From a35bcc4559c87532526c7002c34ed8350d98c7b8 Mon Sep 17 00:00:00 2001\nFrom: \"S.Y. Lee\" <sylee957@gmail.com>\nDate: Thu, 19 Sep 2019 07:44:05 +0900\nSubject: [PATCH 1/2] Fix block collapse with zero block matrix\n\n---\n sympy/matrices/expressions/matexpr.py                | 2 ++\n sympy/matrices/expressions/tests/test_blockmatrix.py | 9 ++++++++-\n 2 files changed, 10 insertions(+), 1 deletion(-)\n\ndiff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex fd1e6d970afa..48e15cd4910b 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -627,6 +627,8 @@ def _postprocessor(expr):\n                 # manipulate them like non-commutative scalars.\n                 return cls._from_args(nonmatrices + [mat_class(*matrices).doit(deep=False)])\n \n+        if mat_class == MatAdd:\n+            return mat_class(*matrices).doit(deep=False)\n         return mat_class(cls._from_args(nonmatrices), *matrices).doit(deep=False)\n     return _postprocessor\n \ndiff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex 1e1033affce0..908acfc702a3 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -3,7 +3,7 @@\n     BlockMatrix, bc_dist, bc_matadd, bc_transpose, bc_inverse,\n     blockcut, reblock_2x2, deblock)\n from sympy.matrices.expressions import (MatrixSymbol, Identity,\n-        Inverse, trace, Transpose, det)\n+        Inverse, trace, Transpose, det, ZeroMatrix)\n from sympy.matrices import (\n     Matrix, ImmutableMatrix, ImmutableSparseMatrix)\n from sympy.core import Tuple, symbols, Expr\n@@ -104,6 +104,13 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_issue_17624():\n+    a = MatrixSymbol(\"a\", 2, 2)\n+    z = ZeroMatrix(2, 2)\n+    b = BlockMatrix([[a, z], [z, z]])\n+    assert block_collapse(b * b) == BlockMatrix([[a**2, z], [z, z]])\n+    assert block_collapse(b * b * b) == BlockMatrix([[a**3, z], [z, z]])\n+\n def test_BlockMatrix_trace():\n     A, B, C, D = [MatrixSymbol(s, 3, 3) for s in 'ABCD']\n     X = BlockMatrix([[A, B], [C, D]])\n\nFrom 5a7d6d78bc7206e4c96cdebdcb5ba4a1f10f6c72 Mon Sep 17 00:00:00 2001\nFrom: \"S.Y. Lee\" <sylee957@gmail.com>\nDate: Thu, 19 Sep 2019 07:48:23 +0900\nSubject: [PATCH 2/2] Add tests for matrix addition\n\n---\n sympy/matrices/expressions/tests/test_matadd.py | 13 +++++++++++--\n 1 file changed, 11 insertions(+), 2 deletions(-)\n\ndiff --git a/sympy/matrices/expressions/tests/test_matadd.py b/sympy/matrices/expressions/tests/test_matadd.py\nindex 2cd19ba9bbbf..9e7f4d24c7fb 100644\n--- a/sympy/matrices/expressions/tests/test_matadd.py\n+++ b/sympy/matrices/expressions/tests/test_matadd.py\n@@ -1,7 +1,8 @@\n from sympy.matrices.expressions import MatrixSymbol, MatAdd, MatPow, MatMul\n-from sympy.matrices.expressions.matexpr import GenericZeroMatrix\n+from sympy.matrices.expressions.matexpr import GenericZeroMatrix, ZeroMatrix\n from sympy.matrices import eye, ImmutableMatrix\n-from sympy.core import Basic, S\n+from sympy.core import Add, Basic, S\n+from sympy.utilities.pytest import XFAIL, raises\n \n X = MatrixSymbol('X', 2, 2)\n Y = MatrixSymbol('Y', 2, 2)\n@@ -30,3 +31,11 @@ def test_doit_args():\n def test_generic_identity():\n     assert MatAdd.identity == GenericZeroMatrix()\n     assert MatAdd.identity != S.Zero\n+\n+\n+def test_zero_matrix_add():\n+    assert Add(ZeroMatrix(2, 2), ZeroMatrix(2, 2)) == ZeroMatrix(2, 2)\n+\n+@XFAIL\n+def test_matrix_add_with_scalar():\n+    raises(TypeError, lambda: Add(0, ZeroMatrix(2, 2)))\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/17630"}