diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 5369eadbde..09b446d1ba 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -4848,7 +4848,7 @@ default: :rc:`scatter.edgecolors`
             Use a linear or log10 scale on the vertical axis.
 
         mincnt : int > 0, default: *None*
-            If not *None*, only display cells with more than *mincnt*
+            If not *None*, only display cells with at least *mincnt*
             number of points in the cell.
 
         marginals : bool, default: *False*
@@ -5014,7 +5014,7 @@ default: :rc:`scatter.edgecolors`
             if mincnt is None:
                 mincnt = 0
             accum = np.array(
-                [reduce_C_function(acc) if len(acc) > mincnt else np.nan
+                [reduce_C_function(acc) if len(acc) >= mincnt else np.nan
                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
                 float)
diff --git a/test_hexbin_comprehensive.py b/test_hexbin_comprehensive.py
new file mode 100644
index 0000000000..7730e778eb
--- /dev/null
+++ b/test_hexbin_comprehensive.py
@@ -0,0 +1,77 @@
+from matplotlib import pyplot
+import numpy as np
+
+np.random.seed(42)
+
+# Create test data with known distribution
+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T
+Z = np.ones_like(X)
+
+extent = [-3., 3., -3., 3.]
+gridsize = (7, 7)
+
+print("Testing consistency of mincnt parameter between C=None and C!=None cases\n")
+
+for mincnt_val in [None, 0, 1, 2, 3, 5]:
+    # Test without C
+    fig, ax = pyplot.subplots(1, 1)
+    h1 = ax.hexbin(
+        X, Y,
+        mincnt=mincnt_val,
+        extent=extent,
+        gridsize=gridsize,
+        linewidth=0.0,
+        cmap='Blues',
+    )
+    n_hexagons_no_C = len(h1.get_offsets())
+    
+    # Test with C
+    fig, ax = pyplot.subplots(1, 1)
+    h2 = ax.hexbin(
+        X, Y,
+        C=Z,
+        reduce_C_function=np.sum,
+        mincnt=mincnt_val,
+        extent=extent,
+        gridsize=gridsize,
+        linewidth=0.0,
+        cmap='Blues',
+    )
+    n_hexagons_with_C = len(h2.get_offsets())
+    
+    consistent = n_hexagons_no_C == n_hexagons_with_C
+    print(f"mincnt={mincnt_val}: Without C: {n_hexagons_no_C} hexagons, With C: {n_hexagons_with_C} hexagons - Consistent: {consistent}")
+    
+pyplot.close('all')
+
+# Also test edge cases
+print("\nTesting edge cases:")
+
+# Test with data that results in exactly mincnt points in some hexagons
+np.random.seed(123)
+X_sparse = np.array([0, 0, 1, 1, 2, 2, 2])
+Y_sparse = np.array([0, 0, 0, 0, 0, 0, 0])
+Z_sparse = np.ones_like(X_sparse)
+
+for mincnt_val in [1, 2, 3]:
+    fig, ax = pyplot.subplots(1, 1)
+    h1 = ax.hexbin(
+        X_sparse, Y_sparse,
+        mincnt=mincnt_val,
+        extent=[-1, 3, -1, 1],
+        gridsize=(5, 3),
+    )
+    n_no_C = len(h1.get_offsets())
+    
+    fig, ax = pyplot.subplots(1, 1)
+    h2 = ax.hexbin(
+        X_sparse, Y_sparse,
+        C=Z_sparse,
+        reduce_C_function=np.sum,
+        mincnt=mincnt_val,
+        extent=[-1, 3, -1, 1],
+        gridsize=(5, 3),
+    )
+    n_with_C = len(h2.get_offsets())
+    
+    print(f"Sparse data - mincnt={mincnt_val}: Without C: {n_no_C}, With C: {n_with_C} - Consistent: {n_no_C == n_with_C}")
diff --git a/test_hexbin_mincnt.py b/test_hexbin_mincnt.py
new file mode 100644
index 0000000000..ee084b9e0e
--- /dev/null
+++ b/test_hexbin_mincnt.py
@@ -0,0 +1,72 @@
+from matplotlib import pyplot
+import numpy as np
+import matplotlib as mpl
+
+print(f"Matplotlib version: {mpl.__version__}")
+
+np.random.seed(42)
+
+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T
+Z = np.ones_like(X)
+
+extent = [-3., 3., -3., 3.]
+gridsize = (7, 7)
+
+# Test case 1: mincnt=1, no C argument
+fig, ax = pyplot.subplots(1, 1)
+h1 = ax.hexbin(
+    X, Y,
+    mincnt=1,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+ax.set_title("mincnt=1, no C argument")
+n_hexagons_no_C = len(h1.get_offsets())
+print(f"Number of hexagons with mincnt=1, no C: {n_hexagons_no_C}")
+
+# Test case 2: mincnt=1, C argument specified
+fig, ax = pyplot.subplots(1, 1)
+h2 = ax.hexbin(
+    X, Y,
+    C=Z,
+    reduce_C_function=np.sum,
+    mincnt=1,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+ax.set_title("mincnt=1, C argument specified")
+n_hexagons_with_C = len(h2.get_offsets())
+print(f"Number of hexagons with mincnt=1, C specified: {n_hexagons_with_C}")
+
+# Test case 3: mincnt=0, C argument specified  
+fig, ax = pyplot.subplots(1, 1)
+h3 = ax.hexbin(
+    X, Y,
+    C=Z,
+    reduce_C_function=np.sum,
+    mincnt=0,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+ax.set_title("mincnt=0, C argument specified")
+n_hexagons_with_C_0 = len(h3.get_offsets())
+print(f"Number of hexagons with mincnt=0, C specified: {n_hexagons_with_C_0}")
+
+print(f"\nInconsistency detected: {n_hexagons_no_C != n_hexagons_with_C}")
+print(f"With mincnt=1 and no C, we get {n_hexagons_no_C} hexagons")
+print(f"With mincnt=1 and C specified, we get {n_hexagons_with_C} hexagons")
+print(f"With mincnt=0 and C specified, we get {n_hexagons_with_C_0} hexagons")
+
+# Show that mincnt=0 with C gives same result as mincnt=1 without C
+print(f"\nmincnt=0 with C gives same result as mincnt=1 without C: {n_hexagons_no_C == n_hexagons_with_C_0}")
+
+# pyplot.show()
diff --git a/test_mincnt_regression.py b/test_mincnt_regression.py
new file mode 100644
index 0000000000..fe6f66421b
--- /dev/null
+++ b/test_mincnt_regression.py
@@ -0,0 +1,71 @@
+"""
+Test for mincnt parameter consistency in hexbin.
+This ensures the fix for issue remains valid.
+"""
+import numpy as np
+import pytest
+from matplotlib import pyplot as plt
+
+
+def test_hexbin_mincnt_consistency():
+    """Test that mincnt behavior is consistent whether C is None or not."""
+    np.random.seed(42)
+    
+    # Generate test data
+    X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T
+    Z = np.ones_like(X)
+    
+    extent = [-3., 3., -3., 3.]
+    gridsize = (7, 7)
+    
+    # Test various mincnt values
+    for mincnt in [None, 0, 1, 2, 3, 5]:
+        # Without C
+        fig, ax = plt.subplots()
+        h1 = ax.hexbin(X, Y, mincnt=mincnt, extent=extent, gridsize=gridsize)
+        n_no_C = len(h1.get_offsets())
+        plt.close(fig)
+        
+        # With C
+        fig, ax = plt.subplots()
+        h2 = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=mincnt, 
+                       extent=extent, gridsize=gridsize)
+        n_with_C = len(h2.get_offsets())
+        plt.close(fig)
+        
+        # They should be equal
+        assert n_no_C == n_with_C, \
+            f"mincnt={mincnt}: inconsistent behavior (no C: {n_no_C}, with C: {n_with_C})"
+
+
+def test_hexbin_mincnt_edge_cases():
+    """Test edge cases with exact mincnt boundaries."""
+    # Create data with known counts per hexagon
+    X = np.array([0, 0, 1, 1, 2, 2, 2])
+    Y = np.array([0, 0, 0, 0, 0, 0, 0])
+    Z = np.ones_like(X)
+    
+    extent = [-1, 3, -1, 1]
+    gridsize = (5, 3)
+    
+    # Test mincnt boundaries
+    for mincnt in [1, 2, 3]:
+        fig, ax = plt.subplots()
+        h1 = ax.hexbin(X, Y, mincnt=mincnt, extent=extent, gridsize=gridsize)
+        n_no_C = len(h1.get_offsets())
+        plt.close(fig)
+        
+        fig, ax = plt.subplots()
+        h2 = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=mincnt,
+                       extent=extent, gridsize=gridsize)
+        n_with_C = len(h2.get_offsets())
+        plt.close(fig)
+        
+        assert n_no_C == n_with_C, \
+            f"Edge case mincnt={mincnt}: inconsistent (no C: {n_no_C}, with C: {n_with_C})"
+
+
+if __name__ == "__main__":
+    test_hexbin_mincnt_consistency()
+    test_hexbin_mincnt_edge_cases()
+    print("All tests passed!")
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..cc5c3cef9b
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,83 @@
+from matplotlib import pyplot
+import numpy as np
+
+np.random.seed(42)
+
+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T
+Z = np.ones_like(X)
+
+extent = [-3., 3., -3., 3.]  # doc: "Order of scalars is (left, right, bottom, top)"
+gridsize = (7, 7)  # doc: "int or (int, int), optional, default is 100"
+
+# #### no mincnt specified, no C argument
+fig, ax = pyplot.subplots(1, 1)
+h1 = ax.hexbin(
+    X, Y,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")  # for contrast
+print(f"No mincnt, no C: {len(h1.get_offsets())} hexagons")
+
+# #### mincnt=1 specified, no C argument
+fig, ax = pyplot.subplots(1, 1)
+h2 = ax.hexbin(
+    X, Y,
+    mincnt=1,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+print(f"mincnt=1, no C: {len(h2.get_offsets())} hexagons")
+
+# #### no mincnt specified, C argument specified
+fig, ax = pyplot.subplots(1, 1)
+h3 = ax.hexbin(
+    X, Y,
+    C=Z,
+    reduce_C_function=np.sum,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+print(f"No mincnt, with C: {len(h3.get_offsets())} hexagons")
+
+# #### mincnt=1 specified, C argument specified
+fig, ax = pyplot.subplots(1, 1)
+h4 = ax.hexbin(
+    X, Y,
+    C=Z,
+    reduce_C_function=np.sum,
+    mincnt=1,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+print(f"mincnt=1, with C: {len(h4.get_offsets())} hexagons")
+
+# #### mincnt=0 specified, C argument specified
+fig, ax = pyplot.subplots(1, 1)
+h5 = ax.hexbin(
+    X, Y,
+    C=Z,
+    reduce_C_function=np.sum,
+    mincnt=0,
+    extent=extent,
+    gridsize=gridsize,
+    linewidth=0.0,
+    cmap='Blues',
+)
+ax.set_facecolor("green")
+print(f"mincnt=0, with C: {len(h5.get_offsets())} hexagons")
+
+print("\nAfter fix:")
+print(f"mincnt=1 without C ({len(h2.get_offsets())}) == mincnt=1 with C ({len(h4.get_offsets())}): {len(h2.get_offsets()) == len(h4.get_offsets())}")
+print("The issue is fixed!")
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..614065ed2a
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,44 @@
+"""
+Verify that the issue described in the bug report is fixed.
+"""
+from matplotlib import pyplot
+import numpy as np
+
+print("Verifying fix for hexbin mincnt parameter inconsistency")
+print("=" * 60)
+
+np.random.seed(42)
+
+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T
+Z = np.ones_like(X)
+
+extent = [-3., 3., -3., 3.]
+gridsize = (7, 7)
+
+# The issue: with mincnt=1, different behavior depending on whether C is supplied
+fig, ax = pyplot.subplots(1, 1)
+h_no_c = ax.hexbin(X, Y, mincnt=1, extent=extent, gridsize=gridsize)
+n_no_c = len(h_no_c.get_offsets())
+
+fig, ax = pyplot.subplots(1, 1)
+h_with_c = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=1, 
+                     extent=extent, gridsize=gridsize)
+n_with_c = len(h_with_c.get_offsets())
+
+print(f"Original issue description:")
+print(f"  With mincnt=1 and no C: {n_no_c} hexagons")
+print(f"  With mincnt=1 and C specified: {n_with_c} hexagons")
+print(f"  Are they equal? {n_no_c == n_with_c}")
+print()
+
+if n_no_c == n_with_c:
+    print("✓ FIXED: The behavior is now consistent!")
+else:
+    print("✗ NOT FIXED: The behavior is still inconsistent!")
+    
+print()
+print("The fix changes the condition from 'len(acc) > mincnt' to 'len(acc) >= mincnt'")
+print("when C is specified, making it consistent with the C=None case.")
+print()
+print("This ensures that mincnt=1 means 'show hexagons with at least 1 point'")
+print("regardless of whether C is specified or not.")
