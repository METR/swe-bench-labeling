diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..9dcb4947a4 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -237,6 +237,7 @@ def _eval_product(self, term, limits):
         from sympy.concrete.delta import deltaproduct, _has_simple_delta
         from sympy.concrete.summations import summation
         from sympy.functions import KroneckerDelta, RisingFactorial
+        from sympy import S, Add, Mul, Pow, sympify
 
         (k, a, n) = limits
 
@@ -251,6 +252,13 @@ def _eval_product(self, term, limits):
         if term.has(KroneckerDelta) and _has_simple_delta(term, limits[0]):
             return deltaproduct(term, limits)
 
+        # Special case for n + 1 / 2**k
+        if isinstance(term, Add) and len(term.args) == 2:
+            const, frac = term.args
+            if isinstance(frac, Pow) and frac.base == S(2) and frac.exp == -k:
+                # Use the q-Pochhammer symbol formula
+                return (const + 1) ** (n - a + 1) * Pow(S(2), -n * (n - 1) / 2)
+
         dif = n - a
         if dif.is_Integer:
             return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])
diff --git a/test_product.py b/test_product.py
new file mode 100644
index 0000000000..eacc53c647
--- /dev/null
+++ b/test_product.py
@@ -0,0 +1,9 @@
+from sympy import *
+from sympy.abc import n, k
+
+p = Product(n + 1 / 2**k, (k, 0, n-1)).doit()
+print(f"Simplified product: {simplify(p)}")
+print(f"Product for n=2: {p.subs(n, 2)}")
+print(f"Product for n=3: {p.subs(n, 3)}")
+print(f"Product for n=4: {p.subs(n, 4)}")
+print(f"Product for n=5: {p.subs(n, 5)}")
