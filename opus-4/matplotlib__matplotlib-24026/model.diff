diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py
index c580043eeb..50eb54540e 100644
--- a/lib/matplotlib/stackplot.py
+++ b/lib/matplotlib/stackplot.py
@@ -7,6 +7,7 @@ https://stackoverflow.com/q/2225995/
 """
 
 import numpy as np
+import itertools
 
 from matplotlib import _api
 
@@ -70,7 +71,10 @@ def stackplot(axes, x, *args,
 
     labels = iter(labels)
     if colors is not None:
-        axes.set_prop_cycle(color=colors)
+        if len(colors) == 0:
+            colors = None
+        else:
+            colors = itertools.cycle(colors)
 
     # Assume data passed has not been 'stacked', so stack it here.
     # We'll need a float buffer for the upcoming calculations.
@@ -108,7 +112,10 @@ def stackplot(axes, x, *args,
         stack += first_line
 
     # Color between x = 0 and the first array.
-    color = axes._get_lines.get_next_color()
+    if colors is not None:
+        color = next(colors)
+    else:
+        color = axes._get_lines.get_next_color()
     coll = axes.fill_between(x, first_line, stack[0, :],
                              facecolor=color, label=next(labels, None),
                              **kwargs)
@@ -117,7 +124,10 @@ def stackplot(axes, x, *args,
 
     # Color between array i-1 and array i
     for i in range(len(y) - 1):
-        color = axes._get_lines.get_next_color()
+        if colors is not None:
+            color = next(colors)
+        else:
+            color = axes._get_lines.get_next_color()
         r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],
                                    facecolor=color, label=next(labels, None),
                                    **kwargs))
diff --git a/lib/matplotlib/stackplot.py.backup b/lib/matplotlib/stackplot.py.backup
new file mode 100644
index 0000000000..67e99f8b3b
--- /dev/null
+++ b/lib/matplotlib/stackplot.py.backup
@@ -0,0 +1,124 @@
+"""
+Stacked area plot for 1D arrays inspired by Douglas Y'barbo's stackoverflow
+answer:
+https://stackoverflow.com/q/2225995/
+
+(https://stackoverflow.com/users/66549/doug)
+"""
+
+import numpy as np
+
+from matplotlib import _api
+
+__all__ = ['stackplot']
+
+
+def stackplot(axes, x, *args,
+              labels=(), colors=None, baseline='zero',
+              **kwargs):
+    """
+    Draw a stacked area plot.
+
+    Parameters
+    ----------
+    x : (N,) array-like
+
+    y : (M, N) array-like
+        The data is assumed to be unstacked. Each of the following
+        calls is legal::
+
+            stackplot(x, y)           # where y has shape (M, N)
+            stackplot(x, y1, y2, y3)  # where y1, y2, y3, y4 have length N
+
+    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}
+        Method used to calculate the baseline:
+
+        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.
+        - ``'sym'``:  Symmetric around zero and is sometimes called
+          'ThemeRiver'.
+        - ``'wiggle'``: Minimizes the sum of the squared slopes.
+        - ``'weighted_wiggle'``: Does the same but weights to account for
+          size of each layer. It is also called 'Streamgraph'-layout. More
+          details can be found at http://leebyron.com/streamgraph/.
+
+    labels : list of str, optional
+        A sequence of labels to assign to each data series. If unspecified,
+        then no labels will be applied to artists.
+
+    colors : list of color, optional
+        A sequence of colors to be cycled through and used to color the stacked
+        areas. The sequence need not be exactly the same length as the number
+        of provided *y*, in which case the colors will repeat from the
+        beginning.
+
+        If not specified, the colors from the Axes property cycle will be used.
+
+    data : indexable object, optional
+        DATA_PARAMETER_PLACEHOLDER
+
+    **kwargs
+        All other keyword arguments are passed to `.Axes.fill_between`.
+
+    Returns
+    -------
+    list of `.PolyCollection`
+        A list of `.PolyCollection` instances, one for each element in the
+        stacked area plot.
+    """
+
+    y = np.row_stack(args)
+
+    labels = iter(labels)
+    if colors is not None:
+        colors = iter(colors)
+
+    # Assume data passed has not been 'stacked', so stack it here.
+    # We'll need a float buffer for the upcoming calculations.
+    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))
+
+    _api.check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],
+                       baseline=baseline)
+    if baseline == 'zero':
+        first_line = 0.
+
+    elif baseline == 'sym':
+        first_line = -np.sum(y, 0) * 0.5
+        stack += first_line[None, :]
+
+    elif baseline == 'wiggle':
+        m = y.shape[0]
+        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)
+        first_line /= -m
+        stack += first_line
+
+    elif baseline == 'weighted_wiggle':
+        total = np.sum(y, 0)
+        # multiply by 1/total (or zero) to avoid infinities in the division:
+        inv_total = np.zeros_like(total)
+        mask = total > 0
+        inv_total[mask] = 1.0 / total[mask]
+        increase = np.hstack((y[:, 0:1], np.diff(y)))
+        below_size = total - stack
+        below_size += 0.5 * y
+        move_up = below_size * inv_total
+        move_up[:, 0] = 0.5
+        center = (move_up - 0.5) * increase
+        center = np.cumsum(center.sum(0))
+        first_line = center - 0.5 * total
+        stack += first_line
+
+    # Color between x = 0 and the first array.
+    color = axes._get_lines.get_next_color()
+    coll = axes.fill_between(x, first_line, stack[0, :],
+                             facecolor=color, label=next(labels, None),
+                             **kwargs)
+    coll.sticky_edges.y[:] = [0]
+    r = [coll]
+
+    # Color between array i-1 and array i
+    for i in range(len(y) - 1):
+        color = axes._get_lines.get_next_color()
+        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],
+                                   facecolor=color, label=next(labels, None),
+                                   **kwargs))
+    return r
diff --git a/stackplot_content.txt b/stackplot_content.txt
new file mode 100644
index 0000000000..c580043eeb
--- /dev/null
+++ b/stackplot_content.txt
@@ -0,0 +1,124 @@
+"""
+Stacked area plot for 1D arrays inspired by Douglas Y'barbo's stackoverflow
+answer:
+https://stackoverflow.com/q/2225995/
+
+(https://stackoverflow.com/users/66549/doug)
+"""
+
+import numpy as np
+
+from matplotlib import _api
+
+__all__ = ['stackplot']
+
+
+def stackplot(axes, x, *args,
+              labels=(), colors=None, baseline='zero',
+              **kwargs):
+    """
+    Draw a stacked area plot.
+
+    Parameters
+    ----------
+    x : (N,) array-like
+
+    y : (M, N) array-like
+        The data is assumed to be unstacked. Each of the following
+        calls is legal::
+
+            stackplot(x, y)           # where y has shape (M, N)
+            stackplot(x, y1, y2, y3)  # where y1, y2, y3, y4 have length N
+
+    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}
+        Method used to calculate the baseline:
+
+        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.
+        - ``'sym'``:  Symmetric around zero and is sometimes called
+          'ThemeRiver'.
+        - ``'wiggle'``: Minimizes the sum of the squared slopes.
+        - ``'weighted_wiggle'``: Does the same but weights to account for
+          size of each layer. It is also called 'Streamgraph'-layout. More
+          details can be found at http://leebyron.com/streamgraph/.
+
+    labels : list of str, optional
+        A sequence of labels to assign to each data series. If unspecified,
+        then no labels will be applied to artists.
+
+    colors : list of color, optional
+        A sequence of colors to be cycled through and used to color the stacked
+        areas. The sequence need not be exactly the same length as the number
+        of provided *y*, in which case the colors will repeat from the
+        beginning.
+
+        If not specified, the colors from the Axes property cycle will be used.
+
+    data : indexable object, optional
+        DATA_PARAMETER_PLACEHOLDER
+
+    **kwargs
+        All other keyword arguments are passed to `.Axes.fill_between`.
+
+    Returns
+    -------
+    list of `.PolyCollection`
+        A list of `.PolyCollection` instances, one for each element in the
+        stacked area plot.
+    """
+
+    y = np.row_stack(args)
+
+    labels = iter(labels)
+    if colors is not None:
+        axes.set_prop_cycle(color=colors)
+
+    # Assume data passed has not been 'stacked', so stack it here.
+    # We'll need a float buffer for the upcoming calculations.
+    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))
+
+    _api.check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],
+                       baseline=baseline)
+    if baseline == 'zero':
+        first_line = 0.
+
+    elif baseline == 'sym':
+        first_line = -np.sum(y, 0) * 0.5
+        stack += first_line[None, :]
+
+    elif baseline == 'wiggle':
+        m = y.shape[0]
+        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)
+        first_line /= -m
+        stack += first_line
+
+    elif baseline == 'weighted_wiggle':
+        total = np.sum(y, 0)
+        # multiply by 1/total (or zero) to avoid infinities in the division:
+        inv_total = np.zeros_like(total)
+        mask = total > 0
+        inv_total[mask] = 1.0 / total[mask]
+        increase = np.hstack((y[:, 0:1], np.diff(y)))
+        below_size = total - stack
+        below_size += 0.5 * y
+        move_up = below_size * inv_total
+        move_up[:, 0] = 0.5
+        center = (move_up - 0.5) * increase
+        center = np.cumsum(center.sum(0))
+        first_line = center - 0.5 * total
+        stack += first_line
+
+    # Color between x = 0 and the first array.
+    color = axes._get_lines.get_next_color()
+    coll = axes.fill_between(x, first_line, stack[0, :],
+                             facecolor=color, label=next(labels, None),
+                             **kwargs)
+    coll.sticky_edges.y[:] = [0]
+    r = [coll]
+
+    # Color between array i-1 and array i
+    for i in range(len(y) - 1):
+        color = axes._get_lines.get_next_color()
+        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],
+                                   facecolor=color, label=next(labels, None),
+                                   **kwargs))
+    return r
diff --git a/test_stackplot_cn_aliases.py b/test_stackplot_cn_aliases.py
new file mode 100644
index 0000000000..ce539c8f1a
--- /dev/null
+++ b/test_stackplot_cn_aliases.py
@@ -0,0 +1,74 @@
+"""
+Test for the stackplot CN alias fix.
+This tests the specific issue reported in GitHub issue #14221.
+"""
+
+import matplotlib.pyplot as plt
+from matplotlib.patches import Rectangle
+import numpy as np
+
+
+def test_stackplot_cn_aliases():
+    """Test that stackplot accepts CN color aliases without error."""
+    my_data = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])
+    fig, ax = plt.subplots()
+    
+    # These should all work without raising ValueError
+    ax.plot([1, 3], [1, 3], color='C0')
+    ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))
+    ax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])
+    
+    plt.close(fig)
+
+
+def test_stackplot_cycler_not_modified():
+    """Test that stackplot doesn't modify the axes cycler."""
+    fig, ax = plt.subplots()
+    
+    # Get initial color from cycler
+    line1 = ax.plot([1, 2], [1, 2])[0]
+    initial_color = line1.get_color()
+    ax.clear()
+    
+    # Use stackplot with explicit colors
+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])
+    
+    # Plot again to see if cycler was affected
+    line2 = ax.plot([1, 2], [1, 2])[0]
+    next_color = line2.get_color()
+    
+    assert initial_color == next_color, f"Cycler was modified: {initial_color} -> {next_color}"
+    
+    plt.close(fig)
+
+
+def test_stackplot_color_cycling():
+    """Test that colors cycle when fewer colors than data series."""
+    fig, ax = plt.subplots()
+    
+    # 3 data series with only 2 colors - should cycle
+    result = ax.stackplot([1, 2, 3], [[1, 2, 3], [2, 3, 4], [3, 4, 5]], 
+                         colors=['red', 'blue'])
+    
+    # Check that we got 3 collections
+    assert len(result) == 3
+    
+    # Check colors cycle correctly
+    assert result[0].get_facecolor()[0].tolist()[:3] == [1.0, 0.0, 0.0]  # red
+    assert result[1].get_facecolor()[0].tolist()[:3] == [0.0, 0.0, 1.0]  # blue  
+    assert result[2].get_facecolor()[0].tolist()[:3] == [1.0, 0.0, 0.0]  # red (cycled)
+    
+    plt.close(fig)
+
+
+if __name__ == "__main__":
+    test_stackplot_cn_aliases()
+    print("✓ test_stackplot_cn_aliases passed")
+    
+    test_stackplot_cycler_not_modified()
+    print("✓ test_stackplot_cycler_not_modified passed")
+    
+    test_stackplot_color_cycling()
+    print("✓ test_stackplot_color_cycling passed")
+    
+    print("\nAll tests passed!")
diff --git a/test_stackplot_comprehensive.py b/test_stackplot_comprehensive.py
new file mode 100644
index 0000000000..caf40a6903
--- /dev/null
+++ b/test_stackplot_comprehensive.py
@@ -0,0 +1,107 @@
+import matplotlib.pyplot as plt
+import numpy as np
+import matplotlib.colors as mcolors
+
+# Test 1: CN color aliases work
+print("Test 1: CN color aliases")
+try:
+    fig, ax = plt.subplots()
+    data = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
+    ax.stackplot([1, 2, 3], data, colors=['C0', 'C1', 'C2'])
+    print("✓ CN aliases work")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ CN aliases failed: {e}")
+
+# Test 2: Regular color names still work
+print("\nTest 2: Regular color names")
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], data, colors=['red', 'green', 'blue'])
+    print("✓ Regular color names work")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Regular color names failed: {e}")
+
+# Test 3: Hex colors still work
+print("\nTest 3: Hex colors")
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], data, colors=['#FF0000', '#00FF00', '#0000FF'])
+    print("✓ Hex colors work")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Hex colors failed: {e}")
+
+# Test 4: Default colors (no colors parameter) still work
+print("\nTest 4: Default colors")
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], data)
+    print("✓ Default colors work")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Default colors failed: {e}")
+
+# Test 5: Colors cycle properly when fewer colors than data series
+print("\nTest 5: Color cycling")
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], data, colors=['red', 'blue'])  # 2 colors for 3 series
+    print("✓ Color cycling works")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Color cycling failed: {e}")
+
+# Test 6: Cycler is not modified
+print("\nTest 6: Cycler preservation")
+fig, ax = plt.subplots()
+# Get initial cycler color
+line1 = ax.plot([1, 2], [1, 2])[0]
+initial_color = line1.get_color()
+ax.clear()
+
+# Use stackplot with colors
+ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])
+
+# Check cycler hasn't changed
+line2 = ax.plot([1, 2], [1, 2])[0]
+next_color = line2.get_color()
+
+if initial_color == next_color:
+    print("✓ Cycler not modified")
+else:
+    print(f"✗ Cycler was modified: {initial_color} -> {next_color}")
+plt.close(fig)
+
+# Test 7: All baseline options still work
+print("\nTest 7: Baseline options")
+baselines = ['zero', 'sym', 'wiggle', 'weighted_wiggle']
+for baseline in baselines:
+    try:
+        fig, ax = plt.subplots()
+        ax.stackplot([1, 2, 3], [[1, 2, 3], [2, 3, 4]], baseline=baseline, colors=['C0', 'C1'])
+        print(f"✓ Baseline '{baseline}' works")
+        plt.close(fig)
+    except Exception as e:
+        print(f"✗ Baseline '{baseline}' failed: {e}")
+
+# Test 8: Mixed usage - some plots with CN aliases, some without
+print("\nTest 8: Mixed usage")
+try:
+    fig, (ax1, ax2) = plt.subplots(1, 2)
+    
+    # First subplot with CN aliases
+    ax1.plot([1, 2], [1, 2], color='C0', label='line')
+    ax1.stackplot([1, 2], [[1, 2], [3, 4]], colors=['C1', 'C2'], labels=['stack1', 'stack2'])
+    
+    # Second subplot without colors (using default cycler)
+    ax2.plot([1, 2], [1, 2], label='line')
+    ax2.stackplot([1, 2], [[1, 2], [3, 4]], labels=['stack1', 'stack2'])
+    
+    print("✓ Mixed usage works")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Mixed usage failed: {e}")
+
+print("\nAll tests completed!")
diff --git a/test_stackplot_edge_cases.py b/test_stackplot_edge_cases.py
new file mode 100644
index 0000000000..393e52c98b
--- /dev/null
+++ b/test_stackplot_edge_cases.py
@@ -0,0 +1,44 @@
+"""Test edge cases for stackplot CN alias fix."""
+
+import matplotlib.pyplot as plt
+import numpy as np
+
+
+# Test empty colors list
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=[])
+    print("✓ Empty colors list works (uses default cycler)")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Empty colors list failed: {e}")
+
+# Test single color for multiple series
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['C0'])
+    print("✓ Single color for multiple series works")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Single color failed: {e}")
+
+# Test mix of CN aliases and regular colors
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 
+                 colors=['C0', 'red', '#00FF00'])
+    print("✓ Mix of CN aliases and regular colors works")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ Mix of colors failed: {e}")
+
+# Test that None colors parameter works
+try:
+    fig, ax = plt.subplots()
+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=None)
+    print("✓ None colors parameter works")
+    plt.close(fig)
+except Exception as e:
+    print(f"✗ None colors failed: {e}")
+
+print("\nAll edge case tests completed!")
diff --git a/test_stackplot_issue.py b/test_stackplot_issue.py
new file mode 100644
index 0000000000..84754c20d5
--- /dev/null
+++ b/test_stackplot_issue.py
@@ -0,0 +1,41 @@
+import matplotlib.pyplot as plt
+from matplotlib.patches import Rectangle
+import numpy as np
+
+# Test case from the issue
+my_data = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])
+fig, ax = plt.subplots()
+
+# This should work (and does)
+ax.plot([1, 3], [1, 3], color='C0')
+ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))
+
+# This should work but currently raises ValueError
+try:
+    ax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])
+    print("SUCCESS: stackplot with CN aliases worked!")
+except ValueError as e:
+    print(f"ERROR: {e}")
+
+# Also test that the cycler is not modified
+fig2, ax2 = plt.subplots()
+# Get initial color from cycler
+line1 = ax2.plot([1, 2], [1, 2])[0]
+initial_color = line1.get_color()
+
+# Use stackplot with explicit colors
+ax2.clear()
+ax2.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])
+
+# Plot again to see if cycler was affected
+line2 = ax2.plot([1, 2], [1, 2])[0]
+next_color = line2.get_color()
+
+print(f"Initial color: {initial_color}")
+print(f"Color after stackplot: {next_color}")
+if initial_color == next_color:
+    print("SUCCESS: Cycler was not modified by stackplot")
+else:
+    print("ERROR: Cycler was modified by stackplot")
+
+plt.close('all')
