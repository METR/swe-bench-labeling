{"instance_id": "sympy__sympy-15599", "score": "I", "diff": "diff --git a/check_test_expectation.py b/check_test_expectation.py\nnew file mode 100644\nindex 0000000000..8f157ac152\n--- /dev/null\n+++ b/check_test_expectation.py\n@@ -0,0 +1,30 @@\n+from sympy import Symbol, Mod, Float\n+\n+x = Symbol('x')\n+point3 = Float(3.3) % 1\n+\n+print(f\"point3 = {point3}\")\n+print(f\"1 - point3 = {1 - point3}\")\n+\n+# Test assertion says:\n+# assert (x - 3.3) % 1 == Mod(1.*x + 1 - point3, 1)\n+\n+left = (x - 3.3) % 1\n+right = Mod(1.*x + 1 - point3, 1)\n+\n+print(f\"\\nLeft side: (x - 3.3) % 1 = {left}\")\n+print(f\"Right side: Mod(1.*x + 1 - point3, 1) = {right}\")\n+\n+# But 1 - point3 = 1 - 0.3 = 0.7\n+print(f\"\\nSo right side is: Mod(1.0*x + 0.7, 1)\")\n+\n+# Are they equal?\n+print(f\"\\nAre they equal? {left == right}\")\n+print(f\"Left expanded: {left}\")\n+print(f\"Right expanded: {right}\")\n+\n+# Let's check the case without float\n+y = Symbol('y')\n+print(f\"\\n(y - 3) % 1 = {(y - 3) % 1}\")\n+print(f\"Mod(y + 1 - 3, 1) = {Mod(y + 1 - 3, 1)}\")\n+print(f\"Mod(y - 2, 1) = {Mod(y - 2, 1)}\")\ndiff --git a/debug_float_mod.py b/debug_float_mod.py\nnew file mode 100644\nindex 0000000000..6fb488105e\n--- /dev/null\n+++ b/debug_float_mod.py\n@@ -0,0 +1,27 @@\n+from sympy import Symbol, Mod, Float\n+\n+x = Symbol('x')\n+point3 = Float(3.3) % 1\n+print(f\"point3 = {point3}\")\n+\n+# The original expression\n+left = (x - 3.3) % 1\n+print(f\"(x - 3.3) % 1 = {left}\")\n+\n+# The expected expression\n+right = Mod(1.*x + 1 - point3, 1)\n+print(f\"Mod(1.*x + 1 - point3, 1) = {right}\")\n+\n+# Let's see what happens with our fix\n+print(f\"\\nDetailed analysis:\")\n+print(f\"x - 3.3 = {x - 3.3}\")\n+print(f\"Type: {type(x - 3.3)}\")\n+\n+# Test with concrete value\n+test_val = 5\n+left_val = left.subs(x, test_val)\n+right_val = right.subs(x, test_val)\n+print(f\"\\nWith x = {test_val}:\")\n+print(f\"Left: {left_val}\")\n+print(f\"Right: {right_val}\")\n+print(f\"Float values: {float(left_val)} vs {float(right_val)}\")\ndiff --git a/debug_mod_change.py b/debug_mod_change.py\nnew file mode 100644\nindex 0000000000..026b65dd5c\n--- /dev/null\n+++ b/debug_mod_change.py\n@@ -0,0 +1,31 @@\n+from sympy import Symbol, Mod, Float, Add\n+\n+x = Symbol('x')\n+\n+# Test case from failing test\n+expr = x - 3.3\n+print(f\"expr = {expr}\")\n+print(f\"type = {type(expr)}\")\n+print(f\"is_Add = {isinstance(expr, Add)}\")\n+\n+# Apply mod operation\n+result = expr % 1\n+print(f\"\\nexpr % 1 = {result}\")\n+print(f\"type = {type(result)}\")\n+\n+# Let's trace what happens step by step\n+print(\"\\n--- Tracing evaluation ---\")\n+\n+# expr is an Add: x + (-3.3)\n+# When we do % 1, it goes through simplify terms section\n+# Each term is evaluated: Mod(x, 1) and Mod(-3.3, 1)\n+\n+print(f\"Mod(x, 1) = {Mod(x, 1)}\")\n+print(f\"Mod(-3.3, 1) = {Mod(-3.3, 1)}\")\n+print(f\"Mod(Float(3.3), 1) = {Mod(Float(3.3), 1)}\")\n+\n+# Test with integer symbol\n+i = Symbol('i', integer=True)\n+print(f\"\\nWith integer symbol:\")\n+print(f\"Mod(3*i, 2) = {Mod(3*i, 2)}\")\n+print(f\"Mod(1.0*i, 2) = {Mod(1.0*i, 2)}\")\ndiff --git a/minimal_test.py b/minimal_test.py\nnew file mode 100644\nindex 0000000000..26a00de6a4\n--- /dev/null\n+++ b/minimal_test.py\n@@ -0,0 +1,24 @@\n+from sympy import Symbol, Mod\n+\n+# Simple case to understand the issue\n+x = Symbol('x')\n+\n+# This is what the test expects to remain unchanged\n+expr = Mod(1.0*x + 0.7, 1)\n+print(f\"Mod(1.0*x + 0.7, 1) = {expr}\")\n+\n+# But let's see what happens when we build it differently\n+result = (x - 3.3) % 1\n+print(f\"(x - 3.3) % 1 = {result}\")\n+\n+# The issue is that the test expects these to be equal:\n+# (x - 3.3) % 1 == Mod(1.0*x + 0.7, 1)\n+# But our change makes the right side simplify to 0.7\n+\n+# Let's test the integer case\n+i = Symbol('i', integer=True)\n+print(f\"\\nMod(3*i, 2) = {Mod(3*i, 2)}\")\n+\n+# And with float coefficient\n+print(f\"Mod(1.0*i, 1) = {Mod(1.0*i, 1)}\")\n+print(f\"Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex eae25630cc..0ef017ed6e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -123,9 +123,16 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if mod_l and all(inner.args[1] == q for inner in mod_l):\n+            # Check if we should apply the simplification\n+            # We need to be careful with float coefficients\n+            was = non_mod_l[:]\n+            non_mod_l_eval = [cls(x, q) for x in non_mod_l]\n+            changed = was != non_mod_l_eval\n+            \n+            # Only apply if we have integer terms or if mod_l has terms\n+            if changed or (mod_l and all(inner.args[1] == q for inner in mod_l)):\n                 # finding distributive term\n-                non_mod_l = [cls(x, q) for x in non_mod_l]\n+                non_mod_l = non_mod_l_eval\n                 mod = []\n                 non_mod = []\n                 for j in non_mod_l:\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 04d3b1ab9f..05e2d1979b 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1624,6 +1624,7 @@ def test_Mod():\n     i = Symbol('i', integer=True)\n     assert (3*i*x) % (2*i*y) == i*Mod(3*x, 2*y)\n     assert Mod(4*i, 4) == 0\n+    assert Mod(3*i, 2) == Mod(i, 2)\n \n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\ndiff --git a/test_mod_issue.py b/test_mod_issue.py\nnew file mode 100644\nindex 0000000000..45801c70a0\n--- /dev/null\n+++ b/test_mod_issue.py\n@@ -0,0 +1,20 @@\n+from sympy import Symbol, Mod\n+\n+# Create an integer symbol\n+i = Symbol('i', integer=True)\n+\n+# Test the current behavior\n+print(\"Current behavior:\")\n+print(f\"Mod(3*i, 2) = {Mod(3*i, 2)}\")\n+print(f\"Expected: Mod(i, 2)\")\n+\n+# Also test with regular symbols\n+k = Symbol('k')\n+print(f\"\\nWith regular symbol k:\")\n+print(f\"Mod(3*k, 2) = {Mod(3*k, 2)}\")\n+\n+# Test some related cases\n+print(f\"\\nRelated cases:\")\n+print(f\"Mod(4*i, 4) = {Mod(4*i, 4)}\")\n+print(f\"Mod(5*i, 3) = {Mod(5*i, 3)}\")\n+print(f\"Mod(7*i, 2) = {Mod(7*i, 2)}\")\ndiff --git a/trace_add_handling.py b/trace_add_handling.py\nnew file mode 100644\nindex 0000000000..57394a494d\n--- /dev/null\n+++ b/trace_add_handling.py\n@@ -0,0 +1,27 @@\n+from sympy import Symbol, Mod, Float, Add\n+\n+x = Symbol('x')\n+\n+# The issue is with Add handling\n+expr = 1.0*x + 0.7\n+print(f\"expr = {expr}\")\n+print(f\"type = {type(expr)}\")\n+print(f\"is Add? {isinstance(expr, Add)}\")\n+\n+# When Mod(1.0*x + 0.7, 1) is evaluated, it goes through Add handling\n+# The Add handling applies Mod to each term\n+print(f\"\\nAdd handling would do:\")\n+print(f\"  Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\n+print(f\"  Mod(0.7, 1) = {Mod(0.7, 1)}\")\n+print(f\"  Sum = {Mod(1.0*x, 1) + Mod(0.7, 1)}\")\n+\n+# But the test expects this to remain as Mod(1.0*x + 0.7, 1)\n+# Let's see what the test is actually checking\n+point3 = Float(3.3) % 1\n+print(f\"\\nTest case:\")\n+print(f\"  point3 = {point3}\")\n+print(f\"  1 - point3 = {1 - point3}\")\n+print(f\"  (x - 3.3) % 1 = {(x - 3.3) % 1}\")\n+print(f\"  Mod(1.*x + 1 - point3, 1) = {Mod(1.*x + 1 - point3, 1)}\")\n+\n+# The issue is that the right side simplifies because Mod(1.0*x, 1) = 0\ndiff --git a/trace_mod_eval.py b/trace_mod_eval.py\nnew file mode 100644\nindex 0000000000..68a0af1fbc\n--- /dev/null\n+++ b/trace_mod_eval.py\n@@ -0,0 +1,30 @@\n+from sympy import Symbol, Mod, Float, Add, Mul\n+\n+x = Symbol('x')\n+i = Symbol('i', integer=True)\n+\n+# Case 1: Mod(3*i, 2) - this should simplify\n+print(\"Case 1: Mod(3*i, 2)\")\n+expr1 = 3*i\n+print(f\"  expr = {expr1}, type = {type(expr1)}\")\n+print(f\"  isinstance(expr1, Mul) = {isinstance(expr1, Mul)}\")\n+print(f\"  Result: {Mod(expr1, 2)}\")\n+\n+# Case 2: Mod(1.0*x + 0.7, 1) - this should NOT simplify the 1.0*x part away\n+print(\"\\nCase 2: Mod(1.0*x + 0.7, 1)\")\n+expr2 = 1.0*x + 0.7\n+print(f\"  expr = {expr2}, type = {type(expr2)}\")\n+print(f\"  isinstance(expr2, Add) = {isinstance(expr2, Add)}\")\n+print(f\"  Result: {Mod(expr2, 1)}\")\n+\n+# The problem is in the Add handling, not Mul\n+# Let's see what happens with Add terms\n+print(\"\\nAdd term handling:\")\n+print(f\"  Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\n+print(f\"  Mod(0.7, 1) = {Mod(0.7, 1)}\")\n+\n+# Check the mul case specifically\n+print(\"\\nMul case with float:\")\n+print(f\"  Mod(1.0*i, 2) = {Mod(1.0*i, 2)}\")\n+print(f\"  1.0*i is Mul? {isinstance(1.0*i, Mul)}\")\n+print(f\"  i has assumptions: {i.assumptions0}\")\n", "gold_standard_diff": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex eae25630cc21..0498f7a75dbe 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,6 +1,7 @@\n from __future__ import print_function, division\n \n-from sympy.core.numbers import nan\n+from sympy.core.numbers import nan, Integer\n+from sympy.core.compatibility import integer_types\n from .function import Function\n \n \n@@ -45,7 +46,7 @@ def doit(p, q):\n \n             if q.is_Number:\n                 if p.is_Number:\n-                    return (p % q)\n+                    return p%q\n                 if q == 2:\n                     if p.is_even:\n                         return S.Zero\n@@ -64,7 +65,7 @@ def doit(p, q):\n             except TypeError:\n                 pass\n             else:\n-                if type(d) is int:\n+                if isinstance(d, integer_types):\n                     rv = p - d*q\n                     if (rv*q < 0) == True:\n                         rv += q\n@@ -139,6 +140,17 @@ def doit(p, q):\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n \n+            if q.is_Integer and q is not S.One:\n+                _ = []\n+                for i in non_mod_l:\n+                    if i.is_Integer and (i % q is not S.Zero):\n+                        _.append(i%q)\n+                    else:\n+                        _.append(i)\n+                non_mod_l = _\n+\n+            p = Mul(*(non_mod_l + mod_l))\n+\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 04d3b1ab9fe5..5f58f9284c9a 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1662,6 +1662,12 @@ def test_Mod():\n     assert Mod(Mod(x + 2, 4)*(x + 4), 4) == Mod(x*(x + 2), 4)\n     assert Mod(Mod(x + 2, 4)*4, 4) == 0\n \n+    # issue 15493\n+    i, j = symbols('i j', integer=True, positive=True)\n+    assert Mod(3*i, 2) == Mod(i, 2)\n+    assert Mod(8*i/j, 4) == 4*Mod(2*i/j, 1)\n+    assert Mod(8*i, 4) == 0\n+\n \n def test_Mod_is_integer():\n     p = Symbol('p', integer=True)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/15599"}