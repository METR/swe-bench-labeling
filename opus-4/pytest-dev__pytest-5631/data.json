{"instance_id": "pytest-dev__pytest-5631", "score": "C", "diff": "diff --git a/src/_pytest/compat.py b/src/_pytest/compat.py\nindex d238061b4..3ce9558d7 100644\n--- a/src/_pytest/compat.py\n+++ b/src/_pytest/compat.py\n@@ -68,7 +68,7 @@ def num_mock_patch_args(function):\n     if any(mock_modules):\n         sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n         return len(\n-            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n+            [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]\n         )\n     return len(patchings)\n \ndiff --git a/test_array_patch.py b/test_array_patch.py\nnew file mode 100644\nindex 000000000..9f73b9435\n--- /dev/null\n+++ b/test_array_patch.py\n@@ -0,0 +1,30 @@\n+from unittest.mock import patch, DEFAULT\n+\n+class ArrayLike:\n+    \"\"\"An object that simulates numpy array behavior when compared.\"\"\"\n+    def __init__(self, data):\n+        self.data = data\n+    \n+    def __eq__(self, other):\n+        # This simulates numpy array behavior - returns array of booleans\n+        return [x == other for x in self.data]\n+    \n+    def __contains__(self, item):\n+        # This is what happens with 'in' operator \n+        # When used as 'item in array', numpy returns array of booleans\n+        result = [x == item for x in self.data]\n+        # But Python expects a boolean from __contains__\n+        # With numpy arrays, this causes: ValueError: truth value is ambiguous\n+        if len(result) > 1:\n+            raise ValueError(\"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\")\n+        return result[0] if result else False\n+\n+# First test: patch with DEFAULT (should work)\n+@patch('sys.stdout')  # This uses DEFAULT implicitly\n+def test_default_patch(mock_stdout):\n+    pass\n+\n+# Second test: patch with ArrayLike (should fail)\n+@patch('sys.stdout', new=ArrayLike([-5.5, 3.0]))\n+def test_array_patch():\n+    pass\ndiff --git a/test_issue_reproduction.py b/test_issue_reproduction.py\nnew file mode 100644\nindex 000000000..7c358646b\n--- /dev/null\n+++ b/test_issue_reproduction.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Reproduction of the exact issue from the bug report.\n+This test should fail with pytest 3.6.0 before the fix and pass after.\n+\"\"\"\n+from unittest.mock import patch\n+\n+# Simulate numpy array since numpy is not available in the test environment\n+class MockNumpyArray:\n+    \"\"\"Mock numpy array that simulates the problematic behavior.\"\"\"\n+    def __init__(self, values):\n+        self.values = values\n+        \n+    def __eq__(self, other):\n+        # Return an array-like object that causes ValueError on truth check\n+        class ComparisonResult:\n+            def __init__(self, results):\n+                self.results = results\n+                \n+            def __bool__(self):\n+                if len(self.results) > 1:\n+                    raise ValueError(\"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\")\n+                return self.results[0] if self.results else False\n+                \n+        return ComparisonResult([val == other for val in self.values])\n+\n+# Create a mock np.array function\n+class np:\n+    @staticmethod\n+    def array(values):\n+        return MockNumpyArray(values)\n+\n+# This is the exact code from the issue report\n+@patch(target='sys.stdout', new=np.array([-5.5, 3.0]))\n+def test_patch_array():\n+    \"\"\"Test case from the issue report that should work after the fix.\"\"\"\n+    pass\n+\n+if __name__ == \"__main__\":\n+    # Run pytest on this file\n+    import subprocess\n+    import sys\n+    result = subprocess.run([sys.executable, \"-m\", \"pytest\", __file__, \"-v\"], capture_output=True, text=True)\n+    print(result.stdout)\n+    print(result.stderr)\ndiff --git a/test_mock_patch_fix.py b/test_mock_patch_fix.py\nnew file mode 100644\nindex 000000000..6c7557161\n--- /dev/null\n+++ b/test_mock_patch_fix.py\n@@ -0,0 +1,70 @@\n+\"\"\"\n+Test to verify the fix for the numpy array patch issue.\n+This test verifies that pytest can collect tests that use @patch with numpy-like arrays.\n+\"\"\"\n+from unittest.mock import patch, DEFAULT, MagicMock\n+\n+\n+class ArrayLike:\n+    \"\"\"Simulates a numpy array that raises ValueError on truth value check.\"\"\"\n+    def __init__(self, data):\n+        self.data = data\n+    \n+    def __eq__(self, other):\n+        # Simulate numpy array behavior - returns array of booleans\n+        class ArrayResult:\n+            def __init__(self, values):\n+                self.values = values\n+                \n+            def __bool__(self):\n+                # This simulates numpy's error\n+                if len(self.values) > 1:\n+                    raise ValueError(\"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\")\n+                return self.values[0] if self.values else False\n+        \n+        return ArrayResult([x == other for x in self.data])\n+\n+\n+# Test 1: Regular patch with DEFAULT (implicit)\n+@patch('sys.stdout')\n+def test_regular_patch_default(mock_stdout):\n+    \"\"\"Test that regular patches still work correctly.\"\"\"\n+    assert mock_stdout is not None\n+\n+\n+# Test 2: Patch with explicit DEFAULT\n+@patch('sys.stdout', new=DEFAULT)\n+def test_explicit_default_patch(mock_stdout):\n+    \"\"\"Test that explicit DEFAULT patches work correctly.\"\"\"\n+    assert mock_stdout is not None\n+\n+\n+# Test 3: Patch with a regular object\n+@patch('sys.stdout', new=MagicMock())\n+def test_patch_with_object():\n+    \"\"\"Test that patches with regular objects work correctly.\"\"\"\n+    pass\n+\n+\n+# Test 4: Patch with array-like object (main test case)\n+@patch('sys.stdout', new=ArrayLike([-5.5, 3.0]))\n+def test_patch_with_array():\n+    \"\"\"Test that patches with array-like objects that have ambiguous truth values work.\"\"\"\n+    pass\n+\n+\n+# Test 5: Multiple patches with mixed types\n+@patch('sys.stderr', new=ArrayLike([1, 2, 3]))\n+@patch('sys.stdout')\n+def test_multiple_patches_mixed(mock_stdout):\n+    \"\"\"Test multiple decorators with mixed patch types.\"\"\"\n+    assert mock_stdout is not None\n+\n+\n+# Test 6: Patch with attribute_name (should not be affected by the fix)\n+# We need to patch an existing attribute\n+import sys\n+@patch.object(sys, 'exc_info', new=ArrayLike([10, 20]))\n+def test_patch_with_attribute():\n+    \"\"\"Test patch.object which sets attribute_name.\"\"\"\n+    pass\ndiff --git a/test_numpy_like.py b/test_numpy_like.py\nnew file mode 100644\nindex 000000000..d9b35a399\n--- /dev/null\n+++ b/test_numpy_like.py\n@@ -0,0 +1,51 @@\n+# Let's test the exact behavior that causes the issue\n+from unittest.mock import DEFAULT\n+\n+# Create a mock numpy array class\n+class NumpyArray:\n+    \"\"\"Simulates numpy array behavior with 'in' operator\"\"\"\n+    def __init__(self, data):\n+        self.data = data\n+        \n+    def __eq__(self, other):\n+        # numpy arrays return an array of element-wise comparisons\n+        class ArrayResult:\n+            def __init__(self, values):\n+                self.values = values\n+                \n+            def __bool__(self):\n+                # This is what causes the ValueError in numpy\n+                if len(self.values) > 1:\n+                    raise ValueError(\"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\")\n+                return self.values[0] if self.values else False\n+        \n+        return ArrayResult([x == other for x in self.data])\n+\n+\n+# Simulating the exact code from compat.py line 71\n+sentinels = [DEFAULT]\n+arr = NumpyArray([-5.5, 3.0])\n+\n+# This should trigger the error\n+try:\n+    result = arr in sentinels\n+    print(f\"Result: {result}\")\n+except ValueError as e:\n+    print(f\"Got expected error: {e}\")\n+\n+# Now let's test the list comprehension as in the actual code\n+class MockPatch:\n+    def __init__(self, new, attribute_name=None):\n+        self.new = new\n+        self.attribute_name = attribute_name\n+\n+patchings = [\n+    MockPatch(new=DEFAULT),  # Normal patch\n+    MockPatch(new=arr),      # Patch with array\n+]\n+\n+try:\n+    result = [p for p in patchings if not p.attribute_name and p.new in sentinels]\n+    print(f\"List comprehension result: {result}\")\n+except ValueError as e:\n+    print(f\"Got expected error in list comprehension: {e}\")\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 000000000..78c5c1c37\n--- /dev/null\n+++ b/verify_fix.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Script to verify that the fix handles the problematic code correctly.\n+\"\"\"\n+from unittest.mock import DEFAULT\n+\n+# Simulating the original problematic code\n+class NumpyArrayLike:\n+    def __eq__(self, other):\n+        # When comparing with DEFAULT, numpy arrays return array of booleans\n+        class Result:\n+            def __bool__(self):\n+                raise ValueError(\"The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\")\n+        return Result()\n+\n+# Mock patch object\n+class MockPatch:\n+    def __init__(self, new, attribute_name=None):\n+        self.new = new\n+        self.attribute_name = attribute_name\n+\n+# Test the original code that caused the issue\n+sentinels = [DEFAULT]\n+array = NumpyArrayLike()\n+\n+# This would cause ValueError with the original code\n+try:\n+    result = array in sentinels\n+    print(\"ERROR: Should have raised ValueError\")\n+except ValueError as e:\n+    print(f\"Expected ValueError with 'in' operator: {e}\")\n+\n+# Now test our fix using 'is' comparison\n+patchings = [MockPatch(new=array)]\n+try:\n+    # Our fix: using 'any(p.new is s for s in sentinels)' instead of 'p.new in sentinels'\n+    result = [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]\n+    print(f\"SUCCESS: Fix works correctly. Result: {result} (empty list expected)\")\n+except Exception as e:\n+    print(f\"ERROR: Fix failed with: {e}\")\n+\n+# Also test that the fix still correctly identifies DEFAULT sentinels\n+patchings = [MockPatch(new=DEFAULT)]\n+result = [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]\n+print(f\"DEFAULT sentinel test: {len(result)} patches found (1 expected)\")\n", "gold_standard_diff": "diff --git a/changelog/5606.bugfix.rst b/changelog/5606.bugfix.rst\nnew file mode 100644\nindex 00000000000..82332ba9972\n--- /dev/null\n+++ b/changelog/5606.bugfix.rst\n@@ -0,0 +1,2 @@\n+Fixed internal error when test functions were patched with objects that cannot be compared\n+for truth values against others, like ``numpy`` arrays.\ndiff --git a/src/_pytest/compat.py b/src/_pytest/compat.py\nindex d238061b4ab..52ffc36bc98 100644\n--- a/src/_pytest/compat.py\n+++ b/src/_pytest/compat.py\n@@ -64,13 +64,18 @@ def num_mock_patch_args(function):\n     patchings = getattr(function, \"patchings\", None)\n     if not patchings:\n         return 0\n-    mock_modules = [sys.modules.get(\"mock\"), sys.modules.get(\"unittest.mock\")]\n-    if any(mock_modules):\n-        sentinels = [m.DEFAULT for m in mock_modules if m is not None]\n-        return len(\n-            [p for p in patchings if not p.attribute_name and p.new in sentinels]\n-        )\n-    return len(patchings)\n+\n+    mock_sentinel = getattr(sys.modules.get(\"mock\"), \"DEFAULT\", object())\n+    ut_mock_sentinel = getattr(sys.modules.get(\"unittest.mock\"), \"DEFAULT\", object())\n+\n+    return len(\n+        [\n+            p\n+            for p in patchings\n+            if not p.attribute_name\n+            and (p.new is mock_sentinel or p.new is ut_mock_sentinel)\n+        ]\n+    )\n \n \n def getfuncargnames(function, is_method=False, cls=None):\ndiff --git a/testing/python/integration.py b/testing/python/integration.py\nindex a6b8dddf395..73419eef424 100644\n--- a/testing/python/integration.py\n+++ b/testing/python/integration.py\n@@ -178,6 +178,34 @@ def test_hello_mock(self, abspath):\n         reprec = testdir.inline_run()\n         reprec.assertoutcome(passed=2)\n \n+    def test_mock_sentinel_check_against_numpy_like(self, testdir):\n+        \"\"\"Ensure our function that detects mock arguments compares against sentinels using\n+        identity to circumvent objects which can't be compared with equality against others\n+        in a truth context, like with numpy arrays (#5606).\n+        \"\"\"\n+        testdir.makepyfile(\n+            dummy=\"\"\"\n+            class NumpyLike:\n+                def __init__(self, value):\n+                    self.value = value\n+                def __eq__(self, other):\n+                    raise ValueError(\"like numpy, cannot compare against others for truth\")\n+            FOO = NumpyLike(10)\n+        \"\"\"\n+        )\n+        testdir.makepyfile(\n+            \"\"\"\n+            from unittest.mock import patch\n+            import dummy\n+            class Test(object):\n+                @patch(\"dummy.FOO\", new=dummy.NumpyLike(50))\n+                def test_hello(self):\n+                    assert dummy.FOO.value == 50\n+        \"\"\"\n+        )\n+        reprec = testdir.inline_run()\n+        reprec.assertoutcome(passed=1)\n+\n     def test_mock(self, testdir):\n         pytest.importorskip(\"mock\", \"1.0.1\")\n         testdir.makepyfile(\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/5631"}