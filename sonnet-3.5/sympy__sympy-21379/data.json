{"instance_id": "sympy__sympy-21379", "score": "C", "diff": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex bfec61de64..4cd9be52f8 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -4394,9 +4394,16 @@ def _parallel_poly_from_expr(exprs, opt):\n     if not opt.gens:\n         raise PolificationFailed(opt, origs, exprs, True)\n \n+    # Handle Piecewise generators by converting them to their underlying expressions\n+    # This allows for proper substitution and evaluation of Piecewise functions in polynomials\n+    new_gens = []\n     for k in opt.gens:\n         if isinstance(k, Piecewise):\n-            raise PolynomialError(\"Piecewise generators do not make sense\")\n+            # Convert Piecewise to its underlying expression\n+            new_gens.append(k.as_expr())\n+        else:\n+            new_gens.append(k)\n+    opt.gens = tuple(new_gens)\n \n     coeffs_list, lengths = [], []\n \ndiff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 8f7e464148..952d4b254a 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3477,4 +3477,11 @@ def test_issue_20985():\n     from sympy import symbols\n     w, R = symbols('w R')\n     poly = Poly(1.0 + I*w/R, w, 1/R)\n+\n+def test_piecewise_poly():\n+    from sympy import Piecewise\n+    p = Poly(Piecewise((x, x > 0), (x**2, True)))\n+    assert p.as_expr() == Piecewise((x, x > 0), (x**2, True))\n+    assert p.subs({x: 2}) == 2\n+    assert p.subs({x: -2}) == 4\n     assert poly.degree() == S(1)\n", "gold_standard_diff": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex b4f3de25234b..ebe7862aef6e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n         from sympy.core.exprtools import gcd_terms\n+        from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n \n         def doit(p, q):\n@@ -166,10 +167,13 @@ def doit(p, q):\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n-        G = gcd(p, q)\n-        if G != 1:\n-            p, q = [\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n+        try:\n+            G = gcd(p, q)\n+            if G != 1:\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\n+                        for i in (p, q)]\n+        except PolynomialError:  # issue 21373\n+            G = S.One\n         pwas, qwas = p, q\n \n         # simplify terms\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 2dc6589f8c67..f19cfeeaa2d8 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1913,6 +1913,16 @@ def test_Mod():\n     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n+    # issue 21373\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    expr.subs({1: 1.0})\n+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n+\n \n def test_Mod_Pow():\n     # modular exponentiation\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/21379"}