{"instance_id": "pytest-dev__pytest-10051", "score": "I", "diff": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex a4f4214b1..29974b793 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -396,7 +396,11 @@ class LogCaptureFixture:\n \n         .. versionadded:: 3.4\n         \"\"\"\n-        return self._item.stash[caplog_records_key].get(when, [])\n+        if when not in (\"setup\", \"call\", \"teardown\"):\n+            raise ValueError(\"Invalid value for 'when': {}\".format(when))\n+        \n+        self._item.stash[caplog_records_key][when] = self.records\n+        return self._item.stash[caplog_records_key][when]\n \n     @property\n     def text(self) -> str:\n@@ -441,6 +445,8 @@ class LogCaptureFixture:\n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n         self.handler.reset()\n+        for when in (\"setup\", \"call\", \"teardown\"):\n+            self._item.stash[caplog_records_key][when] = []\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\n", "gold_standard_diff": "From c7e784f95d6ff7dc1e9d1a1dbc234a39c0125816 Mon Sep 17 00:00:00 2001\nFrom: \"zx.qiu\" <zx.qiu@trip.com>\nDate: Wed, 15 Jun 2022 23:11:55 +0800\nSubject: [PATCH 1/4] Fix stage caplog records not clear\n\nCloses #9877\n---\n AUTHORS                         |  1 +\n changelog/9877.bugfix.rst       |  1 +\n src/_pytest/logging.py          | 12 ++++++++++++\n testing/logging/test_fixture.py | 13 +++++++++++++\n 4 files changed, 27 insertions(+)\n create mode 100644 changelog/9877.bugfix.rst\n\ndiff --git a/AUTHORS b/AUTHORS\nindex d1f1b5503f2..7d27f5adadf 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -363,5 +363,6 @@ Yuval Shimon\n Zac Hatfield-Dodds\n Zachary Kneupper\n Zachary OBrien\n+Zhouxin Qiu\n Zolt\u00e1n M\u00e1t\u00e9\n Zsolt Cserna\ndiff --git a/changelog/9877.bugfix.rst b/changelog/9877.bugfix.rst\nnew file mode 100644\nindex 00000000000..ace3a4385a4\n--- /dev/null\n+++ b/changelog/9877.bugfix.rst\n@@ -0,0 +1 @@\n+Fixed ``caplog.get_records(when)`` still get the stage records after ``caplog.clear()``\ndiff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex a4f4214b137..96709ae93cf 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -335,6 +335,16 @@ def __init__(self) -> None:\n         \"\"\"Create a new log handler.\"\"\"\n         super().__init__(StringIO())\n         self.records: List[logging.LogRecord] = []\n+        self.set_when(None)\n+\n+    def set_when(self, when: Optional[str]) -> None:\n+        \"\"\"Prepare for the given test phase (setup/call/teardown).\"\"\"\n+        self._when = when\n+\n+    def get_when(self) -> Optional[str]:\n+        return self._when\n+\n+    when = property(get_when, set_when)\n \n     def emit(self, record: logging.LogRecord) -> None:\n         \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n@@ -441,6 +451,7 @@ def messages(self) -> List[str]:\n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n         self.handler.reset()\n+        self._item.stash[caplog_records_key][self.handler.when] = self.records\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\n@@ -695,6 +706,7 @@ def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, Non\n             level=self.log_level,\n         ) as report_handler:\n             caplog_handler.reset()\n+            caplog_handler.set_when(when)\n             report_handler.reset()\n             item.stash[caplog_records_key][when] = caplog_handler.records\n             item.stash[caplog_handler_key] = caplog_handler\ndiff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex bcb20de5805..6b85ce60a63 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -172,6 +172,19 @@ def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardow\n     assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n \n \n+def test_clear_for_call_stage(caplog, logging_during_setup_and_teardown):\n+    logger.info(\"a_call_log\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"a_call_log\"]\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n+    caplog.clear()\n+\n+    assert caplog.get_records(\"call\") == []\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n+\n def test_ini_controls_global_log_level(pytester: Pytester) -> None:\n     pytester.makepyfile(\n         \"\"\"\n\nFrom f29f79e39f698d33ec773b24a06b38c38ee0cdaa Mon Sep 17 00:00:00 2001\nFrom: \"zx.qiu\" <zx.qiu@trip.com>\nDate: Fri, 24 Jun 2022 19:17:55 +0800\nSubject: [PATCH 2/4] Use records.clear() in LogCaptureHandler when\n caplog.clear()\n\n---\n src/_pytest/logging.py          | 19 +++++--------------\n testing/logging/test_fixture.py |  5 +++++\n 2 files changed, 10 insertions(+), 14 deletions(-)\n\ndiff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 96709ae93cf..2eb69fdbfb4 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -40,7 +40,6 @@\n else:\n     logging_StreamHandler = logging.StreamHandler\n \n-\n DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n@@ -335,16 +334,6 @@ def __init__(self) -> None:\n         \"\"\"Create a new log handler.\"\"\"\n         super().__init__(StringIO())\n         self.records: List[logging.LogRecord] = []\n-        self.set_when(None)\n-\n-    def set_when(self, when: Optional[str]) -> None:\n-        \"\"\"Prepare for the given test phase (setup/call/teardown).\"\"\"\n-        self._when = when\n-\n-    def get_when(self) -> Optional[str]:\n-        return self._when\n-\n-    when = property(get_when, set_when)\n \n     def emit(self, record: logging.LogRecord) -> None:\n         \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n@@ -355,6 +344,10 @@ def reset(self) -> None:\n         self.records = []\n         self.stream = StringIO()\n \n+    def clear(self) -> None:\n+        self.records.clear()\n+        self.stream = StringIO()\n+\n     def handleError(self, record: logging.LogRecord) -> None:\n         if logging.raiseExceptions:\n             # Fail the test if the log message is bad (emit failed).\n@@ -450,8 +443,7 @@ def messages(self) -> List[str]:\n \n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n-        self.handler.reset()\n-        self._item.stash[caplog_records_key][self.handler.when] = self.records\n+        self.handler.clear()\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\n@@ -706,7 +698,6 @@ def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, Non\n             level=self.log_level,\n         ) as report_handler:\n             caplog_handler.reset()\n-            caplog_handler.set_when(when)\n             report_handler.reset()\n             item.stash[caplog_records_key][when] = caplog_handler.records\n             item.stash[caplog_handler_key] = caplog_handler\ndiff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex 6b85ce60a63..e9e73d05f98 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -184,6 +184,11 @@ def test_clear_for_call_stage(caplog, logging_during_setup_and_teardown):\n     assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n     assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n \n+    logging.info(\"a_call_log_after_clear\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"a_call_log_after_clear\"]\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n \n def test_ini_controls_global_log_level(pytester: Pytester) -> None:\n     pytester.makepyfile(\n\nFrom aa83fa353c58c8b9f6b6afecbc5a223e9731d720 Mon Sep 17 00:00:00 2001\nFrom: EmptyRabbit <32815055+EmptyRabbit@users.noreply.github.com>\nDate: Thu, 7 Jul 2022 19:29:50 +0800\nSubject: [PATCH 3/4] Update changelog/9877.bugfix.rst\n\nCo-authored-by: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\n---\n changelog/9877.bugfix.rst | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/changelog/9877.bugfix.rst b/changelog/9877.bugfix.rst\nindex ace3a4385a4..77b1b8c38ff 100644\n--- a/changelog/9877.bugfix.rst\n+++ b/changelog/9877.bugfix.rst\n@@ -1 +1 @@\n-Fixed ``caplog.get_records(when)`` still get the stage records after ``caplog.clear()``\n+ensure ``caplog.get_records(when)`` returns current/correct data after invoking ``caplog.clear()``\n\nFrom 87265973218e37bf7839bfbbd25fe69f1fe50a15 Mon Sep 17 00:00:00 2001\nFrom: Bruno Oliveira <nicoddemus@gmail.com>\nDate: Thu, 7 Jul 2022 09:39:57 -0300\nSubject: [PATCH 4/4] Update changelog/9877.bugfix.rst\n\n---\n changelog/9877.bugfix.rst | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/changelog/9877.bugfix.rst b/changelog/9877.bugfix.rst\nindex 77b1b8c38ff..1d2264c6157 100644\n--- a/changelog/9877.bugfix.rst\n+++ b/changelog/9877.bugfix.rst\n@@ -1 +1 @@\n-ensure ``caplog.get_records(when)`` returns current/correct data after invoking ``caplog.clear()``\n+Ensure ``caplog.get_records(when)`` returns current/correct data after invoking ``caplog.clear()``.\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10051"}