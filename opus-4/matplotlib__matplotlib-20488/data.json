{"instance_id": "matplotlib__matplotlib-20488", "score": "I", "diff": "diff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..c2f781b311\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,105 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib import colors\n+import matplotlib.scale as scale\n+import matplotlib.cbook as cbook\n+\n+# Test the issue\n+data = np.full((5, 5), -1, dtype=np.float64)\n+data[0:2, :] = 1E20\n+\n+print(f\"data.max() = {data.max()}\")\n+print(f\"data type = {data.dtype}\")\n+\n+# Create a LogNorm instance\n+norm = colors.LogNorm(vmin=100, vmax=data.max())\n+print(f\"\\nLogNorm created with vmin={norm.vmin}, vmax={norm.vmax}\")\n+\n+# Simulate what happens in image.py _make_image\n+A = np.ma.masked_less_equal(data, 0, copy=False)\n+scaled_dtype = np.float64\n+\n+# Simulate the vrange calculation from image.py\n+a_min = A.min()\n+a_max = A.max()\n+print(f\"\\na_min = {a_min}, a_max = {a_max}\")\n+print(f\"a_min == a_max: {a_min == a_max}\")\n+\n+# The offset and frac values used in image.py\n+offset = .1\n+frac = .8\n+\n+# This is what happens in image.py\n+vmin, vmax = norm.vmin, norm.vmax\n+vrange = np.array([vmin, vmax], dtype=scaled_dtype)\n+print(f\"\\nOriginal vrange = {vrange}\")\n+\n+# The issue: when a_min == a_max, the scaling operations cause problems\n+# Let's trace through step by step\n+vrange_scaled = vrange.copy()\n+vrange_scaled -= a_min\n+print(f\"After subtracting a_min: vrange_scaled = {vrange_scaled}\")\n+\n+# When a_min == a_max, the division is skipped, but offset is still added\n+if a_min != a_max:\n+    vrange_scaled /= ((a_max - a_min) / frac)\n+    print(f\"After division: vrange_scaled = {vrange_scaled}\")\n+else:\n+    print(\"Skipping division because a_min == a_max\")\n+\n+vrange_scaled += offset\n+print(f\"After adding offset: vrange_scaled = {vrange_scaled}\")\n+\n+# Then later it's reversed...\n+vrange_unscaled = vrange_scaled.copy()\n+vrange_unscaled -= offset\n+# When a_min == a_max, the multiplication is also skipped\n+if a_min != a_max:\n+    vrange_unscaled *= ((a_max - a_min) / frac)\n+else:\n+    print(\"Skipping multiplication because a_min == a_max\")\n+vrange_unscaled += a_min\n+\n+print(f\"\\nAfter unscaling: vrange_unscaled = {vrange_unscaled}\")\n+print(f\"Original vrange was: {vrange}\")\n+print(f\"PROBLEM: vmin changed from {vmin} to {vrange_unscaled[0]}!\")\n+\n+# Now test different data where min != max\n+print(\"\\n\\n\" + \"=\"*60)\n+print(\"Testing with data where min != max...\")\n+data2 = np.full((5, 5), -1, dtype=np.float64)\n+data2[0:2, :] = 1E20\n+data2[2, 2] = 1E19  # Add a different value\n+\n+A2 = np.ma.masked_less_equal(data2, 0, copy=False) \n+a_min2 = A2.min()\n+a_max2 = A2.max()\n+print(f\"a_min2 = {a_min2}, a_max2 = {a_max2}\")\n+print(f\"a_min2 == a_max2: {a_min2 == a_max2}\")\n+\n+vrange2 = np.array([vmin, vmax], dtype=scaled_dtype)\n+print(f\"Original vrange2 = {vrange2}\")\n+vrange2_scaled = vrange2.copy()\n+vrange2_scaled -= a_min2\n+print(f\"After subtracting a_min2: vrange2_scaled = {vrange2_scaled}\")\n+if a_min2 != a_max2:\n+    vrange2_scaled /= ((a_max2 - a_min2) / frac)\n+    print(f\"After division: vrange2_scaled = {vrange2_scaled}\")\n+vrange2_scaled += offset\n+print(f\"After adding offset: vrange2_scaled = {vrange2_scaled}\")\n+\n+vrange2_unscaled = vrange2_scaled.copy()\n+vrange2_unscaled -= offset\n+if a_min2 != a_max2:\n+    vrange2_unscaled *= ((a_max2 - a_min2) / frac)\n+    print(f\"After multiplication: vrange2_unscaled = {vrange2_unscaled}\")\n+vrange2_unscaled += a_min2\n+\n+print(f\"After adding a_min2: vrange2_unscaled = {vrange2_unscaled}\")\n+print(f\"PROBLEM: vmin changed from {vmin} to {vrange2_unscaled[0]}!\")\n+\n+# The real issue: when vmin is much smaller than a_min, \n+# the subtraction and division cause precision loss\n+print(f\"\\nThe issue is: vmin={vmin} << a_min2={a_min2}\")\n+print(f\"vmin - a_min2 = {vmin - a_min2}\")\n+print(f\"This gets normalized to a very small negative number that rounds to 0\")\ndiff --git a/test_fix_verification.py b/test_fix_verification.py\nnew file mode 100644\nindex 0000000000..3a1f4975b3\n--- /dev/null\n+++ b/test_fix_verification.py\n@@ -0,0 +1,62 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib import colors\n+\n+print(\"Testing LogNorm with huge range data...\")\n+\n+# Test case 1: All values are the same huge value (original failing case)\n+data1 = np.full((5, 5), -1, dtype=np.float64)\n+data1[0:2, :] = 1E20\n+\n+fig1, ax1 = plt.subplots()\n+try:\n+    im1 = ax1.imshow(data1, norm=colors.LogNorm(vmin=100, vmax=data1.max()),\n+                     interpolation='nearest', cmap='viridis')\n+    fig1.canvas.draw()\n+    print(\"\u2713 Test 1 passed: All values same huge value\")\n+except Exception as e:\n+    print(f\"\u2717 Test 1 failed: {e}\")\n+\n+# Test case 2: Mix of huge values \n+data2 = np.full((5, 5), -1, dtype=np.float64)\n+data2[0:2, :] = 1E20\n+data2[2, 2] = 1E19\n+\n+fig2, ax2 = plt.subplots()\n+try:\n+    im2 = ax2.imshow(data2, norm=colors.LogNorm(vmin=100, vmax=data2.max()),\n+                     interpolation='nearest', cmap='viridis')\n+    fig2.canvas.draw()\n+    print(\"\u2713 Test 2 passed: Mix of huge values\")\n+except Exception as e:\n+    print(f\"\u2717 Test 2 failed: {e}\")\n+\n+# Test case 3: Very small vmin with huge data\n+data3 = np.full((5, 5), -1, dtype=np.float64)\n+data3[0:2, :] = 1E100\n+\n+fig3, ax3 = plt.subplots()\n+try:\n+    im3 = ax3.imshow(data3, norm=colors.LogNorm(vmin=1e-10, vmax=data3.max()),\n+                     interpolation='nearest', cmap='viridis')\n+    fig3.canvas.draw()\n+    print(\"\u2713 Test 3 passed: Very small vmin with huge data\")\n+except Exception as e:\n+    print(f\"\u2717 Test 3 failed: {e}\")\n+\n+# Test case 4: Edge case with zeros that should be masked\n+data4 = np.array([[1E20, 1E20], [0, 1E20]])\n+\n+fig4, ax4 = plt.subplots()\n+try:\n+    im4 = ax4.imshow(data4, norm=colors.LogNorm(vmin=100, vmax=data4.max()),\n+                     interpolation='nearest', cmap='viridis')\n+    fig4.canvas.draw()\n+    print(\"\u2713 Test 4 passed: Data with zeros\")\n+except Exception as e:\n+    print(f\"\u2717 Test 4 failed: {e}\")\n+\n+# Clean up\n+plt.close('all')\n+\n+print(\"\\nAll tests completed!\")\n", "gold_standard_diff": "diff --git a/lib/matplotlib/image.py b/lib/matplotlib/image.py\nindex 95bb42d75c61..b710e7ac0901 100644\n--- a/lib/matplotlib/image.py\n+++ b/lib/matplotlib/image.py\n@@ -532,9 +532,9 @@ def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                 # we have re-set the vmin/vmax to account for small errors\n                 # that may have moved input values in/out of range\n                 s_vmin, s_vmax = vrange\n-                if isinstance(self.norm, mcolors.LogNorm):\n-                    if s_vmin < 0:\n-                        s_vmin = max(s_vmin, np.finfo(scaled_dtype).eps)\n+                if isinstance(self.norm, mcolors.LogNorm) and s_vmin <= 0:\n+                    # Don't give 0 or negative values to LogNorm\n+                    s_vmin = np.finfo(scaled_dtype).eps\n                 with cbook._setattr_cm(self.norm,\n                                        vmin=s_vmin,\n                                        vmax=s_vmax,\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4fb..42ed7479ae54 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,23 +1233,24 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@pytest.mark.parametrize('x', [-1, 1])\n @check_figures_equal(extensions=['png'])\n-def test_huge_range_log(fig_test, fig_ref):\n-    data = np.full((5, 5), -1, dtype=np.float64)\n+def test_huge_range_log(fig_test, fig_ref, x):\n+    # parametrize over bad lognorm -1 values and large range 1 -> 1e20\n+    data = np.full((5, 5), x, dtype=np.float64)\n     data[0:2, :] = 1E20\n \n     ax = fig_test.subplots()\n-    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap='viridis')\n+    ax.imshow(data, norm=colors.LogNorm(vmin=1, vmax=data.max()),\n+              interpolation='nearest', cmap='viridis')\n \n-    data = np.full((5, 5), -1, dtype=np.float64)\n+    data = np.full((5, 5), x, dtype=np.float64)\n     data[0:2, :] = 1000\n \n-    cmap = copy(plt.get_cmap('viridis'))\n-    cmap.set_under('w')\n     ax = fig_ref.subplots()\n-    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap=cmap)\n+    cmap = plt.get_cmap('viridis').with_extremes(under='w')\n+    ax.imshow(data, norm=colors.Normalize(vmin=1, vmax=data.max()),\n+              interpolation='nearest', cmap=cmap)\n \n \n @check_figures_equal()\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/20488"}