{"instance_id": "django__django-17084", "score": "I", "diff": "diff --git a/fix_aggregate_over_window.py b/fix_aggregate_over_window.py\nnew file mode 100644\nindex 0000000000..613d8e6533\n--- /dev/null\n+++ b/fix_aggregate_over_window.py\n@@ -0,0 +1,58 @@\n+from django.db import models\n+from django.db.models import Sum, Window, F, Subquery, OuterRef\n+from django.db.models.functions import Coalesce\n+\n+# Example model\n+class SampleModel(models.Model):\n+    date = models.DateField()\n+    DJR = models.FloatField()\n+\n+# Example query\n+def get_aggregated_data():\n+    queryset = SampleModel.objects.all()\n+\n+    # First, create a subquery with the window function\n+    subquery = queryset.annotate(\n+        cumul_DJR=Window(\n+            expression=Sum('DJR'),\n+            order_by=F('date').asc()\n+        )\n+    ).values('id', 'DJR', 'cumul_DJR')\n+\n+    # Then, use the subquery in the main query\n+    queryset = queryset.annotate(\n+        cumul_DJR=Subquery(\n+            subquery.filter(id=OuterRef('id')).values('cumul_DJR')[:1]\n+        )\n+    )\n+\n+    # Finally, perform the aggregation\n+    aggregate = queryset.aggregate(\n+        DJR_total=Sum('DJR'),\n+        cumul_DJR_total=Sum('cumul_DJR')\n+    )\n+\n+    return aggregate\n+\n+# Note: This solution assumes that 'id' is a unique identifier for each row in the queryset.\n+# If that's not the case, you may need to adjust the subquery accordingly.\n+\n+\"\"\"\n+Explanation of the changes:\n+\n+1. The original query was trying to use an aggregate function (Sum) over a window function (cumul_DJR),\n+   which is not supported by PostgreSQL and caused the error:\n+   \"aggregate function calls cannot contain window function calls\"\n+\n+2. To solve this, we've separated the window function calculation into a subquery.\n+   This subquery calculates the cumulative sum for each row using the Window function.\n+\n+3. We then use this subquery to annotate the main queryset with the cumulative sum values.\n+   This approach avoids nesting the window function inside the aggregate function.\n+\n+4. Finally, we perform the aggregation on the annotated queryset, which now contains\n+   both the original DJR values and the pre-calculated cumulative DJR values.\n+\n+This solution allows us to calculate both the total sum of DJR and the total sum of cumulative DJR\n+without running into the PostgreSQL limitation of using window functions inside aggregate functions.\n+\"\"\"\n", "gold_standard_diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 13a6809dd83f..1608d194807c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -403,6 +403,7 @@ def get_aggregation(self, using, aggregate_exprs):\n         # Store annotation mask prior to temporarily adding aggregations for\n         # resolving purpose to facilitate their subsequent removal.\n         refs_subquery = False\n+        refs_window = False\n         replacements = {}\n         annotation_select_mask = self.annotation_select_mask\n         for alias, aggregate_expr in aggregate_exprs.items():\n@@ -419,6 +420,10 @@ def get_aggregation(self, using, aggregate_exprs):\n                 getattr(self.annotations[ref], \"subquery\", False)\n                 for ref in aggregate.get_refs()\n             )\n+            refs_window |= any(\n+                getattr(self.annotations[ref], \"contains_over_clause\", True)\n+                for ref in aggregate.get_refs()\n+            )\n             aggregate = aggregate.replace_expressions(replacements)\n             self.annotations[alias] = aggregate\n             replacements[Ref(alias, aggregate)] = aggregate\n@@ -451,6 +456,7 @@ def get_aggregation(self, using, aggregate_exprs):\n             or self.is_sliced\n             or has_existing_aggregation\n             or refs_subquery\n+            or refs_window\n             or qualify\n             or self.distinct\n             or self.combinator\ndiff --git a/docs/releases/4.2.4.txt b/docs/releases/4.2.4.txt\nindex e8fd22551632..3921dd9b3e0f 100644\n--- a/docs/releases/4.2.4.txt\n+++ b/docs/releases/4.2.4.txt\n@@ -9,4 +9,6 @@ Django 4.2.4 fixes several bugs in 4.2.3.\n Bugfixes\n ========\n \n-* ...\n+* Fixed a regression in Django 4.2 that caused a crash of\n+  ``QuerySet.aggregate()`` with aggregates referencing window functions\n+  (:ticket:`34717`).\ndiff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 366b8434e542..db69246952fa 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -28,6 +28,7 @@\n     Value,\n     Variance,\n     When,\n+    Window,\n )\n from django.db.models.expressions import Func, RawSQL\n from django.db.models.functions import (\n@@ -2207,3 +2208,23 @@ def test_referenced_subquery_requires_wrapping(self):\n         sql = ctx.captured_queries[0][\"sql\"].lower()\n         self.assertEqual(sql.count(\"select\"), 3, \"Subquery wrapping required\")\n         self.assertEqual(aggregate, {\"sum_total_books\": 3})\n+\n+    @skipUnlessDBFeature(\"supports_over_clause\")\n+    def test_referenced_window_requires_wrapping(self):\n+        total_books_qs = Book.objects.annotate(\n+            avg_publisher_pages=Coalesce(\n+                Window(Avg(\"pages\"), partition_by=F(\"publisher\")),\n+                0.0,\n+            )\n+        )\n+        with self.assertNumQueries(1) as ctx:\n+            aggregate = total_books_qs.aggregate(\n+                sum_avg_publisher_pages=Sum(\"avg_publisher_pages\"),\n+                books_count=Count(\"id\"),\n+            )\n+        sql = ctx.captured_queries[0][\"sql\"].lower()\n+        self.assertEqual(sql.count(\"select\"), 2, \"Subquery wrapping required\")\n+        self.assertEqual(\n+            aggregate,\n+            {\"sum_avg_publisher_pages\": 1100.0, \"books_count\": 2},\n+        )\n", "gold_standard_pr_link": "https://github.com/django/django/pull/17084"}