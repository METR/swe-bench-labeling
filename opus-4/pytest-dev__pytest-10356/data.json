{"instance_id": "pytest-dev__pytest-10356", "score": "I", "diff": "diff --git a/pytest_test.ini b/pytest_test.ini\nnew file mode 100644\nindex 000000000..5720dae4c\n--- /dev/null\n+++ b/pytest_test.ini\n@@ -0,0 +1,6 @@\n+[pytest]\n+markers =\n+    foo: foo marker\n+    bar: bar marker\n+    baz: baz marker\n+    qux: qux marker\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..95da2fd8e 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -360,6 +360,28 @@ def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n     mark_list = getattr(obj, \"pytestmark\", [])\n     if not isinstance(mark_list, list):\n         mark_list = [mark_list]\n+    \n+    # If obj is a class, we need to collect markers from all classes in MRO\n+    # but without duplicates from the direct pytestmark attribute\n+    if inspect.isclass(obj):\n+        # First check if obj has its own pytestmark that's not inherited\n+        own_mark_list = []\n+        if \"pytestmark\" in obj.__dict__:\n+            own_mark_list = mark_list\n+        \n+        # Now collect from all parent classes in MRO (excluding object)\n+        mro_marks = []\n+        for cls in obj.__mro__[1:-1]:  # Skip self (obj) and object\n+            # Only get marks that are directly on the class\n+            if \"pytestmark\" in cls.__dict__:\n+                cls_marks = getattr(cls, \"pytestmark\", [])\n+                if not isinstance(cls_marks, list):\n+                    cls_marks = [cls_marks]\n+                mro_marks.extend(cls_marks)\n+        \n+        # Combine MRO marks with own marks\n+        mark_list = mro_marks + own_mark_list\n+    \n     return normalize_mark_list(mark_list)\n \n \ndiff --git a/test_issue_scenario.py b/test_issue_scenario.py\nnew file mode 100644\nindex 000000000..2ca0ddb1e\n--- /dev/null\n+++ b/test_issue_scenario.py\n@@ -0,0 +1,32 @@\n+# This is the exact test scenario from the issue\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        # In practice markers are resolved using MRO (so foo wins), unless the\n+        # metaclass is applied\n+        pass\n+\n+# Let's verify it works by checking markers programmatically\n+def test_verify_markers():\n+    \"\"\"Verify that TestDings.test_dings has both foo and bar markers\"\"\"\n+    from _pytest.mark.structures import get_unpacked_marks\n+    \n+    # Get marks from the test class\n+    marks = list(get_unpacked_marks(TestDings))\n+    mark_names = [m.name for m in marks]\n+    \n+    print(f\"Marks on TestDings: {mark_names}\")\n+    \n+    # Both foo and bar should be present\n+    assert \"foo\" in mark_names\n+    assert \"bar\" in mark_names\ndiff --git a/test_mark_inheritance.py b/test_mark_inheritance.py\nnew file mode 100644\nindex 000000000..3be51c9a2\n--- /dev/null\n+++ b/test_mark_inheritance.py\n@@ -0,0 +1,24 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        # In practice markers are resolved using MRO (so foo wins)\n+        pass\n+\n+# Let's also test the markers directly\n+if __name__ == \"__main__\":\n+    # Check what markers are on the test\n+    import inspect\n+    test_func = TestDings.test_dings\n+    print(\"Direct pytestmark on TestDings:\", getattr(TestDings, 'pytestmark', None))\n+    print(\"Direct pytestmark on Foo:\", getattr(Foo, 'pytestmark', None))\n+    print(\"Direct pytestmark on Bar:\", getattr(Bar, 'pytestmark', None))\ndiff --git a/test_mark_inheritance_detailed.py b/test_mark_inheritance_detailed.py\nnew file mode 100644\nindex 000000000..c154aaad3\n--- /dev/null\n+++ b/test_mark_inheritance_detailed.py\n@@ -0,0 +1,36 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self, request):\n+        # Get all markers on this test\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"bar\" in markers\n+\n+# Test with single inheritance too\n+@pytest.mark.baz\n+class TestSingleInheritance(Foo):\n+    def test_single(self, request):\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"baz\" in markers\n+\n+# Test deep inheritance\n+@pytest.mark.qux\n+class TestDeepInheritance(TestDings):\n+    def test_deep(self, request):\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"bar\" in markers\n+        assert \"qux\" in markers\ndiff --git a/test_mark_mro_simple.py b/test_mark_mro_simple.py\nnew file mode 100644\nindex 000000000..13eb06964\n--- /dev/null\n+++ b/test_mark_mro_simple.py\n@@ -0,0 +1,14 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        pass\n", "gold_standard_diff": "diff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nnew file mode 100644\nindex 00000000000..8f65637896d\n--- /dev/null\n+++ b/changelog/7792.bugfix.rst\n@@ -0,0 +1,5 @@\n+Marks are now inherited according to the full MRO in test classes. Previously, if a test class inherited from two or more classes, only marks from the first super-class would apply.\n+\n+When inheriting marks from super-classes, marks from the sub-classes are now ordered before marks from the super-classes, in MRO order. Previously it was the reverse.\n+\n+When inheriting marks from super-classes, the `pytestmark` attribute of the sub-class now only contains the marks directly applied to it. Previously, it also contained marks from its super-classes. Please note that this attribute should not normally be accessed directly; use :func:`pytest.Node.iter_markers` instead.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c9243..5186c9ea3b6 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,12 +355,35 @@ def __call__(self, *args: object, **kwargs: object):\n         return self.with_args(*args, **kwargs)\n \n \n-def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n-    return normalize_mark_list(mark_list)\n+def get_unpacked_marks(\n+    obj: Union[object, type],\n+    *,\n+    consider_mro: bool = True,\n+) -> List[Mark]:\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+\n+    If obj is a class and consider_mro is true, return marks applied to\n+    this class and all of its super-classes in MRO order. If consider_mro\n+    is false, only return marks applied directly to this class.\n+    \"\"\"\n+    if isinstance(obj, type):\n+        if not consider_mro:\n+            mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\n+        else:\n+            mark_lists = [x.__dict__.get(\"pytestmark\", []) for x in obj.__mro__]\n+        mark_list = []\n+        for item in mark_lists:\n+            if isinstance(item, list):\n+                mark_list.extend(item)\n+            else:\n+                mark_list.append(item)\n+    else:\n+        mark_attribute = getattr(obj, \"pytestmark\", [])\n+        if isinstance(mark_attribute, list):\n+            mark_list = mark_attribute\n+        else:\n+            mark_list = [mark_attribute]\n+    return list(normalize_mark_list(mark_list))\n \n \n def normalize_mark_list(\n@@ -388,7 +411,7 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    obj.pytestmark = [*get_unpacked_marks(obj, consider_mro=False), mark]\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 65f2581bd63..e2d1a40c38a 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1109,3 +1109,27 @@ def test_foo():\n     result = pytester.runpytest(foo, \"-m\", expr)\n     result.stderr.fnmatch_lines([expected])\n     assert result.ret == ExitCode.USAGE_ERROR\n+\n+\n+def test_mark_mro() -> None:\n+    xfail = pytest.mark.xfail\n+\n+    @xfail(\"a\")\n+    class A:\n+        pass\n+\n+    @xfail(\"b\")\n+    class B:\n+        pass\n+\n+    @xfail(\"c\")\n+    class C(A, B):\n+        pass\n+\n+    from _pytest.mark.structures import get_unpacked_marks\n+\n+    all_marks = get_unpacked_marks(C)\n+\n+    assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n+\n+    assert get_unpacked_marks(C, consider_mro=False) == [xfail(\"c\").mark]\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10356"}