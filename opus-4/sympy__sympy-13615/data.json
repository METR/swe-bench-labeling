{"instance_id": "sympy__sympy-13615", "score": "C", "diff": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb74..91acc24fa2 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1725,6 +1725,40 @@ def reduce(A, B):\n         if isinstance(B, Union):\n             return Intersection(s.complement(A) for s in B.args)\n \n+        # Special handling for FiniteSet - Interval case with mixed content\n+        if isinstance(A, FiniteSet) and isinstance(B, Interval):\n+            # Separate elements that can be evaluated vs those that cannot\n+            definite_in = []\n+            definite_out = []\n+            unknown = []\n+            \n+            for elem in A:\n+                contains_result = B.contains(elem)\n+                if contains_result is S.true:\n+                    definite_in.append(elem)\n+                elif contains_result is S.false:\n+                    definite_out.append(elem)\n+                else:\n+                    unknown.append(elem)\n+            \n+            # If we have unknown elements, we need to keep them as Complement\n+            if unknown:\n+                result_parts = []\n+                if definite_out:\n+                    result_parts.append(FiniteSet(*definite_out))\n+                if unknown:\n+                    result_parts.append(Complement(FiniteSet(*unknown), B, evaluate=False))\n+                \n+                if len(result_parts) == 0:\n+                    return EmptySet()\n+                elif len(result_parts) == 1:\n+                    return result_parts[0]\n+                else:\n+                    return Union(*result_parts)\n+            else:\n+                # All elements can be definitively classified\n+                return FiniteSet(*definite_out) if definite_out else EmptySet()\n+\n         result = B._complement(A)\n         if result != None:\n             return result\ndiff --git a/test_complement_comprehensive.py b/test_complement_comprehensive.py\nnew file mode 100644\nindex 0000000000..5656ce5f68\n--- /dev/null\n+++ b/test_complement_comprehensive.py\n@@ -0,0 +1,70 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Union\n+\n+x, y, z = symbols('x y z')\n+\n+print(\"Test cases:\")\n+print()\n+\n+# Original issue case\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+result = Complement(a, b)\n+print(f\"1. Complement({a}, {b}) = {result}\")\n+print(\"   Expected: {x, y} \\\\ [-10, 10]\")\n+expected1 = '{x, y} \\\\ Interval(-10, 10)'\n+print(f\"   Pass: {str(result) == expected1}\")\n+print()\n+\n+# Case with only numbers\n+c = FiniteSet(1, 2, 3, 15)\n+d = Interval(0, 10)\n+result2 = Complement(c, d)\n+print(f\"2. Complement({c}, {d}) = {result2}\")\n+print(\"   Expected: {15}\")\n+print(f\"   Pass: {result2 == FiniteSet(15)}\")\n+print()\n+\n+# Case with only symbols\n+e = FiniteSet(x, y, z)\n+f = Interval(0, 10)\n+result3 = Complement(e, f)\n+print(f\"3. Complement({e}, {f}) = {result3}\")\n+print(\"   Expected: {x, y, z} \\\\ [0, 10]\")\n+expected3 = '{x, y, z} \\\\ Interval(0, 10)'\n+print(f\"   Pass: {str(result3) == expected3}\")\n+print()\n+\n+# Mixed case with some numbers in interval, some out\n+g = FiniteSet(x, y, 5, 15)\n+h = Interval(0, 10)\n+result4 = Complement(g, h)\n+print(f\"4. Complement({g}, {h}) = {result4}\")\n+print(\"   Expected: Union({15}, {x, y} \\\\ [0, 10])\")\n+print(f\"   Pass: {isinstance(result4, Union)}\")\n+print()\n+\n+# Empty result case\n+i = FiniteSet(5, 6, 7)\n+j = Interval(0, 10)\n+result5 = Complement(i, j)\n+print(f\"5. Complement({i}, {j}) = {result5}\")\n+print(\"   Expected: EmptySet\")\n+print(f\"   Pass: {result5 == S.EmptySet}\")\n+print()\n+\n+# Test that other Complement operations still work\n+k = Interval(0, 5)\n+l = Interval(2, 7)\n+result6 = Complement(k, l)\n+print(f\"6. Complement({k}, {l}) = {result6}\")\n+print(\"   Expected: [0, 2)\")\n+print(f\"   Pass: {result6 == Interval(0, 2, False, True)}\")\n+print()\n+\n+# FiniteSet - FiniteSet\n+m = FiniteSet(1, 2, 3, x)\n+n = FiniteSet(2, 3, y)\n+result7 = Complement(m, n)\n+print(f\"7. Complement({m}, {n}) = {result7}\")\n+# This should use the existing FiniteSet logic\n+print(f\"   Pass: {1 in result7 and x in result7 and 2 not in result7}\")\ndiff --git a/test_complement_debug.py b/test_complement_debug.py\nnew file mode 100644\nindex 0000000000..f468591724\n--- /dev/null\n+++ b/test_complement_debug.py\n@@ -0,0 +1,26 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection\n+\n+x, y = symbols('x y')\n+\n+# Test what happens in the complement operation\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+\n+print(\"Step by step:\")\n+print(f\"a = {a}\")\n+print(f\"b = {b}\")\n+print()\n+\n+# What does a.complement(S.Reals) return?\n+comp_reals = a.complement(S.Reals)\n+print(f\"a.complement(S.Reals) = {comp_reals}\")\n+print()\n+\n+# What does Intersection(b, comp_reals) return?\n+result = Intersection(b, comp_reals)\n+print(f\"Intersection(b, a.complement(S.Reals)) = {result}\")\n+print()\n+\n+# Let's look at the actual Complement object\n+comp = Complement(a, b, evaluate=False)\n+print(f\"Complement(a, b, evaluate=False) = {comp}\")\ndiff --git a/test_complement_issue.py b/test_complement_issue.py\nnew file mode 100644\nindex 0000000000..0bbb2bac9c\n--- /dev/null\n+++ b/test_complement_issue.py\n@@ -0,0 +1,15 @@\n+from sympy import FiniteSet, Interval, Complement, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test case from the issue\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+result = Complement(a, b)\n+print(f\"Complement({a}, {b}) = {result}\")\n+print(f\"Expected: {{x, y}} \\\\ [-10, 10]\")\n+print()\n+\n+# Let's also test the reverse\n+c = Complement(b, a)\n+print(f\"Complement({b}, {a}) = {c}\")\ndiff --git a/test_complement_semantics.py b/test_complement_semantics.py\nnew file mode 100644\nindex 0000000000..f7f6d397a3\n--- /dev/null\n+++ b/test_complement_semantics.py\n@@ -0,0 +1,43 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection\n+\n+# Let's understand the semantics of _complement\n+\n+# First, let's see what Set._complement does\n+print(\"Testing Set._complement:\")\n+a = Interval(0, 5)\n+b = FiniteSet(2, 3)\n+\n+# According to the comment in Set._complement, it behaves as other - self\n+# So a._complement(b) should be b - a = EmptySet (since 2, 3 are in [0, 5])\n+print(f\"Interval(0, 5)._complement(FiniteSet(2, 3)) = {a._complement(b)}\")\n+print(\"This should be FiniteSet(2, 3) - Interval(0, 5) = EmptySet\")\n+print()\n+\n+# Let's verify by creating the Complement directly\n+print(f\"Complement(FiniteSet(2, 3), Interval(0, 5)) = {Complement(FiniteSet(2, 3), Interval(0, 5))}\")\n+print()\n+\n+# Now let's trace through what happens in our problematic case\n+x, y = symbols('x y')\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+print(\"Tracing Complement(FiniteSet(x, y, 2), Interval(-10, 10)):\")\n+print(\"1. Complement.reduce is called\")\n+print(\"2. It calls interval._complement(fs)\")\n+print(\"3. Since fs contains a number (2), Interval._complement calls Set._complement\")\n+print(\"4. Set._complement (line 206-208) returns Intersection(interval, fs.complement(S.Reals))\")\n+print()\n+\n+# What is fs.complement(S.Reals)?\n+comp = fs.complement(S.Reals)\n+print(f\"fs.complement(S.Reals) = {comp}\")\n+print()\n+\n+# What is the intersection?\n+inter = Intersection(interval, comp)\n+print(f\"Intersection(interval, fs.complement(S.Reals)) = {inter}\")\n+print()\n+\n+# This is computing interval - fs, not fs - interval!\n+print(\"So the current code computes interval - fs = {x, y}, not fs - interval!\")\ndiff --git a/test_complement_verify.py b/test_complement_verify.py\nnew file mode 100644\nindex 0000000000..c1ed8d7f40\n--- /dev/null\n+++ b/test_complement_verify.py\n@@ -0,0 +1,32 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S\n+\n+# Test to verify the semantic issue\n+\n+# Simple case: FiniteSet - FiniteSet\n+a = FiniteSet(1, 2, 3)\n+b = FiniteSet(2, 3, 4)\n+print(f\"Complement({a}, {b}) = {Complement(a, b)}\")\n+print(f\"Expected: {{1}}\")\n+print()\n+\n+# Another simple case: Interval - Interval\n+c = Interval(0, 5)\n+d = Interval(2, 7)\n+print(f\"Complement({c}, {d}) = {Complement(c, d)}\")\n+print(f\"Expected: [0, 2)\")\n+print()\n+\n+# The problematic case from the issue\n+x, y = symbols('x y')\n+e = FiniteSet(x, y, 2)\n+f = Interval(-10, 10)\n+print(f\"Complement({e}, {f}) = {Complement(e, f)}\")\n+print(f\"Expected: {{x, y}} \\\\ [-10, 10]\")\n+print()\n+\n+# Check what B._complement(A) actually computes\n+g = Interval(0, 5)\n+h = FiniteSet(2, 3)\n+# g._complement(h) should compute g - h = [0, 2) U (2, 3) U (3, 5]\n+print(f\"Interval(0, 5)._complement(FiniteSet(2, 3)) = {g._complement(h)}\")\n+print(\"This shows that B._complement(A) computes B - A, not A - B!\")\ndiff --git a/test_contains_check.py b/test_contains_check.py\nnew file mode 100644\nindex 0000000000..2ddf0370f0\n--- /dev/null\n+++ b/test_contains_check.py\n@@ -0,0 +1,19 @@\n+from sympy import FiniteSet, Interval, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test what elements are contained\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+print(\"Checking which elements of FiniteSet(x, y, 2) are in Interval(-10, 10):\")\n+for el in fs:\n+    contained = interval.contains(el)\n+    print(f\"  {el} in interval: {contained}\")\n+    print(f\"  {el} in interval != True: {contained != True}\")\n+print()\n+\n+# So the result should be elements where contains != True\n+result = [el for el in fs if interval.contains(el) != True]\n+print(f\"Elements where interval.contains(el) != True: {result}\")\n+print(f\"FiniteSet of these elements: {FiniteSet(*result)}\")\ndiff --git a/test_interval_complement.py b/test_interval_complement.py\nnew file mode 100644\nindex 0000000000..ea6fc0c788\n--- /dev/null\n+++ b/test_interval_complement.py\n@@ -0,0 +1,35 @@\n+from sympy import FiniteSet, Interval, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test Interval._complement with FiniteSet\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+# Check what happens in Interval._complement\n+print(\"In Interval._complement(self, other) where self=Interval(-10,10), other=FiniteSet(x,y,2):\")\n+print()\n+\n+# Line 1001-1002: check if other is FiniteSet\n+print(\"isinstance(other, FiniteSet):\", isinstance(fs, FiniteSet))\n+\n+# Line 1002: extract numbers from other\n+nums = [m for m in fs.args if m.is_number]\n+print(f\"nums = [m for m in other.args if m.is_number] = {nums}\")\n+\n+# Line 1003-1004: check if nums is empty\n+print(f\"nums == [] : {nums == []}\")\n+print()\n+\n+# Since nums is not empty ([2]), it goes to line 1006\n+print(\"Since nums is not empty, it calls Set._complement(self, other)\")\n+print(\"which should return the intersection computation...\")\n+print()\n+\n+# But we're getting {x, y} instead. Let me check if there's something else going on\n+from sympy.sets.sets import Set\n+\n+# What does the base Set._complement return?\n+base_result = Set._complement(interval, fs)\n+print(f\"Set._complement(interval, fs) = {base_result}\")\n+print(f\"Type: {type(base_result)}\")\ndiff --git a/test_trace_simplification.py b/test_trace_simplification.py\nnew file mode 100644\nindex 0000000000..0a7afe5108\n--- /dev/null\n+++ b/test_trace_simplification.py\n@@ -0,0 +1,32 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection, Union\n+from sympy.sets.sets import Set\n+\n+x, y = symbols('x y')\n+\n+# Create our sets\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+# What does interval._complement(fs) return?\n+print(\"Calling interval._complement(fs):\")\n+result = interval._complement(fs)\n+print(f\"Result: {result}\")\n+print(f\"Type: {type(result)}\")\n+print()\n+\n+# What does Set._complement(fs, interval) return?\n+print(\"Calling Set._complement(fs, interval):\")\n+result2 = Set._complement(fs, interval)\n+print(f\"Result: {result2}\")\n+print()\n+\n+# Let's manually compute what should happen\n+print(\"Manual computation:\")\n+print(f\"fs.complement(S.Reals) = {fs.complement(S.Reals)}\")\n+comp = fs.complement(S.Reals)\n+print(f\"Intersection(interval, comp) = {Intersection(interval, comp)}\")\n+\n+# Let's see what this evaluates to\n+inter = Intersection(interval, comp, evaluate=False)\n+print(f\"Intersection(interval, comp, evaluate=False) = {inter}\")\n+print(f\"After evaluation: {inter.doit()}\")\n", "gold_standard_diff": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb7429..659b778808ae 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -217,7 +217,17 @@ def _complement(self, other):\n             return S.EmptySet\n \n         elif isinstance(other, FiniteSet):\n-            return FiniteSet(*[el for el in other if self.contains(el) != True])\n+            from sympy.utilities.iterables import sift\n+\n+            def ternary_sift(el):\n+                contains = self.contains(el)\n+                return contains if contains in [True, False] else None\n+\n+            sifted = sift(other, ternary_sift)\n+            # ignore those that are contained in self\n+            return Union(FiniteSet(*(sifted[False])),\n+                Complement(FiniteSet(*(sifted[None])), self, evaluate=False)\n+                if sifted[None] else S.EmptySet)\n \n     def symmetric_difference(self, other):\n         \"\"\"\ndiff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 8c59d85b2045..f4d0483197ed 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -187,6 +187,10 @@ def test_Complement():\n \n     assert S.Reals - Union(S.Naturals, FiniteSet(pi)) == \\\n             Intersection(S.Reals - S.Naturals, S.Reals - FiniteSet(pi))\n+    # isssue 12712\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n+            Complement(FiniteSet(x, y), Interval(-10, 10))\n+\n \n def test_complement():\n     assert Interval(0, 1).complement(S.Reals) == \\\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13615"}