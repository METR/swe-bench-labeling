{"instance_id": "matplotlib__matplotlib-26113", "score": "C", "diff": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 5369eadbde..09b446d1ba 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -4848,7 +4848,7 @@ default: :rc:`scatter.edgecolors`\n             Use a linear or log10 scale on the vertical axis.\n \n         mincnt : int > 0, default: *None*\n-            If not *None*, only display cells with more than *mincnt*\n+            If not *None*, only display cells with at least *mincnt*\n             number of points in the cell.\n \n         marginals : bool, default: *False*\n@@ -5014,7 +5014,7 @@ default: :rc:`scatter.edgecolors`\n             if mincnt is None:\n                 mincnt = 0\n             accum = np.array(\n-                [reduce_C_function(acc) if len(acc) > mincnt else np.nan\n+                [reduce_C_function(acc) if len(acc) >= mincnt else np.nan\n                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]\n                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.\n                 float)\ndiff --git a/test_hexbin_comprehensive.py b/test_hexbin_comprehensive.py\nnew file mode 100644\nindex 0000000000..7730e778eb\n--- /dev/null\n+++ b/test_hexbin_comprehensive.py\n@@ -0,0 +1,77 @@\n+from matplotlib import pyplot\n+import numpy as np\n+\n+np.random.seed(42)\n+\n+# Create test data with known distribution\n+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T\n+Z = np.ones_like(X)\n+\n+extent = [-3., 3., -3., 3.]\n+gridsize = (7, 7)\n+\n+print(\"Testing consistency of mincnt parameter between C=None and C!=None cases\\n\")\n+\n+for mincnt_val in [None, 0, 1, 2, 3, 5]:\n+    # Test without C\n+    fig, ax = pyplot.subplots(1, 1)\n+    h1 = ax.hexbin(\n+        X, Y,\n+        mincnt=mincnt_val,\n+        extent=extent,\n+        gridsize=gridsize,\n+        linewidth=0.0,\n+        cmap='Blues',\n+    )\n+    n_hexagons_no_C = len(h1.get_offsets())\n+    \n+    # Test with C\n+    fig, ax = pyplot.subplots(1, 1)\n+    h2 = ax.hexbin(\n+        X, Y,\n+        C=Z,\n+        reduce_C_function=np.sum,\n+        mincnt=mincnt_val,\n+        extent=extent,\n+        gridsize=gridsize,\n+        linewidth=0.0,\n+        cmap='Blues',\n+    )\n+    n_hexagons_with_C = len(h2.get_offsets())\n+    \n+    consistent = n_hexagons_no_C == n_hexagons_with_C\n+    print(f\"mincnt={mincnt_val}: Without C: {n_hexagons_no_C} hexagons, With C: {n_hexagons_with_C} hexagons - Consistent: {consistent}\")\n+    \n+pyplot.close('all')\n+\n+# Also test edge cases\n+print(\"\\nTesting edge cases:\")\n+\n+# Test with data that results in exactly mincnt points in some hexagons\n+np.random.seed(123)\n+X_sparse = np.array([0, 0, 1, 1, 2, 2, 2])\n+Y_sparse = np.array([0, 0, 0, 0, 0, 0, 0])\n+Z_sparse = np.ones_like(X_sparse)\n+\n+for mincnt_val in [1, 2, 3]:\n+    fig, ax = pyplot.subplots(1, 1)\n+    h1 = ax.hexbin(\n+        X_sparse, Y_sparse,\n+        mincnt=mincnt_val,\n+        extent=[-1, 3, -1, 1],\n+        gridsize=(5, 3),\n+    )\n+    n_no_C = len(h1.get_offsets())\n+    \n+    fig, ax = pyplot.subplots(1, 1)\n+    h2 = ax.hexbin(\n+        X_sparse, Y_sparse,\n+        C=Z_sparse,\n+        reduce_C_function=np.sum,\n+        mincnt=mincnt_val,\n+        extent=[-1, 3, -1, 1],\n+        gridsize=(5, 3),\n+    )\n+    n_with_C = len(h2.get_offsets())\n+    \n+    print(f\"Sparse data - mincnt={mincnt_val}: Without C: {n_no_C}, With C: {n_with_C} - Consistent: {n_no_C == n_with_C}\")\ndiff --git a/test_hexbin_mincnt.py b/test_hexbin_mincnt.py\nnew file mode 100644\nindex 0000000000..ee084b9e0e\n--- /dev/null\n+++ b/test_hexbin_mincnt.py\n@@ -0,0 +1,72 @@\n+from matplotlib import pyplot\n+import numpy as np\n+import matplotlib as mpl\n+\n+print(f\"Matplotlib version: {mpl.__version__}\")\n+\n+np.random.seed(42)\n+\n+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T\n+Z = np.ones_like(X)\n+\n+extent = [-3., 3., -3., 3.]\n+gridsize = (7, 7)\n+\n+# Test case 1: mincnt=1, no C argument\n+fig, ax = pyplot.subplots(1, 1)\n+h1 = ax.hexbin(\n+    X, Y,\n+    mincnt=1,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+ax.set_title(\"mincnt=1, no C argument\")\n+n_hexagons_no_C = len(h1.get_offsets())\n+print(f\"Number of hexagons with mincnt=1, no C: {n_hexagons_no_C}\")\n+\n+# Test case 2: mincnt=1, C argument specified\n+fig, ax = pyplot.subplots(1, 1)\n+h2 = ax.hexbin(\n+    X, Y,\n+    C=Z,\n+    reduce_C_function=np.sum,\n+    mincnt=1,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+ax.set_title(\"mincnt=1, C argument specified\")\n+n_hexagons_with_C = len(h2.get_offsets())\n+print(f\"Number of hexagons with mincnt=1, C specified: {n_hexagons_with_C}\")\n+\n+# Test case 3: mincnt=0, C argument specified  \n+fig, ax = pyplot.subplots(1, 1)\n+h3 = ax.hexbin(\n+    X, Y,\n+    C=Z,\n+    reduce_C_function=np.sum,\n+    mincnt=0,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+ax.set_title(\"mincnt=0, C argument specified\")\n+n_hexagons_with_C_0 = len(h3.get_offsets())\n+print(f\"Number of hexagons with mincnt=0, C specified: {n_hexagons_with_C_0}\")\n+\n+print(f\"\\nInconsistency detected: {n_hexagons_no_C != n_hexagons_with_C}\")\n+print(f\"With mincnt=1 and no C, we get {n_hexagons_no_C} hexagons\")\n+print(f\"With mincnt=1 and C specified, we get {n_hexagons_with_C} hexagons\")\n+print(f\"With mincnt=0 and C specified, we get {n_hexagons_with_C_0} hexagons\")\n+\n+# Show that mincnt=0 with C gives same result as mincnt=1 without C\n+print(f\"\\nmincnt=0 with C gives same result as mincnt=1 without C: {n_hexagons_no_C == n_hexagons_with_C_0}\")\n+\n+# pyplot.show()\ndiff --git a/test_mincnt_regression.py b/test_mincnt_regression.py\nnew file mode 100644\nindex 0000000000..fe6f66421b\n--- /dev/null\n+++ b/test_mincnt_regression.py\n@@ -0,0 +1,71 @@\n+\"\"\"\n+Test for mincnt parameter consistency in hexbin.\n+This ensures the fix for issue remains valid.\n+\"\"\"\n+import numpy as np\n+import pytest\n+from matplotlib import pyplot as plt\n+\n+\n+def test_hexbin_mincnt_consistency():\n+    \"\"\"Test that mincnt behavior is consistent whether C is None or not.\"\"\"\n+    np.random.seed(42)\n+    \n+    # Generate test data\n+    X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T\n+    Z = np.ones_like(X)\n+    \n+    extent = [-3., 3., -3., 3.]\n+    gridsize = (7, 7)\n+    \n+    # Test various mincnt values\n+    for mincnt in [None, 0, 1, 2, 3, 5]:\n+        # Without C\n+        fig, ax = plt.subplots()\n+        h1 = ax.hexbin(X, Y, mincnt=mincnt, extent=extent, gridsize=gridsize)\n+        n_no_C = len(h1.get_offsets())\n+        plt.close(fig)\n+        \n+        # With C\n+        fig, ax = plt.subplots()\n+        h2 = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=mincnt, \n+                       extent=extent, gridsize=gridsize)\n+        n_with_C = len(h2.get_offsets())\n+        plt.close(fig)\n+        \n+        # They should be equal\n+        assert n_no_C == n_with_C, \\\n+            f\"mincnt={mincnt}: inconsistent behavior (no C: {n_no_C}, with C: {n_with_C})\"\n+\n+\n+def test_hexbin_mincnt_edge_cases():\n+    \"\"\"Test edge cases with exact mincnt boundaries.\"\"\"\n+    # Create data with known counts per hexagon\n+    X = np.array([0, 0, 1, 1, 2, 2, 2])\n+    Y = np.array([0, 0, 0, 0, 0, 0, 0])\n+    Z = np.ones_like(X)\n+    \n+    extent = [-1, 3, -1, 1]\n+    gridsize = (5, 3)\n+    \n+    # Test mincnt boundaries\n+    for mincnt in [1, 2, 3]:\n+        fig, ax = plt.subplots()\n+        h1 = ax.hexbin(X, Y, mincnt=mincnt, extent=extent, gridsize=gridsize)\n+        n_no_C = len(h1.get_offsets())\n+        plt.close(fig)\n+        \n+        fig, ax = plt.subplots()\n+        h2 = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=mincnt,\n+                       extent=extent, gridsize=gridsize)\n+        n_with_C = len(h2.get_offsets())\n+        plt.close(fig)\n+        \n+        assert n_no_C == n_with_C, \\\n+            f\"Edge case mincnt={mincnt}: inconsistent (no C: {n_no_C}, with C: {n_with_C})\"\n+\n+\n+if __name__ == \"__main__\":\n+    test_hexbin_mincnt_consistency()\n+    test_hexbin_mincnt_edge_cases()\n+    print(\"All tests passed!\")\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000000..cc5c3cef9b\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,83 @@\n+from matplotlib import pyplot\n+import numpy as np\n+\n+np.random.seed(42)\n+\n+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T\n+Z = np.ones_like(X)\n+\n+extent = [-3., 3., -3., 3.]  # doc: \"Order of scalars is (left, right, bottom, top)\"\n+gridsize = (7, 7)  # doc: \"int or (int, int), optional, default is 100\"\n+\n+# #### no mincnt specified, no C argument\n+fig, ax = pyplot.subplots(1, 1)\n+h1 = ax.hexbin(\n+    X, Y,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")  # for contrast\n+print(f\"No mincnt, no C: {len(h1.get_offsets())} hexagons\")\n+\n+# #### mincnt=1 specified, no C argument\n+fig, ax = pyplot.subplots(1, 1)\n+h2 = ax.hexbin(\n+    X, Y,\n+    mincnt=1,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+print(f\"mincnt=1, no C: {len(h2.get_offsets())} hexagons\")\n+\n+# #### no mincnt specified, C argument specified\n+fig, ax = pyplot.subplots(1, 1)\n+h3 = ax.hexbin(\n+    X, Y,\n+    C=Z,\n+    reduce_C_function=np.sum,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+print(f\"No mincnt, with C: {len(h3.get_offsets())} hexagons\")\n+\n+# #### mincnt=1 specified, C argument specified\n+fig, ax = pyplot.subplots(1, 1)\n+h4 = ax.hexbin(\n+    X, Y,\n+    C=Z,\n+    reduce_C_function=np.sum,\n+    mincnt=1,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+print(f\"mincnt=1, with C: {len(h4.get_offsets())} hexagons\")\n+\n+# #### mincnt=0 specified, C argument specified\n+fig, ax = pyplot.subplots(1, 1)\n+h5 = ax.hexbin(\n+    X, Y,\n+    C=Z,\n+    reduce_C_function=np.sum,\n+    mincnt=0,\n+    extent=extent,\n+    gridsize=gridsize,\n+    linewidth=0.0,\n+    cmap='Blues',\n+)\n+ax.set_facecolor(\"green\")\n+print(f\"mincnt=0, with C: {len(h5.get_offsets())} hexagons\")\n+\n+print(\"\\nAfter fix:\")\n+print(f\"mincnt=1 without C ({len(h2.get_offsets())}) == mincnt=1 with C ({len(h4.get_offsets())}): {len(h2.get_offsets()) == len(h4.get_offsets())}\")\n+print(\"The issue is fixed!\")\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 0000000000..614065ed2a\n--- /dev/null\n+++ b/verify_fix.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Verify that the issue described in the bug report is fixed.\n+\"\"\"\n+from matplotlib import pyplot\n+import numpy as np\n+\n+print(\"Verifying fix for hexbin mincnt parameter inconsistency\")\n+print(\"=\" * 60)\n+\n+np.random.seed(42)\n+\n+X, Y = np.random.multivariate_normal([0.0, 0.0], [[1.0, 0.1], [0.1, 1.0]], size=250).T\n+Z = np.ones_like(X)\n+\n+extent = [-3., 3., -3., 3.]\n+gridsize = (7, 7)\n+\n+# The issue: with mincnt=1, different behavior depending on whether C is supplied\n+fig, ax = pyplot.subplots(1, 1)\n+h_no_c = ax.hexbin(X, Y, mincnt=1, extent=extent, gridsize=gridsize)\n+n_no_c = len(h_no_c.get_offsets())\n+\n+fig, ax = pyplot.subplots(1, 1)\n+h_with_c = ax.hexbin(X, Y, C=Z, reduce_C_function=np.sum, mincnt=1, \n+                     extent=extent, gridsize=gridsize)\n+n_with_c = len(h_with_c.get_offsets())\n+\n+print(f\"Original issue description:\")\n+print(f\"  With mincnt=1 and no C: {n_no_c} hexagons\")\n+print(f\"  With mincnt=1 and C specified: {n_with_c} hexagons\")\n+print(f\"  Are they equal? {n_no_c == n_with_c}\")\n+print()\n+\n+if n_no_c == n_with_c:\n+    print(\"\u2713 FIXED: The behavior is now consistent!\")\n+else:\n+    print(\"\u2717 NOT FIXED: The behavior is still inconsistent!\")\n+    \n+print()\n+print(\"The fix changes the condition from 'len(acc) > mincnt' to 'len(acc) >= mincnt'\")\n+print(\"when C is specified, making it consistent with the C=None case.\")\n+print()\n+print(\"This ensures that mincnt=1 means 'show hexagons with at least 1 point'\")\n+print(\"regardless of whether C is specified or not.\")\n", "gold_standard_diff": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 5369eadbdefd..46fb69852286 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -5014,7 +5014,7 @@ def reduce_C_function(C: array) -> float\n             if mincnt is None:\n                 mincnt = 0\n             accum = np.array(\n-                [reduce_C_function(acc) if len(acc) > mincnt else np.nan\n+                [reduce_C_function(acc) if len(acc) >= mincnt else np.nan\n                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]\n                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.\n                 float)\ndiff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 065d17f953cb..40afa0146bf0 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -999,6 +999,45 @@ def test_hexbin_log_clim():\n     assert h.get_clim() == (2, 100)\n \n \n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_behavior_upon_C_parameter(fig_test, fig_ref):\n+    # see: gh:12926\n+    datapoints = [\n+        # list of (x, y)\n+        (0, 0),\n+        (0, 0),\n+        (6, 0),\n+        (0, 6),\n+    ]\n+    X, Y = zip(*datapoints)\n+    C = [1] * len(X)\n+    extent = [-10., 10, -10., 10]\n+    gridsize = (7, 7)\n+\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    # without C parameter\n+    ax_ref.hexbin(\n+        X, Y,\n+        extent=extent,\n+        gridsize=gridsize,\n+        mincnt=1,\n+    )\n+    ax_ref.set_facecolor(\"green\")  # for contrast of background\n+\n+    # with C parameter\n+    ax_test.hexbin(\n+        X, Y,\n+        C=[1] * len(X),\n+        reduce_C_function=lambda v: sum(v),\n+        mincnt=1,\n+        extent=extent,\n+        gridsize=gridsize,\n+    )\n+    ax_test.set_facecolor(\"green\")\n+\n+\n def test_inverted_limits():\n     # Test gh:1553\n     # Calling invert_xaxis prior to plotting should not disable autoscaling\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/26113"}