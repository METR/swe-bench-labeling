{"instance_id": "matplotlib__matplotlib-25479", "score": "I", "diff": "diff --git a/lib/matplotlib/pyplot.py b/lib/matplotlib/pyplot.py\nindex 58ce4c03fa..de75ed83c7 100644\n--- a/lib/matplotlib/pyplot.py\n+++ b/lib/matplotlib/pyplot.py\n@@ -2278,9 +2278,15 @@ def set_cmap(cmap: Colormap | str) -> None:\n     matplotlib.cm.register_cmap\n     matplotlib.cm.get_cmap\n     \"\"\"\n-    cmap = get_cmap(cmap)\n+    # Store the original name if a string was passed\n+    if isinstance(cmap, str):\n+        cmap_name = cmap\n+        cmap = get_cmap(cmap)\n+    else:\n+        cmap = get_cmap(cmap)\n+        cmap_name = cmap.name\n \n-    rc('image', cmap=cmap.name)\n+    rc('image', cmap=cmap_name)\n     im = gci()\n \n     if im is not None:\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..c832a9e5b4\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,77 @@\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib.pyplot as plt\n+import matplotlib\n+import numpy as np\n+\n+print(\"Testing comprehensive colormap scenarios...\")\n+\n+# Test 1: Original issue - registering with different names\n+print(\"\\nTest 1: Registering colormap with different internal and registered names\")\n+my_cmap_data = [[  1.5e-03,   4.7e-04,   1.4e-02],\n+                 [  2.3e-03,   1.3e-03,   1.8e-02],\n+                 [  3.3e-03,   2.3e-03,   2.4e-02]]\n+my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', my_cmap_data)\n+cm.register_cmap(name='my_cmap_name', cmap=my_cmap)\n+\n+plt.set_cmap('my_cmap_name')\n+assert plt.rcParams['image.cmap'] == 'my_cmap_name', \"rcParams should use the registered name\"\n+\n+# This should work now\n+try:\n+    plt.figure()\n+    plt.imshow([[1, 1], [2, 2]])\n+    plt.close()\n+    print(\"\u2713 Test 1 passed: Can use registered colormap name with imshow\")\n+except Exception as e:\n+    print(f\"\u2717 Test 1 failed: {e}\")\n+\n+# Test 2: Using built-in colormap names\n+print(\"\\nTest 2: Using built-in colormap names\")\n+plt.set_cmap('viridis')\n+assert plt.rcParams['image.cmap'] == 'viridis', \"rcParams should use 'viridis'\"\n+try:\n+    plt.figure()\n+    plt.imshow([[1, 1], [2, 2]])\n+    plt.close()\n+    print(\"\u2713 Test 2 passed: Built-in colormap names work\")\n+except Exception as e:\n+    print(f\"\u2717 Test 2 failed: {e}\")\n+\n+# Test 3: Passing colormap object directly\n+print(\"\\nTest 3: Passing colormap object directly to set_cmap\")\n+cmap_obj = cm.get_cmap('plasma')\n+plt.set_cmap(cmap_obj)\n+assert plt.rcParams['image.cmap'] == 'plasma', \"rcParams should use colormap's name when object is passed\"\n+try:\n+    plt.figure()\n+    plt.imshow([[1, 1], [2, 2]])\n+    plt.close()\n+    print(\"\u2713 Test 3 passed: Colormap objects work\")\n+except Exception as e:\n+    print(f\"\u2717 Test 3 failed: {e}\")\n+\n+# Test 4: Register colormap where internal name matches registered name\n+print(\"\\nTest 4: Registering colormap where internal name matches registered name\")\n+matching_cmap = LinearSegmentedColormap.from_list('matching_name', my_cmap_data)\n+cm.register_cmap(name='matching_name', cmap=matching_cmap)\n+plt.set_cmap('matching_name')\n+assert plt.rcParams['image.cmap'] == 'matching_name', \"rcParams should use 'matching_name'\"\n+try:\n+    plt.figure()\n+    plt.imshow([[1, 1], [2, 2]])\n+    plt.close()\n+    print(\"\u2713 Test 4 passed: Matching names work\")\n+except Exception as e:\n+    print(f\"\u2717 Test 4 failed: {e}\")\n+\n+# Test 5: Verify gci() gets updated\n+print(\"\\nTest 5: Verify current image gets updated\")\n+plt.figure()\n+im = plt.imshow([[1, 1], [2, 2]], cmap='viridis')\n+plt.set_cmap('plasma')\n+assert im.get_cmap().name == 'plasma', \"Current image should be updated\"\n+plt.close()\n+print(\"\u2713 Test 5 passed: Current image colormap updated\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..0018d22f32\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,55 @@\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap, ListedColormap\n+import matplotlib.pyplot as plt\n+import matplotlib\n+import numpy as np\n+\n+print(\"Testing edge cases...\")\n+\n+# Edge case 1: Test with ListedColormap\n+print(\"\\nEdge case 1: ListedColormap\")\n+colors = ['red', 'green', 'blue']\n+listed_cmap = ListedColormap(colors, name='listed_internal')\n+cm.register_cmap(name='listed_registered', cmap=listed_cmap)\n+\n+plt.set_cmap('listed_registered')\n+assert plt.rcParams['image.cmap'] == 'listed_registered'\n+\n+plt.figure()\n+plt.imshow([[1, 1], [2, 2]])\n+plt.close()\n+print(\"\u2713 ListedColormap works\")\n+\n+# Edge case 2: Re-registering with same name\n+print(\"\\nEdge case 2: Re-registering colormap\")\n+cmap_data = [[0, 0, 0], [1, 1, 1]]\n+cmap1 = LinearSegmentedColormap.from_list('reuse_internal', cmap_data)\n+cm.register_cmap(name='reuse_name', cmap=cmap1, override_builtin=True)\n+\n+plt.set_cmap('reuse_name')\n+orig_rcparam = plt.rcParams['image.cmap']\n+\n+# Re-register with different internal name but same registered name\n+cmap2 = LinearSegmentedColormap.from_list('different_internal', cmap_data)\n+cm.register_cmap(name='reuse_name', cmap=cmap2, override_builtin=True)\n+\n+plt.set_cmap('reuse_name')\n+assert plt.rcParams['image.cmap'] == 'reuse_name'\n+print(\"\u2713 Re-registering colormap works\")\n+\n+# Edge case 3: Invalid colormap name\n+print(\"\\nEdge case 3: Invalid colormap name\")\n+try:\n+    plt.set_cmap('this_colormap_does_not_exist')\n+    print(\"\u2717 Should have raised an error\")\n+except ValueError as e:\n+    print(\"\u2713 Correctly raised ValueError for invalid colormap\")\n+\n+# Edge case 4: None colormap\n+print(\"\\nEdge case 4: Setting None (should use default)\")\n+default_cmap = plt.rcParams['image.cmap']\n+plt.set_cmap(None)\n+# When None is passed, it should use the default from rcParams\n+print(\"\u2713 None colormap handled\")\n+\n+print(\"\\nAll edge cases passed!\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..b21fd5975d\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,34 @@\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib.pyplot as plt\n+import matplotlib\n+\n+print(\"Matplotlib version:\", matplotlib.__version__)\n+\n+my_cmap_data = [[  1.5e-03,   4.7e-04,   1.4e-02],\n+                 [  2.3e-03,   1.3e-03,   1.8e-02],\n+                 [  3.3e-03,   2.3e-03,   2.4e-02]]\n+my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', my_cmap_data)\n+cm.register_cmap(name='my_cmap_name', cmap=my_cmap)\n+\n+print(\"Colormap internal name:\", my_cmap.name)\n+print(\"Registered colormap name:\", 'my_cmap_name')\n+\n+# This works fine\n+retrieved_cmap = cm.get_cmap('my_cmap_name')\n+print(\"Retrieved colormap:\", retrieved_cmap)\n+print(\"Retrieved colormap name:\", retrieved_cmap.name)\n+\n+# Test the issue\n+try:\n+    plt.set_cmap('my_cmap_name')  # This should work\n+    print(\"plt.set_cmap succeeded\")\n+    \n+    # Check what's set in rcParams\n+    print(\"rcParams['image.cmap']:\", plt.rcParams['image.cmap'])\n+    \n+    # This should fail according to the issue\n+    plt.imshow([[1, 1], [2, 2]])\n+    print(\"plt.imshow succeeded!\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000000..7d362df045\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,40 @@\n+\"\"\"\n+Reproduction of the original issue from the bug report.\n+This test should pass with our fix.\n+\"\"\"\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib.pyplot as plt\n+import matplotlib\n+\n+print(\"Reproducing original issue...\")\n+\n+# Exact code from the issue report\n+my_cmap_data = [[  1.5e-03,   4.7e-04,   1.4e-02],\n+                 [  2.3e-03,   1.3e-03,   1.8e-02],\n+                 [  3.3e-03,   2.3e-03,   2.4e-02]]\n+my_cmap = LinearSegmentedColormap.from_list('some_cmap_name', my_cmap_data)\n+cm.register_cmap(name='my_cmap_name', cmap=my_cmap)\n+\n+# The issue was that this would fail because plt.set_cmap would\n+# set rcParams['image.cmap'] to 'some_cmap_name' (the internal name)\n+# instead of 'my_cmap_name' (the registered name)\n+plt.set_cmap('my_cmap_name')  # All OK setting the cmap\n+\n+# This should work now with our fix\n+try:\n+    plt.imshow([[1, 1], [2, 2]])\n+    print(\"SUCCESS: plt.imshow() works with the registered colormap name!\")\n+    print(f\"rcParams['image.cmap'] = '{plt.rcParams['image.cmap']}'\")\n+    print(f\"Expected: 'my_cmap_name' (the registered name)\")\n+    print(f\"Not: 'some_cmap_name' (the internal name)\")\n+except ValueError as e:\n+    print(f\"FAILED: {e}\")\n+    print(\"The issue has not been fixed.\")\n+\n+# Also verify that direct lookup still works as expected\n+retrieved = cm.get_cmap('my_cmap_name')\n+print(f\"\\nDirect lookup cm.get_cmap('my_cmap_name'): {retrieved}\")\n+print(f\"Internal name of retrieved colormap: {retrieved.name}\")\n+\n+plt.close('all')\ndiff --git a/test_set_cmap_fix.py b/test_set_cmap_fix.py\nnew file mode 100644\nindex 0000000000..b59b983970\n--- /dev/null\n+++ b/test_set_cmap_fix.py\n@@ -0,0 +1,51 @@\n+import pytest\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib.pyplot as plt\n+import matplotlib\n+\n+\n+def test_set_cmap_with_registered_name():\n+    \"\"\"Test that set_cmap correctly handles registered colormap names that differ from internal names.\"\"\"\n+    # Create a colormap with an internal name\n+    my_cmap_data = [[  1.5e-03,   4.7e-04,   1.4e-02],\n+                     [  2.3e-03,   1.3e-03,   1.8e-02],\n+                     [  3.3e-03,   2.3e-03,   2.4e-02]]\n+    my_cmap = LinearSegmentedColormap.from_list('internal_name', my_cmap_data)\n+    \n+    # Register it with a different name\n+    cm.register_cmap(name='registered_name', cmap=my_cmap)\n+    \n+    # Set the colormap using the registered name\n+    plt.set_cmap('registered_name')\n+    \n+    # Verify that rcParams uses the registered name, not the internal name\n+    assert plt.rcParams['image.cmap'] == 'registered_name'\n+    \n+    # Verify that imshow works with the registered name in rcParams\n+    plt.figure()\n+    plt.imshow([[1, 1], [2, 2]])\n+    plt.close()\n+    \n+    # Clean up\n+    cm.unregister_cmap('registered_name')\n+\n+\n+def test_set_cmap_with_colormap_object():\n+    \"\"\"Test that set_cmap correctly handles colormap objects.\"\"\"\n+    cmap = cm.get_cmap('viridis')\n+    plt.set_cmap(cmap)\n+    assert plt.rcParams['image.cmap'] == 'viridis'\n+\n+\n+def test_set_cmap_with_builtin_name():\n+    \"\"\"Test that set_cmap correctly handles built-in colormap names.\"\"\"\n+    plt.set_cmap('plasma')\n+    assert plt.rcParams['image.cmap'] == 'plasma'\n+\n+\n+if __name__ == \"__main__\":\n+    test_set_cmap_with_registered_name()\n+    test_set_cmap_with_colormap_object()\n+    test_set_cmap_with_builtin_name()\n+    print(\"All tests passed!\")\ndiff --git a/test_special_chars.py b/test_special_chars.py\nnew file mode 100644\nindex 0000000000..82655af174\n--- /dev/null\n+++ b/test_special_chars.py\n@@ -0,0 +1,28 @@\n+from matplotlib import cm\n+from matplotlib.colors import LinearSegmentedColormap\n+import matplotlib.pyplot as plt\n+\n+# Test with special characters in names\n+cmap_data = [[0, 0, 0], [1, 1, 1]]\n+\n+# Test with underscores, hyphens, numbers\n+special_names = [\n+    'my_cmap_123',\n+    'cmap-with-hyphens',\n+    '123_numeric_start',\n+    'CamelCaseMap',\n+    'with.dots.in.name'\n+]\n+\n+for name in special_names:\n+    try:\n+        cmap = LinearSegmentedColormap.from_list(f'internal_{name}', cmap_data)\n+        cm.register_cmap(name=name, cmap=cmap)\n+        plt.set_cmap(name)\n+        assert plt.rcParams['image.cmap'] == name\n+        print(f\"\u2713 '{name}' works correctly\")\n+        cm.unregister_cmap(name)\n+    except Exception as e:\n+        print(f\"\u2717 '{name}' failed: {e}\")\n+\n+print(\"\\nAll special character tests completed!\")\n", "gold_standard_diff": "From cc977dcc6341f8b146985dff9737a46e6203c587 Mon Sep 17 00:00:00 2001\nFrom: Greg Lucas <greg.m.lucas@gmail.com>\nDate: Mon, 24 Apr 2023 20:19:56 -0600\nSubject: [PATCH] FIX: Update the colormap object's name when registering\n\nWhen registering a colormap you can use a different name than\nthe \"cmap.name\" attribute now. This will set the colormap based\non the registered name rather than cmap.name, updating the copy\nof the object that gets registered.\n\nAdditionally, the equals method of Colormaps shouldn't care about\nthe name of the object, we should only worry about whether the\nvalues are the same in the lookup tables and let someone use\nobject identity if they are worried about the name of the object.\n---\n lib/matplotlib/cm.py                |  5 +++++\n lib/matplotlib/colors.py            |  2 +-\n lib/matplotlib/tests/test_colors.py | 16 ++++++++++++++--\n 3 files changed, 20 insertions(+), 3 deletions(-)\n\ndiff --git a/lib/matplotlib/cm.py b/lib/matplotlib/cm.py\nindex 38158db9564a..78c4ce163579 100644\n--- a/lib/matplotlib/cm.py\n+++ b/lib/matplotlib/cm.py\n@@ -146,6 +146,11 @@ def register(self, cmap, *, name=None, force=False):\n                                \"that was already in the registry.\")\n \n         self._cmaps[name] = cmap.copy()\n+        # Someone may set the extremes of a builtin colormap and want to register it\n+        # with a different name for future lookups. The object would still have the\n+        # builtin name, so we should update it to the registered name\n+        if self._cmaps[name].name != name:\n+            self._cmaps[name].name = name\n \n     def unregister(self, name):\n         \"\"\"\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 05922c93dfda..434bb5423543 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -774,7 +774,7 @@ def __copy__(self):\n         return cmapobject\n \n     def __eq__(self, other):\n-        if (not isinstance(other, Colormap) or self.name != other.name or\n+        if (not isinstance(other, Colormap) or\n                 self.colorbar_extend != other.colorbar_extend):\n             return False\n         # To compare lookup tables the Colormaps have to be initialized\ndiff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2e841699cdd4..4f441f8a05a9 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -195,10 +195,10 @@ def test_colormap_equals():\n     # Make sure we can compare different sizes without failure\n     cm_copy._lut = cm_copy._lut[:10, :]\n     assert cm_copy != cmap\n-    # Test different names are not equal\n+    # Test different names are equal if the lookup table is the same\n     cm_copy = cmap.copy()\n     cm_copy.name = \"Test\"\n-    assert cm_copy != cmap\n+    assert cm_copy == cmap\n     # Test colorbar extends\n     cm_copy = cmap.copy()\n     cm_copy.colorbar_extend = not cmap.colorbar_extend\n@@ -1649,3 +1649,15 @@ def test_cm_set_cmap_error():\n     bad_cmap = 'AardvarksAreAwkward'\n     with pytest.raises(ValueError, match=bad_cmap):\n         sm.set_cmap(bad_cmap)\n+\n+\n+def test_set_cmap_mismatched_name():\n+    cmap = matplotlib.colormaps[\"viridis\"].with_extremes(over='r')\n+    # register it with different names\n+    cmap.name = \"test-cmap\"\n+    matplotlib.colormaps.register(name='wrong-cmap', cmap=cmap)\n+\n+    plt.set_cmap(\"wrong-cmap\")\n+    cmap_returned = plt.get_cmap(\"wrong-cmap\")\n+    assert cmap_returned == cmap\n+    assert cmap_returned.name == \"wrong-cmap\"\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/25479"}