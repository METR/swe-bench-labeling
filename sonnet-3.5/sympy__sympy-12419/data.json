{"instance_id": "sympy__sympy-12419", "score": "I", "diff": "diff --git a/sympy/concrete/summations.py b/sympy/concrete/summations.py\nindex 372487664c..b57b6e4f6c 100644\n--- a/sympy/concrete/summations.py\n+++ b/sympy/concrete/summations.py\n@@ -174,6 +174,18 @@ def doit(self, **hints):\n         else:\n             f = self.function\n \n+        if hasattr(self, 'has_empty_sequence') and self.has_empty_sequence:\n+            return S.Zero\n+\n+        if hasattr(f, '_eval_sum_all_elements'):\n+            return f._eval_sum_all_elements()\n+\n+        if f.is_Matrix and len(self.limits) == 2:\n+            i, i_lower, i_upper = self.limits[0]\n+            j, j_lower, j_upper = self.limits[1]\n+            if (i_lower, i_upper) == (0, f.rows - 1) and (j_lower, j_upper) == (0, f.cols - 1):\n+                return f._eval_sum_all_elements()\n+\n         if self.function.is_Matrix:\n             return self.expand().doit()\n \ndiff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e..5ae3eacb19 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -100,6 +100,12 @@ def __sub__(self, other):\n     def __rsub__(self, other):\n         return MatAdd(other, -self).doit()\n \n+    def _eval_sum_all_elements(self):\n+        from sympy import Sum, Symbol\n+        i = Symbol('i', integer=True)\n+        j = Symbol('j', integer=True)\n+        return Sum(self[i, j], (i, 0, self.rows - 1), (j, 0, self.cols - 1))\n+\n     @_sympifyit('other', NotImplemented)\n     @call_highest_priority('__rmul__')\n     def __mul__(self, other):\n@@ -227,6 +233,14 @@ def is_valid(idx):\n                 (0 <= i) != False and (i < self.rows) != False and\n                 (0 <= j) != False and (j < self.cols) != False)\n \n+    def _eval_sum_all_elements(self):\n+        from sympy import Sum, Symbol, Piecewise, Eq\n+        i = Symbol('i', integer=True)\n+        j = Symbol('j', integer=True)\n+        if self.is_Identity:\n+            return self.rows\n+        return Sum(Piecewise((1, Eq(i, j)), (0, True)), (i, 0, self.rows - 1), (j, 0, self.cols - 1))\n+\n     def __getitem__(self, key):\n         if not isinstance(key, tuple) and isinstance(key, slice):\n             from sympy.matrices.expressions.slice import MatrixSlice\ndiff --git a/test_matrix_sum.py b/test_matrix_sum.py\nnew file mode 100644\nindex 0000000000..e547b95f26\n--- /dev/null\n+++ b/test_matrix_sum.py\n@@ -0,0 +1,25 @@\n+from sympy import *\n+from sympy import Q as Query\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+e = None\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+# Correct: M.T * M is an identity matrix.\n+print(e, e[0, 0], e[0, 1], e[1, 0], e[1, 1])\n+\n+# Correct: The output is True True\n+print(ask(Query.diagonal(e)), ask(Query.integer_elements(e)))\n+\n+# Correct: The sum of the diagonal elements is n\n+print(Sum(e[i, i], (i, 0, n-1)).doit())\n+\n+# Total sum of the elements\n+print(Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())\n+\n+# Direct sum using _eval_sum_all_elements\n+print(e._eval_sum_all_elements().doit())\n", "gold_standard_diff": "diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e32..63951e62d0ed 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -2,11 +2,12 @@\n \n from functools import wraps\n \n-from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr\n+from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq\n from sympy.core.decorators import call_highest_priority\n from sympy.core.compatibility import range\n from sympy.core.sympify import SympifyError, sympify\n from sympy.functions import conjugate, adjoint\n+from sympy.functions.special.tensor_functions import KroneckerDelta\n from sympy.matrices import ShapeError\n from sympy.simplify import simplify\n \n@@ -375,7 +376,6 @@ def _eval_derivative(self, v):\n         if self.args[0] != v.args[0]:\n             return S.Zero\n \n-        from sympy import KroneckerDelta\n         return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])\n \n \n@@ -476,10 +476,12 @@ def conjugate(self):\n         return self\n \n     def _entry(self, i, j):\n-        if i == j:\n+        eq = Eq(i, j)\n+        if eq is S.true:\n             return S.One\n-        else:\n+        elif eq is S.false:\n             return S.Zero\n+        return KroneckerDelta(i, j)\n \n     def _eval_determinant(self):\n         return S.One\ndiff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex dbc54859480e..ffe760b37495 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -65,6 +65,7 @@ def test_ZeroMatrix():\n     with raises(ShapeError):\n         Z**2\n \n+\n def test_ZeroMatrix_doit():\n     Znn = ZeroMatrix(Add(n, n, evaluate=False), n)\n     assert isinstance(Znn.rows, Add)\n@@ -74,6 +75,8 @@ def test_ZeroMatrix_doit():\n \n def test_Identity():\n     A = MatrixSymbol('A', n, m)\n+    i, j = symbols('i j')\n+\n     In = Identity(n)\n     Im = Identity(m)\n \n@@ -84,6 +87,11 @@ def test_Identity():\n     assert In.inverse() == In\n     assert In.conjugate() == In\n \n+    assert In[i, j] != 0\n+    assert Sum(In[i, j], (i, 0, n-1), (j, 0, n-1)).subs(n,3).doit() == 3\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).subs(n,3).doit() == 3\n+\n+\n def test_Identity_doit():\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/12419"}