{"instance_id": "mwaskom__seaborn-3187", "score": "I", "diff": "diff --git a/check_formatter.py b/check_formatter.py\nnew file mode 100644\nindex 00000000..6c4eb072\n--- /dev/null\n+++ b/check_formatter.py\n@@ -0,0 +1,28 @@\n+import matplotlib.pyplot as plt\n+from matplotlib.ticker import ScalarFormatter\n+import numpy as np\n+\n+# Create a formatter and test its methods\n+formatter = ScalarFormatter()\n+formatter.set_scientific(True)\n+formatter.set_powerlimits((0, 0))\n+\n+# Create a dummy axis\n+fig, ax = plt.subplots()\n+ax.set_xlim(1e6, 5e6)\n+formatter.axis = ax.xaxis\n+\n+# Test the formatter\n+locs = np.linspace(1e6, 5e6, 5)\n+labels = formatter.format_ticks(locs)\n+\n+print(\"Labels:\", labels)\n+print(\"Offset text:\", formatter.get_offset())\n+\n+# Check if formatter has get_offset method\n+print(\"\\nFormatter methods:\")\n+for attr in dir(formatter):\n+    if 'offset' in attr.lower():\n+        print(f\"  {attr}\")\n+\n+plt.close(fig)\ndiff --git a/check_offset_behavior.py b/check_offset_behavior.py\nnew file mode 100644\nindex 00000000..43b36623\n--- /dev/null\n+++ b/check_offset_behavior.py\n@@ -0,0 +1,28 @@\n+import matplotlib.pyplot as plt\n+from matplotlib.ticker import ScalarFormatter\n+import numpy as np\n+\n+# Check default offset behavior for different ranges\n+ranges = [\n+    (1, 10),\n+    (100, 1000),\n+    (1000, 10000),\n+    (10000, 100000),\n+    (100000, 1000000),\n+    (1000000, 10000000),\n+]\n+\n+for vmin, vmax in ranges:\n+    fig, ax = plt.subplots()\n+    ax.set_xlim(vmin, vmax)\n+    \n+    # Get the default formatter\n+    formatter = ax.xaxis.get_major_formatter()\n+    \n+    # Format some ticks\n+    locs = np.linspace(vmin, vmax, 5)\n+    labels = formatter.format_ticks(locs)\n+    offset = formatter.get_offset()\n+    \n+    print(f\"Range {vmin:g} to {vmax:g}: Labels={labels[:3]}..., Offset='{offset}'\")\n+    plt.close(fig)\ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 8915616b..865bebb2 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1562,25 +1562,32 @@ class Plotter:\n             var_legend = scales[var]._legend\n             if var_legend is not None:\n                 values, labels = var_legend\n-                for (_, part_id), part_vars, _ in schema:\n+                for (_, part_id), part_vars, _, _ in schema:\n                     if data.ids[var] == part_id:\n                         # Allow multiple plot semantics to represent same data variable\n                         part_vars.append(var)\n                         break\n                 else:\n                     title = self._resolve_label(p, var, data.names[var])\n-                    entry = (title, data.ids[var]), [var], (values, labels)\n+                    # Get the offset from the scale if available\n+                    offset = getattr(scales[var], '_legend_offset', None)\n+                    entry = (title, data.ids[var]), [var], (values, labels), offset\n                     schema.append(entry)\n \n         # Second pass, generate an artist corresponding to each value\n         contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []\n-        for key, variables, (values, labels) in schema:\n+        for key, variables, (values, labels), offset in schema:\n             artists = []\n             for val in values:\n                 artist = mark._legend_artist(variables, val, scales)\n                 if artist is not None:\n                     artists.append(artist)\n             if artists:\n+                # Modify key to include offset in title if present\n+                if offset:\n+                    title, var_id = key\n+                    title_with_offset = f\"{title} ({offset})\"\n+                    key = (title_with_offset, var_id)\n                 contents.append((key, artists, labels))\n \n         self._legend_contents.extend(contents)\ndiff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 55874bf2..7c708fdc 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -61,12 +61,14 @@ class Scale:\n     _matplotlib_scale: ScaleBase\n     _spacer: staticmethod\n     _legend: tuple[list[str], list[Any]] | None\n+    _legend_offset: str | None\n \n     def __post_init__(self):\n \n         self._tick_params = None\n         self._label_params = None\n         self._legend = None\n+        self._legend_offset = None\n \n     def tick(self):\n         raise NotImplementedError()\n@@ -135,6 +137,7 @@ class Scale:\n             _pipeline = []\n             _spacer = None\n             _legend = None\n+            _legend_offset = None\n             _matplotlib_scale = None\n \n         return Identity()\n@@ -380,6 +383,10 @@ class ContinuousBase(Scale):\n             locs = locs[(vmin <= locs) & (locs <= vmax)]\n             labels = axis.major.formatter.format_ticks(locs)\n             new._legend = list(locs), list(labels)\n+            \n+            # Store the formatter offset for use in legend title\n+            offset = axis.major.formatter.get_offset()\n+            new._legend_offset = offset if offset else None\n \n         return new\n \ndiff --git a/test_formatter_with_axis.py b/test_formatter_with_axis.py\nnew file mode 100644\nindex 00000000..779861c5\n--- /dev/null\n+++ b/test_formatter_with_axis.py\n@@ -0,0 +1,33 @@\n+import matplotlib.pyplot as plt\n+from matplotlib.ticker import ScalarFormatter\n+import numpy as np\n+\n+# Create a formatter and test its methods\n+fig, ax = plt.subplots()\n+ax.set_xlim(1e6, 5e6)\n+\n+# Get the formatter from the axis\n+formatter = ax.xaxis.get_major_formatter()\n+print(f\"Formatter type: {type(formatter)}\")\n+\n+# Set view interval to simulate what happens in the code\n+ax.xaxis.set_view_interval(1e6, 5e6)\n+\n+# Get locs from locator\n+locs = ax.xaxis.major.locator()\n+print(f\"Locs from locator: {locs}\")\n+\n+# Filter locs\n+vmin, vmax = 1e6, 5e6\n+locs = locs[(vmin <= locs) & (locs <= vmax)]\n+print(f\"Filtered locs: {locs}\")\n+\n+# Format ticks\n+labels = ax.xaxis.major.formatter.format_ticks(locs)\n+print(f\"Labels: {labels}\")\n+\n+# Get offset after formatting\n+offset = ax.xaxis.major.formatter.get_offset()\n+print(f\"Offset: {offset}\")\n+\n+plt.close(fig)\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 00000000..1f80bac5\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,57 @@\n+import numpy as np\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+import seaborn as sns\n+import seaborn.objects as so\n+\n+# Create synthetic data with large values\n+np.random.seed(42)\n+n = 100\n+data = pd.DataFrame({\n+    'x': np.random.randn(n),\n+    'y': np.random.randn(n),\n+    'category': np.random.choice(['A', 'B', 'C'], n),\n+    'size_small': np.random.uniform(1, 10, n),\n+    'size_large': np.random.uniform(1e6, 5e6, n)  # Large values that will use offset\n+})\n+\n+# Create plot with large values for pointsize\n+plot = (\n+    so.Plot(\n+        data, x=\"x\", y=\"y\",\n+        color=\"category\", pointsize=\"size_large\",\n+    )\n+    .add(so.Dot())\n+)\n+\n+# Save the plot\n+plot.save(\"test_plot_large.png\", dpi=100)\n+print(\"Plot saved as test_plot_large.png\")\n+\n+# Also test with matplotlib's formatter to see the expected behavior\n+fig, ax = plt.subplots(figsize=(6, 4))\n+scatter = ax.scatter(data['x'], data['y'], s=data['size_large']/10000, c=data['category'].astype('category').cat.codes)\n+ax.ticklabel_format(style='scientific', axis='both', scilimits=(0,0))\n+plt.colorbar(scatter, ax=ax)\n+plt.savefig(\"test_plot_mpl.png\", dpi=100)\n+print(\"Matplotlib plot saved as test_plot_mpl.png\")\n+\n+# Let's also check what the formatter produces\n+from matplotlib.ticker import ScalarFormatter\n+formatter = ScalarFormatter()\n+formatter.set_scientific(True)\n+formatter.set_powerlimits((0, 0))\n+\n+# Simulate what happens in the code\n+vmin, vmax = data['size_large'].min(), data['size_large'].max()\n+print(f\"\\nValue range: {vmin:.2e} to {vmax:.2e}\")\n+\n+# Create a dummy axis to use the formatter\n+fig, ax = plt.subplots()\n+ax.set_xlim(vmin, vmax)\n+formatter.axis = ax.xaxis\n+locs = np.linspace(vmin, vmax, 5)\n+labels = formatter.format_ticks(locs)\n+print(f\"\\nFormatter labels: {labels}\")\n+print(f\"Formatter offset: {formatter.get_offset()}\")\n+plt.close(fig)\ndiff --git a/test_legend_offset.py b/test_legend_offset.py\nnew file mode 100644\nindex 00000000..3242fb60\n--- /dev/null\n+++ b/test_legend_offset.py\n@@ -0,0 +1,95 @@\n+import numpy as np\n+import pandas as pd\n+import matplotlib.pyplot as plt\n+import seaborn as sns\n+import seaborn.objects as so\n+\n+# Create synthetic data with various ranges\n+np.random.seed(42)\n+n = 100\n+\n+# Test 1: Large values that should use offset\n+data1 = pd.DataFrame({\n+    'x': np.random.randn(n),\n+    'y': np.random.randn(n),\n+    'category': np.random.choice(['A', 'B', 'C'], n),\n+    'size_large': np.random.uniform(1e6, 5e6, n)\n+})\n+\n+print(\"Test 1: Large values (1e6 to 5e6)\")\n+plot1 = (\n+    so.Plot(\n+        data1, x=\"x\", y=\"y\",\n+        color=\"category\", pointsize=\"size_large\",\n+    )\n+    .add(so.Dot())\n+)\n+plot1.save(\"test_offset_large.png\", dpi=100)\n+print(\"Plot saved as test_offset_large.png\")\n+\n+# Test 2: Small values that should not use offset\n+data2 = pd.DataFrame({\n+    'x': np.random.randn(n),\n+    'y': np.random.randn(n),\n+    'category': np.random.choice(['A', 'B', 'C'], n),\n+    'size_small': np.random.uniform(1, 10, n)\n+})\n+\n+print(\"\\nTest 2: Small values (1 to 10)\")\n+plot2 = (\n+    so.Plot(\n+        data2, x=\"x\", y=\"y\",\n+        color=\"category\", pointsize=\"size_small\",\n+    )\n+    .add(so.Dot())\n+)\n+plot2.save(\"test_offset_small.png\", dpi=100)\n+print(\"Plot saved as test_offset_small.png\")\n+\n+# Test 3: Very large values (1e9)\n+data3 = pd.DataFrame({\n+    'x': np.random.randn(n),\n+    'y': np.random.randn(n), \n+    'category': np.random.choice(['A', 'B', 'C'], n),\n+    'size_very_large': np.random.uniform(1e9, 5e9, n)\n+})\n+\n+print(\"\\nTest 3: Very large values (1e9 to 5e9)\")\n+plot3 = (\n+    so.Plot(\n+        data3, x=\"x\", y=\"y\",\n+        color=\"category\", pointsize=\"size_very_large\",\n+    )\n+    .add(so.Dot())\n+)\n+plot3.save(\"test_offset_very_large.png\", dpi=100)\n+print(\"Plot saved as test_offset_very_large.png\")\n+\n+# Let's also manually check what's happening with the legend\n+from matplotlib.ticker import ScalarFormatter\n+\n+# For large values\n+formatter = ScalarFormatter()\n+formatter.set_powerlimits((0, 0))\n+fig, ax = plt.subplots()\n+ax.set_xlim(1e6, 5e6)\n+formatter.axis = ax.xaxis\n+locs = np.linspace(1e6, 5e6, 5)\n+labels = formatter.format_ticks(locs)\n+offset = formatter.get_offset()\n+print(f\"\\nLarge values - Labels: {labels}, Offset: {offset}\")\n+plt.close(fig)\n+\n+# For small values\n+fig, ax = plt.subplots()\n+ax.set_xlim(1, 10)\n+formatter.axis = ax.xaxis\n+locs = np.linspace(1, 10, 5)\n+labels = formatter.format_ticks(locs)\n+offset = formatter.get_offset()\n+print(f\"Small values - Labels: {labels}, Offset: {offset}\")\n+plt.close(fig)\n+\n+# Check if legends were created correctly\n+print(\"\\nChecking if legends include offset information...\")\n+print(\"Expected: Large value legends should show offset (1e6), small value legends should not\")\ndiff --git a/test_offset_large.png b/test_offset_large.png\nnew file mode 100644\nindex 00000000..ef14a53b\nBinary files /dev/null and b/test_offset_large.png differ\ndiff --git a/test_offset_small.png b/test_offset_small.png\nnew file mode 100644\nindex 00000000..8dd1cc97\nBinary files /dev/null and b/test_offset_small.png differ\ndiff --git a/test_offset_very_large.png b/test_offset_very_large.png\nnew file mode 100644\nindex 00000000..f743d647\nBinary files /dev/null and b/test_offset_very_large.png differ\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 00000000..db6170ce\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,34 @@\n+import numpy as np\n+import pandas as pd\n+import seaborn as sns\n+import seaborn.objects as so\n+\n+# Recreate the issue scenario from the bug report\n+# Using synthetic data since we can't load penguins dataset\n+np.random.seed(42)\n+n = 200\n+\n+# Create penguin-like data\n+penguins = pd.DataFrame({\n+    'species': np.random.choice(['Adelie', 'Chinstrap', 'Gentoo'], n),\n+    'bill_length_mm': np.random.normal(44, 5, n),\n+    'bill_depth_mm': np.random.normal(17, 2, n),\n+    'body_mass_g': np.random.normal(4200, 800, n)\n+})\n+\n+# Add body_mass_mg column as in the original issue\n+penguins[\"body_mass_mg\"] = penguins[\"body_mass_g\"] * 1000\n+\n+print(f\"body_mass_mg range: {penguins['body_mass_mg'].min():.0f} to {penguins['body_mass_mg'].max():.0f}\")\n+\n+# Create the plot from the issue\n+(\n+    so.Plot(\n+        penguins, x=\"bill_length_mm\", y=\"bill_depth_mm\",\n+        color=\"species\", pointsize=\"body_mass_mg\",\n+    )\n+    .add(so.Dot())\n+).save(\"test_original_issue.png\", dpi=100)\n+\n+print(\"Plot saved as test_original_issue.png\")\n+print(\"The legend for pointsize should now show 'body_mass_mg (1e6)' instead of just 'body_mass_mg'\")\ndiff --git a/test_plot_large.png b/test_plot_large.png\nnew file mode 100644\nindex 00000000..a0254cd8\nBinary files /dev/null and b/test_plot_large.png differ\ndiff --git a/test_plot_mpl.png b/test_plot_mpl.png\nnew file mode 100644\nindex 00000000..dd3c0736\nBinary files /dev/null and b/test_plot_mpl.png differ\n", "gold_standard_diff": "diff --git a/doc/whatsnew/v0.12.2.rst b/doc/whatsnew/v0.12.2.rst\nindex 8eeb8f1990..ad12a778e1 100644\n--- a/doc/whatsnew/v0.12.2.rst\n+++ b/doc/whatsnew/v0.12.2.rst\n@@ -6,6 +6,8 @@ v0.12.2 (Unreleased)\n \n - |Enhancement| Automatic mark widths are now calculated separately for unshared facet axes (:pr:`3119`).\n \n+- |Fix| Fixed a bug where legends for numeric variables with large values with be incorrectly shown (i.e. with a missing offset or exponent; :pr:`3187`).\n+\n - |Fix| Fixed a regression in v0.12.0 where manually-added labels could have duplicate legend entries (:pr:`3116`).\n \n - |Fix| Fixed a bug in :func:`histplot` with `kde=True` and `log_scale=True` where the curve was not scaled properly (:pr:`3173`).\ndiff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 55874bf2ed..c91f6fdc46 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -378,6 +378,14 @@ def spacer(x):\n             axis.set_view_interval(vmin, vmax)\n             locs = axis.major.locator()\n             locs = locs[(vmin <= locs) & (locs <= vmax)]\n+            # Avoid having an offset / scientific notation in a legend\n+            # as we don't represent that anywhere so it ends up incorrect.\n+            # This could become an option (e.g. Continuous.label(offset=True))\n+            # in which case we would need to figure out how to show it.\n+            if hasattr(axis.major.formatter, \"set_useOffset\"):\n+                axis.major.formatter.set_useOffset(False)\n+            if hasattr(axis.major.formatter, \"set_scientific\"):\n+                axis.major.formatter.set_scientific(False)\n             labels = axis.major.formatter.format_ticks(locs)\n             new._legend = list(locs), list(labels)\n \ndiff --git a/seaborn/utils.py b/seaborn/utils.py\nindex 2407853c51..3cf01755a4 100644\n--- a/seaborn/utils.py\n+++ b/seaborn/utils.py\n@@ -699,6 +699,10 @@ def get_view_interval(self):\n         formatter = mpl.ticker.LogFormatter()\n     else:\n         formatter = mpl.ticker.ScalarFormatter()\n+        # Avoid having an offset/scientific notation which we don't currently\n+        # have any way of representing in the legend\n+        formatter.set_useOffset(False)\n+        formatter.set_scientific(False)\n     formatter.axis = dummy_axis()\n \n     # TODO: The following two lines should be replaced\ndiff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex e4ba99e12f..2bff6bed17 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -2051,6 +2051,15 @@ def _legend_artist(self, variables, value, scales):\n         p = Plot(**xy, color=[\"a\", \"b\", \"c\", \"d\"]).add(NoLegendMark()).plot()\n         assert not p._figure.legends\n \n+    def test_legend_has_no_offset(self, xy):\n+\n+        color = np.add(xy[\"x\"], 1e8)\n+        p = Plot(**xy, color=color).add(MockMark()).plot()\n+        legend = p._figure.legends[0]\n+        assert legend.texts\n+        for text in legend.texts:\n+            assert float(text.get_text()) > 1e7\n+\n \n class TestDefaultObject:\n \ndiff --git a/tests/test_relational.py b/tests/test_relational.py\nindex b100f4ecac..467b04a512 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -675,6 +675,12 @@ def test_ax_kwarg_removal(self, long_df):\n         assert len(ax.collections) == 0\n         assert len(g.ax.collections) > 0\n \n+    def test_legend_has_no_offset(self, long_df):\n+\n+        g = relplot(data=long_df, x=\"x\", y=\"y\", hue=long_df[\"z\"] + 1e8)\n+        for text in g.legend.texts:\n+            assert float(text.get_text()) > 1e7\n+\n \n class TestLinePlotter(SharedAxesLevelTests, Helpers):\n \n", "gold_standard_pr_link": "https://github.com/mwaskom/seaborn/pull/3187"}