{"instance_id": "django__django-10554", "score": "I", "diff": "diff --git a/test_union_debug.py b/test_union_debug.py\nnew file mode 100644\nindex 0000000000..4a854487b7\n--- /dev/null\n+++ b/test_union_debug.py\n@@ -0,0 +1,113 @@\n+\"\"\"\n+Debug test for the union ordering issue\n+\"\"\"\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import QuerySet\n+\n+# Create a test model\n+class Dimension(models.Model):\n+    name = models.CharField(max_length=100)\n+    order = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Dimension)\n+\n+# Insert test data\n+Dimension.objects.create(id=10, name=\"test10\", order=1)\n+Dimension.objects.create(id=11, name=\"test11\", order=2)\n+Dimension.objects.create(id=16, name=\"test16\", order=3)\n+Dimension.objects.create(id=17, name=\"test17\", order=4)\n+\n+print(\"Test data created:\")\n+print(list(Dimension.objects.values_list('id', flat=True)))\n+\n+# Reproduce the issue\n+print(\"\\nCreating union queryset with ordering...\")\n+qs = (\n+    Dimension.objects.filter(pk__in=[10, 11])\n+    .union(Dimension.objects.filter(pk__in=[16, 17]))\n+    .order_by('order')\n+)\n+\n+print(\"Initial qs query.order_by:\", qs.query.order_by)\n+\n+# Get compiler and check order_by\n+compiler = qs.query.get_compiler(using=qs.db)\n+print(\"\\nChecking compiler.get_order_by() before evaluation:\")\n+order_by = compiler.get_order_by()\n+print(\"Order by expressions:\")\n+for expr, (sql, params, is_ref) in order_by:\n+    print(f\"  Expression: {expr}, SQL: {sql}, is_ref: {is_ref}\")\n+    if hasattr(expr, 'expression') and hasattr(expr.expression, 'sql'):\n+        print(f\"    Inner expression SQL: {expr.expression.sql}\")\n+\n+print(\"\\nEvaluating qs...\")\n+list(qs)\n+\n+# Check again after evaluation\n+print(\"\\nChecking order_by after initial evaluation:\")\n+order_by = compiler.get_order_by()\n+for expr, (sql, params, is_ref) in order_by:\n+    print(f\"  Expression: {expr}, SQL: {sql}, is_ref: {is_ref}\")\n+    if hasattr(expr, 'expression') and hasattr(expr.expression, 'sql'):\n+        print(f\"    Inner expression SQL: {expr.expression.sql}\")\n+\n+# This causes re-evaluation of the original qs to break\n+print(\"\\nCreating derived queryset...\")\n+derived_qs = qs.order_by().values_list('pk', flat=True)\n+\n+print(\"\\nEvaluating derived qs...\")\n+list(derived_qs)\n+\n+print(\"\\nChecking original qs compiler order_by after derived qs evaluation:\")\n+order_by = compiler.get_order_by()\n+for expr, (sql, params, is_ref) in order_by:\n+    print(f\"  Expression: {expr}, SQL: {sql}, is_ref: {is_ref}\")\n+    if hasattr(expr, 'expression') and hasattr(expr.expression, 'sql'):\n+        print(f\"    Inner expression SQL: {expr.expression.sql}\")\n+\n+print(\"\\nTrying to re-evaluate original qs:\")\n+try:\n+    list(qs)\n+    print(\"Success!\")\n+except Exception as e:\n+    print(f\"ERROR: {type(e).__name__}: {e}\")\n+    \n+    # Check if the order_by has positional reference\n+    print(\"\\nDebugging the error...\")\n+    for expr, (sql, params, is_ref) in order_by:\n+        print(f\"  Expression type: {type(expr)}\")\n+        print(f\"  Expression: {expr}\")\n+        if hasattr(expr, 'get_source_expressions'):\n+            sources = expr.get_source_expressions()\n+            print(f\"  Source expressions: {sources}\")\n+            for s in sources:\n+                print(f\"    Source type: {type(s)}\")\n+                if hasattr(s, 'sql'):\n+                    print(f\"    Source SQL: {s.sql}\")\ndiff --git a/test_union_ordering.py b/test_union_ordering.py\nnew file mode 100644\nindex 0000000000..bd1185b81f\n--- /dev/null\n+++ b/test_union_ordering.py\n@@ -0,0 +1,85 @@\n+\"\"\"\n+Test for the union ordering issue\n+\"\"\"\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.postgresql',\n+            'NAME': 'test_db',\n+            'USER': 'postgres',\n+            'PASSWORD': 'postgres',\n+            'HOST': 'localhost',\n+            'PORT': '5432',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import QuerySet\n+\n+# Create a test model\n+class Dimension(models.Model):\n+    name = models.CharField(max_length=100)\n+    order = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Dimension)\n+\n+# Insert test data\n+Dimension.objects.create(id=10, name=\"test10\", order=1)\n+Dimension.objects.create(id=11, name=\"test11\", order=2)\n+Dimension.objects.create(id=16, name=\"test16\", order=3)\n+Dimension.objects.create(id=17, name=\"test17\", order=4)\n+\n+print(\"Test data created:\")\n+print(list(Dimension.objects.values_list('id', flat=True)))\n+\n+# Reproduce the issue\n+print(\"\\nCreating union queryset with ordering...\")\n+qs = (\n+    Dimension.objects.filter(pk__in=[10, 11])\n+    .union(Dimension.objects.filter(pk__in=[16, 17]))\n+    .order_by('order')\n+)\n+\n+print(\"Initial qs evaluation:\")\n+print(list(qs))\n+\n+# Print the SQL to debug\n+print(\"\\nSQL for original qs:\")\n+print(qs.query)\n+\n+# This causes re-evaluation of the original qs to break\n+print(\"\\nCreating derived queryset...\")\n+derived_qs = qs.order_by().values_list('pk', flat=True)\n+print(\"Derived qs:\", list(derived_qs))\n+\n+print(\"\\nSQL for derived qs:\")\n+print(derived_qs.query)\n+\n+print(\"\\nTrying to re-evaluate original qs (this should fail):\")\n+try:\n+    print(list(qs))\n+    print(\"SQL after re-evaluation:\")\n+    print(qs.query)\n+except Exception as e:\n+    print(f\"ERROR: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex a791908cafee..a14f1254aa6b 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -356,7 +356,12 @@ def get_order_by(self):\n                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n                         break\n                 else:\n-                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n+                    if col_alias:\n+                        raise DatabaseError('ORDER BY term does not match any column in the result set.')\n+                    # Add column used in ORDER BY clause without an alias to\n+                    # the selected columns.\n+                    self.query.add_select_col(src)\n+                    resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n             sql, params = self.compile(resolved)\n             # Don't add the same column twice, but the order direction is\n             # not taken into account so we strip it. When this entire method\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 08d7faf1947c..fc0844219369 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1774,6 +1774,10 @@ def clear_select_fields(self):\n         self.select = ()\n         self.values_select = ()\n \n+    def add_select_col(self, col):\n+        self.select += col,\n+        self.values_select += col.output_field.name,\n+\n     def set_select(self, cols):\n         self.default_cols = False\n         self.select = tuple(cols)\ndiff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 227972e8c4e8..6d1ac9c2bf04 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -153,6 +153,29 @@ def test_union_with_values_list_on_annotated_and_unannotated(self):\n         qs2 = Number.objects.filter(num=9)\n         self.assertCountEqual(qs1.union(qs2).values_list('num', flat=True), [1, 9])\n \n+    def test_union_with_values_list_and_order(self):\n+        ReservedName.objects.bulk_create([\n+            ReservedName(name='rn1', order=7),\n+            ReservedName(name='rn2', order=5),\n+            ReservedName(name='rn0', order=6),\n+            ReservedName(name='rn9', order=-1),\n+        ])\n+        qs1 = ReservedName.objects.filter(order__gte=6)\n+        qs2 = ReservedName.objects.filter(order__lte=5)\n+        union_qs = qs1.union(qs2)\n+        for qs, expected_result in (\n+            # Order by a single column.\n+            (union_qs.order_by('-pk').values_list('order', flat=True), [-1, 6, 5, 7]),\n+            (union_qs.order_by('pk').values_list('order', flat=True), [7, 5, 6, -1]),\n+            (union_qs.values_list('order', flat=True).order_by('-pk'), [-1, 6, 5, 7]),\n+            (union_qs.values_list('order', flat=True).order_by('pk'), [7, 5, 6, -1]),\n+            # Order by multiple columns.\n+            (union_qs.order_by('-name', 'pk').values_list('order', flat=True), [-1, 5, 7, 6]),\n+            (union_qs.values_list('order', flat=True).order_by('-name', 'pk'), [-1, 5, 7, 6]),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertEqual(list(qs), expected_result)\n+\n     def test_count_union(self):\n         qs1 = Number.objects.filter(num__lte=1).values('num')\n         qs2 = Number.objects.filter(num__gte=2, num__lte=3).values('num')\n", "gold_standard_pr_link": "https://github.com/django/django/pull/10554"}