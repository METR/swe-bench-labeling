{"instance_id": "pydata__xarray-2905", "score": "C", "diff": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 00000000..0fce5c1e\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,21 @@\n+import xarray as xr\n+import numpy as np\n+\n+good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])\n+\n+class HasValues(object):\n+    values = 5\n+    \n+good_indexed.loc[{'dim_0': 0}] = set()\n+bad_indexed.loc[{'dim_0': 0}] = HasValues()\n+\n+print(\"good_indexed.values =>\", good_indexed.values)\n+print(\"bad_indexed.values =>\", bad_indexed.values)\n+\n+# Test with another object that has values attribute\n+class AnotherHasValues(object):\n+    values = [1, 2, 3]\n+\n+test_indexed = xr.DataArray([None])\n+test_indexed.loc[{'dim_0': 0}] = AnotherHasValues()\n+print(\"test_indexed.values =>\", test_indexed.values)\ndiff --git a/test_pandas_compat.py b/test_pandas_compat.py\nnew file mode 100644\nindex 00000000..07ca92fb\n--- /dev/null\n+++ b/test_pandas_compat.py\n@@ -0,0 +1,31 @@\n+import xarray as xr\n+import pandas as pd\n+import numpy as np\n+\n+# Test that pandas objects still work correctly\n+arr = xr.DataArray([1, 2, 3])\n+\n+# Test with pandas Series\n+s = pd.Series([10, 20, 30])\n+arr.loc[{'dim_0': 0}] = s[0]\n+print(\"After assigning pandas Series element:\", arr.values)\n+\n+# Test with pandas DataFrame  \n+df = pd.DataFrame({'a': [100, 200, 300]})\n+arr2 = xr.DataArray([[1, 2], [3, 4]])\n+try:\n+    # This should work if dimensions match\n+    arr2.loc[{'dim_0': 0}] = df.iloc[0].values\n+    print(\"After assigning DataFrame row values:\", arr2.values)\n+except Exception as e:\n+    print(\"Error with DataFrame:\", e)\n+\n+# Test direct pandas Series assignment\n+arr3 = xr.DataArray([None, None, None])\n+arr3[:] = pd.Series([1, 2, 3])\n+print(\"After assigning full pandas Series:\", arr3.values)\n+\n+# Test that the fix doesn't affect numpy arrays\n+arr4 = xr.DataArray([None])\n+arr4.loc[{'dim_0': 0}] = np.array(42)\n+print(\"After assigning numpy scalar:\", arr4.values)\ndiff --git a/test_values_attribute_fix.py b/test_values_attribute_fix.py\nnew file mode 100644\nindex 00000000..d19ae7b0\n--- /dev/null\n+++ b/test_values_attribute_fix.py\n@@ -0,0 +1,52 @@\n+import xarray as xr\n+import numpy as np\n+import pandas as pd\n+\n+\n+def test_setitem_object_with_values_attribute():\n+    \"\"\"Test that objects with .values attribute are not coerced when assigned to DataArray\"\"\"\n+    \n+    # Test case 1: Object with scalar .values attribute\n+    class HasScalarValues:\n+        values = 5\n+    \n+    arr = xr.DataArray([None])\n+    obj = HasScalarValues()\n+    arr.loc[{'dim_0': 0}] = obj\n+    \n+    # Should store the object itself, not extract .values\n+    assert isinstance(arr.values[0], HasScalarValues)\n+    assert arr.values[0] is obj\n+    \n+    # Test case 2: Object with array .values attribute\n+    class HasArrayValues:\n+        values = [1, 2, 3]\n+    \n+    arr2 = xr.DataArray([None])\n+    obj2 = HasArrayValues()\n+    arr2.loc[{'dim_0': 0}] = obj2\n+    \n+    # Should store the object itself\n+    assert isinstance(arr2.values[0], HasArrayValues)\n+    assert arr2.values[0] is obj2\n+    \n+    # Test case 3: Ensure pandas objects still work correctly\n+    arr3 = xr.DataArray([1, 2, 3])\n+    series = pd.Series([10, 20, 30])\n+    arr3[:] = series\n+    np.testing.assert_array_equal(arr3.values, [10, 20, 30])\n+    \n+    # Test case 4: Multiple objects with values\n+    arr4 = xr.DataArray([None, None])\n+    obj3 = HasScalarValues()\n+    obj4 = HasScalarValues()\n+    arr4[0] = obj3\n+    arr4[1] = obj4\n+    \n+    assert isinstance(arr4.values[0], HasScalarValues)\n+    assert isinstance(arr4.values[1], HasScalarValues)\n+    \n+\n+if __name__ == \"__main__\":\n+    test_setitem_object_with_values_attribute()\n+    print(\"All tests passed!\")\ndiff --git a/test_values_extraction.py b/test_values_extraction.py\nnew file mode 100644\nindex 00000000..94377faa\n--- /dev/null\n+++ b/test_values_extraction.py\n@@ -0,0 +1,19 @@\n+import pandas as pd\n+import numpy as np\n+\n+# Test what types have .values that should be extracted\n+df = pd.DataFrame([[1, 2], [3, 4]])\n+series = pd.Series([1, 2, 3])\n+\n+print(\"DataFrame type:\", type(df))\n+print(\"Series type:\", type(series))\n+print(\"DataFrame.values type:\", type(df.values))\n+print(\"Series.values type:\", type(series.values))\n+\n+# Check inheritance\n+print(\"\\nDataFrame bases:\", pd.DataFrame.__bases__)\n+print(\"Series bases:\", pd.Series.__bases__)\n+\n+# Check if they have a common base that we can use\n+print(\"\\nIs DataFrame a pd.core.generic.NDFrame?\", isinstance(df, pd.core.generic.NDFrame))\n+print(\"Is Series a pd.core.generic.NDFrame?\", isinstance(series, pd.core.generic.NDFrame))\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 45553eb9..8e9df1aa 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -218,7 +218,14 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    # only extract .values from pandas objects (DataFrame/Series)\n+    # this check uses pandas' internal structure to avoid extracting .values\n+    # from arbitrary objects that happen to have a .values attribute\n+    if hasattr(pd.core.generic, 'NDFrame') and isinstance(data, pd.core.generic.NDFrame):\n+        data = data.values\n+    elif isinstance(data, (pd.DataFrame, pd.Series)):\n+        # fallback for older pandas versions or if internal structure changes\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1ae3e1f..50526d1c 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -1872,6 +1872,51 @@ class TestVariable(VariableSubclassobjects):\n         expected = Variable([\"x\", \"y\"], [[2, 3], [3, 4], [4, 5]])\n         assert_identical(v, expected)\n \n+    def test_setitem_object_with_values_attribute(self):\n+        \"\"\"Test that objects with .values attribute are not coerced when assigned\"\"\"\n+        # Regression test for GH issue - objects with .values should be stored as-is\n+        # and not have their .values attribute extracted\n+        \n+        # Test with scalar .values attribute\n+        class HasScalarValues:\n+            values = 5\n+        \n+        v = Variable([\"x\"], [None])\n+        obj = HasScalarValues()\n+        v[0] = obj\n+        \n+        # Should store the object itself, not extract .values\n+        assert isinstance(v.values[0], HasScalarValues)\n+        assert v.values[0] is obj\n+        \n+        # Test with array .values attribute\n+        class HasArrayValues:\n+            values = [1, 2, 3]\n+        \n+        v2 = Variable([\"x\"], [None])\n+        obj2 = HasArrayValues()\n+        v2[0] = obj2\n+        \n+        # Should store the object itself\n+        assert isinstance(v2.values[0], HasArrayValues)\n+        assert v2.values[0] is obj2\n+        \n+        # Test with multiple objects\n+        v3 = Variable([\"x\"], [None, None])\n+        obj3 = HasScalarValues()\n+        obj4 = HasScalarValues()\n+        v3[0] = obj3\n+        v3[1] = obj4\n+        \n+        assert isinstance(v3.values[0], HasScalarValues)\n+        assert isinstance(v3.values[1], HasScalarValues)\n+        \n+        # Ensure pandas objects still work correctly (extract .values)\n+        v4 = Variable([\"x\"], [1, 2, 3])\n+        series = pd.Series([10, 20, 30])\n+        v4[:] = series\n+        assert_array_equal(v4.values, [10, 20, 30])\n+\n     def test_coarsen(self):\n         v = self.cls([\"x\"], [0, 1, 2, 3, 4])\n         actual = v.coarsen({\"x\": 2}, boundary=\"pad\", func=\"mean\")\n", "gold_standard_diff": "From c770858c3c2fdc5215d33a9bb5697a130cacfea5 Mon Sep 17 00:00:00 2001\nFrom: Yunus Sevinchan <yunussevinchan@gmail.com>\nDate: Wed, 17 Apr 2019 23:33:52 +0200\nSubject: [PATCH 1/8] In as_compatible_data, check explicitly for nested\n self-described types\n\nThis change was prompted by the fact that `getattr(data, 'values', data)`\naffected any kind of data with a `values` attribute, which is not the\ndesired behaviour at that point.\n\nThis also extends tests to assert that custom objects with such an\nattribute are not attempted to be converted\n---\n xarray/core/variable.py       |  3 ++-\n xarray/tests/test_variable.py | 11 ++++++++++-\n 2 files changed, 12 insertions(+), 2 deletions(-)\n\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 96c6b7bd59b..244892714c1 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -171,7 +171,8 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, 'value', data), 'ns')\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, 'values', data)\n+    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex eec8d268026..ee208e32e07 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2018,13 +2018,22 @@ def __init__(self, array):\n         class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n             pass\n \n+        # Type with data stored in values attribute\n+        class CustomWithValuesAttr:\n+            def __init__(self, array):\n+                self.values = array\n+\n         array = CustomArray(np.arange(3))\n         orig = Variable(dims=('x'), data=array, attrs={'foo': 'bar'})\n         assert isinstance(orig._data, np.ndarray)  # should not be CustomArray\n \n         array = CustomIndexable(np.arange(3))\n         orig = Variable(dims=('x'), data=array, attrs={'foo': 'bar'})\n-        assert isinstance(orig._data, CustomIndexable)\n+        assert isinstance(orig._data, CustomIndexable)        \n+\n+        array = CustomWithValuesAttr(np.arange(3))\n+        orig = Variable(dims=('x'), data=array, attrs={'foo': 'bar'})\n+        assert isinstance(orig._data, CustomWithValuesAttr)\n \n \n def test_raise_no_warning_for_nan_in_binary_ops():\n\nFrom 69ed5e5a418ab2b5de2fb6d43080371d62e5bc89 Mon Sep 17 00:00:00 2001\nFrom: Yunus Sevinchan <yunussevinchan@gmail.com>\nDate: Wed, 17 Apr 2019 23:49:50 +0200\nSubject: [PATCH 2/8] Add whats-new entry\n\n---\n doc/whats-new.rst | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex e9bdc710029..d5492c0aa51 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -28,6 +28,10 @@ Bug fixes\n   By `Mayeul d'Avezac <https://github.com/mdavezac>`_.\n - Return correct count for scalar datetime64 arrays (:issue:`2770`)\n   By `Dan Nowacki <https://github.com/dnowacki-usgs>`_.\n+- Use specific type checks in\n+  :py:func:`~xarray.core.variable.as_compatible_data` instead of blanket\n+  access to ``values`` attribute (:issue:`2097`)\n+  By `Yunus Sevinchan <https://github.com/blusquare>`_.\n \n .. _whats-new.0.12.1:\n \n\nFrom b890edea09c532a8dc8fcad56260f91799de161d Mon Sep 17 00:00:00 2001\nFrom: Yunus Sevinchan <yunussevinchan@gmail.com>\nDate: Wed, 17 Apr 2019 23:54:35 +0200\nSubject: [PATCH 3/8] Remove trailing whitespace\n\n---\n xarray/tests/test_variable.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex ee208e32e07..b7938567391 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2029,7 +2029,7 @@ def __init__(self, array):\n \n         array = CustomIndexable(np.arange(3))\n         orig = Variable(dims=('x'), data=array, attrs={'foo': 'bar'})\n-        assert isinstance(orig._data, CustomIndexable)        \n+        assert isinstance(orig._data, CustomIndexable)\n \n         array = CustomWithValuesAttr(np.arange(3))\n         orig = Variable(dims=('x'), data=array, attrs={'foo': 'bar'})\n\nFrom 7905c6f418ac4e32478dfed339272d8a27f23626 Mon Sep 17 00:00:00 2001\nFrom: Yunus Sevinchan <yunussevinchan@gmail.com>\nDate: Wed, 17 Apr 2019 23:33:52 +0200\nSubject: [PATCH 4/8] In as_compatible_data, check explicitly for nested\n self-described types\n\nThis change was prompted by the fact that `getattr(data, 'values', data)`\naffected any kind of data with a `values` attribute, which is not the\ndesired behaviour at that point.\n\nThis also extends tests to assert that custom objects with such an\nattribute are not attempted to be converted\n---\n xarray/core/variable.py       | 3 ++-\n xarray/tests/test_variable.py | 9 +++++++++\n 2 files changed, 11 insertions(+), 1 deletion(-)\n\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 041c303dd3a..ab5cda38783 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -199,7 +199,8 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex 245dc1acc42..4982cccda26 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2129,6 +2129,11 @@ def __init__(self, array):\n         class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n             pass\n \n+        # Type with data stored in values attribute\n+        class CustomWithValuesAttr:\n+            def __init__(self, array):\n+                self.values = array\n+\n         array = CustomArray(np.arange(3))\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, np.ndarray)  # should not be CustomArray\n@@ -2137,6 +2142,10 @@ class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, CustomIndexable)\n \n+        array = CustomWithValuesAttr(np.arange(3))\n+        orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n+        assert isinstance(orig._data, CustomWithValuesAttr)\n+\n \n def test_raise_no_warning_for_nan_in_binary_ops():\n     with pytest.warns(None) as record:\n\nFrom 2dc7f9f9a92368b35f4e06b06f8e80623046ac3d Mon Sep 17 00:00:00 2001\nFrom: dcherian <deepak@cherian.net>\nDate: Sat, 30 Nov 2019 15:49:04 -0500\nSubject: [PATCH 5/8] whats-new\n\n---\n doc/whats-new.rst | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 884c3cef91c..8024eaafc61 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -32,7 +32,10 @@ New Features\n \n Bug fixes\n ~~~~~~~~~\n-\n+- Use specific type checks in\n+  :py:func:`~xarray.core.variable.as_compatible_data` instead of blanket\n+  access to ``values`` attribute (:issue:`2097`)\n+  By `Yunus Sevinchan <https://github.com/blusquare>`_.\n \n Documentation\n ~~~~~~~~~~~~~\n\nFrom 9d7eaacc11baef837c280bdd920cf9dd7e114806 Mon Sep 17 00:00:00 2001\nFrom: dcherian <deepak@cherian.net>\nDate: Sat, 30 Nov 2019 17:58:15 -0500\nSubject: [PATCH 6/8] Fix test.\n\n---\n xarray/tests/test_variable.py | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex 4982cccda26..9a401455c9b 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2143,8 +2143,8 @@ def __init__(self, array):\n         assert isinstance(orig._data, CustomIndexable)\n \n         array = CustomWithValuesAttr(np.arange(3))\n-        orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n-        assert isinstance(orig._data, CustomWithValuesAttr)\n+        orig = Variable(dims=(\"x\"), data=[array], attrs={\"foo\": \"bar\"})\n+        assert isinstance(orig._data.item(), CustomWithValuesAttr)\n \n \n def test_raise_no_warning_for_nan_in_binary_ops():\n\nFrom 55ce662477a089b405bdbc4d90cbb4746c7d0469 Mon Sep 17 00:00:00 2001\nFrom: Yunus Sevinchan <yunussevinchan@gmail.com>\nDate: Sun, 1 Dec 2019 16:57:47 +0100\nSubject: [PATCH 7/8] Update @blsqr github URL in whats-new\n\n---\n doc/whats-new.rst | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex d9a2abe1d84..691107545fd 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -35,7 +35,7 @@ Bug fixes\n - Use specific type checks in\n   :py:func:`~xarray.core.variable.as_compatible_data` instead of blanket\n   access to ``values`` attribute (:issue:`2097`)\n-  By `Yunus Sevinchan <https://github.com/blusquare>`_.\n+  By `Yunus Sevinchan <https://github.com/blsqr>`_.\n \n Documentation\n ~~~~~~~~~~~~~\n\nFrom ad71bb2da711434989f872531c220c3bbe9374d5 Mon Sep 17 00:00:00 2001\nFrom: Keewis <keewis@posteo.de>\nDate: Wed, 17 Feb 2021 23:47:35 +0100\nSubject: [PATCH 8/8] actually check that values is not extracted\n\n---\n xarray/tests/test_variable.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex 57afb13f7c6..0d4c8662d21 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2314,7 +2314,7 @@ def __init__(self, array):\n         assert isinstance(orig._data, CustomIndexable)\n \n         array = CustomWithValuesAttr(np.arange(3))\n-        orig = Variable(dims=(\"x\"), data=[array], attrs={\"foo\": \"bar\"})\n+        orig = Variable(dims=(), data=array)\n         assert isinstance(orig._data.item(), CustomWithValuesAttr)\n \n \n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/2905"}