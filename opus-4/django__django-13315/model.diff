diff --git a/django/forms/models.py b/django/forms/models.py
index 5d115458a1..f993bb9c98 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):
     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):
         limit_choices_to = formfield.get_limit_choices_to()
         if limit_choices_to is not None:
-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)
+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()
 
 
 def fields_for_model(model, fields=None, exclude=None, widgets=None,
diff --git a/test_limit_choices_to_distinct.py b/test_limit_choices_to_distinct.py
new file mode 100644
index 0000000000..1675b62eba
--- /dev/null
+++ b/test_limit_choices_to_distinct.py
@@ -0,0 +1,62 @@
+"""
+Test for limit_choices_to with Q objects involving joins to ensure no duplicates.
+"""
+from django import forms
+from django.db import models
+from django.test import TestCase
+from django.forms.models import modelform_factory
+
+
+class LimitChoicesDistinctTests(TestCase):
+    """
+    Test that limit_choices_to with Q objects on ForeignKey fields 
+    doesn't produce duplicate options when the query involves joins.
+    """
+    
+    def test_limit_choices_to_q_object_no_duplicates(self):
+        """
+        When using limit_choices_to with a Q object that involves joins,
+        the resulting queryset should not contain duplicates.
+        """
+        # Create test models
+        class Tag(models.Model):
+            name = models.CharField(max_length=50)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        class Article(models.Model):
+            title = models.CharField(max_length=100)
+            tags = models.ManyToManyField(Tag)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        class Comment(models.Model):
+            article = models.ForeignKey(
+                Article, 
+                on_delete=models.CASCADE,
+                limit_choices_to=models.Q(tags__name='important')
+            )
+            text = models.TextField()
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        # Create test data
+        tag1 = Tag.objects.create(name='important')
+        tag2 = Tag.objects.create(name='important')
+        article = Article.objects.create(title='Test Article')
+        article.tags.add(tag1, tag2)
+        
+        # Create form and check queryset
+        CommentForm = modelform_factory(Comment, fields=['article', 'text'])
+        form = CommentForm()
+        
+        # The article should appear only once in the queryset
+        article_list = list(form.fields['article'].queryset)
+        self.assertEqual(len(article_list), 1)
+        self.assertEqual(article_list[0], article)
+        
+        # Verify the queryset is distinct
+        self.assertEqual(form.fields['article'].queryset.count(), 1)
diff --git a/test_limit_choices_to_duplicates.py b/test_limit_choices_to_duplicates.py
new file mode 100644
index 0000000000..46c88dfb09
--- /dev/null
+++ b/test_limit_choices_to_duplicates.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Setup Django
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+# Now create test models
+from django.db import models
+from django.forms.models import modelform_factory
+
+class Tag(models.Model):
+    name = models.CharField(max_length=50)
+    
+    class Meta:
+        app_label = 'test_app'
+
+class Article(models.Model):
+    title = models.CharField(max_length=100)
+    tags = models.ManyToManyField(Tag)
+    
+    class Meta:
+        app_label = 'test_app'
+
+class Comment(models.Model):
+    article = models.ForeignKey(
+        Article, 
+        on_delete=models.CASCADE,
+        limit_choices_to=models.Q(tags__name='important')
+    )
+    text = models.TextField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+# Create tables
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Tag)
+    schema_editor.create_model(Article)
+    schema_editor.create_model(Comment)
+
+# Create test data
+tag1 = Tag.objects.create(name='important')
+tag2 = Tag.objects.create(name='important')  # Another tag with same name
+tag3 = Tag.objects.create(name='not-important')
+article = Article.objects.create(title='Test Article')
+article.tags.add(tag1, tag2)  # Adding two tags that match the filter
+
+# Create a form
+CommentForm = modelform_factory(Comment, fields=['article', 'text'])
+form = CommentForm()
+
+# Check the queryset
+queryset = form.fields['article'].queryset
+print(f"Queryset SQL: {queryset.query}")
+print(f"Number of items in queryset: {queryset.count()}")
+print(f"Items: {list(queryset)}")
+
+# Check if duplicates exist
+from collections import Counter
+article_ids = [a.id for a in queryset]
+print(f"Article IDs: {article_ids}")
+duplicates = [item for item, count in Counter(article_ids).items() if count > 1]
+if duplicates:
+    print(f"DUPLICATES FOUND: {duplicates}")
+else:
+    print("No duplicates found")
