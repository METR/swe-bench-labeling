{"instance_id": "django__django-14017", "score": "C", "diff": "diff --git a/debug_combinable.py b/debug_combinable.py\nnew file mode 100644\nindex 0000000000..625e2c3262\n--- /dev/null\n+++ b/debug_combinable.py\n@@ -0,0 +1,38 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ]\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Q, Exists\n+from django.contrib.auth.models import User\n+\n+# Check if Exists has conditional attribute\n+exists_obj = Exists(User.objects.all())\n+print(f\"Exists has 'conditional' attribute: {hasattr(exists_obj, 'conditional')}\")\n+print(f\"Exists.conditional value: {getattr(exists_obj, 'conditional', 'NOT SET')}\")\n+\n+# Check if Q has conditional attribute\n+q_obj = Q()\n+print(f\"\\nQ has 'conditional' attribute: {hasattr(q_obj, 'conditional')}\")\n+print(f\"Q.conditional value: {getattr(q_obj, 'conditional', 'NOT SET')}\")\n+\n+# Check inheritance\n+print(f\"\\nExists MRO: {Exists.__mro__}\")\n+print(f\"\\nQ MRO: {Q.__mro__}\")\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex ffc3a7fda5..f4bca2c31c 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -137,11 +137,15 @@ class Combinable:\n         return self._combine(other, self.POW, True)\n \n     def __rand__(self, other):\n+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n+            return Q(other) & Q(self)\n         raise NotImplementedError(\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n \n     def __ror__(self, other):\n+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n+            return Q(other) | Q(self)\n         raise NotImplementedError(\n             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n         )\n@@ -1150,6 +1154,7 @@ class Subquery(Expression):\n class Exists(Subquery):\n     template = 'EXISTS(%(subquery)s)'\n     output_field = fields.BooleanField()\n+    conditional = True\n \n     def __init__(self, queryset, negated=False, **kwargs):\n         self.negated = negated\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..2c9a1198db 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -59,9 +59,13 @@ class Q(tree.Node):\n         return obj\n \n     def __or__(self, other):\n+        if not isinstance(other, Q) and getattr(other, 'conditional', False):\n+            return NotImplemented\n         return self._combine(other, self.OR)\n \n     def __and__(self, other):\n+        if not isinstance(other, Q) and getattr(other, 'conditional', False):\n+            return NotImplemented\n         return self._combine(other, self.AND)\n \n     def __invert__(self):\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..3c5318fcf1\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,56 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ]\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Q, Exists\n+from django.contrib.auth.models import User\n+\n+# Test 1: Exists() & Q() - this works\n+print(\"Test 1: Exists(User.objects.all()) & Q()\")\n+try:\n+    result1 = Exists(User.objects.all()) & Q()\n+    print(f\"Success: {result1}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+# Test 2: Q() & Exists() - this fails\n+print(\"\\nTest 2: Q() & Exists(User.objects.all())\")\n+try:\n+    result2 = Q() & Exists(User.objects.all())\n+    print(f\"Success: {result2}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+# Test 3: Exists() | Q() - this works\n+print(\"\\nTest 3: Exists(User.objects.all()) | Q()\")\n+try:\n+    result3 = Exists(User.objects.all()) | Q()\n+    print(f\"Success: {result3}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+# Test 4: Q() | Exists() - this fails\n+print(\"\\nTest 4: Q() | Exists(User.objects.all())\")\n+try:\n+    result4 = Q() | Exists(User.objects.all())\n+    print(f\"Success: {result4}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..43a9e16f4d\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,94 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ]\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Q, Exists, F, Value\n+from django.contrib.auth.models import User\n+\n+print(\"Testing Q and Exists combinations:\")\n+print(\"-\" * 50)\n+\n+# Test 1: Basic combinations\n+exists = Exists(User.objects.all())\n+q = Q(username='test')\n+\n+# AND operations\n+print(\"1. Exists & Q:\")\n+result = exists & q\n+print(f\"   {result}\")\n+\n+print(\"\\n2. Q & Exists:\")\n+result = q & exists\n+print(f\"   {result}\")\n+\n+# OR operations\n+print(\"\\n3. Exists | Q:\")\n+result = exists | q\n+print(f\"   {result}\")\n+\n+print(\"\\n4. Q | Exists:\")\n+result = q | exists\n+print(f\"   {result}\")\n+\n+# Test with empty Q\n+print(\"\\n5. Empty Q() & Exists:\")\n+result = Q() & exists\n+print(f\"   {result}\")\n+\n+print(\"\\n6. Exists & Empty Q():\")\n+result = exists & Q()\n+print(f\"   {result}\")\n+\n+# Test negation\n+print(\"\\n7. ~Exists & Q:\")\n+result = ~exists & q\n+print(f\"   {result}\")\n+\n+print(\"\\n8. Q & ~Exists:\")\n+result = q & ~exists\n+print(f\"   {result}\")\n+\n+# Test chaining\n+print(\"\\n9. Q & Exists & Q:\")\n+result = Q(id=1) & exists & Q(username='test')\n+print(f\"   {result}\")\n+\n+# Test that Q & Q still works\n+print(\"\\n10. Q & Q (should still work):\")\n+result = Q(id=1) & Q(username='test')\n+print(f\"   {result}\")\n+\n+# Test that non-conditional expressions still raise TypeError\n+print(\"\\n11. Q & F (should raise TypeError):\")\n+try:\n+    result = Q() & F('username')\n+    print(f\"   Unexpected success: {result}\")\n+except TypeError as e:\n+    print(f\"   Expected TypeError: {e}\")\n+\n+print(\"\\n12. Q & Value (should raise TypeError):\")\n+try:\n+    result = Q() & Value(1)\n+    print(f\"   Unexpected success: {result}\")\n+except TypeError as e:\n+    print(f\"   Expected TypeError: {e}\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/test_exists_q_combination.py b/test_exists_q_combination.py\nnew file mode 100644\nindex 0000000000..d92888930e\n--- /dev/null\n+++ b/test_exists_q_combination.py\n@@ -0,0 +1,44 @@\n+from django.db.models import Q, Exists\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class TestExistsQCombination(TestCase):\n+    def test_exists_and_q_both_ways(self):\n+        \"\"\"Test that Exists() & Q() and Q() & Exists() both work\"\"\"\n+        # Create test queryset\n+        qs = TestModel.objects.all()\n+        \n+        # Test Exists() & Q() - this should work\n+        result1 = Exists(qs) & Q()\n+        self.assertIsNotNone(result1)\n+        \n+        # Test Q() & Exists() - this currently raises TypeError\n+        try:\n+            result2 = Q() & Exists(qs)\n+            self.assertIsNotNone(result2)\n+        except TypeError as e:\n+            print(f\"TypeError raised: {e}\")\n+            \n+    def test_exists_or_q_both_ways(self):\n+        \"\"\"Test that Exists() | Q() and Q() | Exists() both work\"\"\"\n+        # Create test queryset\n+        qs = TestModel.objects.all()\n+        \n+        # Test Exists() | Q() - this should work\n+        result1 = Exists(qs) | Q()\n+        self.assertIsNotNone(result1)\n+        \n+        # Test Q() | Exists() - this currently raises TypeError\n+        try:\n+            result2 = Q() | Exists(qs)\n+            self.assertIsNotNone(result2)\n+        except TypeError as e:\n+            print(f\"TypeError raised: {e}\")\ndiff --git a/test_exists_q_combination_final.py b/test_exists_q_combination_final.py\nnew file mode 100644\nindex 0000000000..a3014d3799\n--- /dev/null\n+++ b/test_exists_q_combination_final.py\n@@ -0,0 +1,80 @@\n+from django.db.models import Q, Exists\n+from django.test import TestCase\n+from django.contrib.auth.models import User\n+\n+\n+class ExistsQCombinationTests(TestCase):\n+    def test_exists_and_q_combination(self):\n+        \"\"\"Test that Exists and Q objects can be combined with & operator in both orders.\"\"\"\n+        qs = User.objects.filter(username='test')\n+        exists = Exists(qs)\n+        q = Q(id=1)\n+        \n+        # Both directions should work\n+        result1 = exists & q\n+        result2 = q & exists\n+        \n+        # Results should be Q objects\n+        self.assertIsInstance(result1, Q)\n+        self.assertIsInstance(result2, Q)\n+        \n+        # Test with empty Q\n+        empty_q = Q()\n+        result3 = exists & empty_q\n+        result4 = empty_q & exists\n+        \n+        self.assertIsInstance(result3, Q)\n+        self.assertIsInstance(result4, Q)\n+    \n+    def test_exists_or_q_combination(self):\n+        \"\"\"Test that Exists and Q objects can be combined with | operator in both orders.\"\"\"\n+        qs = User.objects.filter(username='test')\n+        exists = Exists(qs)\n+        q = Q(id=1)\n+        \n+        # Both directions should work\n+        result1 = exists | q\n+        result2 = q | exists\n+        \n+        # Results should be Q objects\n+        self.assertIsInstance(result1, Q)\n+        self.assertIsInstance(result2, Q)\n+        \n+        # Test with empty Q\n+        empty_q = Q()\n+        result3 = exists | empty_q\n+        result4 = empty_q | exists\n+        \n+        self.assertIsInstance(result3, Q)\n+        self.assertIsInstance(result4, Q)\n+    \n+    def test_negated_exists_q_combination(self):\n+        \"\"\"Test that negated Exists can be combined with Q.\"\"\"\n+        qs = User.objects.filter(username='test')\n+        exists = Exists(qs)\n+        q = Q(id=1)\n+        \n+        # Test negated Exists\n+        result1 = ~exists & q\n+        result2 = q & ~exists\n+        \n+        self.assertIsInstance(result1, Q)\n+        self.assertIsInstance(result2, Q)\n+    \n+    def test_complex_exists_q_combination(self):\n+        \"\"\"Test complex combinations of Exists and Q.\"\"\"\n+        qs = User.objects.filter(username='test')\n+        exists = Exists(qs)\n+        q1 = Q(id=1)\n+        q2 = Q(email='test@example.com')\n+        \n+        # Test chaining\n+        result = q1 & exists & q2\n+        self.assertIsInstance(result, Q)\n+        \n+        # Test nested combinations\n+        result = (exists | q1) & q2\n+        self.assertIsInstance(result, Q)\n+        \n+        result = q1 & (q2 | exists)\n+        self.assertIsInstance(result, Q)\ndiff --git a/test_operator_order.py b/test_operator_order.py\nnew file mode 100644\nindex 0000000000..c6bf46ed1e\n--- /dev/null\n+++ b/test_operator_order.py\n@@ -0,0 +1,33 @@\n+class TestQ:\n+    def __and__(self, other):\n+        print(f\"TestQ.__and__ called with {other}\")\n+        if not isinstance(other, TestQ):\n+            raise TypeError(f\"TypeError from TestQ.__and__: {other}\")\n+        return f\"TestQ & {other}\"\n+        \n+class TestExists:\n+    def __and__(self, other):\n+        print(f\"TestExists.__and__ called with {other}\")\n+        return f\"TestExists & {other}\"\n+        \n+    def __rand__(self, other):\n+        print(f\"TestExists.__rand__ called with {other}\")\n+        return f\"{other} & TestExists\"\n+\n+# Test the operator precedence\n+q = TestQ()\n+e = TestExists()\n+\n+print(\"Test 1: e & q\")\n+try:\n+    result = e & q\n+    print(f\"Result: {result}\")\n+except Exception as ex:\n+    print(f\"Exception: {ex}\")\n+\n+print(\"\\nTest 2: q & e\")\n+try:\n+    result = q & e\n+    print(f\"Result: {result}\")\n+except Exception as ex:\n+    print(f\"Exception: {ex}\")\ndiff --git a/trace_issue.py b/trace_issue.py\nnew file mode 100644\nindex 0000000000..c4a7b983c3\n--- /dev/null\n+++ b/trace_issue.py\n@@ -0,0 +1,44 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ]\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Q, Exists\n+from django.contrib.auth.models import User\n+\n+# Let's manually trace what happens\n+q_obj = Q()\n+exists_obj = Exists(User.objects.all())\n+\n+print(f\"Q has conditional: {hasattr(q_obj, 'conditional')} = {getattr(q_obj, 'conditional', None)}\")\n+print(f\"Exists has conditional: {hasattr(exists_obj, 'conditional')} = {getattr(exists_obj, 'conditional', None)}\")\n+\n+print(\"\\nChecking __rand__ method:\")\n+print(f\"Exists has __rand__: {hasattr(exists_obj, '__rand__')}\")\n+\n+# Let's manually call what Python would call\n+print(\"\\nManually calling exists_obj.__rand__(q_obj):\")\n+try:\n+    result = exists_obj.__rand__(q_obj)\n+    print(f\"Result: {result}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n", "gold_standard_diff": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa5648c..ae0f8861075c 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,7 +40,7 @@ def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n+        if not(isinstance(other, Q) or getattr(other, 'conditional', False) is True):\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 08ea0a51d350..9ecc033b6b2b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -815,6 +815,28 @@ def test_boolean_expression_combined(self):\n             Employee.objects.filter(Exists(is_poc) | Q(salary__lt=15)),\n             [self.example_inc.ceo, self.max],\n         )\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q(salary__gte=30) & Exists(is_ceo)),\n+            [self.max],\n+        )\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q(salary__lt=15) | Exists(is_poc)),\n+            [self.example_inc.ceo, self.max],\n+        )\n+\n+    def test_boolean_expression_combined_with_empty_Q(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions):\n+                self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n \n \n class IterableLookupInnerExpressionsTests(TestCase):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14017"}