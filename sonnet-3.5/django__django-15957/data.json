{"instance_id": "django__django-15957", "score": "I", "diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be0deb90b0..ea1c28580b 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -2162,6 +2162,13 @@ class Prefetch:\n \n         self.queryset = queryset\n         self.to_attr = to_attr\n+        self.slice = None\n+        if queryset is not None and queryset._result_cache is None:\n+            if queryset._limit is not None or queryset._high_mark is not None:\n+                self.slice = (queryset._low_mark, queryset._high_mark)\n+                queryset._limit = None\n+                queryset._high_mark = None\n+                queryset._low_mark = 0\n \n     def __getstate__(self):\n         obj_dict = self.__dict__.copy()\n@@ -2287,6 +2294,10 @@ def prefetch_related_objects(model_instances, *related_lookups):\n                 first_obj, through_attr, to_attr\n             )\n \n+            if lookup.queryset is not None and lookup.slice is not None:\n+                # Apply the slice to the queryset\n+                lookup.queryset = lookup.queryset[lookup.slice[0]:lookup.slice[1]]\n+\n             if not attr_found:\n                 raise AttributeError(\n                     \"Cannot find '%s' on %s object, '%s' is an invalid \"\ndiff --git a/docs/ref/models/querysets.txt b/docs/ref/models/querysets.txt\nindex 223bb452b0..d77e14b2ea 100644\n--- a/docs/ref/models/querysets.txt\n+++ b/docs/ref/models/querysets.txt\n@@ -1116,6 +1116,17 @@ must be restricted to a homogeneous set of results. For example, prefetching\n objects referenced by a ``GenericForeignKey`` is only supported if the query\n is restricted to one ``ContentType``.\n \n+``prefetch_related`` now supports sliced querysets, allowing you to limit the number\n+of related objects fetched. This is particularly useful when you want to prefetch\n+a subset of related objects. For example:\n+\n+    >>> Pizza.objects.prefetch_related(Prefetch('toppings', queryset=Topping.objects.all()[:3]))\n+\n+This will prefetch only the first three toppings for each pizza. The slicing is\n+applied to the queryset before the prefetch operation is performed, which can\n+significantly reduce the amount of data transferred and improve performance when\n+dealing with large datasets.\n+\n For example, suppose you have these models::\n \n     from django.db import models\n", "gold_standard_diff": "From 242499f2dc2bf24a9a5c855690a2e13d3303581a Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <charette.s@gmail.com>\nDate: Sat, 13 Aug 2022 02:14:19 -0400\nSubject: [PATCH] Fixed #26780 -- Added prefetch_related() support for sliced\n queries.\n\nThis was made possible by window function filtering support added in\nf387d024fc75569d2a4a338bfda76cc2f328f627.\n---\n .../db/models/fields/related_descriptors.py   | 33 ++++++++--\n docs/releases/4.2.txt                         |  3 +\n tests/prefetch_related/tests.py               | 64 +++++++++++++++++++\n 3 files changed, 93 insertions(+), 7 deletions(-)\n\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b192df4fbf9d..6e9f7bccbf7f 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -64,8 +64,10 @@ class Child(Model):\n \"\"\"\n \n from django.core.exceptions import FieldError\n-from django.db import connections, router, transaction\n-from django.db.models import Q, signals\n+from django.db import DEFAULT_DB_ALIAS, connections, router, transaction\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n from django.db.models.query import QuerySet\n from django.db.models.query_utils import DeferredAttribute\n from django.db.models.utils import resolve_callables\n@@ -81,6 +83,24 @@ def __set__(self, instance, value):\n         instance.__dict__[self.field.attname] = value\n \n \n+def _filter_prefetch_queryset(queryset, field_name, instances):\n+    predicate = Q(**{f\"{field_name}__in\": instances})\n+    if queryset.query.is_sliced:\n+        low_mark, high_mark = queryset.query.low_mark, queryset.query.high_mark\n+        order_by = [\n+            expr\n+            for expr, _ in queryset.query.get_compiler(\n+                using=queryset._db or DEFAULT_DB_ALIAS\n+            ).get_order_by()\n+        ]\n+        window = Window(RowNumber(), partition_by=field_name, order_by=order_by)\n+        predicate &= GreaterThan(window, low_mark)\n+        if high_mark is not None:\n+            predicate &= LessThanOrEqual(window, high_mark)\n+        queryset.query.clear_limits()\n+    return queryset.filter(predicate)\n+\n+\n class ForwardManyToOneDescriptor:\n     \"\"\"\n     Accessor to the related object on the forward side of a many-to-one or\n@@ -718,8 +738,7 @@ def get_prefetch_queryset(self, instances, queryset=None):\n             rel_obj_attr = self.field.get_local_related_value\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n-            query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            queryset = _filter_prefetch_queryset(queryset, self.field.name, instances)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1050,9 +1069,9 @@ def get_prefetch_queryset(self, instances, queryset=None):\n \n             queryset._add_hints(instance=instances[0])\n             queryset = queryset.using(queryset._db or self._db)\n-\n-            query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n+            queryset = _filter_prefetch_queryset(\n+                queryset._next_is_sticky(), self.query_field_name, instances\n+            )\n \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\ndiff --git a/docs/releases/4.2.txt b/docs/releases/4.2.txt\nindex ed00ee1350fb..1eaf22173ad0 100644\n--- a/docs/releases/4.2.txt\n+++ b/docs/releases/4.2.txt\n@@ -193,6 +193,9 @@ Models\n   :ref:`window-functions` with the exception of disjunctive filter lookups\n   against window functions when performing aggregation.\n \n+* :meth:`~.QuerySet.prefetch_related` now supports\n+  :class:`~django.db.models.Prefetch` objects with sliced querysets.\n+\n Requests and Responses\n ~~~~~~~~~~~~~~~~~~~~~~\n \ndiff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 1ac17fde7302..0ac05864767b 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1908,3 +1908,67 @@ def test_nested_prefetch_is_not_overwritten_by_related_object(self):\n         self.assertIs(Room.house.is_cached(self.room), True)\n         with self.assertNumQueries(0):\n             house.rooms.first().house.address\n+\n+\n+class PrefetchLimitTests(TestDataMixin, TestCase):\n+    def test_m2m_forward(self):\n+        authors = Author.objects.all()  # Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n+\n+    def test_m2m_reverse(self):\n+        books = Book.objects.order_by(\"title\")\n+        with self.assertNumQueries(3):\n+            authors = list(\n+                Author.objects.prefetch_related(\n+                    Prefetch(\"books\", books),\n+                    Prefetch(\"books\", books[1:2], to_attr=\"books_sliced\"),\n+                )\n+            )\n+        for author in authors:\n+            with self.subTest(author=author):\n+                self.assertEqual(author.books_sliced, list(author.books.all())[1:2])\n+\n+    def test_foreignkey_reverse(self):\n+        authors = Author.objects.order_by(\"-name\")\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors,\n+                    ),\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors[1:],\n+                        to_attr=\"first_time_authors_sliced\",\n+                    ),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(\n+                    book.first_time_authors_sliced,\n+                    list(book.first_time_authors.all())[1:],\n+                )\n+\n+    def test_reverse_ordering(self):\n+        authors = Author.objects.reverse()  # Reverse Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15957"}