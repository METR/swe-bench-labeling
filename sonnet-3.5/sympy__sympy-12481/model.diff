diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..9b8dac6141 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -843,6 +843,11 @@ def __new__(cls, *args, **kwargs):
         Permutation([0, 4, 3, 5, 1, 2], size=10)
         >>> _.array_form
         [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]
+
+        Non-disjoint cycles are allowed and applied in left-to-right order:
+
+        >>> Permutation([[0, 1], [0, 1]])
+        Permutation([0, 1])
         """
         size = kwargs.pop('size', None)
         if size is not None:
@@ -878,6 +883,29 @@ def __new__(cls, *args, **kwargs):
             raise ValueError("Permutation argument must be a list of ints, "
                              "a list of lists, Permutation or Cycle.")
 
+        # Handle cyclic form input, including non-disjoint cycles
+        if is_sequence(a) and all(is_sequence(cycle) for cycle in a):
+            max_element = max(max(cycle) for cycle in a)
+            perm = list(range(max_element + 1))
+            for cycle in a:
+                # Apply the cycle to the current permutation
+                new_perm = perm.copy()
+                for i in range(len(cycle)):
+                    new_perm[cycle[i]] = perm[cycle[(i + 1) % len(cycle)]]
+                perm = new_perm
+            if size is not None:
+                if size < len(perm):
+                    raise ValueError("Size must be at least %d" % len(perm))
+                perm.extend(range(len(perm), size))
+            return cls._af_new(perm)
+
+        # Handle array form input
+        if is_sequence(a) and all(isinstance(i, int) for i in a):
+            if size is not None:
+                if size < len(a):
+                    raise ValueError("Size must be at least %d" % len(a))
+                a = list(a) + list(range(len(a), size))
+            return cls._af_new(a)
 
         # safe to assume args are valid; this also makes a copy
         # of the args
@@ -1298,11 +1326,12 @@ def __mul__(self, other):
         """
         a = self.array_form
         # __rmul__ makes sure the other is a Permutation
-        b = other.array_form
+        b = list(other.array_form)  # Convert to list to avoid range issues
         if not b:
             perm = a
         else:
-            b.extend(list(range(len(b), len(a))))
+            if len(b) < len(a):
+                b.extend(range(len(b), len(a)))
             perm = [b[i] for i in a] + b[len(a):]
         return _af_new(perm)
 
diff --git a/test_permutation.py b/test_permutation.py
new file mode 100644
index 0000000000..5413d32c1a
--- /dev/null
+++ b/test_permutation.py
@@ -0,0 +1,21 @@
+from sympy.combinatorics.permutations import Permutation
+
+def test_non_disjoint_cycles():
+    # Test with non-disjoint cycles
+    p = Permutation([[0, 1], [0, 1]])
+    print("Test 1 result:", p.array_form)
+    assert p.array_form == [0, 1], f"Expected [0, 1], but got {p.array_form}"
+
+    # Test with more complex non-disjoint cycles
+    p = Permutation([[0, 1, 2], [1, 3]])
+    print("Test 2 result:", p.array_form)
+    assert p.array_form == [1, 3, 0, 2], f"Expected [1, 3, 0, 2], but got {p.array_form}"
+
+    # Test with disjoint cycles (should work as before)
+    p = Permutation([[0, 1], [2, 3]])
+    print("Test 3 result:", p.array_form)
+    assert p.array_form == [1, 0, 3, 2], f"Expected [1, 0, 3, 2], but got {p.array_form}"
+
+if __name__ == "__main__":
+    test_non_disjoint_cycles()
+    print("All tests passed!")
