{"instance_id": "django__django-14351", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 6629a1fd51..367d069633 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1391,6 +1391,13 @@ class Query(BaseExpression):\n                                          negated=q_object.negated)\n         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n         for child in q_object.children:\n+            if isinstance(child, tuple) and len(child) == 2:\n+                lookup, value = child\n+                if lookup.endswith('__in') and hasattr(value, 'query'):\n+                    # If the lookup is '__in' and the value is a queryset,\n+                    # modify the queryset to only select the 'id' column\n+                    value = value.values('id')\n+                child = (lookup, value)\n             child_clause, needed_inner = self.build_filter(\n                 child, can_reuse=used_aliases, branch_negated=branch_negated,\n                 current_negated=current_negated, allow_joins=allow_joins,\n", "gold_standard_diff": "From 136ff592ad8aa8b7fa1e61435e5501cc98ce8573 Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <charette.s@gmail.com>\nDate: Tue, 4 May 2021 23:42:52 -0400\nSubject: [PATCH] Fixed #32690 -- Fixed __in lookup crash when combining with\n filtered aggregates.\n\nHaving lookups group by subquery right-hand-sides is likely unnecessary\nin the first place but relatively large amount of work would be needed\nto achieve that such as making Lookup instances proper resolvable\nexpressions.\n\nRegression in 35431298226165986ad07e91f9d3aca721ff38ec.\n\nThanks James A. Munsch for the report.\n---\n django/db/models/lookups.py        | 9 +++++++++\n tests/aggregation_regress/tests.py | 8 ++++++++\n 2 files changed, 17 insertions(+)\n\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 5089737034fa..8d3648b3935e 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -406,6 +406,15 @@ def process_rhs(self, compiler, connection):\n                 self.rhs.add_fields(['pk'])\n             return super().process_rhs(compiler, connection)\n \n+    def get_group_by_cols(self, alias=None):\n+        cols = self.lhs.get_group_by_cols()\n+        if hasattr(self.rhs, 'get_group_by_cols'):\n+            if not getattr(self.rhs, 'has_select_fields', True):\n+                self.rhs.clear_select_clause()\n+                self.rhs.add_fields(['pk'])\n+            cols.extend(self.rhs.get_group_by_cols())\n+        return cols\n+\n     def get_rhs_op(self, connection, rhs):\n         return 'IN %s' % rhs\n \ndiff --git a/tests/aggregation_regress/tests.py b/tests/aggregation_regress/tests.py\nindex 877e7b49a7c8..5d841b166a35 100644\n--- a/tests/aggregation_regress/tests.py\n+++ b/tests/aggregation_regress/tests.py\n@@ -1525,6 +1525,14 @@ class DistinctAggregate(Aggregate):\n             allow_distinct = True\n         DistinctAggregate('foo', distinct=True)\n \n+    @skipUnlessDBFeature('supports_subqueries_in_group_by')\n+    def test_having_subquery_select(self):\n+        authors = Author.objects.filter(pk=self.a1.pk)\n+        books = Book.objects.annotate(Count('authors')).filter(\n+            Q(authors__in=authors) | Q(authors__count__gt=2)\n+        )\n+        self.assertEqual(set(books), {self.b1, self.b4})\n+\n \n class JoinPromotionTests(TestCase):\n     def test_ticket_21150(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14351"}