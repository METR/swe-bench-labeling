{"instance_id": "pytest-dev__pytest-10051", "score": "I", "diff": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex a4f4214b1..84b01640b 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -441,6 +441,14 @@ class LogCaptureFixture:\n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n         self.handler.reset()\n+        # Update the stash reference to point to the new records list\n+        # This ensures get_records() stays in sync with records\n+        if hasattr(self._item, 'stash') and caplog_records_key in self._item.stash:\n+            for phase in self._item.stash[caplog_records_key]:\n+                if self._item.stash[caplog_records_key][phase] is not self.handler.records:\n+                    # Only update if it's pointing to the old list\n+                    # We check using 'is not' to see if it's the same object\n+                    self._item.stash[caplog_records_key][phase] = self.handler.records\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\ndiff --git a/test_caplog_issue.py b/test_caplog_issue.py\nnew file mode 100644\nindex 000000000..115371d88\n--- /dev/null\n+++ b/test_caplog_issue.py\n@@ -0,0 +1,71 @@\n+import logging\n+\n+def test_caplog_clear_get_records_consistency(caplog) -> None:\n+    \"\"\"Test that caplog.get_records() stays consistent with caplog.records after clear().\"\"\"\n+    def verify_consistency() -> None:\n+        assert caplog.get_records(\"call\") == caplog.records\n+\n+    verify_consistency()\n+    logging.warning(\"test\")\n+    verify_consistency()\n+    caplog.clear()\n+    verify_consistency()  # This should not fail\n+\n+\n+def test_caplog_clear_multiple_calls(caplog) -> None:\n+    \"\"\"Test that multiple clear() calls work correctly.\"\"\"\n+    # First add some logs\n+    logging.warning(\"message 1\")\n+    logging.error(\"message 2\")\n+    assert len(caplog.records) == 2\n+    assert len(caplog.get_records(\"call\")) == 2\n+    \n+    # Clear once\n+    caplog.clear()\n+    assert len(caplog.records) == 0\n+    assert len(caplog.get_records(\"call\")) == 0\n+    \n+    # Add more logs\n+    logging.error(\"message 3\")\n+    assert len(caplog.records) == 1\n+    assert len(caplog.get_records(\"call\")) == 1\n+    \n+    # Clear again\n+    caplog.clear()\n+    assert len(caplog.records) == 0\n+    assert len(caplog.get_records(\"call\")) == 0\n+    \n+    # Verify consistency after multiple clears\n+    assert caplog.get_records(\"call\") == caplog.records\n+\n+\n+def test_caplog_clear_text_is_cleared(caplog) -> None:\n+    \"\"\"Test that caplog.text is also cleared.\"\"\"\n+    logging.warning(\"test message\")\n+    assert \"test message\" in caplog.text\n+    assert len(caplog.records) > 0\n+    \n+    caplog.clear()\n+    assert caplog.text == \"\"\n+    assert len(caplog.records) == 0\n+\n+\n+def test_caplog_clear_messages_is_cleared(caplog) -> None:\n+    \"\"\"Test that caplog.messages is also cleared.\"\"\"\n+    logging.warning(\"test message\")\n+    assert \"test message\" in caplog.messages\n+    assert len(caplog.messages) > 0\n+    \n+    caplog.clear()\n+    assert caplog.messages == []\n+    assert len(caplog.records) == 0\n+\n+\n+def test_caplog_clear_record_tuples_is_cleared(caplog) -> None:\n+    \"\"\"Test that caplog.record_tuples is also cleared.\"\"\"\n+    logging.warning(\"test message\")\n+    assert len(caplog.record_tuples) > 0\n+    \n+    caplog.clear()\n+    assert caplog.record_tuples == []\n+    assert len(caplog.records) == 0\ndiff --git a/test_comprehensive_caplog.py b/test_comprehensive_caplog.py\nnew file mode 100644\nindex 000000000..5f9abd8c1\n--- /dev/null\n+++ b/test_comprehensive_caplog.py\n@@ -0,0 +1,68 @@\n+import logging\n+import pytest\n+\n+\n+def test_clear_during_different_phases(caplog):\n+    \"\"\"Test that clear() works correctly in different test phases.\"\"\"\n+    # During call phase\n+    caplog.set_level(logging.INFO)\n+    logging.info(\"message 1\")\n+    assert len(caplog.records) == 1\n+    assert len(caplog.get_records(\"call\")) == 1\n+    \n+    caplog.clear()\n+    assert len(caplog.records) == 0\n+    assert len(caplog.get_records(\"call\")) == 0\n+    \n+    # Add more after clear\n+    logging.warning(\"message 2\")\n+    assert len(caplog.records) == 1\n+    assert len(caplog.get_records(\"call\")) == 1\n+    assert caplog.records[0].message == \"message 2\"\n+    assert caplog.get_records(\"call\")[0].message == \"message 2\"\n+\n+\n+def test_clear_preserves_other_phases(caplog):\n+    \"\"\"Test that clear() only affects the current phase.\"\"\"\n+    # This test verifies that if we have logs in multiple phases,\n+    # clear() in one phase doesn't affect others\n+    \n+    # We can't easily test setup phase from within the test,\n+    # but we can verify that get_records for non-existent phases returns empty\n+    assert caplog.get_records(\"setup\") == []\n+    assert caplog.get_records(\"teardown\") == []\n+    \n+    # Log in call phase\n+    logging.error(\"call phase log\")\n+    assert len(caplog.get_records(\"call\")) == 1\n+    \n+    # Clear should only affect current (call) phase\n+    caplog.clear()\n+    assert len(caplog.get_records(\"call\")) == 0\n+    # Other phases should still be empty (not affected)\n+    assert caplog.get_records(\"setup\") == []\n+    assert caplog.get_records(\"teardown\") == []\n+\n+\n+def test_handler_records_sync(caplog):\n+    \"\"\"Test that handler.records stays in sync with get_records.\"\"\"\n+    # Initial state\n+    assert caplog.records == caplog.handler.records\n+    assert caplog.get_records(\"call\") == caplog.handler.records\n+    \n+    # After logging\n+    logging.critical(\"test\")\n+    assert caplog.records == caplog.handler.records\n+    assert caplog.get_records(\"call\") == caplog.handler.records\n+    \n+    # After clear\n+    caplog.clear()\n+    assert caplog.records == caplog.handler.records\n+    assert caplog.get_records(\"call\") == caplog.handler.records\n+    assert len(caplog.records) == 0\n+    \n+    # After more logging\n+    logging.critical(\"test2\")\n+    assert caplog.records == caplog.handler.records\n+    assert caplog.get_records(\"call\") == caplog.handler.records\n+    assert len(caplog.records) == 1\ndiff --git a/test_phase_issue.py b/test_phase_issue.py\nnew file mode 100644\nindex 000000000..f0c69ad88\n--- /dev/null\n+++ b/test_phase_issue.py\n@@ -0,0 +1,27 @@\n+import logging\n+import pytest\n+\n+@pytest.fixture\n+def setup_logs(caplog):\n+    \"\"\"Fixture that logs during setup phase.\"\"\"\n+    caplog.set_level(\"INFO\")\n+    logging.getLogger().info(\"setup log\")\n+    yield\n+    \n+def test_phases_are_separate(caplog, setup_logs):\n+    \"\"\"Test that setup and call phase logs are kept separate.\"\"\"\n+    # Check setup phase logs\n+    setup_records = caplog.get_records(\"setup\")\n+    assert len(setup_records) == 1\n+    assert setup_records[0].message == \"setup log\"\n+    \n+    # Log in call phase\n+    logging.getLogger().info(\"call log\")\n+    \n+    # Check call phase logs\n+    call_records = caplog.get_records(\"call\")\n+    assert len(call_records) == 1\n+    assert call_records[0].message == \"call log\"\n+    \n+    # Ensure phases are separate\n+    assert caplog.get_records(\"setup\") != caplog.get_records(\"call\")\n", "gold_standard_diff": "diff --git a/AUTHORS b/AUTHORS\nindex d1f1b5503f2..7d27f5adadf 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -363,5 +363,6 @@ Yuval Shimon\n Zac Hatfield-Dodds\n Zachary Kneupper\n Zachary OBrien\n+Zhouxin Qiu\n Zolt\u00e1n M\u00e1t\u00e9\n Zsolt Cserna\ndiff --git a/changelog/9877.bugfix.rst b/changelog/9877.bugfix.rst\nnew file mode 100644\nindex 00000000000..1d2264c6157\n--- /dev/null\n+++ b/changelog/9877.bugfix.rst\n@@ -0,0 +1 @@\n+Ensure ``caplog.get_records(when)`` returns current/correct data after invoking ``caplog.clear()``.\ndiff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex a4f4214b137..2eb69fdbfb4 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -40,7 +40,6 @@\n else:\n     logging_StreamHandler = logging.StreamHandler\n \n-\n DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n@@ -345,6 +344,10 @@ def reset(self) -> None:\n         self.records = []\n         self.stream = StringIO()\n \n+    def clear(self) -> None:\n+        self.records.clear()\n+        self.stream = StringIO()\n+\n     def handleError(self, record: logging.LogRecord) -> None:\n         if logging.raiseExceptions:\n             # Fail the test if the log message is bad (emit failed).\n@@ -440,7 +443,7 @@ def messages(self) -> List[str]:\n \n     def clear(self) -> None:\n         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n-        self.handler.reset()\n+        self.handler.clear()\n \n     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n         \"\"\"Set the level of a logger for the duration of a test.\ndiff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex bcb20de5805..e9e73d05f98 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -172,6 +172,24 @@ def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardow\n     assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n \n \n+def test_clear_for_call_stage(caplog, logging_during_setup_and_teardown):\n+    logger.info(\"a_call_log\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"a_call_log\"]\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n+    caplog.clear()\n+\n+    assert caplog.get_records(\"call\") == []\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n+    logging.info(\"a_call_log_after_clear\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"a_call_log_after_clear\"]\n+    assert [x.message for x in caplog.get_records(\"setup\")] == [\"a_setup_log\"]\n+    assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n+\n+\n def test_ini_controls_global_log_level(pytester: Pytester) -> None:\n     pytester.makepyfile(\n         \"\"\"\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10051"}