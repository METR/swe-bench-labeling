{"instance_id": "sphinx-doc__sphinx-9258", "score": "C", "diff": "diff --git a/setup.py b/setup.py\nindex 2538952e3..94e1d8b32 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.14,<0.18',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 7d39d80ed..ba021b36b 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -304,7 +304,7 @@ class PyXrefMixin:\n     def make_xrefs(self, rolename: str, domain: str, target: str,\n                    innernode: Type[TextlikeNode] = nodes.emphasis,\n                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n-        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\.\\.\\.)'\n+        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\s*\\|\\s*|\\.\\.\\.)'\n         delims_re = re.compile(delims)\n         sub_targets = re.split(delims, target)\n \ndiff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py\nindex 6d48e910c..b9f5511b0 100644\n--- a/sphinx/util/docfields.py\n+++ b/sphinx/util/docfields.py\n@@ -75,7 +75,19 @@ class Field:\n     def make_xrefs(self, rolename: str, domain: str, target: str,\n                    innernode: Type[TextlikeNode] = addnodes.literal_emphasis,\n                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n-        return [self.make_xref(rolename, domain, target, innernode, contnode, env)]\n+        # Check if this is a union type with pipe character\n+        if '|' in target and domain == 'py':\n+            # Split on pipe and create xrefs for each type\n+            parts = [part.strip() for part in target.split('|')]\n+            result: List[Node] = []\n+            for i, part in enumerate(parts):\n+                if i > 0:\n+                    # Add separator between types\n+                    result.append(nodes.Text(' | '))\n+                result.append(self.make_xref(rolename, domain, part, innernode, None, env))\n+            return result\n+        else:\n+            return [self.make_xref(rolename, domain, target, innernode, contnode, env)]\n \n     def make_entry(self, fieldarg: str, content: List[Node]) -> Tuple[str, List[Node]]:\n         return (fieldarg, content)\ndiff --git a/test_ext_docfields_union.py b/test_ext_docfields_union.py\nnew file mode 100644\nindex 000000000..c4004caa0\n--- /dev/null\n+++ b/test_ext_docfields_union.py\n@@ -0,0 +1,106 @@\n+\"\"\"\n+Tests for union type support in docfields using pipe character\n+\n+This tests the enhancement that allows specifying multiple types using the | (pipe) character.\n+\"\"\"\n+\n+import pytest\n+from docutils import nodes\n+from sphinx import addnodes\n+from sphinx.util.docfields import Field, TypedField\n+from sphinx.domains.python import PyTypedField, PyField, PyXrefMixin\n+\n+\n+def test_field_make_xrefs_with_union():\n+    \"\"\"Test Field.make_xrefs with union types using pipe character\"\"\"\n+    field = Field('test', label='Test')\n+    \n+    # Test single type (no pipe)\n+    xrefs = field.make_xrefs('class', 'py', 'str')\n+    assert len(xrefs) == 1\n+    assert isinstance(xrefs[0], addnodes.pending_xref)\n+    assert xrefs[0].get('reftarget') == 'str'\n+    \n+    # Test union type with pipe\n+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')\n+    assert len(xrefs) == 3\n+    assert isinstance(xrefs[0], addnodes.pending_xref)\n+    assert xrefs[0].get('reftarget') == 'bytes'\n+    assert isinstance(xrefs[1], nodes.Text)\n+    assert xrefs[1].astext() == ' | '\n+    assert isinstance(xrefs[2], addnodes.pending_xref)\n+    assert xrefs[2].get('reftarget') == 'str'\n+    \n+    # Test multiple union types\n+    xrefs = field.make_xrefs('class', 'py', 'int | float | complex')\n+    assert len(xrefs) == 5\n+    assert xrefs[0].get('reftarget') == 'int'\n+    assert xrefs[1].astext() == ' | '\n+    assert xrefs[2].get('reftarget') == 'float'\n+    assert xrefs[3].astext() == ' | '\n+    assert xrefs[4].get('reftarget') == 'complex'\n+    \n+    # Test with extra spaces\n+    xrefs = field.make_xrefs('class', 'py', 'bytes  |  str')\n+    assert len(xrefs) == 3\n+    assert xrefs[0].get('reftarget') == 'bytes'\n+    assert xrefs[2].get('reftarget') == 'str'\n+\n+\n+def test_typed_field_with_union():\n+    \"\"\"Test TypedField with union types\"\"\"\n+    field = TypedField('parameter', names=('param',), typenames=('type',),\n+                       typerolename='class')\n+    \n+    # Test union type\n+    xrefs = field.make_xrefs('class', 'py', 'list | tuple | set')\n+    assert len(xrefs) == 5\n+    assert all(isinstance(x, (addnodes.pending_xref, nodes.Text)) for x in xrefs)\n+\n+\n+def test_pyxref_mixin_make_xrefs():\n+    \"\"\"Test PyXrefMixin.make_xrefs with various delimiters including pipe\"\"\"\n+    \n+    class TestPyXref(PyXrefMixin):\n+        def make_xref(self, rolename, domain, target, innernode=nodes.emphasis,\n+                      contnode=None, env=None):\n+            # Simplified version without env dependency\n+            if not rolename:\n+                return contnode or innernode(target, target)\n+            refnode = addnodes.pending_xref('', refdomain=domain, refexplicit=False,\n+                                            reftype=rolename, reftarget=target)\n+            refnode += contnode or innernode(target, target)\n+            return refnode\n+    \n+    mixin = TestPyXref()\n+    \n+    # Test pipe delimiter\n+    xrefs = mixin.make_xrefs('class', 'py', 'bytes | str')\n+    assert len(xrefs) == 3\n+    assert isinstance(xrefs[0], addnodes.pending_xref)\n+    assert xrefs[0].get('reftarget') == 'bytes'\n+    assert isinstance(xrefs[1], nodes.emphasis)\n+    assert xrefs[1].astext() == ' | '\n+    assert isinstance(xrefs[2], addnodes.pending_xref)\n+    assert xrefs[2].get('reftarget') == 'str'\n+    \n+    # Test 'or' delimiter (existing functionality)\n+    xrefs = mixin.make_xrefs('class', 'py', 'bytes or str')\n+    assert len(xrefs) == 3\n+    assert xrefs[0].get('reftarget') == 'bytes'\n+    assert xrefs[1].astext() == ' or '\n+    assert xrefs[2].get('reftarget') == 'str'\n+    \n+    # Test comma delimiter (existing functionality)\n+    xrefs = mixin.make_xrefs('class', 'py', 'List[int, str]')\n+    assert len(xrefs) == 5\n+    assert xrefs[0].get('reftarget') == 'List'\n+    assert xrefs[2].get('reftarget') == 'int'\n+    assert xrefs[4].get('reftarget') == 'str'\n+\n+\n+if __name__ == '__main__':\n+    test_field_make_xrefs_with_union()\n+    test_typed_field_with_union()\n+    test_pyxref_mixin_make_xrefs()\n+    print(\"All tests passed!\")\ndiff --git a/test_py_typed_field.py b/test_py_typed_field.py\nnew file mode 100644\nindex 000000000..1d67a67f1\n--- /dev/null\n+++ b/test_py_typed_field.py\n@@ -0,0 +1,23 @@\n+\"\"\"Test PyTypedField with union types\"\"\"\n+\n+from sphinx.domains.python import PyTypedField\n+from sphinx import addnodes\n+from docutils import nodes\n+\n+def test_py_typed_field():\n+    # Test with PyTypedField\n+    field = PyTypedField('parameter', names=('param',), typenames=('type',), \n+                         typerolename='class')\n+    \n+    # Test union types\n+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')\n+    print(f\"PyTypedField union type: {xrefs}\")\n+    print(f\"Number of elements: {len(xrefs)}\")\n+    for i, node in enumerate(xrefs):\n+        if isinstance(node, nodes.Text):\n+            print(f\"Element {i}: Text node - '{node.astext()}'\")\n+        elif isinstance(node, addnodes.pending_xref):\n+            print(f\"Element {i}: XRef to '{node.get('reftarget')}'\")\n+\n+if __name__ == '__main__':\n+    test_py_typed_field()\ndiff --git a/test_union_simple.py b/test_union_simple.py\nnew file mode 100644\nindex 000000000..e37dd1682\n--- /dev/null\n+++ b/test_union_simple.py\n@@ -0,0 +1,63 @@\n+\"\"\"Simple test to see if union types work\"\"\"\n+\n+import os\n+import tempfile\n+import subprocess\n+\n+# Create test directory\n+tmpdir = tempfile.mkdtemp(prefix=\"sphinx_union_test_\")\n+print(f\"Test directory: {tmpdir}\")\n+\n+# Create conf.py\n+with open(os.path.join(tmpdir, 'conf.py'), 'w') as f:\n+    f.write('''\n+project = 'Test'\n+extensions = []\n+''')\n+\n+# Create index.rst\n+with open(os.path.join(tmpdir, 'index.rst'), 'w') as f:\n+    f.write('''\n+Test\n+====\n+\n+.. py:function:: foo(text)\n+\n+   :param text: The text\n+   :type text: bytes | str\n+''')\n+\n+# Build\n+result = subprocess.run(\n+    ['sphinx-build', '-b', 'html', '-v', tmpdir, os.path.join(tmpdir, '_build')],\n+    capture_output=True,\n+    text=True\n+)\n+\n+print(\"\\nBuild stdout:\")\n+print(result.stdout)\n+if result.stderr:\n+    print(\"\\nBuild stderr:\")\n+    print(result.stderr)\n+\n+# Check HTML\n+html_file = os.path.join(tmpdir, '_build', 'index.html')\n+if os.path.exists(html_file):\n+    with open(html_file, 'r') as f:\n+        content = f.read()\n+    \n+    # Extract the relevant part\n+    import re\n+    match = re.search(r'<em[^>]*>bytes[^<]*</em>.*?<em[^>]*>str[^<]*</em>', content, re.DOTALL)\n+    if match:\n+        print(f\"\\nFound in HTML: {match.group()}\")\n+    else:\n+        # Try to find any mention\n+        if 'bytes' in content and 'str' in content:\n+            # Find context around bytes\n+            idx = content.find('bytes')\n+            if idx > 0:\n+                print(f\"\\nContext around 'bytes': ...{content[idx-50:idx+50]}...\")\n+                \n+print(f\"\\n\\nOutput saved in: {tmpdir}\")\n+print(\"To examine: less \" + html_file)\ndiff --git a/test_union_types.py b/test_union_types.py\nnew file mode 100644\nindex 000000000..c5b04f10a\n--- /dev/null\n+++ b/test_union_types.py\n@@ -0,0 +1,39 @@\n+\"\"\"Test for union types with pipe character\"\"\"\n+\n+from sphinx.util.docfields import TypedField\n+from sphinx import addnodes\n+from docutils import nodes\n+\n+def test_union_types():\n+    # Parse the type string\n+    field = TypedField('parameter', names=('param',), typenames=('type',), \n+                       typerolename='class')\n+    \n+    # Test new behavior with pipe\n+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')\n+    print(f\"Union type behavior: {xrefs}\")\n+    print(f\"Number of elements: {len(xrefs)}\")\n+    for i, node in enumerate(xrefs):\n+        if isinstance(node, nodes.Text):\n+            print(f\"Element {i}: Text node - '{node.astext()}'\")\n+        elif isinstance(node, addnodes.pending_xref):\n+            print(f\"Element {i}: XRef to '{node.get('reftarget')}'\")\n+            \n+    # Test with multiple types\n+    print(\"\\nTest with 3 types:\")\n+    xrefs = field.make_xrefs('class', 'py', 'int | float | str')\n+    for i, node in enumerate(xrefs):\n+        if isinstance(node, nodes.Text):\n+            print(f\"Element {i}: Text node - '{node.astext()}'\")\n+        elif isinstance(node, addnodes.pending_xref):\n+            print(f\"Element {i}: XRef to '{node.get('reftarget')}'\")\n+            \n+    # Test without pipe (should work as before)\n+    print(\"\\nTest without pipe:\")\n+    xrefs = field.make_xrefs('class', 'py', 'str')\n+    print(f\"Single type: {len(xrefs)} element(s)\")\n+    if xrefs and isinstance(xrefs[0], addnodes.pending_xref):\n+        print(f\"XRef to '{xrefs[0].get('reftarget')}'\")\n+\n+if __name__ == '__main__':\n+    test_union_types()\ndiff --git a/test_union_types_full.py b/test_union_types_full.py\nnew file mode 100644\nindex 000000000..e4ed5a7cc\n--- /dev/null\n+++ b/test_union_types_full.py\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Test for union types with pipe character in Sphinx documentation\n+\"\"\"\n+\n+import os\n+import tempfile\n+import shutil\n+from pathlib import Path\n+\n+def create_test_project():\n+    \"\"\"Create a test Sphinx project with union types\"\"\"\n+    \n+    # Create temporary directory\n+    tmpdir = tempfile.mkdtemp()\n+    print(f\"Created temp dir: {tmpdir}\")\n+    \n+    # Create conf.py\n+    conf_content = '''\n+project = 'Test Union Types'\n+extensions = ['sphinx.ext.autodoc']\n+'''\n+    \n+    with open(os.path.join(tmpdir, 'conf.py'), 'w') as f:\n+        f.write(conf_content)\n+    \n+    # Create index.rst with function documentation\n+    index_content = '''\n+Test Union Types\n+================\n+\n+.. py:function:: foo(text)\n+\n+   Process some text.\n+\n+   :param text: The text to process\n+   :type text: bytes | str\n+   :returns: Processed text\n+   :rtype: str\n+\n+.. py:function:: bar(value)\n+\n+   Process a numeric value.\n+\n+   :param value: The value to process  \n+   :type value: int | float | complex\n+   :returns: Result\n+   :rtype: float\n+\n+.. py:function:: baz(data)\n+\n+   Process data without union type.\n+\n+   :param data: The data to process\n+   :type data: dict\n+   :returns: Processed data\n+   :rtype: dict\n+'''\n+    \n+    with open(os.path.join(tmpdir, 'index.rst'), 'w') as f:\n+        f.write(index_content)\n+    \n+    return tmpdir\n+\n+def build_and_check(tmpdir):\n+    \"\"\"Build the documentation and check output\"\"\"\n+    import subprocess\n+    \n+    # Build HTML documentation\n+    result = subprocess.run(\n+        ['sphinx-build', '-b', 'html', tmpdir, os.path.join(tmpdir, '_build', 'html')],\n+        capture_output=True,\n+        text=True\n+    )\n+    \n+    print(\"Build output:\")\n+    print(result.stdout)\n+    if result.stderr:\n+        print(\"Build errors:\")\n+        print(result.stderr)\n+    \n+    # Read the generated HTML\n+    html_file = os.path.join(tmpdir, '_build', 'html', 'index.html')\n+    if os.path.exists(html_file):\n+        with open(html_file, 'r') as f:\n+            html_content = f.read()\n+        \n+        # Check for union types in output\n+        if 'bytes' in html_content and 'str' in html_content:\n+            print(\"\\n\u2713 Union types found in HTML output\")\n+            \n+            # Look for the specific pattern\n+            import re\n+            # Search for links to bytes and str\n+            bytes_link = re.search(r'<a[^>]*>bytes</a>', html_content)\n+            str_link = re.search(r'<a[^>]*>str</a>', html_content)\n+            \n+            if bytes_link and str_link:\n+                print(\"\u2713 Both types are properly linked\")\n+            else:\n+                print(\"\u2717 Types might not be properly linked\")\n+                \n+    else:\n+        print(\"\u2717 HTML file not found\")\n+    \n+    return result.returncode == 0\n+\n+if __name__ == '__main__':\n+    tmpdir = create_test_project()\n+    try:\n+        success = build_and_check(tmpdir)\n+        if success:\n+            print(\"\\n\u2713 Test passed!\")\n+        else:\n+            print(\"\\n\u2717 Test failed!\")\n+    finally:\n+        # Clean up\n+        shutil.rmtree(tmpdir)\n+        print(f\"\\nCleaned up temp dir: {tmpdir}\")\ndiff --git a/tox.ini b/tox.ini\nindex a363e187f..3b8bc12d0 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -27,7 +27,7 @@ setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -m pytest --durations 25 {posargs}\n+    python -X dev -m pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n", "gold_standard_diff": "From a1b0e55548589253f997e9b9a1f2465c3c7e22f3 Mon Sep 17 00:00:00 2001\nFrom: Takeshi KOMIYA <i.tkomiya@gmail.com>\nDate: Sat, 22 May 2021 01:55:43 +0900\nSubject: [PATCH] Close #1874: py domain: Support union types using `|` in\n info-field-list\n\n---\n CHANGES                  |  1 +\n sphinx/domains/python.py |  2 +-\n tests/test_domain_py.py  | 34 ++++++++++++++++++++++++++++++++++\n 3 files changed, 36 insertions(+), 1 deletion(-)\n\ndiff --git a/CHANGES b/CHANGES\nindex e094cd79ad0..db57819c254 100644\n--- a/CHANGES\n+++ b/CHANGES\n@@ -39,6 +39,7 @@ Features added\n   text\n * #9176: i18n: Emit a debug message if message catalog file not found under\n   :confval:`locale_dirs`\n+* #1874: py domain: Support union types using ``|`` in info-field-list\n * #9097: Optimize the paralell build\n * #9131: Add :confval:`nitpick_ignore_regex` to ignore nitpicky warnings using\n   regular expressions\ndiff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex 7d39d80edc4..ba021b36b94 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -304,7 +304,7 @@ def make_xref(self, rolename: str, domain: str, target: str,\n     def make_xrefs(self, rolename: str, domain: str, target: str,\n                    innernode: Type[TextlikeNode] = nodes.emphasis,\n                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n-        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\.\\.\\.)'\n+        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+|\\s*\\|\\s*|\\.\\.\\.)'\n         delims_re = re.compile(delims)\n         sub_targets = re.split(delims, target)\n \ndiff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 2614c8ff6c2..52ec0c2d43c 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -1009,6 +1009,40 @@ def test_info_field_list(app):\n                 **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n \n \n+def test_info_field_list_piped_type(app):\n+    text = (\".. py:module:: example\\n\"\n+            \".. py:class:: Class\\n\"\n+            \"\\n\"\n+            \"   :param age: blah blah\\n\"\n+            \"   :type age: int | str\\n\")\n+    doctree = restructuredtext.parse(app, text)\n+\n+    assert_node(doctree,\n+                (nodes.target,\n+                 addnodes.index,\n+                 addnodes.index,\n+                 [desc, ([desc_signature, ([desc_annotation, \"class \"],\n+                                           [desc_addname, \"example.\"],\n+                                           [desc_name, \"Class\"])],\n+                         [desc_content, nodes.field_list, nodes.field, (nodes.field_name,\n+                                                                        nodes.field_body)])]))\n+    assert_node(doctree[3][1][0][0][1],\n+                ([nodes.paragraph, ([addnodes.literal_strong, \"age\"],\n+                                    \" (\",\n+                                    [pending_xref, addnodes.literal_emphasis, \"int\"],\n+                                    [addnodes.literal_emphasis, \" | \"],\n+                                    [pending_xref, addnodes.literal_emphasis, \"str\"],\n+                                    \")\",\n+                                    \" -- \",\n+                                    \"blah blah\")],))\n+    assert_node(doctree[3][1][0][0][1][0][2], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"int\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+    assert_node(doctree[3][1][0][0][1][0][4], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+\n+\n def test_info_field_list_var(app):\n     text = (\".. py:class:: Class\\n\"\n             \"\\n\"\n", "gold_standard_pr_link": "https://github.com/sphinx-doc/sphinx/pull/9258"}