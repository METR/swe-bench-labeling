diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 118bfced89..75d740a866 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -1299,6 +1299,42 @@ def _format_value(value):
 
 def _format_float(value):
     """Format a floating number to make sure it gets the decimal point."""
+    # First try using the standard string representation
+    value_str = str(value)
+    
+    # Check if it needs a decimal point
+    if "." not in value_str and "E" not in value_str and "e" not in value_str:
+        value_str += ".0"
+    
+    # Check the length
+    if len(value_str) <= 20:
+        # Normalize E notation if present
+        if "E" in value_str or "e" in value_str:
+            if "e" in value_str:
+                value_str = value_str.replace("e", "E")
+            significand, exponent = value_str.split("E")
+            if exponent[0] in ("+", "-"):
+                sign = exponent[0]
+                exponent = exponent[1:]
+            else:
+                sign = ""
+            value_str = f"{significand}E{sign}{int(exponent):02d}"
+            
+            # Check length again
+            if len(value_str) > 20:
+                # Fall back to .16G format if normalization made it too long
+                value_str = f"{value:.16G}"
+        
+        # If still within limits, use it
+        if len(value_str) <= 20:
+            # Handle special float values to maintain compatibility
+            if value_str.upper() in ('INF', '-INF', 'NAN'):
+                value_str = value_str.upper()
+                if "." not in value_str:
+                    value_str += ".0"
+            return value_str
+    
+    # Fall back to original implementation with .16G format
     value_str = f"{value:.16G}"
     if "." not in value_str and "E" not in value_str:
         value_str += ".0"
diff --git a/pyproject.toml b/pyproject.toml
index 65df5b1b77..d02c4f9eda 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["setuptools",
+requires = ["setuptools==68.0.0",
             "setuptools_scm>=6.2",
             "wheel",
             "cython==0.29.30",
diff --git a/test_card_fix.py b/test_card_fix.py
new file mode 100644
index 0000000000..90722a6ba4
--- /dev/null
+++ b/test_card_fix.py
@@ -0,0 +1,72 @@
+from astropy.io import fits
+
+# Monkey patch the improved function for testing
+def _format_float_improved(value):
+    """Format a floating number to make sure it gets the decimal point."""
+    # First try using the standard string representation
+    value_str = str(value)
+    
+    # Check if it needs a decimal point
+    if "." not in value_str and "E" not in value_str and "e" not in value_str:
+        value_str += ".0"
+    
+    # Check the length
+    if len(value_str) <= 20:
+        # Normalize E notation if present
+        if "E" in value_str or "e" in value_str:
+            if "e" in value_str:
+                value_str = value_str.replace("e", "E")
+            significand, exponent = value_str.split("E")
+            if exponent[0] in ("+", "-"):
+                sign = exponent[0]
+                exponent = exponent[1:]
+            else:
+                sign = ""
+            value_str = f"{significand}E{sign}{int(exponent):02d}"
+            
+            # Check length again
+            if len(value_str) > 20:
+                # Fall back to .16G format
+                value_str = f"{value:.16G}"
+        
+        # If still within limits, use it
+        if len(value_str) <= 20:
+            return value_str
+    
+    # Fall back to original implementation
+    value_str = f"{value:.16G}"
+    if "." not in value_str and "E" not in value_str:
+        value_str += ".0"
+    elif "E" in value_str:
+        significand, exponent = value_str.split("E")
+        if exponent[0] in ("+", "-"):
+            sign = exponent[0]
+            exponent = exponent[1:]
+        else:
+            sign = ""
+        value_str = f"{significand}E{sign}{int(exponent):02d}"
+
+    # Limit the value string to at most 20 characters.
+    str_len = len(value_str)
+    if str_len > 20:
+        idx = value_str.find("E")
+        if idx < 0:
+            value_str = value_str[:20]
+        else:
+            value_str = value_str[: 20 - (str_len - idx)] + value_str[idx:]
+
+    return value_str
+
+# Replace the original function
+import astropy.io.fits.card
+astropy.io.fits.card._format_float = _format_float_improved
+
+# Now test the original issue
+value = 0.009125
+print(f"Testing with value: {value}")
+
+card = fits.Card('HIERARCH ESO IFM CL RADIUS', value, '[m] radius arround actuator to avoid')
+print(f"\nCard created successfully!")
+print(f"repr(card): {repr(card)}")
+print(f"str(card): {str(card)}")
+print(f"\nComment truncated: {'[m] radius arround actuator' in str(card) and 'to avoid' not in str(card)}")
diff --git a/test_card_float_format.py b/test_card_float_format.py
new file mode 100644
index 0000000000..ff709fc665
--- /dev/null
+++ b/test_card_float_format.py
@@ -0,0 +1,82 @@
+"""
+Test case for the float formatting fix that can be added to the test suite
+"""
+import warnings
+import pytest
+from astropy.io import fits
+
+
+def test_card_float_representation_precision():
+    """
+    Test that Card uses optimal float string representation.
+    
+    Regression test for issue where values like 0.009125 were unnecessarily
+    expanded to 0.009124999999999999, causing comment truncation.
+    """
+    # Test the specific problematic case
+    value = 0.009125
+    comment = '[m] radius arround actuator to avoid'
+    
+    with warnings.catch_warnings(record=True) as w:
+        warnings.simplefilter("always") 
+        card = fits.Card('HIERARCH ESO IFM CL RADIUS', value, comment)
+        
+        # Should not generate truncation warning
+        truncation_warnings = [warning for warning in w if 'Card is too long' in str(warning.message)]
+        assert len(truncation_warnings) == 0
+        
+        # Comment should not be truncated
+        card_str = str(card)
+        assert comment in card_str
+        
+        # Value should use compact representation
+        assert '0.009125' in card_str
+        assert '0.009124999999999999' not in card_str
+
+
+def test_card_float_various_formats():
+    """Test that various float formats are handled correctly."""
+    test_cases = [
+        # (value, expected_in_card_string)
+        (0.1, '0.1'),
+        (0.009125, '0.009125'),
+        (1.234567890123456789, '1.2345678901234567'),  # Should use str() representation
+        (1e-10, '1E-10'),
+        (1e10, '10000000000.0'),
+        (123.0, '123.0'),
+    ]
+    
+    for value, expected in test_cases:
+        card = fits.Card('TEST', value, 'comment')
+        card_str = str(card)
+        assert expected in card_str, f"Expected '{expected}' in card string for value {value}, got: {card_str}"
+
+
+def test_card_float_round_trip():
+    """Test that float values can be round-tripped through Card creation."""
+    # Create a header with a problematic float value
+    hdr = fits.Header()
+    hdr['TEST'] = (0.009125, '[m] radius arround actuator to avoid')
+    
+    # Get the card
+    card = hdr.cards['TEST']
+    
+    # Should be able to recreate the card without warnings
+    with warnings.catch_warnings(record=True) as w:
+        warnings.simplefilter("always")
+        new_card = fits.Card(card.keyword, card.value, card.comment)
+        
+        # No truncation warning should be issued
+        truncation_warnings = [warning for warning in w if 'Card is too long' in str(warning.message)]
+        assert len(truncation_warnings) == 0
+        
+        # Values and comments should match
+        assert new_card.value == card.value
+        assert new_card.comment == card.comment
+
+
+if __name__ == "__main__":
+    test_card_float_representation_precision()
+    test_card_float_various_formats() 
+    test_card_float_round_trip()
+    print("All tests passed!")
diff --git a/test_card_issue.py b/test_card_issue.py
new file mode 100644
index 0000000000..191740d89e
--- /dev/null
+++ b/test_card_issue.py
@@ -0,0 +1,23 @@
+from astropy.io import fits
+
+# Test the issue with float representation
+value = 0.009125
+print(f"Original value: {value}")
+print(f"String representation: {str(value)}")
+print(f"Format with .16G: {value:.16G}")
+print(f"Length of str(value): {len(str(value))}")
+print(f"Length of .16G format: {len(f'{value:.16G}')}")
+
+# Try to create a card with this value
+try:
+    card = fits.Card('HIERARCH ESO IFM CL RADIUS', value, '[m] radius arround actuator to avoid')
+    print(f"\nCard created:")
+    print(f"repr(card): {repr(card)}")
+    print(f"str(card): {str(card)}")
+except Exception as e:
+    print(f"Error: {e}")
+
+# Also test the _format_float function directly
+from astropy.io.fits.card import _format_float
+print(f"\n_format_float({value}): '{_format_float(value)}'")
+print(f"Length: {len(_format_float(value))}")
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..369592e3b1
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,80 @@
+import numpy as np
+from astropy.io import fits
+
+# Test various edge cases
+test_cases = [
+    # (keyword, value, comment, expected_truncation)
+    ('TEST1', 0.009125, '[m] radius arround actuator to avoid', False),
+    ('TEST2', 0.1, 'A comment', False),
+    ('TEST3', 1.23456789012345678901234567890, 'Many decimals', False),
+    ('TEST4', 1e-10, 'Small number', False),
+    ('TEST5', 1e300, 'Large number', False),
+    ('TEST6', float('inf'), 'Infinity', False),
+    ('TEST7', float('-inf'), 'Negative infinity', False),
+    ('TEST8', float('nan'), 'Not a number', False),
+    ('HIERARCH VERY LONG KEYWORD NAME', 0.009125, 'This should truncate the comment', True),
+    ('TEST9', 12345678901234567890.0, 'Large integer as float', False),
+]
+
+print("Testing various Card creations:")
+print("-" * 80)
+
+for keyword, value, comment, expect_truncation in test_cases:
+    try:
+        # Suppress warnings for this test
+        import warnings
+        with warnings.catch_warnings(record=True) as w:
+            warnings.simplefilter("always")
+            card = fits.Card(keyword, value, comment)
+            
+            # Check if warning was issued
+            warning_issued = any('Card is too long' in str(warning.message) for warning in w)
+            
+            # Check if comment was truncated
+            comment_truncated = comment not in str(card)
+            
+            print(f"\nKeyword: {keyword}")
+            print(f"Value: {value} -> formatted as: '{card._value}'")
+            print(f"Comment: {comment}")
+            print(f"Warning issued: {warning_issued}")
+            print(f"Comment truncated: {comment_truncated}")
+            print(f"Expected truncation: {expect_truncation}")
+            print(f"Result: {'PASS' if comment_truncated == expect_truncation else 'FAIL'}")
+            print(f"Card: {str(card)[:80]}")
+            
+    except Exception as e:
+        print(f"\nKeyword: {keyword}")
+        print(f"ERROR: {str(e)}")
+
+# Test that we can read and recreate cards from a FITS file
+print("\n" + "="*80)
+print("Testing round-trip card creation:")
+
+# Create a test FITS file with our problematic value
+hdu = fits.PrimaryHDU()
+hdu.header['ESO IFM CL RADIUS'] = (0.009125, '[m] radius arround actuator to avoid')
+hdu.header['TESTVAL'] = (1.234567890123456789, 'Many decimals')
+
+# Get the cards
+card1 = hdu.header.cards['ESO IFM CL RADIUS'] 
+card2 = hdu.header.cards['TESTVAL']
+
+print(f"\nOriginal card 1: {card1}")
+print(f"Can recreate without warning: ", end="")
+try:
+    with warnings.catch_warnings(record=True) as w:
+        warnings.simplefilter("always")
+        new_card1 = fits.Card(f'HIERARCH {card1.keyword}', card1.value, card1.comment)
+        print("YES" if len(w) == 0 else f"NO (warning: {w[0].message})")
+except Exception as e:
+    print(f"ERROR: {e}")
+
+print(f"\nOriginal card 2: {card2}")
+print(f"Can recreate without warning: ", end="")
+try:
+    with warnings.catch_warnings(record=True) as w:
+        warnings.simplefilter("always")
+        new_card2 = fits.Card(card2.keyword, card2.value, card2.comment)
+        print("YES" if len(w) == 0 else f"NO (warning: {w[0].message})")
+except Exception as e:
+    print(f"ERROR: {e}")
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..a068c91980
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,118 @@
+import numpy as np
+from astropy.io.fits.card import _format_float
+
+# Test edge cases including NaN, inf, very small/large numbers, etc.
+test_cases = [
+    # (value, description)
+    (0.0, "zero"),
+    (-0.0, "negative zero"),
+    (1.0, "one"),
+    (-1.0, "negative one"),
+    (0.1, "0.1"),
+    (0.01, "0.01"),
+    (0.001, "0.001"),
+    (0.0001, "0.0001"),
+    (0.00001, "0.00001"),
+    (0.000001, "0.000001"),
+    (0.009125, "the problematic value"),
+    (12345678901234567890.0, "very large integer-like float"),
+    (1.23456789012345678901234567890, "many decimal places"),
+    (1e-300, "very small number"),
+    (1e300, "very large number"),
+    (float('inf'), "infinity"),
+    (float('-inf'), "negative infinity"),
+    (float('nan'), "NaN"),
+    (np.float32(0.009125), "numpy float32"),
+    (np.float64(0.009125), "numpy float64"),
+]
+
+def _format_float_improved(value):
+    """Format a floating number to make sure it gets the decimal point."""
+    # First try using the standard string representation
+    value_str = str(value)
+    
+    # Check if it needs a decimal point
+    if "." not in value_str and "E" not in value_str and "e" not in value_str:
+        value_str += ".0"
+    
+    # Check the length
+    if len(value_str) <= 20:
+        # Normalize E notation if present
+        if "E" in value_str or "e" in value_str:
+            if "e" in value_str:
+                value_str = value_str.replace("e", "E")
+            significand, exponent = value_str.split("E")
+            if exponent[0] in ("+", "-"):
+                sign = exponent[0]
+                exponent = exponent[1:]
+            else:
+                sign = ""
+            value_str = f"{significand}E{sign}{int(exponent):02d}"
+            
+            # Check length again
+            if len(value_str) > 20:
+                # Fall back to .16G format
+                value_str = f"{value:.16G}"
+        
+        # If still within limits, use it
+        if len(value_str) <= 20:
+            return value_str
+    
+    # Fall back to original implementation
+    value_str = f"{value:.16G}"
+    if "." not in value_str and "E" not in value_str:
+        value_str += ".0"
+    elif "E" in value_str:
+        significand, exponent = value_str.split("E")
+        if exponent[0] in ("+", "-"):
+            sign = exponent[0]
+            exponent = exponent[1:]
+        else:
+            sign = ""
+        value_str = f"{significand}E{sign}{int(exponent):02d}"
+
+    # Limit the value string to at most 20 characters.
+    str_len = len(value_str)
+    if str_len > 20:
+        idx = value_str.find("E")
+        if idx < 0:
+            value_str = value_str[:20]
+        else:
+            value_str = value_str[: 20 - (str_len - idx)] + value_str[idx:]
+
+    return value_str
+
+print("Testing edge cases:")
+print("-" * 100)
+print(f"{'Description':<30} {'Value':<25} {'Original':<25} {'Improved':<25} {'Same?':<10}")
+print("-" * 100)
+
+for value, desc in test_cases:
+    try:
+        original = _format_float(value)
+        improved = _format_float_improved(value)
+        same = original == improved
+        print(f"{desc:<30} {str(value):<25} {original:<25} {improved:<25} {same:<10}")
+    except Exception as e:
+        print(f"{desc:<30} {str(value):<25} ERROR: {str(e)}")
+
+# Check round-trip conversion
+print("\n\nRound-trip conversion test (can we parse back what we format?):")
+print("-" * 80)
+
+# Use astropy's parsing function
+from astropy.io.fits.card import _int_or_float
+
+for value, desc in test_cases[:15]:  # Skip inf/nan for round-trip
+    try:
+        improved = _format_float_improved(value)
+        parsed = _int_or_float(improved)
+        
+        # Check if they're close enough (within floating point precision)
+        if isinstance(parsed, float) and not (np.isnan(value) or np.isinf(value)):
+            close = np.isclose(value, parsed, rtol=1e-15)
+            print(f"{desc:<30} {value} -> '{improved}' -> {parsed} (close: {close})")
+        else:
+            print(f"{desc:<30} {value} -> '{improved}' -> {parsed}")
+    except Exception as e:
+        print(f"{desc:<30} ERROR: {str(e)}")
diff --git a/test_fix_verification.py b/test_fix_verification.py
new file mode 100644
index 0000000000..f3227fe4d4
--- /dev/null
+++ b/test_fix_verification.py
@@ -0,0 +1,61 @@
+"""
+Test to verify the fix for the issue where io.fits.Card may use a string 
+representation of floats that is larger than necessary.
+"""
+import warnings
+from astropy.io import fits
+
+def test_float_representation_issue():
+    """Test that we can create a Card with value 0.009125 without truncating the comment"""
+    
+    # The problematic case from the issue
+    value = 0.009125
+    comment = '[m] radius arround actuator to avoid'
+    
+    # This should not produce a warning about truncation
+    with warnings.catch_warnings(record=True) as w:
+        warnings.simplefilter("always")
+        card = fits.Card('HIERARCH ESO IFM CL RADIUS', value, comment)
+        
+        # Check no warning was issued
+        truncation_warnings = [warning for warning in w if 'Card is too long' in str(warning.message)]
+        assert len(truncation_warnings) == 0, f"Unexpected truncation warning: {truncation_warnings}"
+        
+        # Check the comment is not truncated
+        assert comment in str(card), f"Comment was truncated: {str(card)}"
+        
+        # Check the value is formatted correctly
+        assert '0.009125' in str(card), f"Value not formatted as expected: {str(card)}"
+        assert '0.009124999999999999' not in str(card), f"Value expanded unnecessarily: {str(card)}"
+        
+    print("✓ Test passed: Card created successfully without truncation")
+    print(f"  Card: {str(card)}")
+    
+def test_other_float_values():
+    """Test that other float values still work correctly"""
+    
+    test_cases = [
+        (0.1, 'Simple decimal'),
+        (1.234567890123456789, 'Many decimals'),
+        (1e-10, 'Scientific notation small'),
+        (1e10, 'Scientific notation large'),
+    ]
+    
+    for value, comment in test_cases:
+        with warnings.catch_warnings(record=True) as w:
+            warnings.simplefilter("always")
+            card = fits.Card('TESTKEY', value, comment)
+            
+            # These should not produce truncation warnings
+            truncation_warnings = [warning for warning in w if 'Card is too long' in str(warning.message)]
+            assert len(truncation_warnings) == 0, f"Unexpected warning for value {value}"
+            
+            # Comment should not be truncated
+            assert comment in str(card), f"Comment truncated for value {value}"
+            
+            print(f"✓ Value {value} formatted correctly")
+
+if __name__ == "__main__":
+    test_float_representation_issue()
+    test_other_float_values()
+    print("\nAll tests passed!")
diff --git a/test_format_float.py b/test_format_float.py
new file mode 100644
index 0000000000..c494d1bc55
--- /dev/null
+++ b/test_format_float.py
@@ -0,0 +1,97 @@
+from astropy.io.fits.card import _format_float
+
+# Test various float values
+test_values = [
+    0.009125,
+    0.1,
+    0.5,
+    1.0,
+    1.234567890123456789,
+    1e-10,
+    1e10,
+    123456789.123456789,
+    0.000000001,
+]
+
+print("Testing _format_float function:")
+print("-" * 60)
+print(f"{'Value':<25} {'str(value)':<25} {'_format_float(value)':<25}")
+print("-" * 60)
+
+for value in test_values:
+    str_val = str(value)
+    formatted = _format_float(value)
+    print(f"{value:<25} {str_val:<25} {formatted:<25}")
+
+print("\nTesting the issue case specifically:")
+value = 0.009125
+print(f"Value: {value}")
+print(f"str(value): '{str(value)}' (length: {len(str(value))})")
+print(f"_format_float(value): '{_format_float(value)}' (length: {len(_format_float(value))})")
+
+# Test if using str() first would work
+def _format_float_improved(value):
+    """Format a floating number to make sure it gets the decimal point."""
+    # First try using the standard string representation
+    value_str = str(value)
+    
+    # Check if it needs a decimal point
+    if "." not in value_str and "E" not in value_str and "e" not in value_str:
+        value_str += ".0"
+    
+    # Check the length
+    if len(value_str) <= 20:
+        # Normalize E notation if present
+        if "E" in value_str or "e" in value_str:
+            if "e" in value_str:
+                value_str = value_str.replace("e", "E")
+            significand, exponent = value_str.split("E")
+            if exponent[0] in ("+", "-"):
+                sign = exponent[0]
+                exponent = exponent[1:]
+            else:
+                sign = ""
+            value_str = f"{significand}E{sign}{int(exponent):02d}"
+            
+            # Check length again
+            if len(value_str) > 20:
+                # Fall back to .16G format
+                value_str = f"{value:.16G}"
+        
+        # If still within limits, use it
+        if len(value_str) <= 20:
+            return value_str
+    
+    # Fall back to original implementation
+    value_str = f"{value:.16G}"
+    if "." not in value_str and "E" not in value_str:
+        value_str += ".0"
+    elif "E" in value_str:
+        significand, exponent = value_str.split("E")
+        if exponent[0] in ("+", "-"):
+            sign = exponent[0]
+            exponent = exponent[1:]
+        else:
+            sign = ""
+        value_str = f"{significand}E{sign}{int(exponent):02d}"
+
+    # Limit the value string to at most 20 characters.
+    str_len = len(value_str)
+    if str_len > 20:
+        idx = value_str.find("E")
+        if idx < 0:
+            value_str = value_str[:20]
+        else:
+            value_str = value_str[: 20 - (str_len - idx)] + value_str[idx:]
+
+    return value_str
+
+print("\n\nTesting improved version:")
+print("-" * 60)
+print(f"{'Value':<25} {'Original':<25} {'Improved':<25}")
+print("-" * 60)
+
+for value in test_values:
+    original = _format_float(value)
+    improved = _format_float_improved(value)
+    print(f"{value:<25} {original:<25} {improved:<25}")
diff --git a/test_special_floats.py b/test_special_floats.py
new file mode 100644
index 0000000000..344b08d214
--- /dev/null
+++ b/test_special_floats.py
@@ -0,0 +1,29 @@
+import numpy as np
+from astropy.io.fits.card import _format_float
+
+# Test special float cases
+test_values = [
+    float('inf'),
+    float('-inf'), 
+    float('nan'),
+    np.inf,
+    -np.inf,
+    np.nan,
+]
+
+print("Testing special float values:")
+print("-" * 60)
+print(f"{'Value':<20} {'str(value)':<20} {'.16G format':<20} {'Original':<20}")
+print("-" * 60)
+
+for value in test_values:
+    str_val = str(value)
+    format_16g = f"{value:.16G}"
+    original = _format_float(value)
+    print(f"{repr(value):<20} {str_val:<20} {format_16g:<20} {original:<20}")
+
+# Check if these need special handling
+print("\nChecking if special values need .0 suffix:")
+for value in [float('inf'), float('-inf'), float('nan')]:
+    formatted = f"{value:.16G}"
+    print(f"{value}: '{formatted}' -> has decimal: {'.' in formatted}, has E: {'E' in formatted}")
