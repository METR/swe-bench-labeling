{"instance_id": "django__django-12155", "score": "C", "diff": "diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56..9bcb1d371d 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -34,7 +34,10 @@ def trim_docstring(docstring):\n         return ''\n     # Convert tabs to spaces and split into lines\n     lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n+    # Calculate minimum indentation (ignoring first line)\n+    indents = [len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()]\n+    # If there are no non-empty lines after the first, use 0 as the indent\n+    indent = min(indents) if indents else 0\n     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n     return \"\\n\".join(trimmed).strip()\n \ndiff --git a/test_docstring_issue.py b/test_docstring_issue.py\nnew file mode 100644\nindex 0000000000..9bca3ad6bc\n--- /dev/null\n+++ b/test_docstring_issue.py\n@@ -0,0 +1,82 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to reproduce the docstring issue.\"\"\"\n+\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+django.setup()\n+\n+from django.contrib.admindocs.utils import trim_docstring, parse_rst, parse_docstring\n+\n+\n+def test_function_with_first_line_docstring():\n+    \"\"\"This is a test function.\n+    \n+    It has a docstring that starts on the first line.\n+    \"\"\"\n+    pass\n+\n+\n+def test_function_with_empty_first_line():\n+    \"\"\"\n+    This is a test function.\n+    \n+    It has a docstring with an empty first line.\n+    \"\"\"\n+    pass\n+\n+\n+if __name__ == \"__main__\":\n+    # Test the current implementation\n+    print(\"Testing function with docstring on first line:\")\n+    docstring1 = test_function_with_first_line_docstring.__doc__\n+    print(\"Original docstring:\")\n+    print(repr(docstring1))\n+    \n+    try:\n+        trimmed1 = trim_docstring(docstring1)\n+        print(\"\\nTrimmed docstring:\")\n+        print(repr(trimmed1))\n+        \n+        # Try to parse it with rst\n+        title, body, metadata = parse_docstring(docstring1)\n+        print(\"\\nParsed title:\")\n+        print(repr(title))\n+        print(\"\\nParsed body:\")\n+        print(repr(body))\n+        \n+        # Try to render it as RST\n+        print(\"\\nTrying to render as RST...\")\n+        rendered = parse_rst(trimmed1, 'test')\n+        print(\"Success!\")\n+    except Exception as e:\n+        print(f\"\\nError: {type(e).__name__}: {e}\")\n+    \n+    print(\"\\n\" + \"=\"*50 + \"\\n\")\n+    \n+    print(\"Testing function with empty first line:\")\n+    docstring2 = test_function_with_empty_first_line.__doc__\n+    print(\"Original docstring:\")\n+    print(repr(docstring2))\n+    \n+    try:\n+        trimmed2 = trim_docstring(docstring2)\n+        print(\"\\nTrimmed docstring:\")\n+        print(repr(trimmed2))\n+        \n+        # Try to parse it with rst\n+        title, body, metadata = parse_docstring(docstring2)\n+        print(\"\\nParsed title:\")\n+        print(repr(title))\n+        print(\"\\nParsed body:\")\n+        print(repr(body))\n+        \n+        # Try to render it as RST\n+        print(\"\\nTrying to render as RST...\")\n+        rendered = parse_rst(trimmed2, 'test')\n+        print(\"Success!\")\n+    except Exception as e:\n+        print(f\"\\nError: {type(e).__name__}: {e}\")\ndiff --git a/test_docstring_rst_error.py b/test_docstring_rst_error.py\nnew file mode 100644\nindex 0000000000..eaf5425c38\n--- /dev/null\n+++ b/test_docstring_rst_error.py\n@@ -0,0 +1,73 @@\n+#!/usr/bin/env python\n+\"\"\"Test that the RST parsing error is fixed.\"\"\"\n+\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+\n+# Configure URLs\n+from django.urls import path\n+\n+urlpatterns = [\n+    path('admindocs/', lambda request: None, name='django-admindocs-docroot'),\n+]\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'django.contrib.admin',\n+        'django.contrib.admindocs',\n+    ],\n+    ROOT_URLCONF=__name__,\n+)\n+\n+django.setup()\n+\n+from django.contrib.admindocs.utils import trim_docstring, parse_rst, parse_docstring\n+\n+\n+def test_view():\n+    \"\"\"test tests something.\n+    \n+    This is the body of the docstring.\n+    It contains multiple lines.\n+    \"\"\"\n+    pass\n+\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing docstring that starts on first line...\")\n+    \n+    docstring = test_view.__doc__\n+    print(f\"\\nOriginal docstring:\\n{repr(docstring)}\")\n+    \n+    # Test trim_docstring\n+    trimmed = trim_docstring(docstring)\n+    print(f\"\\nTrimmed docstring:\\n{repr(trimmed)}\")\n+    \n+    # Test parse_docstring\n+    title, body, metadata = parse_docstring(docstring)\n+    print(f\"\\nParsed title: {repr(title)}\")\n+    print(f\"Parsed body: {repr(body)}\")\n+    \n+    # The crucial test - parse as RST (this should not raise an error)\n+    print(\"\\nTrying to render trimmed docstring as RST...\")\n+    try:\n+        rendered = parse_rst(trimmed, 'test')\n+        print(\"SUCCESS! No error when rendering RST.\")\n+        print(f\"\\nRendered HTML:\\n{rendered}\")\n+    except Exception as e:\n+        print(f\"ERROR: {type(e).__name__}: {e}\")\n+        import traceback\n+        traceback.print_exc()\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..da425d1720\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,51 @@\n+#!/usr/bin/env python\n+\"\"\"Test edge cases for trim_docstring.\"\"\"\n+\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.contrib.admindocs.utils import trim_docstring\n+\n+\n+# Edge case 1: Single line docstring\n+single_line = \"\"\"This is a single line docstring.\"\"\"\n+\n+# Edge case 2: Docstring with empty subsequent lines\n+empty_subsequent = \"\"\"First line\n+    \n+\n+\n+    \"\"\"\n+\n+# Edge case 3: Only whitespace on subsequent lines\n+whitespace_only = \"\"\"First line\n+        \n+    \"\"\"\n+\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing edge cases:\")\n+    \n+    print(\"\\n1. Single line docstring:\")\n+    print(f\"Original: {repr(single_line)}\")\n+    try:\n+        trimmed = trim_docstring(single_line)\n+        print(f\"Trimmed: {repr(trimmed)}\")\n+    except Exception as e:\n+        print(f\"ERROR: {type(e).__name__}: {e}\")\n+    \n+    print(\"\\n2. Docstring with empty subsequent lines:\")\n+    print(f\"Original: {repr(empty_subsequent)}\")\n+    try:\n+        trimmed = trim_docstring(empty_subsequent)\n+        print(f\"Trimmed: {repr(trimmed)}\")\n+    except Exception as e:\n+        print(f\"ERROR: {type(e).__name__}: {e}\")\n+    \n+    print(\"\\n3. Only whitespace on subsequent lines:\")\n+    print(f\"Original: {repr(whitespace_only)}\")\n+    try:\n+        trimmed = trim_docstring(whitespace_only)\n+        print(f\"Trimmed: {repr(trimmed)}\")\n+    except Exception as e:\n+        print(f\"ERROR: {type(e).__name__}: {e}\")\ndiff --git a/test_issue_scenario.py b/test_issue_scenario.py\nnew file mode 100644\nindex 0000000000..919961b27a\n--- /dev/null\n+++ b/test_issue_scenario.py\n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python\n+\"\"\"Test the exact scenario mentioned in the issue.\"\"\"\n+\n+import os\n+import django\n+from django.conf import settings\n+from django.urls import path\n+\n+# Configure Django settings\n+urlpatterns = [\n+    path('admindocs/', lambda request: None, name='django-admindocs-docroot'),\n+]\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'django.contrib.admin',\n+        'django.contrib.admindocs',\n+    ],\n+    ROOT_URLCONF=__name__,\n+)\n+\n+django.setup()\n+\n+from django.contrib.admindocs.utils import trim_docstring, parse_rst\n+\n+\n+def test():\n+    \"\"\"test tests something.\n+    \"\"\"\n+    pass\n+\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing exact scenario from issue...\")\n+    print(f\"Function docstring: {repr(test.__doc__)}\")\n+    \n+    # Trim the docstring\n+    trimmed = trim_docstring(test.__doc__)\n+    print(f\"Trimmed docstring: {repr(trimmed)}\")\n+    \n+    # Try to parse as RST - this was causing the error before\n+    print(\"\\nTrying to render as RST...\")\n+    try:\n+        rendered = parse_rst(trimmed, 'test')\n+        print(\"SUCCESS! No error when rendering RST.\")\n+        print(f\"Rendered HTML: {rendered}\")\n+    except Exception as e:\n+        print(f\"ERROR: {type(e).__name__}: {e}\")\n+        if \"Error in \\\"default-role\\\" directive\" in str(e):\n+            print(\"\\nThis is the exact error mentioned in the issue!\")\n+        import traceback\n+        traceback.print_exc()\ndiff --git a/test_trim_docstring.py b/test_trim_docstring.py\nnew file mode 100644\nindex 0000000000..738a319e62\n--- /dev/null\n+++ b/test_trim_docstring.py\n@@ -0,0 +1,78 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to reproduce the trim_docstring issue.\"\"\"\n+\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.contrib.admindocs.utils import trim_docstring\n+\n+\n+def test_function_with_first_line_docstring():\n+    \"\"\"This is a test function.\n+    \n+    It has a docstring that starts on the first line.\n+    \"\"\"\n+    pass\n+\n+\n+def test_function_with_empty_first_line():\n+    \"\"\"\n+    This is a test function.\n+    \n+    It has a docstring with an empty first line.\n+    \"\"\"\n+    pass\n+\n+\n+# Simpler docstring case that shows the issue more clearly\n+simple_docstring = \"\"\"Test docstring starts on first line.\n+    Second line is indented.\n+    Third line is also indented.\"\"\"\n+\n+\n+if __name__ == \"__main__\":\n+    # Test the current implementation\n+    print(\"Testing simple docstring:\")\n+    print(\"Original:\")\n+    print(repr(simple_docstring))\n+    \n+    # Current implementation\n+    lines = simple_docstring.expandtabs().splitlines()\n+    print(f\"\\nLines: {lines}\")\n+    \n+    # The problem: when we calculate indent, the first line has 0 indentation\n+    indents = [len(line) - len(line.lstrip()) for line in lines if line.lstrip()]\n+    print(f\"Indents for non-empty lines: {indents}\")\n+    indent = min(indents)\n+    print(f\"Minimum indent: {indent}\")\n+    \n+    # This causes the issue - we're using indent=0 because first line has no indent\n+    trimmed_current = trim_docstring(simple_docstring)\n+    print(\"\\nCurrent trim_docstring result:\")\n+    print(repr(trimmed_current))\n+    print(\"\\nNotice the issue: The second and third lines still have leading spaces!\")\n+    \n+    print(\"\\n\" + \"=\"*50 + \"\\n\")\n+    \n+    # Test with function docstrings\n+    print(\"Testing function with docstring on first line:\")\n+    docstring1 = test_function_with_first_line_docstring.__doc__\n+    print(\"Original docstring:\")\n+    print(repr(docstring1))\n+    \n+    trimmed1 = trim_docstring(docstring1)\n+    print(\"\\nTrimmed docstring:\")\n+    print(repr(trimmed1))\n+    print(\"\\nNotice: Body line still has extra indentation!\")\n+    \n+    print(\"\\n\" + \"=\"*50 + \"\\n\")\n+    \n+    print(\"Testing function with empty first line:\")\n+    docstring2 = test_function_with_empty_first_line.__doc__\n+    print(\"Original docstring:\")\n+    print(repr(docstring2))\n+    \n+    trimmed2 = trim_docstring(docstring2)\n+    print(\"\\nTrimmed docstring:\")\n+    print(repr(trimmed2))\n+    print(\"\\nThis one works correctly!\")\ndiff --git a/tests/admin_docs/test_utils.py b/tests/admin_docs/test_utils.py\nindex 17ea912015..0fb80eb999 100644\n--- a/tests/admin_docs/test_utils.py\n+++ b/tests/admin_docs/test_utils.py\n@@ -118,3 +118,33 @@ class TestUtils(AdminDocsSimpleTestCase):\n         markup = '<p>reST, <cite>interpreted text</cite>, default role.</p>\\n'\n         parts = docutils.core.publish_parts(source=source, writer_name=\"html4css1\")\n         self.assertEqual(parts['fragment'], markup)\n+    \n+    def test_trim_docstring_first_line(self):\n+        \"\"\"\n+        Test trim_docstring() with docstrings that start on the first line.\n+        \"\"\"\n+        # Docstring that starts on the first line (issue case)\n+        docstring_first_line = \"\"\"test tests something.\n+    \n+    This is the body of the docstring.\n+    It has multiple lines.\"\"\"\n+        \n+        expected = \"test tests something.\\n\\nThis is the body of the docstring.\\nIt has multiple lines.\"\n+        self.assertEqual(trim_docstring(docstring_first_line), expected)\n+        \n+        # Ensure parse_rst doesn't throw an error\n+        trimmed = trim_docstring(docstring_first_line)\n+        # This should not raise an exception\n+        output = parse_rst(trimmed, 'test')\n+        self.assertIn('test tests something.', output)\n+        self.assertIn('This is the body of the docstring.', output)\n+        \n+        # Edge case: single line docstring\n+        single_line = \"\"\"This is a single line docstring.\"\"\"\n+        self.assertEqual(trim_docstring(single_line), \"This is a single line docstring.\")\n+        \n+        # Edge case: docstring with only whitespace in subsequent lines\n+        whitespace_only = \"\"\"First line\n+        \n+    \"\"\"\n+        self.assertEqual(trim_docstring(whitespace_only), \"First line\")\n", "gold_standard_diff": "From f47ba7e78033f39742c3bf491e9b15365cefd0db Mon Sep 17 00:00:00 2001\nFrom: Baptiste Mispelon <bmispelon@gmail.com>\nDate: Thu, 28 Nov 2019 17:10:20 +0100\nSubject: [PATCH] Fixed #30255 -- Fixed admindocs errors when rendering\n docstrings without leading newlines.\n\nUsed inspect.cleandoc() which implements PEP-257 instead of an internal\nhook.\n---\n django/contrib/admindocs/utils.py | 20 ++++----------------\n django/contrib/admindocs/views.py |  3 ++-\n tests/admin_docs/test_utils.py    | 23 +++++++++--------------\n 3 files changed, 15 insertions(+), 31 deletions(-)\n\ndiff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py\nindex 4c0e7e2a56e7..b44f151e48a1 100644\n--- a/django/contrib/admindocs/utils.py\n+++ b/django/contrib/admindocs/utils.py\n@@ -3,6 +3,7 @@\n import re\n from email.errors import HeaderParseError\n from email.parser import HeaderParser\n+from inspect import cleandoc\n \n from django.urls import reverse\n from django.utils.regex_helper import _lazy_re_compile\n@@ -24,26 +25,13 @@ def get_view_name(view_func):\n     return mod_name + '.' + view_name\n \n \n-def trim_docstring(docstring):\n-    \"\"\"\n-    Uniformly trim leading/trailing whitespace from docstrings.\n-\n-    Based on https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation\n-    \"\"\"\n-    if not docstring or not docstring.strip():\n-        return ''\n-    # Convert tabs to spaces and split into lines\n-    lines = docstring.expandtabs().splitlines()\n-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())\n-    trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]\n-    return \"\\n\".join(trimmed).strip()\n-\n-\n def parse_docstring(docstring):\n     \"\"\"\n     Parse out the parts of a docstring.  Return (title, body, metadata).\n     \"\"\"\n-    docstring = trim_docstring(docstring)\n+    if not docstring:\n+        return '', '', {}\n+    docstring = cleandoc(docstring)\n     parts = re.split(r'\\n{2,}', docstring)\n     title = parts[0]\n     if len(parts) == 1:\ndiff --git a/django/contrib/admindocs/views.py b/django/contrib/admindocs/views.py\nindex cacdeb91a0af..c5a2f0e822bb 100644\n--- a/django/contrib/admindocs/views.py\n+++ b/django/contrib/admindocs/views.py\n@@ -1,5 +1,6 @@\n import inspect\n from importlib import import_module\n+from inspect import cleandoc\n from pathlib import Path\n \n from django.apps import apps\n@@ -256,7 +257,7 @@ def get_context_data(self, **kwargs):\n                     continue\n                 verbose = func.__doc__\n                 verbose = verbose and (\n-                    utils.parse_rst(utils.trim_docstring(verbose), 'model', _('model:') + opts.model_name)\n+                    utils.parse_rst(cleandoc(verbose), 'model', _('model:') + opts.model_name)\n                 )\n                 # Show properties and methods without arguments as fields.\n                 # Otherwise, show as a 'method with arguments'.\ndiff --git a/tests/admin_docs/test_utils.py b/tests/admin_docs/test_utils.py\nindex 17ea91201514..9ffc25392cad 100644\n--- a/tests/admin_docs/test_utils.py\n+++ b/tests/admin_docs/test_utils.py\n@@ -1,8 +1,9 @@\n import unittest\n \n from django.contrib.admindocs.utils import (\n-    docutils_is_available, parse_docstring, parse_rst, trim_docstring,\n+    docutils_is_available, parse_docstring, parse_rst,\n )\n+from django.test.utils import captured_stderr\n \n from .tests import AdminDocsSimpleTestCase\n \n@@ -31,19 +32,6 @@ class TestUtils(AdminDocsSimpleTestCase):\n     def setUp(self):\n         self.docstring = self.__doc__\n \n-    def test_trim_docstring(self):\n-        trim_docstring_output = trim_docstring(self.docstring)\n-        trimmed_docstring = (\n-            'This __doc__ output is required for testing. I copied this '\n-            'example from\\n`admindocs` documentation. (TITLE)\\n\\n'\n-            'Display an individual :model:`myapp.MyModel`.\\n\\n'\n-            '**Context**\\n\\n``RequestContext``\\n\\n``mymodel``\\n'\n-            '    An instance of :model:`myapp.MyModel`.\\n\\n'\n-            '**Template:**\\n\\n:template:`myapp/my_template.html` '\n-            '(DESCRIPTION)\\n\\nsome_metadata: some data'\n-        )\n-        self.assertEqual(trim_docstring_output, trimmed_docstring)\n-\n     def test_parse_docstring(self):\n         title, description, metadata = parse_docstring(self.docstring)\n         docstring_title = (\n@@ -106,6 +94,13 @@ def test_parse_rst(self):\n         self.assertEqual(parse_rst('`title`', 'filter'), markup % 'filters/#title')\n         self.assertEqual(parse_rst('`title`', 'tag'), markup % 'tags/#title')\n \n+    def test_parse_rst_with_docstring_no_leading_line_feed(self):\n+        title, body, _ = parse_docstring('firstline\\n\\n    second line')\n+        with captured_stderr() as stderr:\n+            self.assertEqual(parse_rst(title, ''), '<p>firstline</p>\\n')\n+            self.assertEqual(parse_rst(body, ''), '<p>second line</p>\\n')\n+        self.assertEqual(stderr.getvalue(), '')\n+\n     def test_publish_parts(self):\n         \"\"\"\n         Django shouldn't break the default role for interpreted text\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12155"}