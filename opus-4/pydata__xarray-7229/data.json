{"instance_id": "pydata__xarray-7229", "score": "I", "diff": "diff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 00000000..c5d6827c\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,52 @@\n+import xarray as xr\n+import numpy as np\n+import pandas as pd\n+\n+# Create a synthetic dataset similar to air_temperature\n+time = pd.date_range(\"2013-01-01\", periods=10, freq=\"4h\")\n+lat = np.linspace(-90, 90, 25)\n+lon = np.linspace(-180, 180, 53)\n+\n+# Create the air temperature variable\n+air = xr.DataArray(\n+    np.random.rand(10, 25, 53) * 40 + 270,  # Random temperatures between 270-310K\n+    coords={\"time\": time, \"lat\": lat, \"lon\": lon},\n+    dims=[\"time\", \"lat\", \"lon\"],\n+    name=\"air\",\n+    attrs={\n+        'long_name': '4xDaily Air temperature at sigma level 995',\n+        'units': 'degK',\n+        'precision': 2,\n+        'GRIB_id': 11,\n+        'GRIB_name': 'TMP',\n+        'var_desc': 'Air temperature',\n+        'dataset': 'NMC Reanalysis',\n+        'level_desc': 'Surface',\n+        'statistic': 'Individual Obs',\n+        'parent_stat': 'Other',\n+        'actual_range': np.array([185.16, 322.1], dtype=np.float32)\n+    }\n+)\n+\n+# Set coordinate attributes\n+air.time.attrs = {'standard_name': 'time', 'long_name': 'Time'}\n+air.lat.attrs = {'standard_name': 'latitude', 'long_name': 'Latitude'}\n+air.lon.attrs = {'standard_name': 'longitude', 'long_name': 'Longitude'}\n+\n+# Create dataset\n+ds = xr.Dataset({\"air\": air})\n+\n+# Check the original time attributes\n+print(\"Original time attributes:\")\n+print(ds.time.attrs)\n+\n+# Apply where with keep_attrs=True\n+result = xr.where(True, ds.air, ds.air, keep_attrs=True)\n+\n+# Check the time attributes after where\n+print(\"\\nTime attributes after where with keep_attrs=True:\")\n+print(result.time.attrs)\n+\n+# Also check the air variable attributes\n+print(\"\\nAir variable attributes:\")\n+print(ds.air.attrs)\ndiff --git a/test_where_attrs_fix.py b/test_where_attrs_fix.py\nnew file mode 100644\nindex 00000000..08d685f2\n--- /dev/null\n+++ b/test_where_attrs_fix.py\n@@ -0,0 +1,55 @@\n+import xarray as xr\n+import numpy as np\n+import pandas as pd\n+\n+def test_where_keep_attrs_preserves_coord_attrs():\n+    \"\"\"Test that xr.where with keep_attrs=True preserves coordinate attributes.\"\"\"\n+    # Create a synthetic dataset similar to air_temperature\n+    time = pd.date_range(\"2013-01-01\", periods=10, freq=\"4h\")\n+    lat = np.linspace(-90, 90, 25)\n+    lon = np.linspace(-180, 180, 53)\n+    \n+    # Create the air temperature variable\n+    air = xr.DataArray(\n+        np.random.rand(10, 25, 53) * 40 + 270,  # Random temperatures between 270-310K\n+        coords={\"time\": time, \"lat\": lat, \"lon\": lon},\n+        dims=[\"time\", \"lat\", \"lon\"],\n+        name=\"air\",\n+        attrs={\n+            'long_name': '4xDaily Air temperature at sigma level 995',\n+            'units': 'degK',\n+            'precision': 2,\n+            'GRIB_id': 11,\n+            'GRIB_name': 'TMP',\n+            'var_desc': 'Air temperature',\n+            'dataset': 'NMC Reanalysis',\n+            'level_desc': 'Surface',\n+            'statistic': 'Individual Obs',\n+            'parent_stat': 'Other',\n+            'actual_range': np.array([185.16, 322.1], dtype=np.float32)\n+        }\n+    )\n+    \n+    # Set coordinate attributes\n+    air.time.attrs = {'standard_name': 'time', 'long_name': 'Time'}\n+    air.lat.attrs = {'standard_name': 'latitude', 'long_name': 'Latitude'}\n+    air.lon.attrs = {'standard_name': 'longitude', 'long_name': 'Longitude'}\n+    \n+    # Create dataset\n+    ds = xr.Dataset({\"air\": air})\n+    \n+    # Apply where with keep_attrs=True\n+    result = xr.where(True, ds.air, ds.air, keep_attrs=True)\n+    \n+    # Test that data variable attributes are preserved\n+    assert result.attrs == air.attrs\n+    \n+    # Test that coordinate attributes are preserved (this is the bug)\n+    assert result.time.attrs == {'standard_name': 'time', 'long_name': 'Time'}\n+    assert result.lat.attrs == {'standard_name': 'latitude', 'long_name': 'Latitude'}\n+    assert result.lon.attrs == {'standard_name': 'longitude', 'long_name': 'Longitude'}\n+    \n+    print(\"All tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_where_keep_attrs_preserves_coord_attrs()\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 3f7e8f74..fd9d00b9 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1860,7 +1860,26 @@ def where(cond, x, y, keep_attrs=None):\n     if keep_attrs is True:\n         # keep the attributes of x, the second parameter, by default to\n         # be consistent with the `where` method of `DataArray` and `Dataset`\n-        keep_attrs = lambda attrs, context: getattr(x, \"attrs\", {})\n+        # However, we need to preserve coordinate attributes from the original coordinates\n+        \n+        # Check if x has attributes (i.e., it's a DataArray or Dataset)\n+        x_attrs = getattr(x, \"attrs\", {})\n+        \n+        def keep_attrs_func(attrs, context):\n+            # If we don't have any x attributes (x is scalar), return empty dict\n+            if not x_attrs:\n+                return {}\n+                \n+            # If we have multiple attribute dictionaries, check if they all match\n+            # This indicates we're dealing with a coordinate that appears in multiple inputs\n+            if len(attrs) > 1 and all(a == attrs[0] for a in attrs[1:]):\n+                # All attrs are the same, so this is likely a coordinate\n+                # Return the original coordinate attrs\n+                return attrs[0]\n+            else:\n+                # This is likely the data variable, return x's attrs\n+                return x_attrs\n+        keep_attrs = keep_attrs_func\n \n     # alignment for three arguments is complicated, so don't support it yet\n     return apply_ufunc(\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 0c9ff5bd1f8..035fe2e435a 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -57,7 +57,8 @@ Deprecations\n \n Bug fixes\n ~~~~~~~~~\n-\n+- Fix handling of coordinate attributes in :py:func:`where`. (:issue:`7220`, :pull:`7229`)\n+  By `Sam Levang <https://github.com/slevang>`_.\n - Import ``nc_time_axis`` when needed (:issue:`7275`, :pull:`7276`).\n   By `Michael Niklas <https://github.com/headtr1ck>`_.\n - Fix static typing of :py:meth:`xr.polyval` (:issue:`7312`, :pull:`7315`).\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 3f7e8f742f6..d2fc9f588b4 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1855,15 +1855,13 @@ def where(cond, x, y, keep_attrs=None):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+    from .dataset import Dataset\n+\n     if keep_attrs is None:\n         keep_attrs = _get_keep_attrs(default=False)\n-    if keep_attrs is True:\n-        # keep the attributes of x, the second parameter, by default to\n-        # be consistent with the `where` method of `DataArray` and `Dataset`\n-        keep_attrs = lambda attrs, context: getattr(x, \"attrs\", {})\n \n     # alignment for three arguments is complicated, so don't support it yet\n-    return apply_ufunc(\n+    result = apply_ufunc(\n         duck_array_ops.where,\n         cond,\n         x,\n@@ -1874,6 +1872,27 @@ def where(cond, x, y, keep_attrs=None):\n         keep_attrs=keep_attrs,\n     )\n \n+    # keep the attributes of x, the second parameter, by default to\n+    # be consistent with the `where` method of `DataArray` and `Dataset`\n+    # rebuild the attrs from x at each level of the output, which could be\n+    # Dataset, DataArray, or Variable, and also handle coords\n+    if keep_attrs is True:\n+        if isinstance(y, Dataset) and not isinstance(x, Dataset):\n+            # handle special case where x gets promoted to Dataset\n+            result.attrs = {}\n+            if getattr(x, \"name\", None) in result.data_vars:\n+                result[x.name].attrs = getattr(x, \"attrs\", {})\n+        else:\n+            # otherwise, fill in global attrs and variable attrs (if they exist)\n+            result.attrs = getattr(x, \"attrs\", {})\n+            for v in getattr(result, \"data_vars\", []):\n+                result[v].attrs = getattr(getattr(x, v, None), \"attrs\", {})\n+        for c in getattr(result, \"coords\", []):\n+            # always fill coord attrs of x\n+            result[c].attrs = getattr(getattr(x, c, None), \"attrs\", {})\n+\n+    return result\n+\n \n @overload\n def polyval(\ndiff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex da1bd014064..73889c362fe 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1925,16 +1925,63 @@ def test_where() -> None:\n \n \n def test_where_attrs() -> None:\n-    cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"cond\"})\n-    x = xr.DataArray([1, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n-    y = xr.DataArray([0, 0], dims=\"x\", attrs={\"attr\": \"y\"})\n+    cond = xr.DataArray([True, False], coords={\"a\": [0, 1]}, attrs={\"attr\": \"cond_da\"})\n+    cond[\"a\"].attrs = {\"attr\": \"cond_coord\"}\n+    x = xr.DataArray([1, 1], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+    x[\"a\"].attrs = {\"attr\": \"x_coord\"}\n+    y = xr.DataArray([0, 0], coords={\"a\": [0, 1]}, attrs={\"attr\": \"y_da\"})\n+    y[\"a\"].attrs = {\"attr\": \"y_coord\"}\n+\n+    # 3 DataArrays, takes attrs from x\n     actual = xr.where(cond, x, y, keep_attrs=True)\n-    expected = xr.DataArray([1, 0], dims=\"x\", attrs={\"attr\": \"x\"})\n+    expected = xr.DataArray([1, 0], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+    expected[\"a\"].attrs = {\"attr\": \"x_coord\"}\n     assert_identical(expected, actual)\n \n-    # ensure keep_attrs can handle scalar values\n+    # x as a scalar, takes no attrs\n+    actual = xr.where(cond, 0, y, keep_attrs=True)\n+    expected = xr.DataArray([0, 0], coords={\"a\": [0, 1]})\n+    assert_identical(expected, actual)\n+\n+    # y as a scalar, takes attrs from x\n+    actual = xr.where(cond, x, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+    expected[\"a\"].attrs = {\"attr\": \"x_coord\"}\n+    assert_identical(expected, actual)\n+\n+    # x and y as a scalar, takes no attrs\n     actual = xr.where(cond, 1, 0, keep_attrs=True)\n-    assert actual.attrs == {}\n+    expected = xr.DataArray([1, 0], coords={\"a\": [0, 1]})\n+    assert_identical(expected, actual)\n+\n+    # cond and y as a scalar, takes attrs from x\n+    actual = xr.where(True, x, y, keep_attrs=True)\n+    expected = xr.DataArray([1, 1], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+    expected[\"a\"].attrs = {\"attr\": \"x_coord\"}\n+    assert_identical(expected, actual)\n+\n+    # DataArray and 2 Datasets, takes attrs from x\n+    ds_x = xr.Dataset(data_vars={\"x\": x}, attrs={\"attr\": \"x_ds\"})\n+    ds_y = xr.Dataset(data_vars={\"x\": y}, attrs={\"attr\": \"y_ds\"})\n+    ds_actual = xr.where(cond, ds_x, ds_y, keep_attrs=True)\n+    ds_expected = xr.Dataset(\n+        data_vars={\n+            \"x\": xr.DataArray([1, 0], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+        },\n+        attrs={\"attr\": \"x_ds\"},\n+    )\n+    ds_expected[\"a\"].attrs = {\"attr\": \"x_coord\"}\n+    assert_identical(ds_expected, ds_actual)\n+\n+    # 2 DataArrays and 1 Dataset, takes attrs from x\n+    ds_actual = xr.where(cond, x.rename(\"x\"), ds_y, keep_attrs=True)\n+    ds_expected = xr.Dataset(\n+        data_vars={\n+            \"x\": xr.DataArray([1, 0], coords={\"a\": [0, 1]}, attrs={\"attr\": \"x_da\"})\n+        },\n+    )\n+    ds_expected[\"a\"].attrs = {\"attr\": \"x_coord\"}\n+    assert_identical(ds_expected, ds_actual)\n \n \n @pytest.mark.parametrize(\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/7229"}