{"instance_id": "django__django-14155", "score": "I", "diff": "diff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509..f313869575 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -45,7 +45,12 @@ class ResolverMatch:\n         self.namespaces = [x for x in namespaces if x] if namespaces else []\n         self.namespace = ':'.join(self.namespaces)\n \n-        if not hasattr(func, '__name__'):\n+        # Handle functools.partial objects\n+        if isinstance(func, functools.partial):\n+            # Use the underlying function for path generation\n+            actual_func = func.func\n+            self._func_path = actual_func.__module__ + '.' + actual_func.__name__\n+        elif not hasattr(func, '__name__'):\n             # A class-based view\n             self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n         else:\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..b708f6ec4a\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,52 @@\n+import functools\n+from django.urls import ResolverMatch\n+\n+\n+class TestView:\n+    \"\"\"Test class-based view\"\"\"\n+    def __init__(self, arg1=None):\n+        self.arg1 = arg1\n+    \n+    def __call__(self, request):\n+        return None\n+\n+\n+def test_func(request, arg1, arg2):\n+    \"\"\"Test function\"\"\"\n+    return None\n+\n+\n+# Edge case 1: Partial with a class (not instance)\n+partial_class = functools.partial(TestView, arg1=\"default1\")\n+instance = partial_class()  # Create instance\n+\n+match1 = ResolverMatch(\n+    func=instance,\n+    args=(),\n+    kwargs={},\n+    url_name='test-partial-cbv',\n+    app_names=[],\n+    namespaces=[],\n+    route='test/'\n+)\n+\n+print(\"Partial class instance:\")\n+print(repr(match1))\n+\n+# Edge case 2: Partial with __qualname__\n+test_func.__qualname__ = \"Module.test_func\"\n+\n+partial_func = functools.partial(test_func, arg1=\"default1\")\n+\n+match2 = ResolverMatch(\n+    func=partial_func,\n+    args=(),\n+    kwargs={'arg2': 'value2'},\n+    url_name='test-partial-func',\n+    app_names=[],\n+    namespaces=[],\n+    route='test/'\n+)\n+\n+print(\"\\nPartial function with __qualname__:\")\n+print(repr(match2))\ndiff --git a/test_nested_partial.py b/test_nested_partial.py\nnew file mode 100644\nindex 0000000000..321276f37c\n--- /dev/null\n+++ b/test_nested_partial.py\n@@ -0,0 +1,30 @@\n+import functools\n+from django.urls import ResolverMatch\n+\n+\n+def test_view(request, arg1, arg2, arg3):\n+    \"\"\"Test view function\"\"\"\n+    return None\n+\n+\n+# Create nested partial functions\n+partial_view1 = functools.partial(test_view, arg1=\"default1\")\n+partial_view2 = functools.partial(partial_view1, arg2=\"default2\")\n+\n+# Create ResolverMatch with nested partial function\n+match_nested = ResolverMatch(\n+    func=partial_view2,\n+    args=(),\n+    kwargs={'arg3': 'value3'},\n+    url_name='test-nested-partial',\n+    app_names=['myapp'],\n+    namespaces=['ns1'],\n+    route='test-nested/'\n+)\n+\n+print(\"Nested partial ResolverMatch:\")\n+print(repr(match_nested))\n+print(f\"\\npartial_view2.func: {partial_view2.func}\")\n+print(f\"isinstance(partial_view2.func, functools.partial): {isinstance(partial_view2.func, functools.partial)}\")\n+print(f\"partial_view1: {partial_view1}\")\n+print(f\"partial_view2.func is partial_view1: {partial_view2.func is partial_view1}\")\ndiff --git a/test_partial_attributes.py b/test_partial_attributes.py\nnew file mode 100644\nindex 0000000000..e02eb7a848\n--- /dev/null\n+++ b/test_partial_attributes.py\n@@ -0,0 +1,28 @@\n+import functools\n+\n+\n+def test_view(request, arg1, arg2):\n+    \"\"\"Test view function\"\"\"\n+    return None\n+\n+\n+# Create a partial function\n+partial_view = functools.partial(test_view, arg1=\"default1\")\n+\n+print(\"Partial attributes:\")\n+print(f\"partial_view.func: {partial_view.func}\")\n+print(f\"partial_view.args: {partial_view.args}\")\n+print(f\"partial_view.keywords: {partial_view.keywords}\")\n+print(f\"hasattr __name__: {hasattr(partial_view, '__name__')}\")\n+try:\n+    print(f\"partial_view.__name__: {partial_view.__name__}\")\n+except AttributeError as e:\n+    print(f\"partial_view.__name__: AttributeError - {e}\")\n+try:\n+    print(f\"partial_view.__module__: {partial_view.__module__}\")\n+except AttributeError as e:\n+    print(f\"partial_view.__module__: AttributeError - {e}\")\n+print(f\"partial_view.func.__name__: {partial_view.func.__name__}\")\n+print(f\"partial_view.func.__module__: {partial_view.func.__module__}\")\n+print(f\"partial_view.__class__.__module__: {partial_view.__class__.__module__}\")\n+print(f\"partial_view.__class__.__name__: {partial_view.__class__.__name__}\")\ndiff --git a/test_partial_cbv.py b/test_partial_cbv.py\nnew file mode 100644\nindex 0000000000..e695cb53f2\n--- /dev/null\n+++ b/test_partial_cbv.py\n@@ -0,0 +1,29 @@\n+import functools\n+from django.urls import ResolverMatch\n+\n+\n+class TestView:\n+    \"\"\"Test class-based view\"\"\"\n+    def __init__(self, arg1=None):\n+        self.arg1 = arg1\n+    \n+    def __call__(self, request):\n+        return None\n+\n+\n+# Create a partial with class instantiation\n+partial_view = functools.partial(TestView, arg1=\"default1\")\n+\n+# Create ResolverMatch with partial class-based view\n+match_partial_cbv = ResolverMatch(\n+    func=partial_view(),  # instantiate the class\n+    args=(),\n+    kwargs={},\n+    url_name='test-partial-cbv',\n+    app_names=['myapp'],\n+    namespaces=['ns1'],\n+    route='test-partial-cbv/'\n+)\n+\n+print(\"Partial CBV ResolverMatch:\")\n+print(repr(match_partial_cbv))\ndiff --git a/test_partial_repr.py b/test_partial_repr.py\nnew file mode 100644\nindex 0000000000..f42e043eb0\n--- /dev/null\n+++ b/test_partial_repr.py\n@@ -0,0 +1,38 @@\n+import functools\n+from django.urls import ResolverMatch\n+\n+\n+def test_view(request, arg1, arg2):\n+    \"\"\"Test view function\"\"\"\n+    return None\n+\n+\n+# Create a partial function\n+partial_view = functools.partial(test_view, arg1=\"default1\")\n+\n+# Create ResolverMatch with regular function\n+match_regular = ResolverMatch(\n+    func=test_view,\n+    args=(),\n+    kwargs={'arg1': 'value1', 'arg2': 'value2'},\n+    url_name='test-view',\n+    app_names=['myapp'],\n+    namespaces=['ns1'],\n+    route='test/'\n+)\n+\n+# Create ResolverMatch with partial function\n+match_partial = ResolverMatch(\n+    func=partial_view,\n+    args=(),\n+    kwargs={'arg2': 'value2'},\n+    url_name='test-partial-view',\n+    app_names=['myapp'],\n+    namespaces=['ns1'],\n+    route='test-partial/'\n+)\n+\n+print(\"Regular function ResolverMatch:\")\n+print(repr(match_regular))\n+print(\"\\nPartial function ResolverMatch:\")\n+print(repr(match_partial))\ndiff --git a/test_partial_resolver_match.py b/test_partial_resolver_match.py\nnew file mode 100644\nindex 0000000000..516e3551fe\n--- /dev/null\n+++ b/test_partial_resolver_match.py\n@@ -0,0 +1,52 @@\n+import functools\n+from django.test import SimpleTestCase\n+from django.urls import ResolverMatch\n+\n+\n+def sample_view(request, arg1, arg2=None):\n+    pass\n+\n+\n+class PartialResolverMatchTests(SimpleTestCase):\n+    \n+    def test_partial_func_repr(self):\n+        \"\"\"Test that ResolverMatch handles functools.partial correctly in __repr__\"\"\"\n+        partial_view = functools.partial(sample_view, arg1=\"default\")\n+        \n+        match = ResolverMatch(\n+            func=partial_view,\n+            args=(),\n+            kwargs={'arg2': 'value'},\n+            url_name='partial-view',\n+            app_names=['myapp'],\n+            namespaces=['ns1'],\n+            route='partial/'\n+        )\n+        \n+        # The repr should show the underlying function, not functools.partial\n+        self.assertIn('test_partial_resolver_match.sample_view', repr(match))\n+        self.assertNotIn('functools.partial', repr(match))\n+        \n+    def test_nested_partial_func_repr(self):\n+        \"\"\"Test that ResolverMatch handles nested functools.partial correctly\"\"\"\n+        partial_view1 = functools.partial(sample_view, arg1=\"default1\")\n+        partial_view2 = functools.partial(partial_view1, arg2=\"default2\")\n+        \n+        match = ResolverMatch(\n+            func=partial_view2,\n+            args=(),\n+            kwargs={},\n+            url_name='nested-partial-view',\n+            app_names=['myapp'],\n+            namespaces=['ns1'],\n+            route='nested-partial/'\n+        )\n+        \n+        # The repr should show the underlying function\n+        self.assertIn('test_partial_resolver_match.sample_view', repr(match))\n+        self.assertNotIn('functools.partial', repr(match))\n+        \n+\n+if __name__ == '__main__':\n+    import unittest\n+    unittest.main()\ndiff --git a/test_partial_unwrap.py b/test_partial_unwrap.py\nnew file mode 100644\nindex 0000000000..7ea1aa6477\n--- /dev/null\n+++ b/test_partial_unwrap.py\n@@ -0,0 +1,19 @@\n+import functools\n+\n+\n+def test_view(request, arg1, arg2, arg3):\n+    \"\"\"Test view function\"\"\"\n+    return None\n+\n+\n+# Create nested partial functions\n+partial_view1 = functools.partial(test_view, arg1=\"default1\")\n+partial_view2 = functools.partial(partial_view1, arg2=\"default2\")\n+\n+print(f\"partial_view1.func: {partial_view1.func}\")\n+print(f\"partial_view2.func: {partial_view2.func}\")\n+print(f\"partial_view1.func is test_view: {partial_view1.func is test_view}\")\n+print(f\"partial_view2.func is partial_view1: {partial_view2.func is partial_view1}\")\n+print(f\"type(partial_view2.func): {type(partial_view2.func)}\")\n+\n+# It seems functools.partial automatically flattens nested partials!\ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795..ff93fbdde0 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1144,6 +1144,29 @@ class ResolverMatchTests(SimpleTestCase):\n             \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n+    \n+    def test_partial_func_repr(self):\n+        \"\"\"Test that ResolverMatch handles functools.partial correctly in __repr__\"\"\"\n+        import functools\n+        \n+        def sample_view(request, arg1, arg2=None):\n+            pass\n+        \n+        partial_view = functools.partial(sample_view, arg1=\"default\")\n+        \n+        match = ResolverMatch(\n+            func=partial_view,\n+            args=(),\n+            kwargs={'arg2': 'value'},\n+            url_name='partial-view',\n+            app_names=['myapp'],\n+            namespaces=['ns1'],\n+            route='partial/'\n+        )\n+        \n+        # The repr should show the underlying function, not functools.partial\n+        self.assertIn('urlpatterns_reverse.tests.sample_view', repr(match))\n+        self.assertNotIn('functools.partial', repr(match))\n \n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n", "gold_standard_diff": "From 41850eec99366a51f98123f7c51e5bc5a8b2798c Mon Sep 17 00:00:00 2001\nFrom: Nick Pope <nick@nickpope.me.uk>\nDate: Fri, 19 Mar 2021 14:44:03 +0000\nSubject: [PATCH] Fixed #32572 -- Improved ResolverMatch.__repr__().\n\nWhen a partial function was passed as the view, the __repr__() would\nshow the `func` argument as `functools.partial` which isn't very\nhelpful, especially as it doesn't reveal the underlying function or\narguments provided.\n---\n django/urls/resolvers.py           | 13 ++++++++++---\n tests/urlpatterns_reverse/tests.py | 24 ++++++++++++++++++++++--\n 2 files changed, 32 insertions(+), 5 deletions(-)\n\ndiff --git a/django/urls/resolvers.py b/django/urls/resolvers.py\nindex 9b00e24509cf..0912a82f14d3 100644\n--- a/django/urls/resolvers.py\n+++ b/django/urls/resolvers.py\n@@ -59,9 +59,16 @@ def __getitem__(self, index):\n         return (self.func, self.args, self.kwargs)[index]\n \n     def __repr__(self):\n-        return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_names=%s, namespaces=%s, route=%s)\" % (\n-            self._func_path, self.args, self.kwargs, self.url_name,\n-            self.app_names, self.namespaces, self.route,\n+        if isinstance(self.func, functools.partial):\n+            func = repr(self.func)\n+        else:\n+            func = self._func_path\n+        return (\n+            'ResolverMatch(func=%s, args=%r, kwargs=%r, url_name=%r, '\n+            'app_names=%r, namespaces=%r, route=%r)' % (\n+                func, self.args, self.kwargs, self.url_name,\n+                self.app_names, self.namespaces, self.route,\n+            )\n         )\n \n \ndiff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 09028be795f2..7190023d3ab3 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1141,10 +1141,30 @@ def test_repr(self):\n         self.assertEqual(\n             repr(resolve('/no_kwargs/42/37/')),\n             \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n-            \"args=('42', '37'), kwargs={}, url_name=no-kwargs, app_names=[], \"\n-            \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n+            \"args=('42', '37'), kwargs={}, url_name='no-kwargs', app_names=[], \"\n+            \"namespaces=[], route='^no_kwargs/([0-9]+)/([0-9]+)/$')\",\n         )\n \n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        tests = [\n+            ('partial', 'template.html'),\n+            ('partial_nested', 'nested_partial.html'),\n+            ('partial_wrapped', 'template.html'),\n+        ]\n+        for name, template_name in tests:\n+            with self.subTest(name=name):\n+                func = (\n+                    f\"functools.partial({views.empty_view!r}, \"\n+                    f\"template_name='{template_name}')\"\n+                )\n+                self.assertEqual(\n+                    repr(resolve(f'/{name}/')),\n+                    f\"ResolverMatch(func={func}, args=(), kwargs={{}}, \"\n+                    f\"url_name='{name}', app_names=[], namespaces=[], \"\n+                    f\"route='{name}/')\",\n+                )\n+\n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14155"}