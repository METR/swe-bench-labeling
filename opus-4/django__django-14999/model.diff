diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py
index 982816be3a..9e2c4e3da9 100644
--- a/django/db/migrations/operations/models.py
+++ b/django/db/migrations/operations/models.py
@@ -320,6 +320,9 @@ class RenameModel(ModelOperation):
         new_model = to_state.apps.get_model(app_label, self.new_name)
         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
             old_model = from_state.apps.get_model(app_label, self.old_name)
+            # If the db_table names are the same, the rename is a no-op at the database level
+            if old_model._meta.db_table == new_model._meta.db_table:
+                return
             # Move the main table
             schema_editor.alter_db_table(
                 new_model,
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..7fbb57e985
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,125 @@
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import connection, models
+from django.db.migrations.operations import RenameModel
+from django.db.migrations.state import ProjectState, ModelState
+
+print("=== Testing Edge Cases for RenameModel with db_table ===\n")
+
+# Clean up any existing test database
+if os.path.exists('test_db.sqlite3'):
+    os.remove('test_db.sqlite3')
+
+# Test 1: Model without custom db_table (should still rename table)
+print("Test 1: Model WITHOUT custom db_table")
+state1 = ProjectState()
+state1.add_model(ModelState(
+    'test_app',
+    'RegularModel',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.CharField(max_length=100)),
+    ],
+    {}  # No db_table specified
+))
+
+RegularModel = state1.apps.get_model('test_app', 'RegularModel')
+print(f"Original db_table: {RegularModel._meta.db_table}")
+
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(RegularModel)
+
+# Rename the model
+rename_op = RenameModel('RegularModel', 'RenamedModel')
+state2 = state1.clone()
+rename_op.state_forwards('test_app', state2)
+
+RenamedModel = state2.apps.get_model('test_app', 'RenamedModel')
+print(f"After rename db_table: {RenamedModel._meta.db_table}")
+
+# Apply database operation
+from django.db import connection as conn
+conn.queries_log.clear()
+
+with connection.schema_editor() as schema_editor:
+    rename_op.database_forwards('test_app', schema_editor, state1, state2)
+
+print(f"Number of queries: {len(conn.queries_log)}")
+print("Should rename table:", any('ALTER TABLE' in q['sql'] and 'RENAME TO' in q['sql'] for q in conn.queries_log))
+
+# Test 2: Model with custom db_table and M2M relationship
+print("\n\nTest 2: Model with custom db_table and M2M relationship")
+state3 = ProjectState()
+
+# Author with custom db_table
+state3.add_model(ModelState(
+    'test_app',
+    'Author',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.CharField(max_length=100)),
+        ('books', models.ManyToManyField('test_app.Book')),
+    ],
+    {'db_table': 'custom_author_table'}
+))
+
+# Book model
+state3.add_model(ModelState(
+    'test_app',
+    'Book',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('title', models.CharField(max_length=100)),
+    ],
+    {}
+))
+
+Author = state3.apps.get_model('test_app', 'Author')
+Book = state3.apps.get_model('test_app', 'Book')
+
+# Get the through model
+through_model = Author._meta.get_field('books').remote_field.through
+print(f"M2M through table: {through_model._meta.db_table}")
+
+# Rename Author to Writer
+rename_op2 = RenameModel('Author', 'Writer')
+state4 = state3.clone()
+rename_op2.state_forwards('test_app', state4)
+
+Writer = state4.apps.get_model('test_app', 'Writer')
+new_through_model = Writer._meta.get_field('books').remote_field.through
+print(f"After rename - Writer db_table: {Writer._meta.db_table}")
+print(f"After rename - M2M through table: {new_through_model._meta.db_table}")
+
+# Clean up
+if os.path.exists('test_db.sqlite3'):
+    os.remove('test_db.sqlite3')
+
+print("\n=== Summary ===")
+print("1. Models WITHOUT custom db_table should still rename the table")
+print("2. Models WITH custom db_table should be a no-op")
+print("3. M2M through tables might change if they're auto-generated")
diff --git a/test_full_scenario.py b/test_full_scenario.py
new file mode 100644
index 0000000000..d26f1ed7ea
--- /dev/null
+++ b/test_full_scenario.py
@@ -0,0 +1,129 @@
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': 'test_db.sqlite3',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import connection, models
+from django.db.migrations.operations import RenameModel, CreateModel
+from django.db.migrations.state import ProjectState, ModelState
+
+# Helper to log SQL queries
+class QueryLogger:
+    def __init__(self):
+        self.queries = []
+        
+    def __enter__(self):
+        from django.db import connection
+        connection.queries_log.clear()
+        return self
+        
+    def __exit__(self, *args):
+        from django.db import connection
+        self.queries = list(connection.queries_log)
+        
+    def print_queries(self):
+        for i, query in enumerate(self.queries):
+            print(f"{i+1}. {query['sql']}")
+
+print("=== Testing RenameModel with db_table ===\n")
+
+# Clean up any existing test database
+if os.path.exists('test_db.sqlite3'):
+    os.remove('test_db.sqlite3')
+
+# Create initial state with models
+initial_state = ProjectState()
+
+# Model with custom db_table
+initial_state.add_model(ModelState(
+    'test_app',
+    'Author',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.CharField(max_length=100)),
+    ],
+    {'db_table': 'custom_author_table'}
+))
+
+# Model with FK to Author
+initial_state.add_model(ModelState(
+    'test_app',
+    'Book',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('title', models.CharField(max_length=100)),
+        ('author', models.ForeignKey('test_app.Author', on_delete=models.CASCADE)),
+    ],
+    {}
+))
+
+# Get the models
+Author = initial_state.apps.get_model('test_app', 'Author')
+Book = initial_state.apps.get_model('test_app', 'Book')
+
+print(f"Author model db_table: {Author._meta.db_table}")
+print(f"Book model db_table: {Book._meta.db_table}")
+
+# Create the tables
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(Author)
+    schema_editor.create_model(Book)
+    
+print("\nTables created successfully")
+
+# Now create the rename operation
+rename_op = RenameModel('Author', 'Writer')
+
+# Apply state change
+new_state = initial_state.clone()
+rename_op.state_forwards('test_app', new_state)
+
+# Get new models
+Writer = new_state.apps.get_model('test_app', 'Writer')
+print(f"\nAfter rename - Writer model db_table: {Writer._meta.db_table}")
+
+# Apply database changes and log queries
+print("\nApplying RenameModel operation...")
+print("SQL queries executed:")
+
+from django.db import connection as conn
+conn.queries_log.clear()
+
+with connection.schema_editor() as schema_editor:
+    rename_op.database_forwards('test_app', schema_editor, initial_state, new_state)
+
+# Print the queries that were executed
+print(f"\nNumber of queries executed: {len(conn.queries_log)}")
+for i, query in enumerate(conn.queries_log):
+    print(f"{i+1}. {query['sql']}")
+
+# Clean up
+if os.path.exists('test_db.sqlite3'):
+    os.remove('test_db.sqlite3')
+
+print("\n=== Analysis ===")
+print("When a model has a custom db_table defined, renaming the model should NOT:")
+print("1. Rename the actual database table (since db_table is explicitly set)")
+print("2. Drop and recreate foreign key constraints unnecessarily")
+print("\nThe operation should be mostly a no-op at the database level.")
diff --git a/test_rename_db_table.py b/test_rename_db_table.py
new file mode 100644
index 0000000000..8371f1d254
--- /dev/null
+++ b/test_rename_db_table.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+from django.test import TestCase, TransactionTestCase
+from django.db import connection, models
+from django.db.migrations.operations import RenameModel, CreateModel
+from django.db.migrations.state import ProjectState, ModelState
+
+# Add the parent directory to sys.path
+sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+
+# Configure Django
+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'
+
+# Set up Django
+django.setup()
+
+# Simple test to verify the issue
+print("Testing RenameModel with db_table...")
+
+# Create initial state with a model that has db_table
+initial_state = ProjectState()
+initial_state.add_model(ModelState(
+    'test_app',
+    'OldModel',
+    [
+        ('id', models.AutoField(primary_key=True)),
+        ('name', models.CharField(max_length=100)),
+    ],
+    {'db_table': 'custom_table'}
+))
+
+# Create the renamed state
+new_state = initial_state.clone()
+operation = RenameModel('OldModel', 'NewModel')
+operation.state_forwards('test_app', new_state)
+
+# Get the models from states
+old_model = initial_state.apps.get_model('test_app', 'OldModel')
+new_model = new_state.apps.get_model('test_app', 'NewModel')
+
+print(f"Old model name: {old_model._meta.model_name}")
+print(f"Old model db_table: {old_model._meta.db_table}")
+print(f"New model name: {new_model._meta.model_name}")  
+print(f"New model db_table: {new_model._meta.db_table}")
+print(f"db_table unchanged: {old_model._meta.db_table == new_model._meta.db_table}")
+
+# Test the database operation
+with connection.schema_editor() as schema_editor:
+    # First create the table
+    schema_editor.create_model(old_model)
+    print("\nTable created successfully")
+    
+    # Apply the rename operation
+    print("\nApplying RenameModel operation...")
+    operation.database_forwards('test_app', schema_editor, initial_state, new_state)
+    print("RenameModel operation completed")
+    
+    # Check if the table still exists with same name
+    with connection.cursor() as cursor:
+        tables = connection.introspection.table_names(cursor)
+        print(f"\nTable 'custom_table' exists: {'custom_table' in tables}")
+    
+    # Clean up
+    schema_editor.delete_model(new_model)
diff --git a/test_rename_issue.py b/test_rename_issue.py
new file mode 100644
index 0000000000..c873dfaf7b
--- /dev/null
+++ b/test_rename_issue.py
@@ -0,0 +1,138 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, connection
+from django.db.migrations.operations import RenameModel, CreateModel
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations.migration import Migration
+from django.db.migrations.executor import MigrationExecutor
+from django.apps import apps
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'test_app',
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+        MIGRATION_MODULES={
+            'test_app': None,
+        }
+    )
+    django.setup()
+
+# Create test app config
+from django.apps import AppConfig
+
+class TestAppConfig(AppConfig):
+    name = 'test_app'
+    label = 'test_app'
+
+# Create a migration to test
+class Migration1(Migration):
+    initial = True
+    
+    operations = [
+        CreateModel(
+            name='OldModel',
+            fields=[
+                ('id', models.AutoField(primary_key=True)),
+                ('name', models.CharField(max_length=100)),
+            ],
+            options={
+                'db_table': 'my_custom_table',
+            },
+        ),
+    ]
+
+class Migration2(Migration):
+    dependencies = [
+        ('test_app', '0001_initial'),
+    ]
+    
+    operations = [
+        RenameModel(
+            old_name='OldModel',
+            new_name='NewModel',
+        ),
+    ]
+
+# Mock some SQL tracking
+class SQLTracker:
+    def __init__(self):
+        self.queries = []
+        
+    def __enter__(self):
+        from django.db import connection
+        self.old_execute = connection.cursor().execute
+        
+        def track_execute(sql, params=None):
+            self.queries.append(sql)
+            return self.old_execute(sql, params)
+            
+        connection.cursor().execute = track_execute
+        return self
+        
+    def __exit__(self, *args):
+        from django.db import connection
+        connection.cursor().execute = self.old_execute
+
+# Run the test
+print("Testing RenameModel operation with db_table...")
+
+# Apply migrations
+from django.db import connection
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+# Track SQL queries
+with connection.schema_editor() as schema_editor:
+    print("\nCapturing SQL for table rename...")
+    
+    # Create from_state and to_state
+    from_state = ProjectState()
+    from_state.add_model(ModelState(
+        'test_app',
+        'OldModel',
+        [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],
+        {'db_table': 'my_custom_table'}
+    ))
+    
+    to_state = ProjectState()
+    to_state.add_model(ModelState(
+        'test_app',
+        'NewModel',
+        [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],
+        {'db_table': 'my_custom_table'}
+    ))
+    
+    # Get models
+    old_model = from_state.apps.get_model('test_app', 'OldModel')
+    new_model = to_state.apps.get_model('test_app', 'NewModel')
+    
+    print(f"Old model db_table: {old_model._meta.db_table}")
+    print(f"New model db_table: {new_model._meta.db_table}")
+    print(f"Tables are the same: {old_model._meta.db_table == new_model._meta.db_table}")
+    
+    # Test what alter_db_table does when tables are the same
+    print("\nTesting alter_db_table with same table names...")
+    try:
+        schema_editor.alter_db_table(
+            new_model,
+            old_model._meta.db_table,
+            new_model._meta.db_table,
+        )
+        print("alter_db_table executed")
+    except Exception as e:
+        print(f"Error: {e}")
diff --git a/test_rename_model_noop.py b/test_rename_model_noop.py
new file mode 100644
index 0000000000..53f1a1bfdd
--- /dev/null
+++ b/test_rename_model_noop.py
@@ -0,0 +1,69 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, connection
+from django.db.migrations.operations import RenameModel
+from django.db.migrations.state import ProjectState, ModelState
+from django.apps import apps
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=True,
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+# Create a test model with db_table
+class OldModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'my_custom_table'
+
+# Create states
+from_state = ProjectState()
+from_state.add_model(ModelState(
+    'test_app',
+    'OldModel',
+    [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],
+    {'db_table': 'my_custom_table'}
+))
+
+to_state = ProjectState()
+to_state.add_model(ModelState(
+    'test_app',
+    'NewModel',
+    [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],
+    {'db_table': 'my_custom_table'}
+))
+
+# Create RenameModel operation
+rename_op = RenameModel('OldModel', 'NewModel')
+
+# Test the operation
+from django.db import connection
+from django.db.migrations.executor import MigrationExecutor
+
+print("Testing RenameModel with db_table...")
+print(f"Old model db_table: {from_state.apps.get_model('test_app', 'OldModel')._meta.db_table}")
+print(f"New model db_table: {to_state.apps.get_model('test_app', 'NewModel')._meta.db_table}")
+
+# Check if they're the same
+old_db_table = from_state.apps.get_model('test_app', 'OldModel')._meta.db_table
+new_db_table = to_state.apps.get_model('test_app', 'NewModel')._meta.db_table
+print(f"Are db_tables the same? {old_db_table == new_db_table}")
diff --git a/test_specific_issue.py b/test_specific_issue.py
new file mode 100644
index 0000000000..4005217e3e
--- /dev/null
+++ b/test_specific_issue.py
@@ -0,0 +1,42 @@
+"""
+Test to verify that RenameModel is not a no-op when db_table is specified.
+According to the issue, it should be a no-op but currently it drops and 
+recreates foreign key constraints in Postgres and recreates the table in SQLite.
+"""
+
+print("\n=== Testing Issue: RenameModel with db_table should be a no-op ===\n")
+
+# Let's check what happens in the alter_db_table method
+print("1. Checking base alter_db_table implementation:")
+print("   - File: django/db/backends/base/schema.py")
+print("   - Lines 470-473 check if old_db_table == new_db_table")
+print("   - If they're equal, it returns early (no-op)")
+
+print("\n2. RenameModel.database_forwards calls alter_db_table with:")
+print("   - old_model._meta.db_table")
+print("   - new_model._meta.db_table")
+
+print("\n3. When a model has db_table specified:")
+print("   - Both old and new models will have the same db_table")
+print("   - So alter_db_table should be a no-op")
+
+print("\n4. The issue mentions:")
+print("   - In Postgres: drops and recreates foreign key constraints")
+print("   - In SQLite: recreates the table")
+
+print("\nLet's trace through the code to see what else happens in database_forwards...")
+
+# Looking at the RenameModel.database_forwards method
+print("\nIn RenameModel.database_forwards (lines 319-368):")
+print("1. Line 324-328: Calls alter_db_table")
+print("2. Line 329-347: Alters fields pointing to this model")
+print("3. Line 348-368: Renames M2M fields")
+
+print("\nThe issue might be in steps 2 and 3, where foreign keys are updated.")
+print("Even if the table name doesn't change, the model name does change,")
+print("so foreign key constraints might be dropped and recreated.")
+
+print("\n=== Proposed Fix ===")
+print("The fix should check if old and new db_table are the same.")
+print("If they are, we should skip the alter_db_table call entirely.")
+print("However, we still need to update foreign key references to use the new model name.")
