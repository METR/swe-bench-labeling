{"instance_id": "django__django-13406", "score": "C", "diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex b48d0df9c0..a27130f720 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -211,6 +211,9 @@ class QuerySet:\n     @query.setter\n     def query(self, value):\n         self._query = value\n+        # When assigning a query, check if it's a values query and set the appropriate iterable class\n+        if hasattr(value, 'values_select') and value.values_select:\n+            self._iterable_class = ValuesIterable\n \n     def as_manager(cls):\n         # Address the circular dependency between `Queryset` and `Manager`.\ndiff --git a/test_fix_verification.py b/test_fix_verification.py\nnew file mode 100644\nindex 0000000000..3f9d4f9e20\n--- /dev/null\n+++ b/test_fix_verification.py\n@@ -0,0 +1,127 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+# Setup Django\n+django.setup()\n+\n+# Now we can import Django components\n+import pickle\n+from django.db import models, connection\n+from django.db.models import Sum\n+\n+# Define a test model\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    category = models.CharField(max_length=16)\n+    value = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+# Create the table\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(TestModel)\n+\n+# Create test data\n+TestModel.objects.create(name='item1', category='A', value=10)\n+TestModel.objects.create(name='item2', category='B', value=20)\n+TestModel.objects.create(name='item3', category='A', value=30)\n+TestModel.objects.create(name='item4', category='B', value=40)\n+\n+print(\"Testing values() with annotate() after pickling/unpickling...\")\n+print(\"=\" * 60)\n+\n+# Test 1: values() with annotate()\n+print(\"\\nTest 1: values() with annotate()\")\n+qs1 = TestModel.objects.values('category').annotate(total=Sum('value'))\n+print(\"Original queryset:\")\n+for item in qs1:\n+    print(f\"  {item}\")\n+print(f\"Type of first result: {type(qs1[0])}\")\n+\n+# Pickle and unpickle the query\n+pickled = pickle.dumps(qs1.query)\n+qs2 = TestModel.objects.all()\n+qs2.query = pickle.loads(pickled)\n+\n+print(\"\\nAfter unpickling:\")\n+try:\n+    for item in qs2:\n+        print(f\"  {item}\")\n+    print(f\"Type of first result: {type(qs2[0])}\")\n+    print(\"SUCCESS: Query works correctly!\")\n+except Exception as e:\n+    print(f\"ERROR: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Test 2: Just values() without annotate\n+print(\"\\n\" + \"=\" * 60)\n+print(\"\\nTest 2: values() without annotate()\")\n+qs3 = TestModel.objects.values('category', 'name')\n+print(\"Original queryset:\")\n+for item in qs3:\n+    print(f\"  {item}\")\n+print(f\"Type of first result: {type(qs3[0])}\")\n+\n+# Pickle and unpickle the query\n+pickled = pickle.dumps(qs3.query)\n+qs4 = TestModel.objects.all()\n+qs4.query = pickle.loads(pickled)\n+\n+print(\"\\nAfter unpickling:\")\n+try:\n+    for item in qs4:\n+        print(f\"  {item}\")\n+    print(f\"Type of first result: {type(qs4[0])}\")\n+    print(\"SUCCESS: Query works correctly!\")\n+except Exception as e:\n+    print(f\"ERROR: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Test 3: Regular query (no values)\n+print(\"\\n\" + \"=\" * 60)\n+print(\"\\nTest 3: Regular query (no values)\")\n+qs5 = TestModel.objects.filter(category='A')\n+print(\"Original queryset:\")\n+for item in qs5:\n+    print(f\"  {item.name} - {item.category} - {item.value}\")\n+\n+# Pickle and unpickle the query\n+pickled = pickle.dumps(qs5.query)\n+qs6 = TestModel.objects.all()\n+qs6.query = pickle.loads(pickled)\n+\n+print(\"\\nAfter unpickling:\")\n+try:\n+    for item in qs6:\n+        print(f\"  {item.name} - {item.category} - {item.value}\")\n+    print(\"SUCCESS: Query works correctly!\")\n+except Exception as e:\n+    print(f\"ERROR: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\n\" + \"=\" * 60)\n+print(\"All tests completed!\")\ndiff --git a/test_pickle_fix.py b/test_pickle_fix.py\nnew file mode 100644\nindex 0000000000..b44cf23fee\n--- /dev/null\n+++ b/test_pickle_fix.py\n@@ -0,0 +1,50 @@\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+\n+import django\n+django.setup()\n+\n+import pickle\n+from django.db.models import Sum\n+from aggregation.models import Author, Book, Publisher\n+\n+# Clear existing data and create test data\n+Author.objects.all().delete()\n+Publisher.objects.all().delete()\n+Book.objects.all().delete()\n+\n+# Create test data\n+a1 = Author.objects.create(name='Author1', age=30)\n+a2 = Author.objects.create(name='Author2', age=40)\n+p1 = Publisher.objects.create(name='Publisher1', num_awards=5)\n+b1 = Book.objects.create(isbn='123', name='Book1', pages=100, rating=4.5, price=20.00, \n+                         contact=a1, publisher=p1, pubdate='2023-01-01')\n+b2 = Book.objects.create(isbn='456', name='Book2', pages=200, rating=4.0, price=30.00,\n+                         contact=a2, publisher=p1, pubdate='2023-01-02')\n+\n+# Original query with values and annotate\n+prices = Book.objects.values('publisher').annotate(total=Sum('price'))\n+print(\"Original query results:\")\n+for item in prices:\n+    print(f\"  {item}\")\n+print(f\"Type of first result: {type(prices[0])}\")\n+print(f\"Original queryset _iterable_class: {prices._iterable_class}\")\n+print(f\"Original query values_select: {prices.query.values_select}\")\n+\n+# Pickle and unpickle the query\n+pickled_query = pickle.dumps(prices.query)\n+\n+# Create new queryset with unpickled query\n+prices2 = Book.objects.all()\n+prices2.query = pickle.loads(pickled_query)\n+\n+print(f\"\\nUnpickled queryset _iterable_class: {prices2._iterable_class}\")\n+print(\"Unpickled query results:\")\n+try:\n+    for item in prices2:\n+        print(f\"  {item}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_pickle_values_issue.py b/test_pickle_values_issue.py\nnew file mode 100644\nindex 0000000000..4471e6bd4d\n--- /dev/null\n+++ b/test_pickle_values_issue.py\n@@ -0,0 +1,72 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+)\n+\n+django.setup()\n+\n+import pickle\n+from django.db import models\n+from django.db.models import Sum\n+from django.test import TestCase\n+\n+\n+class Toy(models.Model):\n+    name = models.CharField(max_length=16)\n+    material = models.CharField(max_length=16)\n+    price = models.PositiveIntegerField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+if __name__ == \"__main__\":\n+    # Create table\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Toy)\n+    \n+    # Create test data\n+    Toy.objects.create(name='foo', price=10, material='wood')\n+    Toy.objects.create(name='bar', price=20, material='plastic')\n+    Toy.objects.create(name='baz', price=100, material='wood')\n+    \n+    # Original query with values and annotate\n+    prices = Toy.objects.values('material').annotate(total_price=Sum('price'))\n+    print(\"Original query results:\")\n+    for item in prices:\n+        print(f\"  {item}\")\n+    print(f\"Type of first result: {type(prices[0])}\")\n+    print(f\"Original queryset _iterable_class: {prices._iterable_class}\")\n+    print(f\"Original query values_select: {prices.query.values_select}\")\n+    print(f\"Original query annotation_select: {prices.query.annotation_select}\")\n+    \n+    # Pickle and unpickle the query\n+    pickled_query = pickle.dumps(prices.query)\n+    \n+    # Create new queryset with unpickled query\n+    prices2 = Toy.objects.all()\n+    unpickled_query = pickle.loads(pickled_query)\n+    print(f\"\\nUnpickled query values_select: {unpickled_query.values_select}\")\n+    print(f\"Unpickled query annotation_select: {unpickled_query.annotation_select}\")\n+    \n+    prices2.query = unpickled_query\n+    \n+    print(f\"\\nUnpickled queryset _iterable_class: {prices2._iterable_class}\")\n+    print(f\"Type of first result: {type(prices2[0])}\")\n+    \n+    # This should work but currently crashes\n+    for item in prices2:\n+        print(f\"  {item}\")\ndiff --git a/test_simple_pickle.py b/test_simple_pickle.py\nnew file mode 100644\nindex 0000000000..acb864f2ce\n--- /dev/null\n+++ b/test_simple_pickle.py\n@@ -0,0 +1,44 @@\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+\n+import django\n+django.setup()\n+\n+import pickle\n+from django.db.models import Sum\n+from queries.models import Number\n+\n+# Clear existing data\n+Number.objects.all().delete()\n+\n+# Create test data\n+Number.objects.create(num=10, other_num=1)\n+Number.objects.create(num=20, other_num=1)\n+Number.objects.create(num=30, other_num=2)\n+\n+# Original query with values and annotate\n+prices = Number.objects.values('other_num').annotate(total=Sum('num'))\n+print(\"Original query results:\")\n+for item in prices:\n+    print(f\"  {item}\")\n+print(f\"Type of first result: {type(prices[0])}\")\n+print(f\"Original queryset _iterable_class: {prices._iterable_class}\")\n+print(f\"Original query values_select: {prices.query.values_select}\")\n+\n+# Pickle and unpickle the query\n+pickled_query = pickle.dumps(prices.query)\n+\n+# Create new queryset with unpickled query\n+prices2 = Number.objects.all()\n+prices2.query = pickle.loads(pickled_query)\n+\n+print(f\"\\nUnpickled queryset _iterable_class: {prices2._iterable_class}\")\n+print(\"Unpickled query results:\")\n+try:\n+    for item in prices2:\n+        print(f\"  {item}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+    import traceback\n+    traceback.print_exc()\n", "gold_standard_diff": "From 5362e08624c6745181944a10979da876934ea136 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Thu, 10 Sep 2020 14:34:04 +0200\nSubject: [PATCH] Fixed #31943 -- Fixed recreating\n QuerySet.values()/values_list() when using a pickled Query.\n\n---\n django/db/models/query.py      |  2 ++\n docs/ref/models/querysets.txt  | 14 ++++++++++++++\n tests/queryset_pickle/tests.py | 24 +++++++++++++++++++++++-\n 3 files changed, 39 insertions(+), 1 deletion(-)\n\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex b48d0df9c000..85cd8311a7d2 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -210,6 +210,8 @@ def query(self):\n \n     @query.setter\n     def query(self, value):\n+        if value.values_select:\n+            self._iterable_class = ValuesIterable\n         self._query = value\n \n     def as_manager(cls):\ndiff --git a/docs/ref/models/querysets.txt b/docs/ref/models/querysets.txt\nindex 228e2cf73627..7f55684e0827 100644\n--- a/docs/ref/models/querysets.txt\n+++ b/docs/ref/models/querysets.txt\n@@ -106,6 +106,20 @@ the query construction and is not part of the public API. However, it is safe\n (and fully supported) to pickle and unpickle the attribute's contents as\n described here.\n \n+.. admonition:: Restrictions on ``QuerySet.values_list()``\n+\n+    If you recreate :meth:`QuerySet.values_list` using the pickled ``query``\n+    attribute, it will be converted to :meth:`QuerySet.values`::\n+\n+        >>> import pickle\n+        >>> qs = Blog.objects.values_list('id', 'name')\n+        >>> qs\n+        <QuerySet [(1, 'Beatles Blog')]>\n+        >>> reloaded_qs = Blog.objects.all()\n+        >>> reloaded_qs.query = pickle.loads(pickle.dumps(qs.query))\n+        >>> reloaded_qs\n+        <QuerySet [{'id': 1, 'name': 'Beatles Blog'}]>\n+\n .. admonition:: You can't share pickles between versions\n \n     Pickles of ``QuerySets`` are only valid for the version of Django that\ndiff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex a58e45caed40..8575c6fe8114 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -11,7 +11,7 @@\n class PickleabilityTestCase(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n-        Happening.objects.create()  # make sure the defaults are working (#20158)\n+        cls.happening = Happening.objects.create()  # make sure the defaults are working (#20158)\n \n     def assert_pickles(self, qs):\n         self.assertEqual(list(pickle.loads(pickle.dumps(qs))), list(qs))\n@@ -224,6 +224,28 @@ def test_annotation_with_callable_default(self):\n         qs = Happening.objects.annotate(latest_time=models.Max('when'))\n         self.assert_pickles(qs)\n \n+    def test_annotation_values(self):\n+        qs = Happening.objects.values('name').annotate(latest_time=models.Max('when'))\n+        reloaded = Happening.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+        self.assertEqual(\n+            reloaded.get(),\n+            {'name': 'test', 'latest_time': self.happening.when},\n+        )\n+\n+    def test_annotation_values_list(self):\n+        # values_list() is reloaded to values() when using a pickled query.\n+        tests = [\n+            Happening.objects.values_list('name'),\n+            Happening.objects.values_list('name', flat=True),\n+            Happening.objects.values_list('name', named=True),\n+        ]\n+        for qs in tests:\n+            with self.subTest(qs._iterable_class.__name__):\n+                reloaded = Happening.objects.all()\n+                reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+                self.assertEqual(reloaded.get(), {'name': 'test'})\n+\n     def test_filter_deferred(self):\n         qs = Happening.objects.all()\n         qs._defer_next_filter = True\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13406"}