{"instance_id": "django__django-11087", "score": "I", "diff": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 3a462f1c4c..de320c2f40 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -232,9 +232,21 @@ class Collector:\n         \"\"\"\n         Get a QuerySet of objects related to `objs` via the relation `related`.\n         \"\"\"\n-        return related.related_model._base_manager.using(self.using).filter(\n+        # Fetch only the fields needed for deletion:\n+        # - primary key (for deletion queries)\n+        # - foreign key fields (for signal handlers and cascade operations)\n+        model = related.related_model\n+        opts = model._meta\n+        fields = [opts.pk.name]\n+        \n+        # Add all foreign key fields  \n+        for field in opts.fields:\n+            if field.many_to_one or field.one_to_one:\n+                fields.append(field.attname)\n+        \n+        return model._base_manager.using(self.using).filter(\n             **{\"%s__in\" % related.field.name: objs}\n-        )\n+        ).only(*fields)\n \n     def instances_with_model(self):\n         for model, instances in self.data.items():\ndiff --git a/test_delete_field_optimization.py b/test_delete_field_optimization.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_delete_fix.py b/test_delete_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_delete_optimization.py b/test_delete_optimization.py\nnew file mode 100644\nindex 0000000000..6b84034371\n--- /dev/null\n+++ b/test_delete_optimization.py\n@@ -0,0 +1,83 @@\n+\"\"\"\n+Test to verify that .delete() only fetches required fields.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.db import models, connection\n+from django.test.utils import setup_test_environment, teardown_test_environment\n+from django.conf import settings\n+from django.apps import apps\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+setup_test_environment()\n+\n+# Create test models\n+class Parent(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Child(models.Model):\n+    parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+    name = models.CharField(max_length=100)\n+    # This field could contain problematic data\n+    data = models.TextField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Parent)\n+    schema_editor.create_model(Child)\n+\n+# Create test data\n+parent = Parent.objects.create(name=\"Test Parent\")\n+child = Child.objects.create(parent=parent, name=\"Test Child\", data=\"Some data\")\n+\n+# Enable query logging\n+from django.db import reset_queries\n+from django.conf import settings\n+settings.DEBUG = True\n+\n+# Reset queries and perform delete\n+reset_queries()\n+parent.delete()\n+\n+# Check the queries\n+print(\"Queries executed during delete:\")\n+for i, query in enumerate(connection.queries):\n+    print(f\"\\nQuery {i+1}:\")\n+    print(f\"SQL: {query['sql']}\")\n+    \n+# Check if Child's data field was selected\n+child_queries = [q for q in connection.queries if 'child' in q['sql'].lower()]\n+if child_queries:\n+    for query in child_queries:\n+        if 'SELECT' in query['sql']:\n+            print(f\"\\nChild SELECT query: {query['sql']}\")\n+            if '\"data\"' in query['sql'] or '`data`' in query['sql'] or 'child.data' in query['sql']:\n+                print(\"ERROR: The 'data' field is being fetched unnecessarily!\")\n+            else:\n+                print(\"OK: The 'data' field is not being fetched.\")\n+\n+teardown_test_environment()\ndiff --git a/test_delete_simple.py b/test_delete_simple.py\nnew file mode 100644\nindex 0000000000..94a5fec392\n--- /dev/null\n+++ b/test_delete_simple.py\n@@ -0,0 +1,63 @@\n+\"\"\"\n+Simple test to verify that .delete() only fetches required fields.\n+\"\"\"\n+import os\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"django.conf.global_settings\")\n+\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.test import TransactionTestCase\n+from django.test.utils import override_settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+    ],\n+    USE_TZ=False,\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+# Track SQL queries\n+queries_executed = []\n+def track_queries(execute, sql, params, many, context):\n+    queries_executed.append(sql)\n+    return execute(sql, params, many, context)\n+\n+# Test with mock models\n+from django.db import models, connection\n+print(\"Testing deletion behavior...\")\n+\n+# Check the original deletion.py code\n+from django.db.models.deletion import Collector\n+\n+# Let's look at the related_objects method\n+collector = Collector(using='default')\n+print(f\"\\nOriginal related_objects method defined at line: {collector.related_objects.__code__.co_firstlineno}\")\n+\n+# Simulate what happens during delete\n+class MockRelated:\n+    def __init__(self):\n+        self.field = type('field', (), {'name': 'parent'})()\n+        self.related_model = type('Child', (), {\n+            '_base_manager': type('manager', (), {\n+                'using': lambda self, db: self,\n+                'filter': lambda self, **kwargs: f\"QuerySet filtering on {kwargs}\"\n+            })()\n+        })()\n+\n+related = MockRelated()\n+print(f\"\\nSimulated query: {collector.related_objects(related, ['obj1', 'obj2'])}\")\n+\n+# The issue is that this creates a regular QuerySet without .only() or .values()\n+# which means ALL fields will be fetched when the QuerySet is evaluated\n+print(\"\\nThe problem: related_objects() doesn't use .only() to limit fields fetched!\")\ndiff --git a/test_unicode_delete_optimization.py b/test_unicode_delete_optimization.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\n", "gold_standard_diff": "From 26c4be2ebe918601c0a13d4abb3f3cab49107c73 Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <charette.s@gmail.com>\nDate: Sat, 16 Mar 2019 19:30:29 -0400\nSubject: [PATCH 1/2] Refs #18676 -- Enabled fast-delete for m2m_changed\n senders.\n\nThere's no reason to disable fast-delete when an intermediary\nmany-to-many model has connected m2m_changed receivers because the\nsignal is only sent when related manager's clear() and remove() methods\nare directly called.\n\nThis must have been overlooked in 1cd6e04cd4f768bcd4385b75de433d497d938f82\ngiven no regression tests fail when m2m_changed is not taken into\nconsideration to determine if fast-delete can be enabled.\n---\n django/db/models/deletion.py | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\ndiff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 3a462f1c4c46..d886331fcf0b 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -136,8 +136,7 @@ def can_fast_delete(self, objs, from_field=None):\n         else:\n             return False\n         if (signals.pre_delete.has_listeners(model) or\n-                signals.post_delete.has_listeners(model) or\n-                signals.m2m_changed.has_listeners(model)):\n+                signals.post_delete.has_listeners(model)):\n             return False\n         # The use of from_field comes from the need to avoid cascade back to\n         # parent when parent delete is cascading to child.\n\nFrom f110de5c04818b8f915dcf65da37a50c1424c6e6 Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <charette.s@gmail.com>\nDate: Tue, 19 Feb 2019 01:33:28 -0500\nSubject: [PATCH 2/2] Fixed #30191 -- Selected only referenced fields during\n cascade deletion.\n\nThe non-referenced fields can only be deferred if no deletion signals\nreceivers are connected for their respective model as connected as these\nreceivers might expect all fields of the deleted model to be present.\n\nThanks Ed Morley for the report.\n---\n django/db/models/deletion.py | 29 +++++++++++++++++++++++++----\n tests/delete/models.py       | 17 +++++++++++++++++\n tests/delete/tests.py        | 36 +++++++++++++++++++++++++++++++++++-\n 3 files changed, 77 insertions(+), 5 deletions(-)\n\ndiff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex d886331fcf0b..d28e596b46dc 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -1,4 +1,5 @@\n from collections import Counter\n+from itertools import chain\n from operator import attrgetter\n \n from django.db import IntegrityError, connections, transaction\n@@ -116,6 +117,12 @@ def add_field_update(self, field, value, objs):\n             model, {}).setdefault(\n             (field, value), set()).update(objs)\n \n+    def _has_signal_listeners(self, model):\n+        return (\n+            signals.pre_delete.has_listeners(model) or\n+            signals.post_delete.has_listeners(model)\n+        )\n+\n     def can_fast_delete(self, objs, from_field=None):\n         \"\"\"\n         Determine if the objects in the given queryset-like or single object\n@@ -135,8 +142,7 @@ def can_fast_delete(self, objs, from_field=None):\n             model = objs.model\n         else:\n             return False\n-        if (signals.pre_delete.has_listeners(model) or\n-                signals.post_delete.has_listeners(model)):\n+        if self._has_signal_listeners(model):\n             return False\n         # The use of from_field comes from the need to avoid cascade back to\n         # parent when parent delete is cascading to child.\n@@ -219,8 +225,23 @@ def collect(self, objs, source=None, nullable=False, collect_related=True,\n                     sub_objs = self.related_objects(related, batch)\n                     if self.can_fast_delete(sub_objs, from_field=field):\n                         self.fast_deletes.append(sub_objs)\n-                    elif sub_objs:\n-                        field.remote_field.on_delete(self, field, sub_objs, self.using)\n+                    else:\n+                        related_model = related.related_model\n+                        # Non-referenced fields can be deferred if no signal\n+                        # receivers are connected for the related model as\n+                        # they'll never be exposed to the user. Skip field\n+                        # deferring when some relationships are select_related\n+                        # as interactions between both features are hard to\n+                        # get right. This should only happen in the rare\n+                        # cases where .related_objects is overridden anyway.\n+                        if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n+                            referenced_fields = set(chain.from_iterable(\n+                                (rf.attname for rf in rel.field.foreign_related_fields)\n+                                for rel in get_candidate_relations_to_delete(related_model._meta)\n+                            ))\n+                            sub_objs = sub_objs.only(*tuple(referenced_fields))\n+                        if sub_objs:\n+                            field.remote_field.on_delete(self, field, sub_objs, self.using)\n             for field in model._meta.private_fields:\n                 if hasattr(field, 'bulk_related_objects'):\n                     # It's something like generic foreign key.\ndiff --git a/tests/delete/models.py b/tests/delete/models.py\nindex 2fc5ebe217db..d2cce023339a 100644\n--- a/tests/delete/models.py\n+++ b/tests/delete/models.py\n@@ -126,3 +126,20 @@ class Base(models.Model):\n \n class RelToBase(models.Model):\n     base = models.ForeignKey(Base, models.DO_NOTHING)\n+\n+\n+class Origin(models.Model):\n+    pass\n+\n+\n+class Referrer(models.Model):\n+    origin = models.ForeignKey(Origin, models.CASCADE)\n+    unique_field = models.IntegerField(unique=True)\n+    large_field = models.TextField()\n+\n+\n+class SecondReferrer(models.Model):\n+    referrer = models.ForeignKey(Referrer, models.CASCADE)\n+    other_referrer = models.ForeignKey(\n+        Referrer, models.CASCADE, to_field='unique_field', related_name='+'\n+    )\ndiff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex ed47d0667dd8..fe77d7d4c804 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -7,7 +7,8 @@\n \n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n-    M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n+    M2MTo, MRNull, Origin, Parent, R, RChild, Referrer, S, T, User, create_a,\n+    get_default_r,\n )\n \n \n@@ -437,6 +438,39 @@ def test_proxied_model_duplicate_queries(self):\n         with self.assertNumQueries(2):\n             avatar.delete()\n \n+    def test_only_referenced_fields_selected(self):\n+        \"\"\"\n+        Only referenced fields are selected during cascade deletion SELECT\n+        unless deletion signals are connected.\n+        \"\"\"\n+        origin = Origin.objects.create()\n+        expected_sql = str(\n+            Referrer.objects.only(\n+                # Both fields are referenced by SecondReferrer.\n+                'id', 'unique_field',\n+            ).filter(origin__in=[origin]).query\n+        )\n+        with self.assertNumQueries(2) as ctx:\n+            origin.delete()\n+        self.assertEqual(ctx.captured_queries[0]['sql'], expected_sql)\n+\n+        def receiver(instance, **kwargs):\n+            pass\n+\n+        # All fields are selected if deletion signals are connected.\n+        for signal_name in ('pre_delete', 'post_delete'):\n+            with self.subTest(signal=signal_name):\n+                origin = Origin.objects.create()\n+                signal = getattr(models.signals, signal_name)\n+                signal.connect(receiver, sender=Referrer)\n+                with self.assertNumQueries(2) as ctx:\n+                    origin.delete()\n+                self.assertIn(\n+                    connection.ops.quote_name('large_field'),\n+                    ctx.captured_queries[0]['sql'],\n+                )\n+                signal.disconnect(receiver, sender=Referrer)\n+\n \n class FastDeleteTests(TestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/11087"}