{"instance_id": "pylint-dev__pylint-8898", "score": "I", "diff": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..51d83f597 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -111,10 +111,77 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n+def _smart_split_regex_csv(value: str) -> list[str]:\n+    \"\"\"Split a comma-separated string while respecting regex syntax.\n+    \n+    This function splits on commas, but only those that are not inside:\n+    - Parentheses ()\n+    - Square brackets []\n+    - Curly braces {}\n+    \n+    This allows regex patterns with commas to be preserved.\n+    \"\"\"\n+    patterns = []\n+    current_pattern = []\n+    depth = {\n+        '(': 0,\n+        '[': 0,\n+        '{': 0\n+    }\n+    escape_next = False\n+    in_char_class = False  # Track if we're inside []\n+    \n+    for char in value:\n+        if escape_next:\n+            current_pattern.append(char)\n+            escape_next = False\n+            continue\n+            \n+        if char == '\\\\':\n+            escape_next = True\n+            current_pattern.append(char)\n+            continue\n+        \n+        # Track character classes separately (they have special rules)\n+        if char == '[' and not in_char_class:\n+            in_char_class = True\n+            depth['['] += 1\n+        elif char == ']' and in_char_class:\n+            in_char_class = False\n+            depth['['] -= 1\n+        # Only track other brackets if not in character class\n+        elif not in_char_class:\n+            if char == '(':\n+                depth['('] += 1\n+            elif char == ')':\n+                depth['('] -= 1\n+            elif char == '{':\n+                depth['{'] += 1\n+            elif char == '}':\n+                depth['{'] -= 1\n+        \n+        # Check if we're at a top-level comma\n+        if char == ',' and all(d == 0 for d in depth.values()) and not in_char_class:\n+            # Found a separator comma\n+            pattern = ''.join(current_pattern).strip()\n+            if pattern:  # Don't add empty patterns\n+                patterns.append(pattern)\n+            current_pattern = []\n+        else:\n+            current_pattern.append(char)\n+    \n+    # Don't forget the last pattern\n+    pattern = ''.join(current_pattern).strip()\n+    if pattern:\n+        patterns.append(pattern)\n+    \n+    return patterns\n+\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _smart_split_regex_csv(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -122,7 +189,7 @@ def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _smart_split_regex_csv(value):\n         patterns.append(\n             re.compile(\n                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\ndiff --git a/test_bad_names_rgxs.py b/test_bad_names_rgxs.py\nnew file mode 100644\nindex 000000000..f5481e467\n--- /dev/null\n+++ b/test_bad_names_rgxs.py\n@@ -0,0 +1,77 @@\n+#!/usr/bin/env python3\n+\"\"\"Test script to verify the fix for bad-names-rgxs with commas in regex\"\"\"\n+\n+import tempfile\n+import os\n+import subprocess\n+\n+# Create a test Python file\n+test_code = \"\"\"\n+# Test file for pylint\n+foo = 1\n+fooo = 2\n+foooo = 3\n+bar = 4\n+\"\"\"\n+\n+# Create a config file with regex containing commas\n+pyproject_toml = \"\"\"\n+[tool.pylint.basic]\n+# capture group ensures that the part after the comma is valid\n+bad-name-rgxs = \"(foo{1,3})\"\n+\"\"\"\n+\n+# Create temporary directory and files\n+with tempfile.TemporaryDirectory() as tmpdir:\n+    # Write test Python file\n+    test_file = os.path.join(tmpdir, \"test.py\")\n+    with open(test_file, \"w\") as f:\n+        f.write(test_code)\n+    \n+    # Write config file\n+    config_file = os.path.join(tmpdir, \"pyproject.toml\")\n+    with open(config_file, \"w\") as f:\n+        f.write(pyproject_toml)\n+    \n+    # Run pylint\n+    print(\"Running pylint with bad-name-rgxs containing commas...\")\n+    print(f\"Config: bad-name-rgxs = \\\"(foo{{1,3}})\\\"\")\n+    print()\n+    \n+    try:\n+        result = subprocess.run(\n+            [\"python\", \"-m\", \"pylint\", test_file, \"--rcfile\", config_file],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        print(\"Exit code:\", result.returncode)\n+        print(\"\\nSTDOUT:\")\n+        print(result.stdout)\n+        if result.stderr:\n+            print(\"\\nSTDERR:\")\n+            print(result.stderr)\n+            \n+    except Exception as e:\n+        print(f\"Error running pylint: {e}\")\n+\n+# Test the transformation directly\n+print(\"\\n\" + \"=\"*60 + \"\\n\")\n+print(\"Testing the transformation directly:\")\n+from pylint.config.argument import _regexp_csv_transfomer\n+\n+test_patterns = [\n+    \"(foo{1,3})\",\n+    \"foo{1,3},bar{2,}\",\n+    \"[a,b,c]+,test\",\n+    \"(?:foo|bar){1,3}\"\n+]\n+\n+for pattern in test_patterns:\n+    print(f\"\\nInput: {pattern}\")\n+    try:\n+        result = _regexp_csv_transfomer(pattern)\n+        print(f\"Success! Compiled patterns: {[p.pattern for p in result]}\")\n+    except Exception as e:\n+        print(f\"Error: {type(e).__name__}: {e}\")\ndiff --git a/test_regex_comma_issue.py b/test_regex_comma_issue.py\nnew file mode 100644\nindex 000000000..d7c2bca42\n--- /dev/null\n+++ b/test_regex_comma_issue.py\n@@ -0,0 +1,46 @@\n+#!/usr/bin/env python3\n+\"\"\"Test script to reproduce the issue with regex containing commas\"\"\"\n+\n+import re\n+from pylint.utils.utils import _splitstrip\n+from pylint.config.argument import _regexp_csv_transfomer\n+\n+# Test the issue\n+test_regex = \"(foo{1,3})\"\n+print(f\"Original regex: {test_regex}\")\n+print(f\"Split result: {_splitstrip(test_regex)}\")\n+\n+# This should fail\n+try:\n+    result = _regexp_csv_transfomer(test_regex)\n+    print(f\"Transformed: {result}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+\n+# Test with other regex patterns that have commas\n+test_cases = [\n+    \"foo{1,3}\",\n+    \"(foo{1,3})\",\n+    \"bar{2,}\",\n+    \"baz{,5}\",\n+    \"test{3,4}|other{1,2}\",\n+    \"[a,b,c]+\",\n+    \"(?:foo|bar){1,3}\"\n+]\n+\n+print(\"\\nTesting various regex patterns with commas:\")\n+for pattern in test_cases:\n+    print(f\"\\nPattern: {pattern}\")\n+    print(f\"Split result: {_splitstrip(pattern)}\")\n+    try:\n+        re.compile(pattern)\n+        print(\"Valid regex: YES\")\n+    except:\n+        print(\"Valid regex: NO\")\n+    \n+    # Test if _regexp_csv_transfomer can handle it\n+    try:\n+        result = _regexp_csv_transfomer(pattern)\n+        print(f\"Transform successful: {result}\")\n+    except Exception as e:\n+        print(f\"Transform failed: {type(e).__name__}: {e}\")\ndiff --git a/test_regex_csv_parser.py b/test_regex_csv_parser.py\nnew file mode 100644\nindex 000000000..0aa515e64\n--- /dev/null\n+++ b/test_regex_csv_parser.py\n@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+\"\"\"Test implementation for a regex-aware CSV parser\"\"\"\n+\n+import re\n+from typing import List, Sequence\n+\n+\n+def _smart_split_regex_csv(value: str) -> List[str]:\n+    \"\"\"Split a comma-separated string while respecting regex syntax.\n+    \n+    This function splits on commas, but only those that are not inside:\n+    - Parentheses ()\n+    - Square brackets []\n+    - Curly braces {}\n+    \n+    This allows regex patterns with commas to be preserved.\n+    \"\"\"\n+    patterns = []\n+    current_pattern = []\n+    depth = {\n+        '(': 0,\n+        '[': 0,\n+        '{': 0\n+    }\n+    escape_next = False\n+    in_char_class = False  # Track if we're inside []\n+    \n+    for i, char in enumerate(value):\n+        if escape_next:\n+            current_pattern.append(char)\n+            escape_next = False\n+            continue\n+            \n+        if char == '\\\\':\n+            escape_next = True\n+            current_pattern.append(char)\n+            continue\n+        \n+        # Track character classes separately (they have special rules)\n+        if char == '[' and not in_char_class:\n+            in_char_class = True\n+            depth['['] += 1\n+        elif char == ']' and in_char_class:\n+            in_char_class = False\n+            depth['['] -= 1\n+        # Only track other brackets if not in character class\n+        elif not in_char_class:\n+            if char == '(':\n+                depth['('] += 1\n+            elif char == ')':\n+                depth['('] -= 1\n+            elif char == '{':\n+                depth['{'] += 1\n+            elif char == '}':\n+                depth['{'] -= 1\n+        \n+        # Check if we're at a top-level comma\n+        if char == ',' and all(d == 0 for d in depth.values()) and not in_char_class:\n+            # Found a separator comma\n+            pattern = ''.join(current_pattern).strip()\n+            if pattern:  # Don't add empty patterns\n+                patterns.append(pattern)\n+            current_pattern = []\n+        else:\n+            current_pattern.append(char)\n+    \n+    # Don't forget the last pattern\n+    pattern = ''.join(current_pattern).strip()\n+    if pattern:\n+        patterns.append(pattern)\n+    \n+    return patterns\n+\n+\n+# Test cases\n+test_cases = [\n+    # Single patterns with commas\n+    (\"foo{1,3}\", [\"foo{1,3}\"]),\n+    (\"(foo{1,3})\", [\"(foo{1,3})\"]),\n+    (\"bar{2,}\", [\"bar{2,}\"]),\n+    (\"baz{,5}\", [\"baz{,5}\"]),\n+    (\"[a,b,c]+\", [\"[a,b,c]+\"]),\n+    (\"(?:foo|bar){1,3}\", [\"(?:foo|bar){1,3}\"]),\n+    \n+    # Multiple patterns\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo{1,3},bar{2,}\", [\"foo{1,3}\", \"bar{2,}\"]),\n+    (\"(foo{1,3}),bar\", [\"(foo{1,3})\", \"bar\"]),\n+    (\"[a,b],foo{1,2}\", [\"[a,b]\", \"foo{1,2}\"]),\n+    \n+    # Edge cases\n+    (\"\", []),\n+    (\"   \", []),\n+    (\"foo,\", [\"foo\"]),\n+    (\",foo\", [\"foo\"]),\n+    (\"foo,,bar\", [\"foo\", \"bar\"]),\n+    \n+    # Complex patterns\n+    (\"test{3,4}|other{1,2},simple\", [\"test{3,4}|other{1,2}\", \"simple\"]),\n+    (\"(?:a{1,3}|b{2,}),c{,5}\", [\"(?:a{1,3}|b{2,})\", \"c{,5}\"]),\n+    \n+    # Escaped characters  \n+    (r\"foo\\,,bar\", [r\"foo\\,\", \"bar\"]),\n+    # Note: foo\\{1,3\\} has literal braces, not regex quantifier, so comma would split\n+]\n+\n+print(\"Testing smart regex CSV parser:\")\n+for input_str, expected in test_cases:\n+    result = _smart_split_regex_csv(input_str)\n+    status = \"\u2713\" if result == expected else \"\u2717\"\n+    print(f\"{status} Input: {repr(input_str)}\")\n+    print(f\"  Expected: {expected}\")\n+    print(f\"  Got:      {result}\")\n+    if result != expected:\n+        print(\"  MISMATCH!\")\n+    \n+    # Also verify each pattern is valid regex\n+    for pattern in result:\n+        try:\n+            re.compile(pattern)\n+        except re.error as e:\n+            print(f\"  WARNING: Invalid regex pattern '{pattern}': {e}\")\n+    print()\n", "gold_standard_diff": "From 8be7a33ef06df64bd2c485efdca62ed527316348 Mon Sep 17 00:00:00 2001\nFrom: lihu <lihu.ben-ezri-ravin@portalinstruments.com>\nDate: Thu, 28 Jul 2022 16:06:58 -0400\nSubject: [PATCH 01/11] Add protection for #7229\n\nDo not split on commas if they are between braces, since that indicates\na quantifier. Also added a protection for slow implementations since\nexisting workarounds may result in long strings of chained regular\nexpressions.\n---\n tests/config/test_config.py | 40 +++++++++++++++++++++++++++++++++++++\n 1 file changed, 40 insertions(+)\n\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 47891aee25..14a0f32cdc 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -5,6 +5,8 @@\n from __future__ import annotations\n \n import os\n+import re\n+import timeit\n from pathlib import Path\n \n import pytest\n@@ -111,6 +113,44 @@ def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     assert \"the-newest has an invalid format, should be a version string.\" in output.err\n \n \n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+]\n+\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_in_quantifier(in_string, expected) -> None:\n+    \"\"\"Check that we correctly parse a comma-separated regex when there are one\n+    or more commas within quantifier expressions.\n+    \"\"\"\n+\n+    def _template_run(in_string):\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        return r.linter.config.bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+\n+    # Catch trivially nonlinear performance\n+    small_input_time = timeit.timeit(\n+        \"_template_run(in_string*100)\",\n+        globals=locals(),\n+        number=10,\n+    )\n+    large_input_time = timeit.timeit(\n+        \"_template_run(in_string*1000)\",\n+        globals=locals(),\n+        number=10,\n+    )\n+    fudge_factor = 3\n+    assert large_input_time < small_input_time * 10 * fudge_factor\n+\n+\n def test_short_verbose(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly handle the -v flag.\"\"\"\n     Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n\nFrom 40889e3b4086f455744e6ab993df12490b2179b3 Mon Sep 17 00:00:00 2001\nFrom: lihu <lihu.ben-ezri-ravin@portalinstruments.com>\nDate: Thu, 28 Jul 2022 17:59:45 -0400\nSubject: [PATCH 02/11] Do not split regex lists in quantifier ranges\n\nFixes #7229\n---\n pylint/config/argument.py |  2 +-\n pylint/utils/__init__.py  |  2 ++\n pylint/utils/utils.py     | 26 +++++++++++++++++++++++++-\n 3 files changed, 28 insertions(+), 2 deletions(-)\n\ndiff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 3c29515176..8c6b8a2cb3 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -102,7 +102,7 @@ def _py_version_transformer(value: str) -> tuple[int, ...]:\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in pylint_utils._check_regexp_csv(value):\n         patterns.append(re.compile(pattern))\n     return patterns\n \ndiff --git a/pylint/utils/__init__.py b/pylint/utils/__init__.py\nindex bc5011db95..9265d0d13e 100644\n--- a/pylint/utils/__init__.py\n+++ b/pylint/utils/__init__.py\n@@ -14,6 +14,7 @@\n     HAS_ISORT_5,\n     IsortDriver,\n     _check_csv,\n+    _check_regexp_csv,\n     _format_option_value,\n     _splitstrip,\n     _unquote,\n@@ -34,6 +35,7 @@\n     \"HAS_ISORT_5\",\n     \"IsortDriver\",\n     \"_check_csv\",\n+    \"_check_regexp_csv\",\n     \"_format_option_value\",\n     \"_splitstrip\",\n     \"_unquote\",\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex 6a4277642b..e33ba81253 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -21,7 +21,8 @@\n import textwrap\n import tokenize\n import warnings\n-from collections.abc import Sequence\n+from collections import deque\n+from collections.abc import Iterable, Sequence\n from io import BufferedReader, BytesIO\n from typing import (\n     TYPE_CHECKING,\n@@ -328,6 +329,29 @@ def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n     return _splitstrip(value)\n \n \n+def _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n+    if isinstance(value, (list, tuple)):\n+        yield from value\n+    else:\n+        # None is a sentinel value here\n+        regexps: deque[deque[str] | None] = deque([None])\n+        open_braces = False\n+        for char in value:\n+            if char == \"{\":\n+                open_braces = True\n+            elif char == \"}\" and open_braces:\n+                open_braces = False\n+\n+            if char == \",\" and not open_braces:\n+                regexps.append(None)\n+            elif regexps[-1] is None:\n+                regexps.pop()\n+                regexps.append(deque([char]))\n+            else:\n+                regexps[-1].append(char)\n+        yield from (\"\".join(regexp).strip() for regexp in regexps if regexp is not None)\n+\n+\n def _comment(string: str) -> str:\n     \"\"\"Return string as a comment.\"\"\"\n     lines = [line.strip() for line in string.splitlines()]\n\nFrom 3347cf5ae8dcf939a19b52771dedff0b36b50738 Mon Sep 17 00:00:00 2001\nFrom: lihu <lihu.ben-ezri-ravin@portalinstruments.com>\nDate: Thu, 28 Jul 2022 18:12:49 -0400\nSubject: [PATCH 03/11] Add news fragment\n\n---\n doc/whatsnew/fragments/7229.bugfix | 5 +++++\n 1 file changed, 5 insertions(+)\n create mode 100644 doc/whatsnew/fragments/7229.bugfix\n\ndiff --git a/doc/whatsnew/fragments/7229.bugfix b/doc/whatsnew/fragments/7229.bugfix\nnew file mode 100644\nindex 0000000000..33c7b578ed\n--- /dev/null\n+++ b/doc/whatsnew/fragments/7229.bugfix\n@@ -0,0 +1,5 @@\n+When parsing comma-separated lists of regular expressions in the config, ignore\n+commas that are inside braces since those indicate quantiers, not dilineation\n+between expressions.\n+\n+Closes #7229\n\nFrom b48c339bfba0415dec70d757e424f3f338becf61 Mon Sep 17 00:00:00 2001\nFrom: Lihu Ben-Ezri-Ravin <lihu.ben-ezri-ravin@portalinstruments.com>\nDate: Fri, 29 Jul 2022 12:53:52 -0400\nSubject: [PATCH 04/11] Remove performance test\n\nOverkill, slows down unit tests\n\nCo-authored-by: Pierre Sassoulas <pierre.sassoulas@gmail.com>\n---\n tests/config/test_config.py | 13 -------------\n 1 file changed, 13 deletions(-)\n\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 14a0f32cdc..5296d67810 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -136,19 +136,6 @@ def _template_run(in_string):\n \n     assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n \n-    # Catch trivially nonlinear performance\n-    small_input_time = timeit.timeit(\n-        \"_template_run(in_string*100)\",\n-        globals=locals(),\n-        number=10,\n-    )\n-    large_input_time = timeit.timeit(\n-        \"_template_run(in_string*1000)\",\n-        globals=locals(),\n-        number=10,\n-    )\n-    fudge_factor = 3\n-    assert large_input_time < small_input_time * 10 * fudge_factor\n \n \n def test_short_verbose(capsys: CaptureFixture) -> None:\n\nFrom cdc55b8d277c389154840ff6e27fccdd1d16b1e0 Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sat, 29 Jul 2023 17:52:44 -0400\nSubject: [PATCH 05/11] Apply review comments\n\n---\n doc/whatsnew/fragments/7229.bugfix | 2 +-\n tests/config/test_config.py        | 2 --\n 2 files changed, 1 insertion(+), 3 deletions(-)\n\ndiff --git a/doc/whatsnew/fragments/7229.bugfix b/doc/whatsnew/fragments/7229.bugfix\nindex 33c7b578ed..c39e130192 100644\n--- a/doc/whatsnew/fragments/7229.bugfix\n+++ b/doc/whatsnew/fragments/7229.bugfix\n@@ -1,5 +1,5 @@\n When parsing comma-separated lists of regular expressions in the config, ignore\n-commas that are inside braces since those indicate quantiers, not dilineation\n+commas that are inside braces since those indicate quantifiers, not delineation\n between expressions.\n \n Closes #7229\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 5296d67810..63ac4388d0 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -6,7 +6,6 @@\n \n import os\n import re\n-import timeit\n from pathlib import Path\n \n import pytest\n@@ -137,7 +136,6 @@ def _template_run(in_string):\n     assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n \n \n-\n def test_short_verbose(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly handle the -v flag.\"\"\"\n     Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n\nFrom 42d4e66a3f7ba8c3e23bd5d3efb9c827b7eb7f3b Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sat, 29 Jul 2023 19:27:30 -0400\nSubject: [PATCH 06/11] (fixup) Add python 3.8 compatibility\n\n---\n tests/config/test_config.py | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 8e7393efc4..7aa779a8f8 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -8,7 +8,7 @@\n import re\n from pathlib import Path\n from tempfile import TemporaryDirectory\n-from typing import Any, cast\n+from typing import Any\n \n import pytest\n from pytest import CaptureFixture\n@@ -136,7 +136,8 @@ def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n             [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n             exit=False,\n         )\n-        return cast(list[re.Pattern[Any]], r.linter.config.bad_names_rgxs)\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n \n     assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n \n\nFrom b4798ae38bf789dec1d265b4b90d80c447e3a549 Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sat, 29 Jul 2023 19:35:54 -0400\nSubject: [PATCH 07/11] Adjust test to be more invalid\n\n---\n tests/config/test_config.py | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 7aa779a8f8..872b568a61 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -164,12 +164,12 @@ def test_csv_regex_error(capsys: CaptureFixture) -> None:\n     \"\"\"\n     with pytest.raises(SystemExit):\n         Run(\n-            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,3})\"],\n+            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,}, foo{1,3}})\"],\n             exit=False,\n         )\n     output = capsys.readouterr()\n     assert (\n-        r\"Error in provided regular expression: (foo{1 beginning at index 0: missing ), unterminated subpattern\"\n+        r\"Error in provided regular expression: (foo{1,} beginning at index 0: missing ), unterminated subpattern\"\n         in output.err\n     )\n \n\nFrom fdd914adac3ef78255ded47362b2d7bbf1eafd4b Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sat, 29 Jul 2023 19:40:15 -0400\nSubject: [PATCH 08/11] Adjust news/docs from #8813 to use bad-names-rgx\n\n---\n doc/data/messages/i/invalid-name/details.rst | 2 +-\n doc/whatsnew/fragments/2018.user_action      | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/doc/data/messages/i/invalid-name/details.rst b/doc/data/messages/i/invalid-name/details.rst\nindex 14cfe6e592..3323bddf44 100644\n--- a/doc/data/messages/i/invalid-name/details.rst\n+++ b/doc/data/messages/i/invalid-name/details.rst\n@@ -99,7 +99,7 @@ Before pylint 3.0, most predefined patterns also enforced a minimum length\n of three characters. If this behavior is desired in versions 3.0 and following,\n it can be had by providing custom regular expressions as described next. (Or,\n if the ``disallowed-name`` check is sufficient instead of ``invalid-name``,\n-providing the single option ``bad-names-rgxs=\"^..?$\"`` will suffice to fail 1-2\n+providing the single option ``bad-names-rgx=\"^..?$\"`` will suffice to fail 1-2\n character names.\n \n Custom regular expressions\ndiff --git a/doc/whatsnew/fragments/2018.user_action b/doc/whatsnew/fragments/2018.user_action\nindex 5e33c8388c..420fe5bccf 100644\n--- a/doc/whatsnew/fragments/2018.user_action\n+++ b/doc/whatsnew/fragments/2018.user_action\n@@ -5,7 +5,7 @@ and name length, and users regularly reported this to be surprising.)\n If checking for a minimum length is still desired, it can be regained in two ways:\n \n - If you are content with a ``disallowed-name`` message (instead of ``invalid-name``),\n-then simply add the option ``bad-names-rgxs=\"^..?$\"``, which will fail 1-2\n+then simply add the option ``bad-names-rgx=\"^..?$\"``, which will fail 1-2\n character-long names. (Ensure you enable ``disallowed-name``.)\n \n - If you would prefer an ``invalid-name`` message to be emitted, or would prefer\n\nFrom a62a6fc3ba0cd9afc426f7684a16214d5e8251b7 Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sun, 30 Jul 2023 10:17:18 -0400\nSubject: [PATCH 09/11] Add docstring\n\n---\n pylint/utils/utils.py | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex 4f9e054f8f..9b27e503e4 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -255,6 +255,8 @@ def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n \n \n def _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n+    r\"\"\"Split a comma-separated list of regexes, taking care to avoid splitting\n+    a regex employing a comma as quantifier, as in `\\d{1,2}`.\"\"\"\n     if isinstance(value, (list, tuple)):\n         yield from value\n     else:\n\nFrom 73599e4c755e08d40a1440607b54d0df601175ae Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sun, 30 Jul 2023 10:22:46 -0400\nSubject: [PATCH 10/11] 'regexes' -> 'regexps'\n\n---\n pylint/utils/utils.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex 9b27e503e4..8f16d2f1f4 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -255,7 +255,7 @@ def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n \n \n def _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n-    r\"\"\"Split a comma-separated list of regexes, taking care to avoid splitting\n+    r\"\"\"Split a comma-separated list of regexps, taking care to avoid splitting\n     a regex employing a comma as quantifier, as in `\\d{1,2}`.\"\"\"\n     if isinstance(value, (list, tuple)):\n         yield from value\n\nFrom 4de6f9d7ffeb69ec88e9a0f352ccaf3911f600dc Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Sun, 30 Jul 2023 10:29:20 -0400\nSubject: [PATCH 11/11] Revert \"Adjust news/docs from #8813 to use\n bad-names-rgx\"\n\nThis reverts commit fdd914adac3ef78255ded47362b2d7bbf1eafd4b.\n---\n doc/data/messages/i/invalid-name/details.rst | 2 +-\n doc/whatsnew/fragments/2018.user_action      | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/doc/data/messages/i/invalid-name/details.rst b/doc/data/messages/i/invalid-name/details.rst\nindex 3323bddf44..14cfe6e592 100644\n--- a/doc/data/messages/i/invalid-name/details.rst\n+++ b/doc/data/messages/i/invalid-name/details.rst\n@@ -99,7 +99,7 @@ Before pylint 3.0, most predefined patterns also enforced a minimum length\n of three characters. If this behavior is desired in versions 3.0 and following,\n it can be had by providing custom regular expressions as described next. (Or,\n if the ``disallowed-name`` check is sufficient instead of ``invalid-name``,\n-providing the single option ``bad-names-rgx=\"^..?$\"`` will suffice to fail 1-2\n+providing the single option ``bad-names-rgxs=\"^..?$\"`` will suffice to fail 1-2\n character names.\n \n Custom regular expressions\ndiff --git a/doc/whatsnew/fragments/2018.user_action b/doc/whatsnew/fragments/2018.user_action\nindex 420fe5bccf..5e33c8388c 100644\n--- a/doc/whatsnew/fragments/2018.user_action\n+++ b/doc/whatsnew/fragments/2018.user_action\n@@ -5,7 +5,7 @@ and name length, and users regularly reported this to be surprising.)\n If checking for a minimum length is still desired, it can be regained in two ways:\n \n - If you are content with a ``disallowed-name`` message (instead of ``invalid-name``),\n-then simply add the option ``bad-names-rgx=\"^..?$\"``, which will fail 1-2\n+then simply add the option ``bad-names-rgxs=\"^..?$\"``, which will fail 1-2\n character-long names. (Ensure you enable ``disallowed-name``.)\n \n - If you would prefer an ``invalid-name`` message to be emitted, or would prefer\n", "gold_standard_pr_link": "https://github.com/pylint-dev/pylint/pull/8898"}