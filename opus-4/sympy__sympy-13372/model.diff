diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..52b4cb9676
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,25 @@
+from sympy import symbols, Mul, Max
+
+x, y = symbols('x y')
+
+# Let's debug what happens with Max(0, y)
+max_expr = Max(0, y)
+print("Max expression:", max_expr)
+print("Max._eval_evalf method exists?", hasattr(Max, '_eval_evalf'))
+
+# Let's try to evaluate Max directly
+try:
+    result = max_expr._eval_evalf(15)
+    print("Max._eval_evalf result:", result)
+    print("Result type:", type(result))
+    if result:
+        print("Result as_real_imag:", result.as_real_imag())
+        re, im = result.as_real_imag()
+        print("re:", re, "type:", type(re))
+        print("im:", im, "type:", type(im))
+        print("re == 0:", re == 0)
+        print("re.is_number:", re.is_number)
+        print("im == 0:", im == 0)
+        print("im.is_number:", im.is_number)
+except Exception as e:
+    print("Error evaluating Max directly:", type(e).__name__, "-", str(e))
diff --git a/debug_order.py b/debug_order.py
new file mode 100644
index 0000000000..7cb1d306a3
--- /dev/null
+++ b/debug_order.py
@@ -0,0 +1,17 @@
+from sympy import symbols, Mul, Max
+from sympy.core.evalf import pure_complex
+
+x, y = symbols('x y')
+
+# Let's see what happens in evalf_mul
+print("Testing Mul(x, Max(0, y), evaluate=False)")
+mul1 = Mul(x, Max(0, y), evaluate=False)
+print("args:", mul1.args)
+print("pure_complex(x):", pure_complex(x))
+print("pure_complex(Max(0, y)):", pure_complex(Max(0, y)))
+
+print("\nTesting Mul(Max(0, y), x, evaluate=False)")
+mul2 = Mul(Max(0, y), x, evaluate=False)
+print("args:", mul2.args)
+print("pure_complex(Max(0, y)):", pure_complex(Max(0, y)))
+print("pure_complex(x):", pure_complex(x))
diff --git a/debug_symbol.py b/debug_symbol.py
new file mode 100644
index 0000000000..3befde2b5d
--- /dev/null
+++ b/debug_symbol.py
@@ -0,0 +1,24 @@
+from sympy import symbols, Mul, Max
+from sympy.core.evalf import evalf
+
+x, y = symbols('x y')
+
+# Let's see what happens when we try to evalf x
+print("evalf(x, 15, {}):")
+try:
+    result = evalf(x, 15, {})
+    print("Result:", result)
+except Exception as e:
+    print("Error:", type(e).__name__, "-", str(e))
+    import traceback
+    traceback.print_exc()
+
+# And Max(0, y)
+print("\nevalf(Max(0, y), 15, {}):")
+try:
+    result = evalf(Max(0, y), 15, {})
+    print("Result:", result)
+except Exception as e:
+    print("Error:", type(e).__name__, "-", str(e))
+    import traceback
+    traceback.print_exc()
diff --git a/sympy/core/evalf.py b/sympy/core/evalf.py
index 72a5fbae52..f34908710a 100644
--- a/sympy/core/evalf.py
+++ b/sympy/core/evalf.py
@@ -1301,12 +1301,16 @@ def evalf(x, prec, options):
             elif re.is_number:
                 re = re._to_mpmath(prec, allow_ints=False)._mpf_
                 reprec = prec
+            else:
+                raise NotImplementedError
             if im == 0:
                 im = None
                 imprec = None
             elif im.is_number:
                 im = im._to_mpmath(prec, allow_ints=False)._mpf_
                 imprec = prec
+            else:
+                raise NotImplementedError
             r = re, im, reprec, imprec
         except AttributeError:
             raise NotImplementedError
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..08ee2c1b06
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,65 @@
+from sympy import symbols, sin, cos, exp, log, sqrt, pi, E, I, Mul, Add, Max, Min
+from sympy import Number, Float, Rational
+
+# Test various expressions with evalf
+x, y, z = symbols('x y z')
+
+test_cases = [
+    # Basic numeric expressions
+    (pi, "pi"),
+    (E, "E"),
+    (sqrt(2), "sqrt(2)"),
+    (Rational(1, 3), "1/3"),
+    
+    # Complex numbers
+    (I, "I"),
+    (1 + 2*I, "1 + 2*I"),
+    
+    # Expressions with symbols
+    (x + 1, "x + 1"),
+    (x * y, "x * y"),
+    
+    # Trigonometric functions
+    (sin(1), "sin(1)"),
+    (cos(pi/4), "cos(pi/4)"),
+    
+    # Exponential and logarithmic
+    (exp(1), "exp(1)"),
+    (log(2), "log(2)"),
+    
+    # The problematic cases
+    (Mul(x, Max(0, y), evaluate=False), "Mul(x, Max(0, y))"),
+    (Mul(Max(0, y), x, evaluate=False), "Mul(Max(0, y), x)"),
+    
+    # Other Max/Min cases
+    (Max(1, 2), "Max(1, 2)"),
+    (Min(1, 2), "Min(1, 2)"),
+    (Max(x, y), "Max(x, y)"),
+    (Min(x, y), "Min(x, y)"),
+    
+    # Mixed expressions
+    (x + Max(0, y), "x + Max(0, y)"),
+    (sin(x) * Max(0, y), "sin(x) * Max(0, y)"),
+]
+
+print("Testing evalf on various expressions:")
+print("-" * 60)
+
+for expr, desc in test_cases:
+    try:
+        result = expr.evalf()
+        print(f"{desc:<30} -> {str(result):<30}")
+    except Exception as e:
+        print(f"{desc:<30} -> ERROR: {type(e).__name__}: {str(e)}")
+
+print("-" * 60)
+print("All tests completed!")
+
+# Test with substitution
+print("\nTesting with substitution:")
+expr = x * Max(0, y)
+try:
+    result = expr.evalf(subs={x: 2, y: 3})
+    print(f"x * Max(0, y) with x=2, y=3 -> {result}")
+except Exception as e:
+    print(f"x * Max(0, y) with x=2, y=3 -> ERROR: {type(e).__name__}: {str(e)}")
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..47547fb961
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,17 @@
+from sympy import symbols, Mul, Max
+
+x, y = symbols('x y')
+
+print("Test 1: Mul(x, Max(0, y), evaluate=False).evalf()")
+try:
+    result1 = Mul(x, Max(0, y), evaluate=False).evalf()
+    print("Result:", result1)
+except Exception as e:
+    print("Error:", type(e).__name__, "-", str(e))
+
+print("\nTest 2: Mul(Max(0, y), x, evaluate=False).evalf()")
+try:
+    result2 = Mul(Max(0, y), x, evaluate=False).evalf()
+    print("Result:", result2)
+except Exception as e:
+    print("Error:", type(e).__name__, "-", str(e))
diff --git a/test_unboundlocalerror_fix.py b/test_unboundlocalerror_fix.py
new file mode 100644
index 0000000000..989398a479
--- /dev/null
+++ b/test_unboundlocalerror_fix.py
@@ -0,0 +1,41 @@
+"""
+Test for the UnboundLocalError fix in evalf
+Issue: https://github.com/sympy/sympy/pull/13059
+"""
+
+from sympy import symbols, Mul, Max, Min, Abs
+
+def test_evalf_unboundlocalerror():
+    """Test that evalf doesn't raise UnboundLocalError with Max/Min/Abs in Mul"""
+    x, y = symbols('x y')
+    
+    # These used to raise UnboundLocalError depending on argument order
+    # Now they should all return the expression unchanged
+    
+    # Max cases
+    assert Mul(x, Max(0, y), evaluate=False).evalf() == x*Max(0, y)
+    assert Mul(Max(0, y), x, evaluate=False).evalf() == x*Max(0, y)
+    
+    # Min cases  
+    assert Mul(x, Min(0, y), evaluate=False).evalf() == x*Min(0, y)
+    assert Mul(Min(0, y), x, evaluate=False).evalf() == x*Min(0, y)
+    
+    # Abs cases
+    assert Mul(x, Abs(y), evaluate=False).evalf() == x*Abs(y)
+    assert Mul(Abs(y), x, evaluate=False).evalf() == x*Abs(y)
+    
+    # Multiple arguments - just check they don't raise errors
+    result1 = Mul(x, Max(0, y), Min(1, y), evaluate=False).evalf()
+    result2 = Mul(Max(0, y), x, Min(1, y), evaluate=False).evalf()
+    # Both should contain x, Max, and Min
+    assert x in result1.free_symbols
+    assert x in result2.free_symbols
+    
+    # With numeric substitution
+    assert Mul(x, Max(0, y), evaluate=False).evalf(subs={x: 2, y: 3}) == 6.0
+    assert Mul(Max(0, y), x, evaluate=False).evalf(subs={x: 2, y: -3}) == 0.0
+    
+    print("All tests passed!")
+
+if __name__ == "__main__":
+    test_evalf_unboundlocalerror()
