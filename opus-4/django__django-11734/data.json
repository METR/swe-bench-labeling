{"instance_id": "django__django-11734", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea..8737f04103 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -23,7 +23,7 @@ from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections\n from django.db.models.aggregates import Count\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.expressions import (\n-    BaseExpression, Col, F, OuterRef, Ref, SimpleCol,\n+    BaseExpression, Col, F, OuterRef, Ref, ResolvedOuterRef, SimpleCol,\n )\n from django.db.models.fields import Field\n from django.db.models.fields.related_lookups import MultiColSource\n@@ -1702,7 +1702,7 @@ class Query(BaseExpression):\n         handle.\n         \"\"\"\n         filter_lhs, filter_rhs = filter_expr\n-        if isinstance(filter_rhs, F):\n+        if isinstance(filter_rhs, F) and not isinstance(filter_rhs, (OuterRef, ResolvedOuterRef)):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\ndiff --git a/test_outerref_issue.py b/test_outerref_issue.py\nnew file mode 100644\nindex 0000000000..d55a5fd732\n--- /dev/null\n+++ b/test_outerref_issue.py\n@@ -0,0 +1,71 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Add tests to the path\n+sys.path.insert(0, '/testbed')\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'tests.queries',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='test',\n+)\n+django.setup()\n+\n+# Import the required models and functions\n+from django.db.models import Exists, OuterRef, Q\n+from tests.queries.models import Number, Item, Tag, NamedCategory, Author, Note, ExtraInfo\n+from django.test import TestCase\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    for model in [NamedCategory, Tag, Note, ExtraInfo, Author, Item, Number]:\n+        if model._meta.db_table not in connection.introspection.table_names():\n+            schema_editor.create_model(model)\n+\n+# Test the issue\n+try:\n+    # This works - filter()\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.filter(tags__category_id=OuterRef('pk'))\n+        )\n+    ).filter(foo=True)\n+    print(\"Filter with OuterRef works:\", qs.query)\n+    \n+    # This crashes - exclude()\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.exclude(tags__category_id=OuterRef('pk'))\n+        )\n+    ).filter(foo=True)\n+    print(\"Exclude with OuterRef:\", qs.query)\n+except Exception as e:\n+    print(\"Exclude error:\", type(e).__name__, str(e))\n+\n+try:\n+    # This also crashes - filter(~Q())\n+    qs = Number.objects.annotate(\n+        foo=Exists(\n+            Item.objects.filter(~Q(tags__category_id=OuterRef('pk')))\n+        )\n+    ).filter(foo=True)\n+    print(\"Filter ~Q with OuterRef:\", qs.query)\n+except Exception as e:\n+    print(\"Filter ~Q error:\", type(e).__name__, str(e))\ndiff --git a/test_outerref_minimal.py b/test_outerref_minimal.py\nnew file mode 100644\nindex 0000000000..8221a16e26\n--- /dev/null\n+++ b/test_outerref_minimal.py\n@@ -0,0 +1,73 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Add tests to the path\n+sys.path.insert(0, '/testbed')\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'tests.queries',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='test',\n+)\n+django.setup()\n+\n+# Import the required models and functions\n+from django.db.models import Exists, OuterRef, Q, Value, IntegerField\n+from tests.queries.models import Number, Item, Tag, NamedCategory, Author, Note, ExtraInfo\n+from django.test import TestCase\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    for model in [NamedCategory, Tag, Note, ExtraInfo, Author, Item, Number]:\n+        if model._meta.db_table not in connection.introspection.table_names():\n+            schema_editor.create_model(model)\n+\n+# Get a simple filter() OuterRef query working\n+print(\"Testing basic OuterRef behavior...\")\n+try:\n+    # filter with OuterRef - should work\n+    qs = Number.objects.annotate(\n+        my_pk=Value(1, output_field=IntegerField())\n+    ).filter(my_pk=OuterRef('pk'))\n+    print(\"Direct OuterRef in filter:\", qs.query)\n+except Exception as e:\n+    print(\"Error:\", type(e).__name__, str(e))\n+\n+# Check if OuterRef is resolved properly when used inside subqueries\n+from django.db.models.sql.query import Query\n+query = Query(Item)\n+filter_expr = ('tags__category_id', OuterRef('pk'))\n+print(\"\\nOriginal OuterRef:\", filter_expr[1], type(filter_expr[1]))\n+print(\"Is OuterRef instance of F?\", isinstance(filter_expr[1], models.F))\n+print(\"Is OuterRef instance of OuterRef?\", isinstance(filter_expr[1], OuterRef))\n+\n+# Check split_exclude behavior\n+query._filtered_relations = {}\n+subquery = Query(Item)\n+subquery._filtered_relations = query._filtered_relations\n+subquery.add_filter(filter_expr)\n+\n+print(\"\\nSubquery created by split_exclude logic:\")\n+print(\"Subquery:\", subquery)\n+\n+# Check the where clause\n+print(\"\\nChecking where clause contents...\")\n+for child in subquery.where.children:\n+    print(\"Child:\", child, type(child))\n", "gold_standard_diff": "From 600628f8f0ab077c62223a54a6c8cde6cbbd1ed1 Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <simon.charette@zapier.com>\nDate: Sun, 1 Sep 2019 14:25:28 -0400\nSubject: [PATCH 1/2] Refs #28442 -- Adjusted related lookups handling of\n expression rhs.\n\nExpressions should never be prepared as other Lookup.get_prep_lookup\nimplementations hint at by returning early on the presence of the\nresolve_expression attribute.\n\nThe previous solution was only handling lookups against related fields\npointing at AutoFields and would break for foreign keys to other fields.\n\nIt was also causing bidirectional coupling between model fields and\nexpressions which the method level import of OuterRef was a symptom of.\n---\n django/db/models/fields/__init__.py        | 4 ----\n django/db/models/fields/related_lookups.py | 2 +-\n 2 files changed, 1 insertion(+), 5 deletions(-)\n\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 6e924a4adfc9..9ce46e3f7363 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2332,10 +2332,6 @@ def get_db_prep_value(self, value, connection, prepared=False):\n             value = connection.ops.validate_autopk_value(value)\n         return value\n \n-    def get_prep_value(self, value):\n-        from django.db.models.expressions import OuterRef\n-        return value if isinstance(value, OuterRef) else super().get_prep_value(value)\n-\n     def contribute_to_class(self, cls, name, **kwargs):\n         assert not cls._meta.auto_field, (\n             \"Model %s can't have more than one auto-generated field.\"\ndiff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex 12f7fb0b9b67..c20e220141ac 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -101,7 +101,7 @@ def as_sql(self, compiler, connection):\n \n class RelatedLookupMixin:\n     def get_prep_lookup(self):\n-        if not isinstance(self.lhs, MultiColSource) and self.rhs_is_direct_value():\n+        if not isinstance(self.lhs, MultiColSource) and not hasattr(self.rhs, 'resolve_expression'):\n             # If we get here, we are dealing with single-column relations.\n             self.rhs = get_normalized_value(self.rhs, self.lhs)[0]\n             # We need to run the related field's get_prep_value(). Consider case\n\nFrom 13a8884a08342817094cc6287c7ae346100a297d Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <simon.charette@zapier.com>\nDate: Sun, 1 Sep 2019 14:35:27 -0400\nSubject: [PATCH 2/2] Fixed #30739 -- Fixed exclusion of multi-valued lookup\n against outer rhs.\n\nOuterRef right hand sides have to be nested, just like F rhs have to,\nduring the subquery pushdown split_exclude performs to ensure they are\nresolved against the outer query aliases.\n---\n django/db/models/sql/query.py |  4 +++-\n tests/queries/tests.py        | 14 +++++++++++---\n 2 files changed, 14 insertions(+), 4 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea55..8e55bd092d8a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1702,7 +1702,9 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n         handle.\n         \"\"\"\n         filter_lhs, filter_rhs = filter_expr\n-        if isinstance(filter_rhs, F):\n+        if isinstance(filter_rhs, OuterRef):\n+            filter_expr = (filter_lhs, OuterRef(filter_rhs))\n+        elif isinstance(filter_rhs, F):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 8339c52a02ef..081fb89d5466 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -6,7 +6,7 @@\n \n from django.core.exceptions import EmptyResultSet, FieldError\n from django.db import DEFAULT_DB_ALIAS, connection\n-from django.db.models import Count, F, Q\n+from django.db.models import Count, Exists, F, OuterRef, Q\n from django.db.models.sql.constants import LOUTER\n from django.db.models.sql.where import NothingNode, WhereNode\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n@@ -2754,10 +2754,10 @@ def setUpTestData(cls):\n         Food.objects.create(name='oranges')\n         Eaten.objects.create(food=f1, meal='dinner')\n         j1 = Job.objects.create(name='Manager')\n-        r1 = Responsibility.objects.create(description='Playing golf')\n+        cls.r1 = Responsibility.objects.create(description='Playing golf')\n         j2 = Job.objects.create(name='Programmer')\n         r2 = Responsibility.objects.create(description='Programming')\n-        JobResponsibilities.objects.create(job=j1, responsibility=r1)\n+        JobResponsibilities.objects.create(job=j1, responsibility=cls.r1)\n         JobResponsibilities.objects.create(job=j2, responsibility=r2)\n \n     def test_to_field(self):\n@@ -2810,6 +2810,14 @@ def test_exclude_reverse_fk_field_ref(self):\n     def test_exclude_with_circular_fk_relation(self):\n         self.assertEqual(ObjectB.objects.exclude(objecta__objectb__name=F('name')).count(), 0)\n \n+    def test_subquery_exclude_outerref(self):\n+        qs = JobResponsibilities.objects.filter(\n+            Exists(Responsibility.objects.exclude(jobs=OuterRef('job'))),\n+        )\n+        self.assertTrue(qs.exists())\n+        self.r1.delete()\n+        self.assertFalse(qs.exists())\n+\n \n class ExcludeTest17600(TestCase):\n     \"\"\"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11734"}