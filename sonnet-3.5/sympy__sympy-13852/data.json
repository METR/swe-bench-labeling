{"instance_id": "sympy__sympy-13852", "score": "I", "diff": "diff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex b8e2b66195..14cb96dbb4 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,10 +253,21 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(z*exp_polar(-I*pi) + 1)\n+    -log(1 - z)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n+    For :math:`s = 2` and rational :math:`z`, the polylogarithm can be expressed\n+    in terms of elementary functions:\n+\n+    >>> from sympy import S\n+    >>> expand_func(polylog(2, S(1)/2))\n+    -log(2)**2/2 + pi**2/12\n+    >>> expand_func(polylog(2, S(1)/3))\n+    -log(3)**2/2 + pi**2/6 + 3*log(3)/2\n+    >>> expand_func(polylog(2, S(2)/3))\n+    -log(3)**2/2 - 3*log(3)/8 + pi**2/6\n+\n     The derivative with respect to :math:`z` can be computed in closed form:\n \n     >>> polylog(s, z).diff(z)\n@@ -288,10 +299,20 @@ def _eval_rewrite_as_lerchphi(self, s, z):\n         return z*lerchphi(z, s, 1)\n \n     def _eval_expand_func(self, **hints):\n-        from sympy import log, expand_mul, Dummy, exp_polar, I\n+        from sympy import log, expand_mul, Dummy, pi, S\n         s, z = self.args\n         if s == 1:\n-            return -log(1 + exp_polar(-I*pi)*z)\n+            return -log(1 - z)\n+        if s == 2:\n+            if z == S.Half:\n+                return -log(2)**2/2 + pi**2/12\n+            elif z.is_rational:\n+                p, q = z.as_numer_denom()\n+                return (pi**2/6 - log(q)**2/2 \n+                        - sum((-1)**k * (q-p)**k * log(q-p) / (k * p**k) \n+                              for k in range(1, q))\n+                        + sum((-1)**k * q**k * log(q) / (k * p**k) \n+                              for k in range(1, q)))\n         if s.is_Integer and s <= 0:\n             u = Dummy('u')\n             start = u/(1 - u)\n", "gold_standard_diff": "From 1c752d37e6904a2476597a79e8aaa565f4bfd428 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sat, 6 Jan 2018 23:48:31 +0000\nSubject: [PATCH 1/5] Implement special values of dilogarithm, most notably at\n 2 and 1/2\n\nExpressions such as polylog(2, 2) and polylog(2, 1/2) now evaluate\nin closed form. Closes #7132.\n\nThe values are confirmed by comparing\n https://en.wikipedia.org/wiki/Spence%27s_function#Special_values\nand\n http://functions.wolfram.com/ZetaFunctionsandPolylogarithms/PolyLog2/03/02/\nand additionally checked by floating point evaluation.\n---\n .../special/tests/test_zeta_functions.py        |  9 ++++++++-\n sympy/functions/special/zeta_functions.py       | 17 +++++++++++++++--\n 2 files changed, 23 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex 3911dadd103b..d0880b613d68 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -1,6 +1,6 @@\n from sympy import (Symbol, zeta, nan, Rational, Float, pi, dirichlet_eta, log,\n                    zoo, expand_func, polylog, lerchphi, S, exp, sqrt, I,\n-                   exp_polar, polar_lift, O, stieltjes)\n+                   exp_polar, polar_lift, O, stieltjes, Abs)\n from sympy.utilities.randtest import (test_derivative_numerically as td,\n                       random_complex_number as randcplx, verify_numerically as tn)\n \n@@ -134,6 +134,13 @@ def test_polylog_expansion():\n     assert myexpand(polylog(-5, z), None)\n \n \n+def test_polylog_values():\n+    assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n+    assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n+    for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n+        assert Abs(polylog(2, z) - polylog(2, z + 1e-13)).evalf() < 1e-12\n+\n+\n def test_lerchphi_expansion():\n     assert myexpand(lerchphi(1, s, a), zeta(s, a))\n     assert myexpand(lerchphi(z, s, 1), polylog(s, z)/z)\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex b8e2b66195e0..05a42d27febb 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -1,12 +1,12 @@\n \"\"\" Riemann zeta and related function. \"\"\"\n from __future__ import print_function, division\n \n-from sympy.core import Function, S, sympify, pi\n+from sympy.core import Function, S, sympify, pi, I\n from sympy.core.function import ArgumentIndexError\n from sympy.core.compatibility import range\n from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic\n from sympy.functions.elementary.exponential import log\n-\n+from sympy.functions.elementary.miscellaneous import sqrt\n \n ###############################################################################\n ###################### LERCH TRANSCENDENT #####################################\n@@ -277,6 +277,19 @@ def eval(cls, s, z):\n             return -dirichlet_eta(s)\n         elif z == 0:\n             return 0\n+        if s == 2:\n+            if z == S.Half:\n+                return pi**2/12 - log(2)**2/2\n+            elif z == 2:\n+                return pi**2/4 - I*pi*log(2)\n+            elif z == -(sqrt(5) - 1)/2:\n+                return -pi**2/15 + log((sqrt(5)-1)/2)**2/2\n+            elif z == -(sqrt(5) + 1)/2:\n+                return -pi**2/10 - log((sqrt(5)+1)/2)**2\n+            elif z == (3 - sqrt(5))/2:\n+                return pi**2/15 - log((sqrt(5)-1)/2)**2\n+            elif z == (sqrt(5) - 1)/2:\n+                return pi**2/10 - log((sqrt(5)-1)/2)**2\n \n     def fdiff(self, argindex=1):\n         s, z = self.args\n\nFrom eae3ee5a41b0df5e1ab7b5b8ed429adbbdcda86d Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sun, 7 Jan 2018 15:44:37 +0000\nSubject: [PATCH 2/5] Test polylog values by comparing with evaluations with\n evaluate=False\n\nTo make sure none of special polylog values are mistyped, they are compared to\nwhat mpmath returns without going through SymPy eval method.\n---\n sympy/functions/special/tests/test_zeta_functions.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex d0880b613d68..1fc2de37b5b4 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -138,7 +138,7 @@ def test_polylog_values():\n     assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n     assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n     for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n-        assert Abs(polylog(2, z) - polylog(2, z + 1e-13)).evalf() < 1e-12\n+        assert Abs(polylog(2, z).evalf() - polylog(2, z, evaluate=False).evalf()) < 1e-15\n \n \n def test_lerchphi_expansion():\n\nFrom 95779840d5a4291d46aebb4eb0567748b123ce24 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sun, 7 Jan 2018 22:55:33 +0000\nSubject: [PATCH 3/5] Polylog should return S.Zero instead of Python's 0 when\n z=0\n\nThe returned value is expected to be a SymPy object, \"return 0\"\nin a SymPy function is incorrect.\n---\n sympy/functions/special/zeta_functions.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 05a42d27febb..09da612c1d60 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -276,7 +276,7 @@ def eval(cls, s, z):\n         elif z == -1:\n             return -dirichlet_eta(s)\n         elif z == 0:\n-            return 0\n+            return S.Zero\n         if s == 2:\n             if z == S.Half:\n                 return pi**2/12 - log(2)**2/2\n\nFrom 39e1eb8d22692f8a470cf8e26b4c7b1313f03cc6 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Mon, 8 Jan 2018 14:36:23 +0000\nSubject: [PATCH 4/5] Evaluate polylog(s, z) for s in [-1, 0, 1], without\n exp_polar\n\npolylog(s, z) has simple formulas for s in -1, 0, 1. They should be\nused by eval, just as it uses the formulas for z in -1, 0, 1 without\nthe user needing to expand_func. For example:\n```\n>>> polylog(2, S(1)/2)\n-log(2)**2/2 + pi**2/12\n>>> polylog(1, S(1)/2)\nlog(2)     # previously this returned unevaluated\n```\nOne has to draw the line somewhere, and I left s = -2 and the rest\nun-evaluated, subject to the user applying expand_func\n\nPer the discussion at #13853 the expansion for s = -1 is simply\n-log(1 - z), as it appears in Wikipedia, Wolfram, etc.\n---\n sympy/functions/special/tests/test_zeta_functions.py | 10 ++++++++--\n sympy/functions/special/zeta_functions.py            | 12 +++++++++---\n 2 files changed, 17 insertions(+), 5 deletions(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex 1fc2de37b5b4..486047694445 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -128,17 +128,23 @@ def test_polylog_expansion():\n     assert polylog(s, 1) == zeta(s)\n     assert polylog(s, -1) == -dirichlet_eta(s)\n \n-    assert myexpand(polylog(1, z), -log(1 + exp_polar(-I*pi)*z))\n+    assert myexpand(polylog(1, z), -log(1 - z))\n     assert myexpand(polylog(0, z), z/(1 - z))\n-    assert myexpand(polylog(-1, z), z**2/(1 - z)**2 + z/(1 - z))\n+    assert myexpand(polylog(-1, z), z/(1 - z)**2)\n+    assert ((1-z)**3 * expand_func(polylog(-2, z))).simplify() == z*(1 + z)\n     assert myexpand(polylog(-5, z), None)\n \n \n def test_polylog_values():\n+    import random\n     assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n     assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n     for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n         assert Abs(polylog(2, z).evalf() - polylog(2, z, evaluate=False).evalf()) < 1e-15\n+    for s in [-1, 0, 1]:\n+        for _ in range(10):\n+            z = random.uniform(-5, 5) + I*random.uniform(-5, 5)\n+            assert Abs(polylog(s, z).evalf() - polylog(s, z, evaluate=False).evalf()) < 1e-15\n \n \n def test_lerchphi_expansion():\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 09da612c1d60..80fbd78bd7d0 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,7 +253,7 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(z*exp_polar(-I*pi) + 1)\n+    -log(1 - z)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n@@ -277,7 +277,7 @@ def eval(cls, s, z):\n             return -dirichlet_eta(s)\n         elif z == 0:\n             return S.Zero\n-        if s == 2:\n+        elif s == 2:\n             if z == S.Half:\n                 return pi**2/12 - log(2)**2/2\n             elif z == 2:\n@@ -290,6 +290,12 @@ def eval(cls, s, z):\n                 return pi**2/15 - log((sqrt(5)-1)/2)**2\n             elif z == (sqrt(5) - 1)/2:\n                 return pi**2/10 - log((sqrt(5)-1)/2)**2\n+        elif s == 1:\n+            return -log(1 - z)\n+        elif s == 0:\n+            return z/(1 - z)\n+        elif s == -1:\n+            return z/(1 - z)**2\n \n     def fdiff(self, argindex=1):\n         s, z = self.args\n@@ -304,7 +310,7 @@ def _eval_expand_func(self, **hints):\n         from sympy import log, expand_mul, Dummy, exp_polar, I\n         s, z = self.args\n         if s == 1:\n-            return -log(1 + exp_polar(-I*pi)*z)\n+            return -log(1 - z)\n         if s.is_Integer and s <= 0:\n             u = Dummy('u')\n             start = u/(1 - u)\n\nFrom 2a0ff1748f50829a47b66c7dc6056729ec7059fc Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Mon, 8 Jan 2018 19:39:12 +0000\nSubject: [PATCH 5/5] Do not expand polylog(1, z) to -log(1-z) without\n expand_func\n\nIt seemed like a good idea, but series summation methods work better\nwith polylog when the sum is to be expressed in terms of zeta function.\n---\n sympy/functions/special/zeta_functions.py | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 80fbd78bd7d0..8e9737aaf647 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,7 +253,7 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(1 - z)\n+    -log(-z + 1)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n@@ -290,8 +290,9 @@ def eval(cls, s, z):\n                 return pi**2/15 - log((sqrt(5)-1)/2)**2\n             elif z == (sqrt(5) - 1)/2:\n                 return pi**2/10 - log((sqrt(5)-1)/2)**2\n-        elif s == 1:\n-            return -log(1 - z)\n+        # For s = 0 or -1 use explicit formulas to evaluate, but\n+        # automatically expanding polylog(1, z) to -log(1-z) seems undesirable\n+        # for summation methods based on hypergeometric functions\n         elif s == 0:\n             return z/(1 - z)\n         elif s == -1:\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13852"}