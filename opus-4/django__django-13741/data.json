{"instance_id": "django__django-13741", "score": "C", "diff": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex b9eb33329f..9a6614a809 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -56,6 +56,7 @@ class ReadOnlyPasswordHashField(forms.Field):\n \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\n+        kwargs.setdefault(\"disabled\", True)\n         super().__init__(*args, **kwargs)\n \n     def bound_data(self, data, initial):\ndiff --git a/fix_password_field.py b/fix_password_field.py\nnew file mode 100644\nindex 0000000000..3a6f6a4c01\n--- /dev/null\n+++ b/fix_password_field.py\n@@ -0,0 +1,24 @@\n+#!/usr/bin/env python3\n+import re\n+\n+# Read the file\n+with open('django/contrib/auth/forms.py', 'r', encoding='utf-8') as f:\n+    content = f.read()\n+\n+# Find and replace the __init__ method of ReadOnlyPasswordHashField\n+old_init = '''    def __init__(self, *args, **kwargs):\n+        kwargs.setdefault(\"required\", False)\n+        super().__init__(*args, **kwargs)'''\n+\n+new_init = '''    def __init__(self, *args, **kwargs):\n+        kwargs.setdefault(\"required\", False)\n+        kwargs.setdefault(\"disabled\", True)\n+        super().__init__(*args, **kwargs)'''\n+\n+content = content.replace(old_init, new_init)\n+\n+# Write the file back\n+with open('django/contrib/auth/forms.py', 'w', encoding='utf-8') as f:\n+    f.write(content)\n+\n+print(\"Updated ReadOnlyPasswordHashField to set disabled=True by default\")\ndiff --git a/test_disabled_password_field.py b/test_disabled_password_field.py\nnew file mode 100644\nindex 0000000000..b8e37b196e\n--- /dev/null\n+++ b/test_disabled_password_field.py\n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.contrib.auth.models import User\n+from django.contrib.auth.forms import UserChangeForm, ReadOnlyPasswordHashField\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+django.setup()\n+\n+# Create a user for testing\n+try:\n+    user = User.objects.create_user('testuser', 'test@example.com', 'testpass123')\n+except:\n+    user = User.objects.get(username='testuser')\n+\n+print(\"Testing ReadOnlyPasswordHashField with disabled=True...\")\n+\n+# Test 1: Verify that ReadOnlyPasswordHashField has disabled=True by default\n+field = ReadOnlyPasswordHashField()\n+print(f\"1. ReadOnlyPasswordHashField disabled property: {field.disabled}\")\n+assert field.disabled == True, \"ReadOnlyPasswordHashField should have disabled=True by default\"\n+\n+# Test 2: Test UserChangeForm without clean_password method\n+# Remove the clean_password method temporarily to test if disabled field works\n+original_clean_password = UserChangeForm.clean_password\n+delattr(UserChangeForm, 'clean_password')\n+\n+try:\n+    # Create form with initial data\n+    form = UserChangeForm(instance=user)\n+    initial_password = form.initial['password']\n+    \n+    # Submit form with changed password (should be ignored due to disabled=True)\n+    post_data = form.initial.copy()\n+    post_data['password'] = 'this_should_be_ignored'\n+    \n+    form = UserChangeForm(instance=user, data=post_data)\n+    \n+    # Validate form\n+    is_valid = form.is_valid()\n+    print(f\"2. Form is valid without clean_password: {is_valid}\")\n+    assert is_valid, \"Form should be valid even without clean_password method\"\n+    \n+    # Check that password field returns initial value\n+    cleaned_password = form.cleaned_data.get('password')\n+    print(f\"3. Initial password hash: {initial_password[:20]}...\")\n+    print(f\"4. Cleaned password hash: {cleaned_password[:20]}...\")\n+    assert cleaned_password == initial_password, \"Password field should return initial value when disabled\"\n+    \n+finally:\n+    # Restore the clean_password method\n+    UserChangeForm.clean_password = original_clean_password\n+\n+# Test 3: Verify that the disabled field doesn't report changes\n+field = ReadOnlyPasswordHashField(initial='initial_hash')\n+field.disabled = True\n+has_changed = field.has_changed('initial_hash', 'different_value')\n+print(f\"5. Disabled field has_changed: {has_changed}\")\n+assert not has_changed, \"Disabled field should not report changes\"\n+\n+print(\"\\nAll tests passed! The ReadOnlyPasswordHashField now uses disabled=True by default.\")\ndiff --git a/test_password_field_disabled.py b/test_password_field_disabled.py\nnew file mode 100644\nindex 0000000000..4b00332913\n--- /dev/null\n+++ b/test_password_field_disabled.py\n@@ -0,0 +1,54 @@\n+from django.contrib.auth.forms import UserChangeForm, ReadOnlyPasswordHashField\n+from django.contrib.auth.models import User\n+from django.test import TestCase\n+\n+class TestPasswordFieldDisabled(TestCase):\n+    def setUp(self):\n+        self.user = User.objects.create_user('testuser', 'test@example.com', 'testpass123')\n+    \n+    def test_readonly_password_field_disabled_by_default(self):\n+        \"\"\"Test that ReadOnlyPasswordHashField has disabled=True by default\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        self.assertTrue(field.disabled)\n+    \n+    def test_userchangeform_without_clean_password(self):\n+        \"\"\"Test that UserChangeForm works correctly without clean_password due to disabled field\"\"\"\n+        # Remove clean_password temporarily  \n+        original_clean_password = getattr(UserChangeForm, 'clean_password', None)\n+        if hasattr(UserChangeForm, 'clean_password'):\n+            delattr(UserChangeForm, 'clean_password')\n+        \n+        try:\n+            # Create form with initial data\n+            form = UserChangeForm(instance=self.user)\n+            initial_password = form.initial['password']\n+            \n+            # Submit form with changed password (should be ignored)\n+            post_data = form.initial.copy()\n+            post_data['password'] = 'this_should_be_ignored'\n+            \n+            form = UserChangeForm(instance=self.user, data=post_data)\n+            \n+            # Validate form\n+            self.assertTrue(form.is_valid())\n+            \n+            # Check that password field returns initial value\n+            self.assertEqual(form.cleaned_data['password'], initial_password)\n+            \n+        finally:\n+            # Restore clean_password if it existed\n+            if original_clean_password:\n+                UserChangeForm.clean_password = original_clean_password\n+    \n+    def test_disabled_field_ignores_user_input(self):\n+        \"\"\"Test that a disabled ReadOnlyPasswordHashField ignores user input\"\"\"\n+        field = ReadOnlyPasswordHashField(initial='initial_hash')\n+        # Even though disabled is now True by default, let's be explicit\n+        self.assertTrue(field.disabled)\n+        \n+        # The bound_data method should return initial value\n+        bound = field.bound_data('user_provided_value', 'initial_hash')\n+        self.assertEqual(bound, 'initial_hash')\n+        \n+        # has_changed should always return False for disabled fields\n+        self.assertFalse(field.has_changed('initial_hash', 'different_value'))\ndiff --git a/tests/auth_tests/test_password_field_disabled.py b/tests/auth_tests/test_password_field_disabled.py\nnew file mode 100644\nindex 0000000000..4b00332913\n--- /dev/null\n+++ b/tests/auth_tests/test_password_field_disabled.py\n@@ -0,0 +1,54 @@\n+from django.contrib.auth.forms import UserChangeForm, ReadOnlyPasswordHashField\n+from django.contrib.auth.models import User\n+from django.test import TestCase\n+\n+class TestPasswordFieldDisabled(TestCase):\n+    def setUp(self):\n+        self.user = User.objects.create_user('testuser', 'test@example.com', 'testpass123')\n+    \n+    def test_readonly_password_field_disabled_by_default(self):\n+        \"\"\"Test that ReadOnlyPasswordHashField has disabled=True by default\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        self.assertTrue(field.disabled)\n+    \n+    def test_userchangeform_without_clean_password(self):\n+        \"\"\"Test that UserChangeForm works correctly without clean_password due to disabled field\"\"\"\n+        # Remove clean_password temporarily  \n+        original_clean_password = getattr(UserChangeForm, 'clean_password', None)\n+        if hasattr(UserChangeForm, 'clean_password'):\n+            delattr(UserChangeForm, 'clean_password')\n+        \n+        try:\n+            # Create form with initial data\n+            form = UserChangeForm(instance=self.user)\n+            initial_password = form.initial['password']\n+            \n+            # Submit form with changed password (should be ignored)\n+            post_data = form.initial.copy()\n+            post_data['password'] = 'this_should_be_ignored'\n+            \n+            form = UserChangeForm(instance=self.user, data=post_data)\n+            \n+            # Validate form\n+            self.assertTrue(form.is_valid())\n+            \n+            # Check that password field returns initial value\n+            self.assertEqual(form.cleaned_data['password'], initial_password)\n+            \n+        finally:\n+            # Restore clean_password if it existed\n+            if original_clean_password:\n+                UserChangeForm.clean_password = original_clean_password\n+    \n+    def test_disabled_field_ignores_user_input(self):\n+        \"\"\"Test that a disabled ReadOnlyPasswordHashField ignores user input\"\"\"\n+        field = ReadOnlyPasswordHashField(initial='initial_hash')\n+        # Even though disabled is now True by default, let's be explicit\n+        self.assertTrue(field.disabled)\n+        \n+        # The bound_data method should return initial value\n+        bound = field.bound_data('user_provided_value', 'initial_hash')\n+        self.assertEqual(bound, 'initial_hash')\n+        \n+        # has_changed should always return False for disabled fields\n+        self.assertFalse(field.has_changed('initial_hash', 'different_value'))\n", "gold_standard_diff": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex b9eb33329f31..20d892279901 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -56,16 +56,9 @@ class ReadOnlyPasswordHashField(forms.Field):\n \n     def __init__(self, *args, **kwargs):\n         kwargs.setdefault(\"required\", False)\n+        kwargs.setdefault('disabled', True)\n         super().__init__(*args, **kwargs)\n \n-    def bound_data(self, data, initial):\n-        # Always return initial because the widget doesn't\n-        # render an input field.\n-        return initial\n-\n-    def has_changed(self, initial, data):\n-        return False\n-\n \n class UsernameField(forms.CharField):\n     def to_python(self, value):\n@@ -163,12 +156,6 @@ def __init__(self, *args, **kwargs):\n         if user_permissions:\n             user_permissions.queryset = user_permissions.queryset.select_related('content_type')\n \n-    def clean_password(self):\n-        # Regardless of what the user provides, return the initial value.\n-        # This is done here, rather than on the field, because the\n-        # field does not have access to the initial value\n-        return self.initial.get('password')\n-\n \n class AuthenticationForm(forms.Form):\n     \"\"\"\ndiff --git a/docs/releases/3.2.txt b/docs/releases/3.2.txt\nindex 7d374da0a7e9..2ab8546026f4 100644\n--- a/docs/releases/3.2.txt\n+++ b/docs/releases/3.2.txt\n@@ -625,6 +625,11 @@ Miscellaneous\n   using :option:`makemessages --locale` option, when they contain hyphens\n   (``'-'``).\n \n+* The ``django.contrib.auth.forms.ReadOnlyPasswordHashField`` form field is now\n+  :attr:`~django.forms.Field.disabled` by default. Therefore\n+  ``UserChangeForm.clean_password()`` is no longer required to return the\n+  initial value.\n+\n .. _deprecated-features-3.2:\n \n Features deprecated in 3.2\ndiff --git a/docs/topics/auth/customizing.txt b/docs/topics/auth/customizing.txt\nindex 6ab830546882..8314d9f1711c 100644\n--- a/docs/topics/auth/customizing.txt\n+++ b/docs/topics/auth/customizing.txt\n@@ -1129,7 +1129,7 @@ code would be required in the app's ``admin.py`` file::\n     class UserChangeForm(forms.ModelForm):\n         \"\"\"A form for updating users. Includes all the fields on\n         the user, but replaces the password field with admin's\n-        password hash display field.\n+        disabled password hash display field.\n         \"\"\"\n         password = ReadOnlyPasswordHashField()\n \n@@ -1137,12 +1137,6 @@ code would be required in the app's ``admin.py`` file::\n             model = MyUser\n             fields = ('email', 'password', 'date_of_birth', 'is_active', 'is_admin')\n \n-        def clean_password(self):\n-            # Regardless of what the user provides, return the initial value.\n-            # This is done here, rather than on the field, because the\n-            # field does not have access to the initial value\n-            return self.initial[\"password\"]\n-\n \n     class UserAdmin(BaseUserAdmin):\n         # The forms to add and change user instances\n@@ -1182,3 +1176,10 @@ Finally, specify the custom model as the default user model for your project\n using the :setting:`AUTH_USER_MODEL` setting in your ``settings.py``::\n \n     AUTH_USER_MODEL = 'customauth.MyUser'\n+\n+.. versionchanged:: 3.2\n+\n+    In older versions, ``ReadOnlyPasswordHashField`` is not\n+    :attr:`~django.forms.Field.disabled` by default and\n+    ``UserChangeForm.clean_password()`` is required to return the initial\n+    value, whatever the user provides.\ndiff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 88b4b3266713..7a731bedc874 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1022,6 +1022,7 @@ def test_render(self):\n \n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n+        self.assertIs(field.disabled, True)\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/13741"}