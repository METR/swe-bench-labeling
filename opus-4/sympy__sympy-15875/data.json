{"instance_id": "sympy__sympy-15875", "score": "I", "diff": "diff --git a/sympy/core/add.py b/sympy/core/add.py\nindex 83a5f2aedc..2be71e30ef 100644\n--- a/sympy/core/add.py\n+++ b/sympy/core/add.py\n@@ -534,36 +534,44 @@ def _eval_is_zero(self):\n             # issue 10528: there is no way to know if a nc symbol\n             # is zero or not\n             return\n-        nz = []\n-        z = 0\n-        im_or_z = False\n-        im = False\n+        # Separate real and imaginary parts\n+        real_part = []\n+        imag_part = []\n         for a in self.args:\n             if a.is_real:\n                 if a.is_zero:\n-                    z += 1\n+                    pass  # Skip zeros\n                 elif a.is_zero is False:\n-                    nz.append(a)\n+                    real_part.append(a)\n                 else:\n-                    return\n+                    return  # Can't determine\n             elif a.is_imaginary:\n-                im = True\n+                imag_part.append(a*S.ImaginaryUnit)  # Convert to real\n             elif (S.ImaginaryUnit*a).is_real:\n-                im_or_z = True\n+                imag_part.append(a*S.ImaginaryUnit)  # Convert to real\n             else:\n-                return\n-        if z == len(self.args):\n+                return  # Can't determine\n+        \n+        # Check if all args were zero\n+        if not real_part and not imag_part:\n             return True\n-        if len(nz) == len(self.args):\n-            return None\n-        b = self.func(*nz)\n-        if b.is_zero:\n-            if not im_or_z and not im:\n-                return True\n-            if im and not im_or_z:\n-                return False\n-        if b.is_zero is False:\n+            \n+        # Check if real part sums to zero\n+        real_sum = self.func(*real_part) if real_part else S.Zero\n+        if real_sum.is_zero is False:\n+            return False\n+        elif real_sum.is_zero is None:\n+            return  # Can't determine\n+            \n+        # Check if imaginary part sums to zero\n+        imag_sum = self.func(*imag_part) if imag_part else S.Zero\n+        if imag_sum.is_zero is False:\n             return False\n+        elif imag_sum.is_zero is None:\n+            return  # Can't determine\n+            \n+        # Both parts sum to zero\n+        return True\n \n     def _eval_is_odd(self):\n         l = [f for f in self.args if not (f.is_even is True)]\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..9d3ea11988\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,73 @@\n+from sympy import *\n+\n+print(\"Testing comprehensive is_zero edge cases...\")\n+\n+# Test 1: Original issue case\n+e1 = -2*I + (1 + I)**2\n+assert e1.is_zero == True\n+print(\"\u2713 Original issue case: -2*I + (1 + I)**2\")\n+\n+# Test 2: Pure imaginary that sums to zero\n+e2 = 3*I - 2*I - I\n+assert e2.is_zero == True\n+print(\"\u2713 Pure imaginary sum to zero: 3*I - 2*I - I\")\n+\n+# Test 3: Pure imaginary that doesn't sum to zero\n+e3 = 3*I - 2*I\n+assert e3.is_zero == False\n+print(\"\u2713 Pure imaginary non-zero: 3*I - 2*I\")\n+\n+# Test 4: Mixed real and imaginary that sums to zero\n+e4 = 2 + 3*I - 2 - 3*I\n+assert e4.is_zero == True\n+print(\"\u2713 Mixed real/imaginary sum to zero: 2 + 3*I - 2 - 3*I\")\n+\n+# Test 5: Mixed real and imaginary, only real part is zero\n+e5 = 3*I - 2*I + 2 - 2\n+assert e5.is_zero == False\n+print(\"\u2713 Only real part zero: 3*I - 2*I + 2 - 2\")\n+\n+# Test 6: Mixed real and imaginary, only imaginary part is zero\n+e6 = 3*I - 3*I + 2 - 1\n+assert e6.is_zero == False\n+print(\"\u2713 Only imaginary part zero: 3*I - 3*I + 2 - 1\")\n+\n+# Test 7: With symbols (real)\n+x = Symbol('x', real=True)\n+e7 = x - x + 2*I - 2*I\n+assert e7.is_zero == True\n+print(\"\u2713 With real symbols: x - x + 2*I - 2*I\")\n+\n+# Test 8: With symbols (imaginary)\n+y = Symbol('y', imaginary=True)\n+e8 = y - y + 2 - 2\n+assert e8.is_zero == True\n+print(\"\u2713 With imaginary symbols: y - y + 2 - 2\")\n+\n+# Test 9: With symbols - undetermined\n+z = Symbol('z')  # No assumptions\n+e9 = z + I*z\n+assert e9.is_zero is None\n+print(\"\u2713 Undetermined with generic symbol: z + I*z\")\n+\n+# Test 10: Complex expression with Pow that needs expanding  \n+e10 = (1 + I)**2 + (1 - I)**2 - 2\n+# This returns False because (1-I)**2 and (1+I)**2 are not expanded\n+# and their imaginary property is not correctly detected\n+assert e10.is_zero == False  \n+print(\"\u2713 Complex power expression (unexpanded): (1 + I)**2 + (1 - I)**2 - 2\")\n+\n+# Test 11: Non-commutative symbols\n+A, B = symbols('A B', commutative=False)\n+e11 = A + B - B - A  # Non-commutative order matters\n+# Even with non-commutative symbols, if they cancel exactly, it's zero\n+e11_2 = A + B - A - B  # This simplifies to zero\n+assert e11_2.is_zero == True  \n+print(\"\u2713 Non-commutative symbols handled correctly\")\n+\n+# Test 12: Infinity cases\n+e12 = oo - oo\n+assert e12.is_zero is None  # Indeterminate\n+print(\"\u2713 Infinity cases handled correctly\")\n+\n+print(\"\\nAll comprehensive tests passed! \u2713\")\ndiff --git a/test_is_zero_fix.py b/test_is_zero_fix.py\nnew file mode 100644\nindex 0000000000..690d4f412d\n--- /dev/null\n+++ b/test_is_zero_fix.py\n@@ -0,0 +1,33 @@\n+from sympy import *\n+\n+# Test cases for the is_zero issue\n+e1 = -2*I + (1 + I)**2\n+print(f\"e1 = {e1}\")\n+print(f\"e1.is_zero = {e1.is_zero}\")\n+print(f\"simplify(e1) = {simplify(e1)}\")\n+print(f\"simplify(e1).is_zero = {simplify(e1).is_zero}\")\n+print()\n+\n+# More test cases\n+e2 = 2*I + (-2*I)\n+print(f\"e2 = {e2}\")\n+print(f\"e2.is_zero = {e2.is_zero}\")\n+print()\n+\n+e3 = I + (-I)\n+print(f\"e3 = {e3}\")\n+print(f\"e3.is_zero = {e3.is_zero}\")\n+print()\n+\n+# Mixed real and imaginary\n+e4 = 1 + I + (-1) + (-I)\n+print(f\"e4 = {e4}\")\n+print(f\"e4.is_zero = {e4.is_zero}\")\n+print()\n+\n+# Test with symbols\n+x = Symbol('x', real=True)\n+y = Symbol('y', real=True)\n+e5 = x*I + (-x)*I\n+print(f\"e5 = {e5}\")\n+print(f\"e5.is_zero = {e5.is_zero}\")\ndiff --git a/test_issue_case.py b/test_issue_case.py\nnew file mode 100644\nindex 0000000000..0255e88a5f\n--- /dev/null\n+++ b/test_issue_case.py\n@@ -0,0 +1,44 @@\n+from sympy import *\n+\n+# Test the specific case from the issue\n+e = -2*I + (1 + I)**2\n+print(f\"e = {e}\")\n+print(f\"e.is_zero = {e.is_zero}\")\n+print(f\"simplify(e) = {simplify(e)}\")\n+print(f\"simplify(e).is_zero = {simplify(e).is_zero}\")\n+\n+# Check that is_zero now returns the correct value\n+assert e.is_zero == True, \"e.is_zero should be True\"\n+assert simplify(e).is_zero == True, \"simplify(e).is_zero should be True\"\n+\n+print(\"\\nAll assertions passed! The issue is fixed.\")\n+\n+# Additional edge cases to ensure correctness\n+print(\"\\nTesting additional edge cases...\")\n+\n+# Complex expression that is zero\n+e2 = 3*I + 2 - 2 - 3*I\n+print(f\"e2 = {e2}\")\n+print(f\"e2.is_zero = {e2.is_zero}\")\n+assert e2.is_zero == True\n+\n+# Complex expression that is NOT zero\n+e3 = 3*I + 2 - 1 - 3*I\n+print(f\"e3 = {e3}\")\n+print(f\"e3.is_zero = {e3.is_zero}\")\n+assert e3.is_zero == False\n+\n+# Expression with unknown zero status\n+x = Symbol('x')\n+e4 = x + I - x - I\n+print(f\"e4 = {e4}\")\n+print(f\"e4.is_zero = {e4.is_zero}\")\n+assert e4.is_zero == True\n+\n+# Expression that cannot be determined\n+e5 = x + I*x\n+print(f\"e5 = {e5}\")\n+print(f\"e5.is_zero = {e5.is_zero}\")\n+assert e5.is_zero is None\n+\n+print(\"\\nAll edge case tests passed!\")\ndiff --git a/test_matrix_rank.py b/test_matrix_rank.py\nnew file mode 100644\nindex 0000000000..2eb91bddbe\n--- /dev/null\n+++ b/test_matrix_rank.py\n@@ -0,0 +1,31 @@\n+from sympy import *\n+\n+# Test that matrix rank calculations work correctly now\n+M = Matrix([\n+    [1, 0, 1+I],\n+    [0, 1, -I],\n+    [1, -I, 1]\n+])\n+\n+print(\"Matrix M:\")\n+print(M)\n+print(f\"\\nMatrix rank: {M.rank()}\")\n+\n+# Create a matrix with complex entries that should have reduced rank\n+M2 = Matrix([\n+    [1, I, 1+I],\n+    [I, -1, -1+I],\n+    [1+I, -1+I, 2*I]\n+])\n+\n+print(\"\\nMatrix M2:\")\n+print(M2)\n+print(f\"Matrix rank: {M2.rank()}\")\n+\n+# Test with the specific expression from the issue\n+e = -2*I + (1 + I)**2\n+M3 = Matrix([[e]])\n+print(f\"\\nMatrix [[{e}]] rank: {M3.rank()}\")\n+assert M3.rank() == 0, \"Matrix with zero entry should have rank 0\"\n+\n+print(\"\\nAll matrix rank tests passed!\")\n", "gold_standard_diff": "diff --git a/sympy/core/add.py b/sympy/core/add.py\nindex 83a5f2aedc6a..24ae64f2c906 100644\n--- a/sympy/core/add.py\n+++ b/sympy/core/add.py\n@@ -554,7 +554,7 @@ def _eval_is_zero(self):\n                 return\n         if z == len(self.args):\n             return True\n-        if len(nz) == len(self.args):\n+        if len(nz) == 0 or len(nz) == len(self.args):\n             return None\n         b = self.func(*nz)\n         if b.is_zero:\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex e2398a4e7c26..28af93d2392b 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1986,10 +1986,15 @@ def test_Add_is_zero():\n     x, y = symbols('x y', zero=True)\n     assert (x + y).is_zero\n \n+    # Issue 15873\n+    e = -2*I + (1 + I)**2\n+    assert e.is_zero is None\n+\n \n def test_issue_14392():\n     assert (sin(zoo)**2).as_real_imag() == (nan, nan)\n \n+\n def test_divmod():\n     assert divmod(x, y) == (x//y, x % y)\n     assert divmod(x, 3) == (x//3, x % 3)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/15875"}