diff --git a/run_python_test.py b/run_python_test.py
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/run_python_test.py
@@ -0,0 +1 @@
+
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index cc1d19fcce..489dbbc56e 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -204,10 +204,10 @@ def _print_Inverse(self, I):
     def _print_Lambda(self, obj):
         args, expr = obj.args
         if len(args) == 1:
-            return "Lambda(%s, %s)" % (args.args[0], expr)
+            return "Lambda(%s, %s)" % (self._print(args.args[0]), self._print(expr))
         else:
             arg_string = ", ".join(self._print(arg) for arg in args)
-            return "Lambda((%s), %s)" % (arg_string, expr)
+            return "Lambda((%s), %s)" % (arg_string, self._print(expr))
 
     def _print_LatticeOp(self, expr):
         args = sorted(expr.args, key=default_sort_key)
@@ -216,9 +216,9 @@ def _print_LatticeOp(self, expr):
     def _print_Limit(self, expr):
         e, z, z0, dir = expr.args
         if str(dir) == "+":
-            return "Limit(%s, %s, %s)" % (e, z, z0)
+            return "Limit(%s, %s, %s)" % (self._print(e), self._print(z), self._print(z0))
         else:
-            return "Limit(%s, %s, %s, dir='%s')" % (e, z, z0, dir)
+            return "Limit(%s, %s, %s, dir='%s')" % (self._print(e), self._print(z), self._print(z0), dir)
 
     def _print_list(self, expr):
         return "[%s]" % self.stringify(expr, ", ")
@@ -237,7 +237,7 @@ def _print_MatrixBase(self, expr):
 
     def _print_MatrixElement(self, expr):
         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
-            + '[%s, %s]' % (expr.i, expr.j)
+            + '[%s, %s]' % (self._print(expr.i), self._print(expr.j))
 
     def _print_MatrixSlice(self, expr):
         def strslice(x):
@@ -630,7 +630,7 @@ def _print_Relational(self, expr):
         }
 
         if expr.rel_op in charmap:
-            return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)
+            return '%s(%s, %s)' % (charmap[expr.rel_op], self._print(expr.lhs), self._print(expr.rhs))
 
         return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)),
                            self._relationals.get(expr.rel_op) or expr.rel_op,
diff --git a/sympy/printing/tests/test_python.py b/sympy/printing/tests/test_python.py
index b059fbdedd..fb8854e213 100644
--- a/sympy/printing/tests/test_python.py
+++ b/sympy/printing/tests/test_python.py
@@ -80,12 +80,12 @@ def test_python_keyword_function_name_escaping():
 
 
 def test_python_relational():
-    assert python(Eq(x, y)) == "e = Eq(x, y)"
+    assert python(Eq(x, y)) == "x = Symbol('x')\ny = Symbol('y')\ne = Eq(x, y)"
     assert python(Ge(x, y)) == "x = Symbol('x')\ny = Symbol('y')\ne = x >= y"
     assert python(Le(x, y)) == "x = Symbol('x')\ny = Symbol('y')\ne = x <= y"
     assert python(Gt(x, y)) == "x = Symbol('x')\ny = Symbol('y')\ne = x > y"
     assert python(Lt(x, y)) == "x = Symbol('x')\ny = Symbol('y')\ne = x < y"
-    assert python(Ne(x/(y + 1), y**2)) in ["e = Ne(x/(1 + y), y**2)", "e = Ne(x/(y + 1), y**2)"]
+    assert python(Ne(x/(y + 1), y**2)) in ["x = Symbol('x')\ny = Symbol('y')\ne = Ne(x/(1 + y), y**2)", "x = Symbol('x')\ny = Symbol('y')\ne = Ne(x/(y + 1), y**2)"]
 
 
 def test_python_functions():
diff --git a/test_final.py b/test_final.py
new file mode 100644
index 0000000000..c66b732e6b
--- /dev/null
+++ b/test_final.py
@@ -0,0 +1,69 @@
+from sympy import S, symbols, Eq, Limit, Lambda, MatrixSymbol, sstr, python
+from sympy.abc import x, y, z
+
+print("Testing all fixes...")
+print("="*50)
+
+# Issue 1: StrPrinter not respecting sympy_integers in subexpressions
+print("\n1. Testing StrPrinter with sympy_integers=True:")
+
+# Test 1a: Basic expression (should work)
+expr = x + S(1)/2
+result = sstr(expr, sympy_integers=True)
+print(f"   x + S(1)/2: {result}")
+assert result == "x + S(1)/2", f"Expected 'x + S(1)/2', got '{result}'"
+
+# Test 1b: Eq (was broken, now fixed)
+expr = Eq(x, S(1)/2)
+result = sstr(expr, sympy_integers=True)
+print(f"   Eq(x, S(1)/2): {result}")
+assert result == "Eq(x, S(1)/2)", f"Expected 'Eq(x, S(1)/2)', got '{result}'"
+
+# Test 1c: Limit (was broken, now fixed)
+expr = Limit(x, x, S(1)/2)
+result = sstr(expr, sympy_integers=True)
+print(f"   Limit(x, x, S(1)/2): {result}")
+assert result == "Limit(x, x, S(1)/2)", f"Expected 'Limit(x, x, S(1)/2)', got '{result}'"
+
+# Test 1d: Lambda (now fixed)
+expr = Lambda(x, x + S(1)/2)
+result = sstr(expr, sympy_integers=True)
+print(f"   Lambda(x, x + S(1)/2): {result}")
+assert result == "Lambda(x, x + S(1)/2)", f"Expected 'Lambda(x, x + S(1)/2)', got '{result}'"
+
+# Test 1e: Complex expressions
+expr = Eq(x + S(1)/3, Limit(y, y, S(2)/5))
+result = sstr(expr, sympy_integers=True)
+print(f"   Eq(x + S(1)/3, Limit(y, y, S(2)/5)): {result}")
+assert "S(1)/3" in result and "S(2)/5" in result, f"Expected fractions with S(), got '{result}'"
+
+print("\n   ✓ All sympy_integers tests passed!")
+
+# Issue 2: Python printer not generating symbol definitions for Eq
+print("\n2. Testing Python printer:")
+
+# Test 2a: Eq (was broken - didn't generate symbol definitions)
+expr = Eq(x, y)
+result = python(expr)
+print(f"   python(Eq(x, y)):")
+for line in result.split('\n'):
+    print(f"      {line}")
+assert "x = Symbol('x')" in result, "Missing x symbol definition"
+assert "y = Symbol('y')" in result, "Missing y symbol definition"
+assert "e = Eq(x, y)" in result, "Missing equation assignment"
+
+# Test 2b: Complex expression with multiple symbols
+a, b, c = symbols('a b c')
+expr = Eq(a + b, c)
+result = python(expr)
+print(f"\n   python(Eq(a + b, c)):")
+for line in result.split('\n'):
+    print(f"      {line}")
+assert "a = Symbol('a')" in result, "Missing a symbol definition"
+assert "b = Symbol('b')" in result, "Missing b symbol definition"
+assert "c = Symbol('c')" in result, "Missing c symbol definition"
+
+print("\n   ✓ All Python printer tests passed!")
+
+print("\n" + "="*50)
+print("All tests completed successfully! ✓")
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..3cce07392e
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,28 @@
+from sympy import S, symbols, Eq, Limit, sstr, python
+from sympy.abc import x, y
+
+# Test cases from the issue
+print("Test 1: x + S(1)/2")
+result1 = sstr(x + S(1)/2, sympy_integers=True)
+print(f"Result: {result1}")
+print(f"Expected: 'x + S(1)/2'")
+print(f"Pass: {result1 == 'x + S(1)/2'}")
+print()
+
+print("Test 2: Eq(x, S(1)/2)")
+result2 = sstr(Eq(x, S(1)/2), sympy_integers=True)
+print(f"Result: {result2}")
+print(f"Expected: 'Eq(x, S(1)/2)'")
+print(f"Pass: {result2 == 'Eq(x, S(1)/2)'}")
+print()
+
+print("Test 3: Limit(x, x, S(1)/2)")
+result3 = sstr(Limit(x, x, S(1)/2), sympy_integers=True)
+print(f"Result: {result3}")
+print(f"Expected: 'Limit(x, x, S(1)/2)'")
+print(f"Pass: {result3 == 'Limit(x, x, S(1)/2)'}")
+print()
+
+print("Test 4: python(Eq(x, y))")
+result4 = python(Eq(x, y))
+print(f"Result: {result4}")
diff --git a/test_specific.py b/test_specific.py
new file mode 100644
index 0000000000..0b487334d4
--- /dev/null
+++ b/test_specific.py
@@ -0,0 +1,38 @@
+from sympy import S, symbols, Eq, Limit, Lambda, MatrixSymbol, sstr, python
+from sympy.abc import x, y, z
+
+# Test cases for sympy_integers setting
+print("Testing sympy_integers setting propagation...")
+
+# Test Eq
+result = sstr(Eq(x, S(1)/2), sympy_integers=True)
+print(f"Eq(x, S(1)/2): {result}")
+assert result == "Eq(x, S(1)/2)", f"Expected 'Eq(x, S(1)/2)', got '{result}'"
+
+# Test Limit
+result = sstr(Limit(x, x, S(1)/2), sympy_integers=True)
+print(f"Limit(x, x, S(1)/2): {result}")
+assert result == "Limit(x, x, S(1)/2)", f"Expected 'Limit(x, x, S(1)/2)', got '{result}'"
+
+# Test Lambda
+result = sstr(Lambda(x, x + S(1)/2), sympy_integers=True)
+print(f"Lambda(x, x + S(1)/2): {result}")
+assert result == "Lambda(x, x + S(1)/2)", f"Expected 'Lambda(x, x + S(1)/2)', got '{result}'"
+
+# Test MatrixElement
+M = MatrixSymbol('M', 2, 2)
+result = sstr(M[S(1)/2, S(1)/3], sympy_integers=True)
+print(f"M[S(1)/2, S(1)/3]: {result}")
+assert result == "M[S(1)/2, S(1)/3]", f"Expected 'M[S(1)/2, S(1)/3]', got '{result}'"
+
+# Test Relational operators
+result = sstr(x >= S(1)/2, sympy_integers=True)
+print(f"x >= S(1)/2: {result}")
+# This should still use infix notation but with proper printing of S(1)/2
+
+print("\nAll tests passed!")
+
+# Now test the python printer issue
+print("\nTesting python printer...")
+result = python(Eq(x, y))
+print(f"python(Eq(x, y)):\n{result}")
