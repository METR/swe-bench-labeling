{"instance_id": "django__django-13109", "score": "C", "diff": "diff --git a/demo_fix.py b/demo_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex d517d7269b..c2aea9c730 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -914,7 +914,7 @@ class ForeignKey(ForeignObject):\n             return\n \n         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n-        qs = self.remote_field.model._default_manager.using(using).filter(\n+        qs = self.remote_field.model._base_manager.using(using).filter(\n             **{self.remote_field.field_name: value}\n         )\n         qs = qs.complex_filter(self.get_limit_choices_to())\ndiff --git a/test_foreignkey_validation.py b/test_foreignkey_validation.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_validation.py b/test_validation.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/tests/foreignkey_validation_test.py b/tests/foreignkey_validation_test.py\nnew file mode 100644\nindex 0000000000..20adec410a\n--- /dev/null\n+++ b/tests/foreignkey_validation_test.py\n@@ -0,0 +1,54 @@\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class ArticleManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n+class Article(models.Model):\n+    title = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+    # Don't include archived articles by default.\n+    objects = ArticleManager()\n+    \n+    class Meta:\n+        app_label = 'foreignkey_validation_test'\n+\n+\n+class FavoriteArticles(models.Model):\n+    article = models.ForeignKey(Article, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'foreignkey_validation_test'\n+\n+\n+class ForeignKeyValidationTest(TestCase):\n+    def test_foreignkey_validation_with_custom_manager(self):\n+        \"\"\"Test that ForeignKey validation works with filtered default managers.\"\"\"\n+        # Create test data\n+        normal_article = Article.objects.create(title=\"Normal Article\", archived=False)\n+        archived_article = Article(title=\"Archived Article\", archived=True)\n+        # We need to use save directly to bypass the manager filtering\n+        archived_article.save()\n+        \n+        # Normal article should validate successfully\n+        fav1 = FavoriteArticles(article=normal_article)\n+        fav1.full_clean()  # Should not raise\n+        \n+        # Archived article should also validate successfully with the fix\n+        # This currently fails because validate() uses _default_manager\n+        fav2 = FavoriteArticles(article=archived_article)\n+        with self.assertRaises(ValidationError) as cm:\n+            fav2.full_clean()\n+        \n+        # The error should mention the invalid value\n+        self.assertIn(str(archived_article.id), str(cm.exception))\n+        \n+        # Direct field validation should also fail currently\n+        field = FavoriteArticles._meta.get_field('article')\n+        with self.assertRaises(ValidationError):\n+            field.validate(archived_article.id, None)\ndiff --git a/tests/model_fields/test_foreignkey_base_manager.py b/tests/model_fields/test_foreignkey_base_manager.py\nnew file mode 100644\nindex 0000000000..53481ab23d\n--- /dev/null\n+++ b/tests/model_fields/test_foreignkey_base_manager.py\n@@ -0,0 +1,78 @@\n+from django.core.exceptions import ValidationError\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class ArticleManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n+class Article(models.Model):\n+    title = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+    # Don't include archived articles by default.\n+    objects = ArticleManager()\n+\n+\n+class FavoriteArticles(models.Model):\n+    article = models.ForeignKey(Article, on_delete=models.CASCADE)\n+\n+\n+class FavoriteArticlesWithLimit(models.Model):\n+    # Test limit_choices_to still works\n+    article = models.ForeignKey(Article, on_delete=models.CASCADE, limit_choices_to={'archived': False})\n+\n+\n+class ForeignKeyBaseManagerTest(TestCase):\n+    def test_foreignkey_validation_with_custom_manager(self):\n+        \"\"\"\n+        ForeignKey validation should use base manager instead of default manager.\n+        \n+        This test verifies that ForeignKey validation works correctly when\n+        the related model has a custom default manager that filters out\n+        some objects.\n+        \"\"\"\n+        # Create test data\n+        normal_article = Article.objects.create(title=\"Normal Article\", archived=False)\n+        archived_article = Article(title=\"Archived Article\", archived=True)\n+        # We need to use save directly to bypass the manager filtering\n+        archived_article.save()\n+        \n+        # Verify the setup - default manager only shows non-archived\n+        self.assertEqual(Article.objects.count(), 1)\n+        self.assertEqual(Article._base_manager.count(), 2)\n+        \n+        # Normal article should validate successfully\n+        fav1 = FavoriteArticles(article=normal_article)\n+        fav1.full_clean()  # Should not raise\n+        \n+        # With the fix, archived article should now validate successfully\n+        # because ForeignKey.validate() uses _base_manager instead of _default_manager\n+        fav2 = FavoriteArticles(article=archived_article)\n+        fav2.full_clean()  # Should not raise after the fix\n+        \n+        # Direct field validation should also pass now\n+        field = FavoriteArticles._meta.get_field('article')\n+        field.validate(archived_article.id, None)  # Should not raise\n+    \n+    def test_foreignkey_validation_with_limit_choices_to(self):\n+        \"\"\"Test that limit_choices_to still works properly with base manager.\"\"\"\n+        # Create test data\n+        normal_article = Article.objects.create(title=\"Normal Article\", archived=False)\n+        archived_article = Article(title=\"Archived Article\", archived=True)\n+        archived_article.save()\n+        \n+        # Normal article should validate successfully\n+        fav1 = FavoriteArticlesWithLimit(article=normal_article)\n+        fav1.full_clean()  # Should not raise\n+        \n+        # Archived article should fail validation due to limit_choices_to\n+        fav2 = FavoriteArticlesWithLimit(article=archived_article)\n+        with self.assertRaises(ValidationError) as cm:\n+            fav2.full_clean()\n+        \n+        # The error should mention that the article doesn't exist\n+        self.assertIn('article instance with id', str(cm.exception))\n+        self.assertIn('does not exist', str(cm.exception))\n", "gold_standard_diff": "From ee0b80423000ebc0fb0961c77ea3ea1d6028542e Mon Sep 17 00:00:00 2001\nFrom: Jon Dufresne <jon.dufresne@gmail.com>\nDate: Thu, 25 Jun 2020 10:28:52 +0200\nSubject: [PATCH] Fixed #31596 -- Changed ForeignKey.validate() to use the base\n manager.\n\n---\n django/db/models/fields/related.py |  2 +-\n docs/releases/3.2.txt              |  5 ++++\n tests/model_forms/models.py        |  9 ++++++\n tests/model_forms/tests.py         | 46 ++++++++++++++++++++++++++++++\n tests/validation/models.py         |  9 ++++++\n tests/validation/tests.py          |  7 +++++\n 6 files changed, 77 insertions(+), 1 deletion(-)\n\ndiff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py\nindex d517d7269ba0..c2aea9c7306e 100644\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -914,7 +914,7 @@ def validate(self, value, model_instance):\n             return\n \n         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n-        qs = self.remote_field.model._default_manager.using(using).filter(\n+        qs = self.remote_field.model._base_manager.using(using).filter(\n             **{self.remote_field.field_name: value}\n         )\n         qs = qs.complex_filter(self.get_limit_choices_to())\ndiff --git a/docs/releases/3.2.txt b/docs/releases/3.2.txt\nindex 8544df77c3fb..743d341a7f73 100644\n--- a/docs/releases/3.2.txt\n+++ b/docs/releases/3.2.txt\n@@ -349,6 +349,11 @@ Miscellaneous\n   (``USE_L10N = True``). After upgrading to Django 3.2 in such configurations,\n   the first request to any previously cached value will be a cache miss.\n \n+* ``ForeignKey.validate()`` now uses\n+  :attr:`~django.db.models.Model._base_manager` rather than\n+  :attr:`~django.db.models.Model._default_manager` to check that related\n+  instances exist.\n+\n .. _deprecated-features-3.2:\n \n Features deprecated in 3.2\ndiff --git a/tests/model_forms/models.py b/tests/model_forms/models.py\nindex 05c6d71a4add..103ed71b446d 100644\n--- a/tests/model_forms/models.py\n+++ b/tests/model_forms/models.py\n@@ -28,8 +28,17 @@ def __repr__(self):\n         return self.__str__()\n \n \n+class WriterManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n class Writer(models.Model):\n     name = models.CharField(max_length=50, help_text='Use both first and last names.')\n+    archived = models.BooleanField(default=False, editable=False)\n+\n+    objects = WriterManager()\n \n     class Meta:\n         ordering = ('name',)\ndiff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex cb8d7c3f8427..42ea63dd4d04 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -1644,6 +1644,52 @@ class Meta:\n         obj.name = 'Alice'\n         obj.full_clean()\n \n+    def test_validate_foreign_key_uses_default_manager(self):\n+        class MyForm(forms.ModelForm):\n+            class Meta:\n+                model = Article\n+                fields = '__all__'\n+\n+        # Archived writers are filtered out by the default manager.\n+        w = Writer.objects.create(name='Randy', archived=True)\n+        data = {\n+            'headline': 'My Article',\n+            'slug': 'my-article',\n+            'pub_date': datetime.date.today(),\n+            'writer': w.pk,\n+            'article': 'lorem ipsum',\n+        }\n+        form = MyForm(data)\n+        self.assertIs(form.is_valid(), False)\n+        self.assertEqual(\n+            form.errors,\n+            {'writer': ['Select a valid choice. That choice is not one of the available choices.']},\n+        )\n+\n+    def test_validate_foreign_key_to_model_with_overridden_manager(self):\n+        class MyForm(forms.ModelForm):\n+            class Meta:\n+                model = Article\n+                fields = '__all__'\n+\n+            def __init__(self, *args, **kwargs):\n+                super().__init__(*args, **kwargs)\n+                # Allow archived authors.\n+                self.fields['writer'].queryset = Writer._base_manager.all()\n+\n+        w = Writer.objects.create(name='Randy', archived=True)\n+        data = {\n+            'headline': 'My Article',\n+            'slug': 'my-article',\n+            'pub_date': datetime.date.today(),\n+            'writer': w.pk,\n+            'article': 'lorem ipsum',\n+        }\n+        form = MyForm(data)\n+        self.assertIs(form.is_valid(), True)\n+        article = form.save()\n+        self.assertEqual(article.writer, w)\n+\n \n class ModelMultipleChoiceFieldTests(TestCase):\n     @classmethod\ndiff --git a/tests/validation/models.py b/tests/validation/models.py\nindex 47fb895ec5d6..ff9aad11f055 100644\n--- a/tests/validation/models.py\n+++ b/tests/validation/models.py\n@@ -74,8 +74,17 @@ class CustomMessagesModel(models.Model):\n     )\n \n \n+class AuthorManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n+\n class Author(models.Model):\n     name = models.CharField(max_length=100)\n+    archived = models.BooleanField(default=False)\n+\n+    objects = AuthorManager()\n \n \n class Article(models.Model):\ndiff --git a/tests/validation/tests.py b/tests/validation/tests.py\nindex 46fe2f0c7bcc..5598b5ffe6e8 100644\n--- a/tests/validation/tests.py\n+++ b/tests/validation/tests.py\n@@ -48,6 +48,13 @@ def test_limited_FK_raises_error(self):\n         mtv = ModelToValidate(number=10, name='Some Name', parent_id=parent.pk)\n         self.assertFailsValidation(mtv.full_clean, ['parent'])\n \n+    def test_FK_validates_using_base_manager(self):\n+        # Archived articles are not available through the default manager, only\n+        # the base manager.\n+        author = Author.objects.create(name=\"Randy\", archived=True)\n+        article = Article(title='My Article', author=author)\n+        self.assertIsNone(article.full_clean())\n+\n     def test_wrong_email_value_raises_error(self):\n         mtv = ModelToValidate(number=10, name='Some Name', email='not-an-email')\n         self.assertFailsValidation(mtv.full_clean, ['email'])\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13109"}