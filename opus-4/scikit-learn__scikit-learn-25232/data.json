{"instance_id": "scikit-learn__scikit-learn-25232", "score": "C", "diff": "diff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex 1d918bc0c..ec52ce7e8 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -117,6 +117,13 @@ class IterativeImputer(_BaseImputer):\n         Which strategy to use to initialize the missing values. Same as the\n         `strategy` parameter in :class:`~sklearn.impute.SimpleImputer`.\n \n+    fill_value : str or numerical value, default=None\n+        When `initial_strategy == \"constant\"`, `fill_value` is used to replace all\n+        occurrences of missing_values in the first imputation round. For string\n+        or object data types, `fill_value` must be a string.\n+        If `None`, `fill_value` will be 0 when imputing numerical\n+        data and \"missing_value\" for strings or object data types.\n+\n     imputation_order : {'ascending', 'descending', 'roman', 'arabic', \\\n             'random'}, default='ascending'\n         The order in which the features will be imputed. Possible values:\n@@ -285,6 +292,7 @@ class IterativeImputer(_BaseImputer):\n             StrOptions({\"ascending\", \"descending\", \"roman\", \"arabic\", \"random\"})\n         ],\n         \"skip_complete\": [\"boolean\"],\n+        \"fill_value\": \"no_validation\",  # any object is valid\n         \"min_value\": [None, Interval(Real, None, None, closed=\"both\"), \"array-like\"],\n         \"max_value\": [None, Interval(Real, None, None, closed=\"both\"), \"array-like\"],\n         \"verbose\": [\"verbose\"],\n@@ -301,6 +309,7 @@ class IterativeImputer(_BaseImputer):\n         tol=1e-3,\n         n_nearest_features=None,\n         initial_strategy=\"mean\",\n+        fill_value=None,\n         imputation_order=\"ascending\",\n         skip_complete=False,\n         min_value=-np.inf,\n@@ -322,6 +331,7 @@ class IterativeImputer(_BaseImputer):\n         self.tol = tol\n         self.n_nearest_features = n_nearest_features\n         self.initial_strategy = initial_strategy\n+        self.fill_value = fill_value\n         self.imputation_order = imputation_order\n         self.skip_complete = skip_complete\n         self.min_value = min_value\n@@ -613,6 +623,7 @@ class IterativeImputer(_BaseImputer):\n             self.initial_imputer_ = SimpleImputer(\n                 missing_values=self.missing_values,\n                 strategy=self.initial_strategy,\n+                fill_value=self.fill_value,\n                 keep_empty_features=self.keep_empty_features,\n             )\n             X_filled = self.initial_imputer_.fit_transform(X)\ndiff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex 86553effa..d6fde2294 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -1524,6 +1524,57 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):\n     assert_allclose(X_imputed[:, 1], 0)\n \n \n+def test_iterative_imputer_fill_value():\n+    \"\"\"Test IterativeImputer with fill_value parameter when initial_strategy='constant'.\"\"\"\n+    # Test with custom fill_value\n+    X = np.array([[1, 2, np.nan], [4, np.nan, 6], [7, 8, 9]])\n+    \n+    # Test with constant strategy and custom fill_value\n+    imputer = IterativeImputer(\n+        initial_strategy='constant', \n+        fill_value=999,\n+        max_iter=1,\n+        random_state=42\n+    )\n+    imputer.fit_transform(X)\n+    assert imputer.initial_imputer_.fill_value == 999\n+    assert_array_equal(imputer.initial_imputer_.statistics_, [999, 999, 999])\n+    \n+    # Test with np.nan as fill_value\n+    imputer_nan = IterativeImputer(\n+        initial_strategy='constant',\n+        fill_value=np.nan,\n+        max_iter=1,\n+        random_state=42\n+    )\n+    imputer_nan.fit_transform(X)\n+    assert np.isnan(imputer_nan.initial_imputer_.fill_value)\n+    assert np.all(np.isnan(imputer_nan.initial_imputer_.statistics_))\n+    \n+    # Test without fill_value (should use default of None, which becomes 0)\n+    imputer_default = IterativeImputer(\n+        initial_strategy='constant',\n+        max_iter=1,\n+        random_state=42\n+    )\n+    imputer_default.fit_transform(X)\n+    assert imputer_default.initial_imputer_.fill_value is None\n+    assert_array_equal(imputer_default.initial_imputer_.statistics_, [0, 0, 0])\n+    \n+    # Test that fill_value is passed through correctly even with other strategies\n+    # (SimpleImputer will ignore it, but it should still be set)\n+    imputer_mean = IterativeImputer(\n+        initial_strategy='mean',\n+        fill_value=999,\n+        max_iter=1,\n+        random_state=42\n+    )\n+    imputer_mean.fit_transform(X)\n+    assert imputer_mean.initial_imputer_.fill_value == 999\n+    # But statistics should be means, not the fill_value\n+    assert imputer_mean.initial_imputer_.statistics_[0] != 999\n+\n+\n @pytest.mark.parametrize(\"keep_empty_features\", [True, False])\n def test_knn_imputer_keep_empty_features(keep_empty_features):\n     \"\"\"Check the behaviour of `keep_empty_features` for `KNNImputer`.\"\"\"\ndiff --git a/validate_fix.py b/validate_fix.py\nnew file mode 100644\nindex 000000000..8b1378917\n--- /dev/null\n+++ b/validate_fix.py\n@@ -0,0 +1 @@\n+\n", "gold_standard_diff": "diff --git a/doc/whats_new/v1.3.rst b/doc/whats_new/v1.3.rst\nindex fa6d3461d3c78..41fec4980aa99 100644\n--- a/doc/whats_new/v1.3.rst\n+++ b/doc/whats_new/v1.3.rst\n@@ -107,6 +107,12 @@ Changelog\n   inconsistent with the sckit-learn verion the estimator was pickled with.\n   :pr:`25297` by `Thomas Fan`_.\n \n+:mod:`sklearn.impute`\n+.....................\n+\n+- |Enhancement| Added the parameter `fill_value` to :class:`impute.IterativeImputer`.\n+  :pr:`25232` by :user:`Thijs van Weezel <ValueInvestorThijs>`.\n+\n :mod:`sklearn.feature_extraction`\n .................................\n \ndiff --git a/sklearn/impute/_iterative.py b/sklearn/impute/_iterative.py\nindex 1d918bc0c4643..60b2013f9c5f8 100644\n--- a/sklearn/impute/_iterative.py\n+++ b/sklearn/impute/_iterative.py\n@@ -117,6 +117,15 @@ class IterativeImputer(_BaseImputer):\n         Which strategy to use to initialize the missing values. Same as the\n         `strategy` parameter in :class:`~sklearn.impute.SimpleImputer`.\n \n+    fill_value : str or numerical value, default=None\n+        When `strategy=\"constant\"`, `fill_value` is used to replace all\n+        occurrences of missing_values. For string or object data types,\n+        `fill_value` must be a string.\n+        If `None`, `fill_value` will be 0 when imputing numerical\n+        data and \"missing_value\" for strings or object data types.\n+\n+        .. versionadded:: 1.3\n+\n     imputation_order : {'ascending', 'descending', 'roman', 'arabic', \\\n             'random'}, default='ascending'\n         The order in which the features will be imputed. Possible values:\n@@ -281,6 +290,7 @@ class IterativeImputer(_BaseImputer):\n         \"initial_strategy\": [\n             StrOptions({\"mean\", \"median\", \"most_frequent\", \"constant\"})\n         ],\n+        \"fill_value\": \"no_validation\",  # any object is valid\n         \"imputation_order\": [\n             StrOptions({\"ascending\", \"descending\", \"roman\", \"arabic\", \"random\"})\n         ],\n@@ -301,6 +311,7 @@ def __init__(\n         tol=1e-3,\n         n_nearest_features=None,\n         initial_strategy=\"mean\",\n+        fill_value=None,\n         imputation_order=\"ascending\",\n         skip_complete=False,\n         min_value=-np.inf,\n@@ -322,6 +333,7 @@ def __init__(\n         self.tol = tol\n         self.n_nearest_features = n_nearest_features\n         self.initial_strategy = initial_strategy\n+        self.fill_value = fill_value\n         self.imputation_order = imputation_order\n         self.skip_complete = skip_complete\n         self.min_value = min_value\n@@ -613,6 +625,7 @@ def _initial_imputation(self, X, in_fit=False):\n             self.initial_imputer_ = SimpleImputer(\n                 missing_values=self.missing_values,\n                 strategy=self.initial_strategy,\n+                fill_value=self.fill_value,\n                 keep_empty_features=self.keep_empty_features,\n             )\n             X_filled = self.initial_imputer_.fit_transform(X)\ndiff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex 86553effafcbf..8851d10b0f14c 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -1524,6 +1524,21 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):\n     assert_allclose(X_imputed[:, 1], 0)\n \n \n+def test_iterative_imputer_constant_fill_value():\n+    \"\"\"Check that we propagate properly the parameter `fill_value`.\"\"\"\n+    X = np.array([[-1, 2, 3, -1], [4, -1, 5, -1], [6, 7, -1, -1], [8, 9, 0, -1]])\n+\n+    fill_value = 100\n+    imputer = IterativeImputer(\n+        missing_values=-1,\n+        initial_strategy=\"constant\",\n+        fill_value=fill_value,\n+        max_iter=0,\n+    )\n+    imputer.fit_transform(X)\n+    assert_array_equal(imputer.initial_imputer_.statistics_, fill_value)\n+\n+\n @pytest.mark.parametrize(\"keep_empty_features\", [True, False])\n def test_knn_imputer_keep_empty_features(keep_empty_features):\n     \"\"\"Check the behaviour of `keep_empty_features` for `KNNImputer`.\"\"\"\n", "gold_standard_pr_link": "https://github.com/scikit-learn/scikit-learn/pull/25232"}