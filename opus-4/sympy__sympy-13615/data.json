{"instance_id": "sympy__sympy-13615", "score": "C", "diff": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb74..91acc24fa2 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1725,6 +1725,40 @@ def reduce(A, B):\n         if isinstance(B, Union):\n             return Intersection(s.complement(A) for s in B.args)\n \n+        # Special handling for FiniteSet - Interval case with mixed content\n+        if isinstance(A, FiniteSet) and isinstance(B, Interval):\n+            # Separate elements that can be evaluated vs those that cannot\n+            definite_in = []\n+            definite_out = []\n+            unknown = []\n+            \n+            for elem in A:\n+                contains_result = B.contains(elem)\n+                if contains_result is S.true:\n+                    definite_in.append(elem)\n+                elif contains_result is S.false:\n+                    definite_out.append(elem)\n+                else:\n+                    unknown.append(elem)\n+            \n+            # If we have unknown elements, we need to keep them as Complement\n+            if unknown:\n+                result_parts = []\n+                if definite_out:\n+                    result_parts.append(FiniteSet(*definite_out))\n+                if unknown:\n+                    result_parts.append(Complement(FiniteSet(*unknown), B, evaluate=False))\n+                \n+                if len(result_parts) == 0:\n+                    return EmptySet()\n+                elif len(result_parts) == 1:\n+                    return result_parts[0]\n+                else:\n+                    return Union(*result_parts)\n+            else:\n+                # All elements can be definitively classified\n+                return FiniteSet(*definite_out) if definite_out else EmptySet()\n+\n         result = B._complement(A)\n         if result != None:\n             return result\ndiff --git a/test_complement_comprehensive.py b/test_complement_comprehensive.py\nnew file mode 100644\nindex 0000000000..5656ce5f68\n--- /dev/null\n+++ b/test_complement_comprehensive.py\n@@ -0,0 +1,70 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Union\n+\n+x, y, z = symbols('x y z')\n+\n+print(\"Test cases:\")\n+print()\n+\n+# Original issue case\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+result = Complement(a, b)\n+print(f\"1. Complement({a}, {b}) = {result}\")\n+print(\"   Expected: {x, y} \\\\ [-10, 10]\")\n+expected1 = '{x, y} \\\\ Interval(-10, 10)'\n+print(f\"   Pass: {str(result) == expected1}\")\n+print()\n+\n+# Case with only numbers\n+c = FiniteSet(1, 2, 3, 15)\n+d = Interval(0, 10)\n+result2 = Complement(c, d)\n+print(f\"2. Complement({c}, {d}) = {result2}\")\n+print(\"   Expected: {15}\")\n+print(f\"   Pass: {result2 == FiniteSet(15)}\")\n+print()\n+\n+# Case with only symbols\n+e = FiniteSet(x, y, z)\n+f = Interval(0, 10)\n+result3 = Complement(e, f)\n+print(f\"3. Complement({e}, {f}) = {result3}\")\n+print(\"   Expected: {x, y, z} \\\\ [0, 10]\")\n+expected3 = '{x, y, z} \\\\ Interval(0, 10)'\n+print(f\"   Pass: {str(result3) == expected3}\")\n+print()\n+\n+# Mixed case with some numbers in interval, some out\n+g = FiniteSet(x, y, 5, 15)\n+h = Interval(0, 10)\n+result4 = Complement(g, h)\n+print(f\"4. Complement({g}, {h}) = {result4}\")\n+print(\"   Expected: Union({15}, {x, y} \\\\ [0, 10])\")\n+print(f\"   Pass: {isinstance(result4, Union)}\")\n+print()\n+\n+# Empty result case\n+i = FiniteSet(5, 6, 7)\n+j = Interval(0, 10)\n+result5 = Complement(i, j)\n+print(f\"5. Complement({i}, {j}) = {result5}\")\n+print(\"   Expected: EmptySet\")\n+print(f\"   Pass: {result5 == S.EmptySet}\")\n+print()\n+\n+# Test that other Complement operations still work\n+k = Interval(0, 5)\n+l = Interval(2, 7)\n+result6 = Complement(k, l)\n+print(f\"6. Complement({k}, {l}) = {result6}\")\n+print(\"   Expected: [0, 2)\")\n+print(f\"   Pass: {result6 == Interval(0, 2, False, True)}\")\n+print()\n+\n+# FiniteSet - FiniteSet\n+m = FiniteSet(1, 2, 3, x)\n+n = FiniteSet(2, 3, y)\n+result7 = Complement(m, n)\n+print(f\"7. Complement({m}, {n}) = {result7}\")\n+# This should use the existing FiniteSet logic\n+print(f\"   Pass: {1 in result7 and x in result7 and 2 not in result7}\")\ndiff --git a/test_complement_debug.py b/test_complement_debug.py\nnew file mode 100644\nindex 0000000000..f468591724\n--- /dev/null\n+++ b/test_complement_debug.py\n@@ -0,0 +1,26 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection\n+\n+x, y = symbols('x y')\n+\n+# Test what happens in the complement operation\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+\n+print(\"Step by step:\")\n+print(f\"a = {a}\")\n+print(f\"b = {b}\")\n+print()\n+\n+# What does a.complement(S.Reals) return?\n+comp_reals = a.complement(S.Reals)\n+print(f\"a.complement(S.Reals) = {comp_reals}\")\n+print()\n+\n+# What does Intersection(b, comp_reals) return?\n+result = Intersection(b, comp_reals)\n+print(f\"Intersection(b, a.complement(S.Reals)) = {result}\")\n+print()\n+\n+# Let's look at the actual Complement object\n+comp = Complement(a, b, evaluate=False)\n+print(f\"Complement(a, b, evaluate=False) = {comp}\")\ndiff --git a/test_complement_issue.py b/test_complement_issue.py\nnew file mode 100644\nindex 0000000000..0bbb2bac9c\n--- /dev/null\n+++ b/test_complement_issue.py\n@@ -0,0 +1,15 @@\n+from sympy import FiniteSet, Interval, Complement, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test case from the issue\n+a = FiniteSet(x, y, 2)\n+b = Interval(-10, 10)\n+result = Complement(a, b)\n+print(f\"Complement({a}, {b}) = {result}\")\n+print(f\"Expected: {{x, y}} \\\\ [-10, 10]\")\n+print()\n+\n+# Let's also test the reverse\n+c = Complement(b, a)\n+print(f\"Complement({b}, {a}) = {c}\")\ndiff --git a/test_complement_semantics.py b/test_complement_semantics.py\nnew file mode 100644\nindex 0000000000..f7f6d397a3\n--- /dev/null\n+++ b/test_complement_semantics.py\n@@ -0,0 +1,43 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection\n+\n+# Let's understand the semantics of _complement\n+\n+# First, let's see what Set._complement does\n+print(\"Testing Set._complement:\")\n+a = Interval(0, 5)\n+b = FiniteSet(2, 3)\n+\n+# According to the comment in Set._complement, it behaves as other - self\n+# So a._complement(b) should be b - a = EmptySet (since 2, 3 are in [0, 5])\n+print(f\"Interval(0, 5)._complement(FiniteSet(2, 3)) = {a._complement(b)}\")\n+print(\"This should be FiniteSet(2, 3) - Interval(0, 5) = EmptySet\")\n+print()\n+\n+# Let's verify by creating the Complement directly\n+print(f\"Complement(FiniteSet(2, 3), Interval(0, 5)) = {Complement(FiniteSet(2, 3), Interval(0, 5))}\")\n+print()\n+\n+# Now let's trace through what happens in our problematic case\n+x, y = symbols('x y')\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+print(\"Tracing Complement(FiniteSet(x, y, 2), Interval(-10, 10)):\")\n+print(\"1. Complement.reduce is called\")\n+print(\"2. It calls interval._complement(fs)\")\n+print(\"3. Since fs contains a number (2), Interval._complement calls Set._complement\")\n+print(\"4. Set._complement (line 206-208) returns Intersection(interval, fs.complement(S.Reals))\")\n+print()\n+\n+# What is fs.complement(S.Reals)?\n+comp = fs.complement(S.Reals)\n+print(f\"fs.complement(S.Reals) = {comp}\")\n+print()\n+\n+# What is the intersection?\n+inter = Intersection(interval, comp)\n+print(f\"Intersection(interval, fs.complement(S.Reals)) = {inter}\")\n+print()\n+\n+# This is computing interval - fs, not fs - interval!\n+print(\"So the current code computes interval - fs = {x, y}, not fs - interval!\")\ndiff --git a/test_complement_verify.py b/test_complement_verify.py\nnew file mode 100644\nindex 0000000000..c1ed8d7f40\n--- /dev/null\n+++ b/test_complement_verify.py\n@@ -0,0 +1,32 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S\n+\n+# Test to verify the semantic issue\n+\n+# Simple case: FiniteSet - FiniteSet\n+a = FiniteSet(1, 2, 3)\n+b = FiniteSet(2, 3, 4)\n+print(f\"Complement({a}, {b}) = {Complement(a, b)}\")\n+print(f\"Expected: {{1}}\")\n+print()\n+\n+# Another simple case: Interval - Interval\n+c = Interval(0, 5)\n+d = Interval(2, 7)\n+print(f\"Complement({c}, {d}) = {Complement(c, d)}\")\n+print(f\"Expected: [0, 2)\")\n+print()\n+\n+# The problematic case from the issue\n+x, y = symbols('x y')\n+e = FiniteSet(x, y, 2)\n+f = Interval(-10, 10)\n+print(f\"Complement({e}, {f}) = {Complement(e, f)}\")\n+print(f\"Expected: {{x, y}} \\\\ [-10, 10]\")\n+print()\n+\n+# Check what B._complement(A) actually computes\n+g = Interval(0, 5)\n+h = FiniteSet(2, 3)\n+# g._complement(h) should compute g - h = [0, 2) U (2, 3) U (3, 5]\n+print(f\"Interval(0, 5)._complement(FiniteSet(2, 3)) = {g._complement(h)}\")\n+print(\"This shows that B._complement(A) computes B - A, not A - B!\")\ndiff --git a/test_contains_check.py b/test_contains_check.py\nnew file mode 100644\nindex 0000000000..2ddf0370f0\n--- /dev/null\n+++ b/test_contains_check.py\n@@ -0,0 +1,19 @@\n+from sympy import FiniteSet, Interval, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test what elements are contained\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+print(\"Checking which elements of FiniteSet(x, y, 2) are in Interval(-10, 10):\")\n+for el in fs:\n+    contained = interval.contains(el)\n+    print(f\"  {el} in interval: {contained}\")\n+    print(f\"  {el} in interval != True: {contained != True}\")\n+print()\n+\n+# So the result should be elements where contains != True\n+result = [el for el in fs if interval.contains(el) != True]\n+print(f\"Elements where interval.contains(el) != True: {result}\")\n+print(f\"FiniteSet of these elements: {FiniteSet(*result)}\")\ndiff --git a/test_interval_complement.py b/test_interval_complement.py\nnew file mode 100644\nindex 0000000000..ea6fc0c788\n--- /dev/null\n+++ b/test_interval_complement.py\n@@ -0,0 +1,35 @@\n+from sympy import FiniteSet, Interval, symbols\n+\n+x, y = symbols('x y')\n+\n+# Test Interval._complement with FiniteSet\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+# Check what happens in Interval._complement\n+print(\"In Interval._complement(self, other) where self=Interval(-10,10), other=FiniteSet(x,y,2):\")\n+print()\n+\n+# Line 1001-1002: check if other is FiniteSet\n+print(\"isinstance(other, FiniteSet):\", isinstance(fs, FiniteSet))\n+\n+# Line 1002: extract numbers from other\n+nums = [m for m in fs.args if m.is_number]\n+print(f\"nums = [m for m in other.args if m.is_number] = {nums}\")\n+\n+# Line 1003-1004: check if nums is empty\n+print(f\"nums == [] : {nums == []}\")\n+print()\n+\n+# Since nums is not empty ([2]), it goes to line 1006\n+print(\"Since nums is not empty, it calls Set._complement(self, other)\")\n+print(\"which should return the intersection computation...\")\n+print()\n+\n+# But we're getting {x, y} instead. Let me check if there's something else going on\n+from sympy.sets.sets import Set\n+\n+# What does the base Set._complement return?\n+base_result = Set._complement(interval, fs)\n+print(f\"Set._complement(interval, fs) = {base_result}\")\n+print(f\"Type: {type(base_result)}\")\ndiff --git a/test_trace_simplification.py b/test_trace_simplification.py\nnew file mode 100644\nindex 0000000000..0a7afe5108\n--- /dev/null\n+++ b/test_trace_simplification.py\n@@ -0,0 +1,32 @@\n+from sympy import FiniteSet, Interval, Complement, symbols, S, Intersection, Union\n+from sympy.sets.sets import Set\n+\n+x, y = symbols('x y')\n+\n+# Create our sets\n+fs = FiniteSet(x, y, 2)\n+interval = Interval(-10, 10)\n+\n+# What does interval._complement(fs) return?\n+print(\"Calling interval._complement(fs):\")\n+result = interval._complement(fs)\n+print(f\"Result: {result}\")\n+print(f\"Type: {type(result)}\")\n+print()\n+\n+# What does Set._complement(fs, interval) return?\n+print(\"Calling Set._complement(fs, interval):\")\n+result2 = Set._complement(fs, interval)\n+print(f\"Result: {result2}\")\n+print()\n+\n+# Let's manually compute what should happen\n+print(\"Manual computation:\")\n+print(f\"fs.complement(S.Reals) = {fs.complement(S.Reals)}\")\n+comp = fs.complement(S.Reals)\n+print(f\"Intersection(interval, comp) = {Intersection(interval, comp)}\")\n+\n+# Let's see what this evaluates to\n+inter = Intersection(interval, comp, evaluate=False)\n+print(f\"Intersection(interval, comp, evaluate=False) = {inter}\")\n+print(f\"After evaluation: {inter.doit()}\")\n", "gold_standard_diff": "From 3a87abbfdac36ca6ead627c47c1876889bf79948 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 01:40:44 +0530\nSubject: [PATCH 1/9] fixed bug in finding Complement\n\n---\n sympy/sets/sets.py | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 773096d6e9b2..4268d55fa20e 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -215,8 +215,16 @@ def _complement(self, other):\n         elif isinstance(other, EmptySet):\n             return S.EmptySet\n \n-        elif isinstance(other, FiniteSet):\n-            return FiniteSet(*[el for el in other if self.contains(el) != True])\n+        elif isinstance(other, FiniteSet): \n+            both_l = non_num, num = [], []\n+            for el in other:\n+                both_l[el.is_number].append(el)\n+            non_num = FiniteSet(*non_num)\n+            out_range = FiniteSet(*[el for el in num if self.contains(el) != True])\n+            if non_num:\n+                return Union(out_range, Complement(non_num , self , evaluate =False))\n+            else:\n+                return out_range\n \n     def symmetric_difference(self, other):\n         \"\"\"\n\nFrom afd1e1a6390a8e693f19cd32b357041513058dc6 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 01:41:02 +0530\nSubject: [PATCH 2/9] added tests\n\n---\n sympy/sets/tests/test_sets.py | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 8c59d85b2045..8673d56db3cd 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -187,6 +187,10 @@ def test_Complement():\n \n     assert S.Reals - Union(S.Naturals, FiniteSet(pi)) == \\\n             Intersection(S.Reals - S.Naturals, S.Reals - FiniteSet(pi))\n+    # isssue 12712\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n+            Complement(FiniteSet(x, y), Interval(-10, 10)) \n+\n \n def test_complement():\n     assert Interval(0, 1).complement(S.Reals) == \\\n\nFrom f18d22c8bf95c5d11d43cc9fcbb14b8f900ac7a9 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 01:43:25 +0530\nSubject: [PATCH 3/9] removed whitespace errors\n\n---\n sympy/sets/sets.py            | 2 +-\n sympy/sets/tests/test_sets.py | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 4268d55fa20e..e3b40838a277 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -215,7 +215,7 @@ def _complement(self, other):\n         elif isinstance(other, EmptySet):\n             return S.EmptySet\n \n-        elif isinstance(other, FiniteSet): \n+        elif isinstance(other, FiniteSet):\n             both_l = non_num, num = [], []\n             for el in other:\n                 both_l[el.is_number].append(el)\ndiff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 8673d56db3cd..f4d0483197ed 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -189,7 +189,7 @@ def test_Complement():\n             Intersection(S.Reals - S.Naturals, S.Reals - FiniteSet(pi))\n     # isssue 12712\n     assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n-            Complement(FiniteSet(x, y), Interval(-10, 10)) \n+            Complement(FiniteSet(x, y), Interval(-10, 10))\n \n \n def test_complement():\n\nFrom 3d5846014f8c6074cd8adc3f91e0bce12ed5f064 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 12:51:15 +0530\nSubject: [PATCH 4/9] improved code qulaity\n\n---\n sympy/sets/sets.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex e3b40838a277..6876985fdcef 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -222,7 +222,7 @@ def _complement(self, other):\n             non_num = FiniteSet(*non_num)\n             out_range = FiniteSet(*[el for el in num if self.contains(el) != True])\n             if non_num:\n-                return Union(out_range, Complement(non_num , self , evaluate =False))\n+                return Union(out_range, Complement(non_num, self, evaluate = False))\n             else:\n                 return out_range\n \n\nFrom 2c6c7e4dd3311e43d22764f4522a1657ccc0a1fd Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 16:13:38 +0530\nSubject: [PATCH 5/9] updated condition\n\n---\n sympy/sets/sets.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 6876985fdcef..d05ceb9a826e 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -220,7 +220,7 @@ def _complement(self, other):\n             for el in other:\n                 both_l[el.is_number].append(el)\n             non_num = FiniteSet(*non_num)\n-            out_range = FiniteSet(*[el for el in num if self.contains(el) != True])\n+            out_range = FiniteSet(*[el for el in num if self.contains(el) == False])\n             if non_num:\n                 return Union(out_range, Complement(non_num, self, evaluate = False))\n             else:\n\nFrom d25a5983752629f55d5ba191c79c66d15c3069d2 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Fri, 17 Nov 2017 20:46:22 +0530\nSubject: [PATCH 6/9] updated condition for None\n\n---\n sympy/sets/sets.py | 12 +++++-------\n 1 file changed, 5 insertions(+), 7 deletions(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex d05ceb9a826e..a8aec26d73f8 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -216,13 +216,11 @@ def _complement(self, other):\n             return S.EmptySet\n \n         elif isinstance(other, FiniteSet):\n-            both_l = non_num, num = [], []\n-            for el in other:\n-                both_l[el.is_number].append(el)\n-            non_num = FiniteSet(*non_num)\n-            out_range = FiniteSet(*[el for el in num if self.contains(el) == False])\n-            if non_num:\n-                return Union(out_range, Complement(non_num, self, evaluate = False))\n+\n+            none_range = FiniteSet(*[el for el in other if self.contains(el) not in [True, False]])\n+            out_range = FiniteSet(*[el for el in other if self.contains(el) == False])\n+            if none_range:\n+                return Union(out_range, Complement(none_range, self, evaluate = False))\n             else:\n                 return out_range\n \n\nFrom 0792dc0ada835c1b9285148bdf982bd2f1cf3feb Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Sun, 19 Nov 2017 06:26:48 +0530\nSubject: [PATCH 7/9] removed spaces\n\n---\n sympy/sets/sets.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex a8aec26d73f8..b28bfb99af20 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -220,7 +220,7 @@ def _complement(self, other):\n             none_range = FiniteSet(*[el for el in other if self.contains(el) not in [True, False]])\n             out_range = FiniteSet(*[el for el in other if self.contains(el) == False])\n             if none_range:\n-                return Union(out_range, Complement(none_range, self, evaluate = False))\n+                return Union(out_range, Complement(none_range, self, evaluate=False))\n             else:\n                 return out_range\n \n\nFrom 0837cd5448f03575eaccd3f4ef4178ed03946cf7 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Mon, 20 Nov 2017 11:11:45 +0530\nSubject: [PATCH 8/9] added a ternary_sift function\n\n---\n sympy/sets/sets.py | 16 ++++++++++------\n 1 file changed, 10 insertions(+), 6 deletions(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 632ea858532f..ee05e00f421e 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -217,13 +217,17 @@ def _complement(self, other):\n             return S.EmptySet\n \n         elif isinstance(other, FiniteSet):\n+            from sympy.utilities.iterables import sift\n \n-            none_range = FiniteSet(*[el for el in other if self.contains(el) not in [True, False]])\n-            out_range = FiniteSet(*[el for el in other if self.contains(el) == False])\n-            if none_range:\n-                return Union(out_range, Complement(none_range, self, evaluate=False))\n-            else:\n-                return out_range\n+            def ternary_sift(el):\n+                contains = self.contains(el)\n+                return contains if contains in [True, False] else None\n+\n+            sifted = sift(other, lambda i: ternary_sift(i))\n+            # ignore those that are contained in self\n+            return Union(FiniteSet(*(sifted[False])),\n+                Complement(FiniteSet(*(sifted[None])), self, evaluate=False)\n+                if sifted[None] else S.EmptySet)\n \n     def symmetric_difference(self, other):\n         \"\"\"\n\nFrom 98df0946fba625988de13eed6ef414ab7e29b183 Mon Sep 17 00:00:00 2001\nFrom: ashishkg0022 <ashishkg0022@gmail.com>\nDate: Mon, 20 Nov 2017 17:34:14 +0530\nSubject: [PATCH 9/9] update function passing\n\n---\n sympy/sets/sets.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex ee05e00f421e..659b778808ae 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -223,7 +223,7 @@ def ternary_sift(el):\n                 contains = self.contains(el)\n                 return contains if contains in [True, False] else None\n \n-            sifted = sift(other, lambda i: ternary_sift(i))\n+            sifted = sift(other, ternary_sift)\n             # ignore those that are contained in self\n             return Union(FiniteSet(*(sifted[False])),\n                 Complement(FiniteSet(*(sifted[None])), self, evaluate=False)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13615"}