{"instance_id": "sympy__sympy-23413", "score": "I", "diff": "diff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b08..4c5d084d8f 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -245,7 +245,11 @@ def _hermite_normal_form(A):\n                 add_columns(A, j, k, 1, -q, 0, 1)\n     # Finally, the HNF consists of those columns of A in which we succeeded in making\n     # a nonzero pivot.\n-    return DomainMatrix.from_rep(A)[:, k:]\n+    # When m > n, we need to return all columns to preserve rank\n+    if m > n:\n+        return DomainMatrix.from_rep(A)\n+    else:\n+        return DomainMatrix.from_rep(A)[:, k:]\n \n \n def _hermite_normal_form_modulo_D(A, D):\ndiff --git a/sympy/polys/matrices/normalforms.py.backup b/sympy/polys/matrices/normalforms.py.backup\nnew file mode 100644\nindex 0000000000..30f5534b08\n--- /dev/null\n+++ b/sympy/polys/matrices/normalforms.py.backup\n@@ -0,0 +1,403 @@\n+'''Functions returning normal forms of matrices'''\n+\n+from collections import defaultdict\n+\n+from .domainmatrix import DomainMatrix\n+from .exceptions import DMDomainError, DMShapeError\n+from sympy.ntheory.modular import symmetric_residue\n+from sympy.polys.domains import QQ, ZZ\n+\n+\n+# TODO (future work):\n+#  There are faster algorithms for Smith and Hermite normal forms, which\n+#  we should implement. See e.g. the Kannan-Bachem algorithm:\n+#  <https://www.researchgate.net/publication/220617516_Polynomial_Algorithms_for_Computing_the_Smith_and_Hermite_Normal_Forms_of_an_Integer_Matrix>\n+\n+\n+def smith_normal_form(m):\n+    '''\n+    Return the Smith Normal Form of a matrix `m` over the ring `domain`.\n+    This will only work if the ring is a principal ideal domain.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import ZZ\n+    >>> from sympy.polys.matrices import DomainMatrix\n+    >>> from sympy.polys.matrices.normalforms import smith_normal_form\n+    >>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n+    ...                   [ZZ(3), ZZ(9), ZZ(6)],\n+    ...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n+    >>> print(smith_normal_form(m).to_Matrix())\n+    Matrix([[1, 0, 0], [0, 10, 0], [0, 0, -30]])\n+\n+    '''\n+    invs = invariant_factors(m)\n+    smf = DomainMatrix.diag(invs, m.domain, m.shape)\n+    return smf\n+\n+\n+def add_columns(m, i, j, a, b, c, d):\n+    # replace m[:, i] by a*m[:, i] + b*m[:, j]\n+    # and m[:, j] by c*m[:, i] + d*m[:, j]\n+    for k in range(len(m)):\n+        e = m[k][i]\n+        m[k][i] = a*e + b*m[k][j]\n+        m[k][j] = c*e + d*m[k][j]\n+\n+\n+def invariant_factors(m):\n+    '''\n+    Return the tuple of abelian invariants for a matrix `m`\n+    (as in the Smith-Normal form)\n+\n+    References\n+    ==========\n+\n+    [1] https://en.wikipedia.org/wiki/Smith_normal_form#Algorithm\n+    [2] http://sierra.nmsu.edu/morandi/notes/SmithNormalForm.pdf\n+\n+    '''\n+    domain = m.domain\n+    if not domain.is_PID:\n+        msg = \"The matrix entries must be over a principal ideal domain\"\n+        raise ValueError(msg)\n+\n+    if 0 in m.shape:\n+        return ()\n+\n+    rows, cols = shape = m.shape\n+    m = list(m.to_dense().rep)\n+\n+    def add_rows(m, i, j, a, b, c, d):\n+        # replace m[i, :] by a*m[i, :] + b*m[j, :]\n+        # and m[j, :] by c*m[i, :] + d*m[j, :]\n+        for k in range(cols):\n+            e = m[i][k]\n+            m[i][k] = a*e + b*m[j][k]\n+            m[j][k] = c*e + d*m[j][k]\n+\n+    def clear_column(m):\n+        # make m[1:, 0] zero by row and column operations\n+        if m[0][0] == 0:\n+            return m  # pragma: nocover\n+        pivot = m[0][0]\n+        for j in range(1, rows):\n+            if m[j][0] == 0:\n+                continue\n+            d, r = domain.div(m[j][0], pivot)\n+            if r == 0:\n+                add_rows(m, 0, j, 1, 0, -d, 1)\n+            else:\n+                a, b, g = domain.gcdex(pivot, m[j][0])\n+                d_0 = domain.div(m[j][0], g)[0]\n+                d_j = domain.div(pivot, g)[0]\n+                add_rows(m, 0, j, a, b, d_0, -d_j)\n+                pivot = g\n+        return m\n+\n+    def clear_row(m):\n+        # make m[0, 1:] zero by row and column operations\n+        if m[0][0] == 0:\n+            return m  # pragma: nocover\n+        pivot = m[0][0]\n+        for j in range(1, cols):\n+            if m[0][j] == 0:\n+                continue\n+            d, r = domain.div(m[0][j], pivot)\n+            if r == 0:\n+                add_columns(m, 0, j, 1, 0, -d, 1)\n+            else:\n+                a, b, g = domain.gcdex(pivot, m[0][j])\n+                d_0 = domain.div(m[0][j], g)[0]\n+                d_j = domain.div(pivot, g)[0]\n+                add_columns(m, 0, j, a, b, d_0, -d_j)\n+                pivot = g\n+        return m\n+\n+    # permute the rows and columns until m[0,0] is non-zero if possible\n+    ind = [i for i in range(rows) if m[i][0] != 0]\n+    if ind and ind[0] != 0:\n+        m[0], m[ind[0]] = m[ind[0]], m[0]\n+    else:\n+        ind = [j for j in range(cols) if m[0][j] != 0]\n+        if ind and ind[0] != 0:\n+            for row in m:\n+                row[0], row[ind[0]] = row[ind[0]], row[0]\n+\n+    # make the first row and column except m[0,0] zero\n+    while (any(m[0][i] != 0 for i in range(1,cols)) or\n+           any(m[i][0] != 0 for i in range(1,rows))):\n+        m = clear_column(m)\n+        m = clear_row(m)\n+\n+    if 1 in shape:\n+        invs = ()\n+    else:\n+        lower_right = DomainMatrix([r[1:] for r in m[1:]], (rows-1, cols-1), domain)\n+        invs = invariant_factors(lower_right)\n+\n+    if m[0][0]:\n+        result = [m[0][0]]\n+        result.extend(invs)\n+        # in case m[0] doesn't divide the invariants of the rest of the matrix\n+        for i in range(len(result)-1):\n+            if result[i] and domain.div(result[i+1], result[i])[1] != 0:\n+                g = domain.gcd(result[i+1], result[i])\n+                result[i+1] = domain.div(result[i], g)[0]*result[i+1]\n+                result[i] = g\n+            else:\n+                break\n+    else:\n+        result = invs + (m[0][0],)\n+    return tuple(result)\n+\n+\n+def _gcdex(a, b):\n+    r\"\"\"\n+    This supports the functions that compute Hermite Normal Form.\n+\n+    Explanation\n+    ===========\n+\n+    Let x, y be the coefficients returned by the extended Euclidean\n+    Algorithm, so that x*a + y*b = g. In the algorithms for computing HNF,\n+    it is critical that x, y not only satisfy the condition of being small\n+    in magnitude -- namely that |x| <= |b|/g, |y| <- |a|/g -- but also that\n+    y == 0 when a | b.\n+\n+    \"\"\"\n+    x, y, g = ZZ.gcdex(a, b)\n+    if a != 0 and b % a == 0:\n+        y = 0\n+        x = -1 if a < 0 else 1\n+    return x, y, g\n+\n+\n+def _hermite_normal_form(A):\n+    r\"\"\"\n+    Compute the Hermite Normal Form of DomainMatrix *A* over :ref:`ZZ`.\n+\n+    Parameters\n+    ==========\n+\n+    A : :py:class:`~.DomainMatrix` over domain :ref:`ZZ`.\n+\n+    Returns\n+    =======\n+\n+    :py:class:`~.DomainMatrix`\n+        The HNF of matrix *A*.\n+\n+    Raises\n+    ======\n+\n+    DMDomainError\n+        If the domain of the matrix is not :ref:`ZZ`.\n+\n+    References\n+    ==========\n+\n+    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n+       (See Algorithm 2.4.5.)\n+\n+    \"\"\"\n+    if not A.domain.is_ZZ:\n+        raise DMDomainError('Matrix must be over domain ZZ.')\n+    # We work one row at a time, starting from the bottom row, and working our\n+    # way up. The total number of rows we will consider is min(m, n), where\n+    # A is an m x n matrix.\n+    m, n = A.shape\n+    rows = min(m, n)\n+    A = A.to_dense().rep.copy()\n+    # Our goal is to put pivot entries in the rightmost columns.\n+    # Invariant: Before processing each row, k should be the index of the\n+    # leftmost column in which we have so far put a pivot.\n+    k = n\n+    for i in range(m - 1, m - 1 - rows, -1):\n+        k -= 1\n+        # k now points to the column in which we want to put a pivot.\n+        # We want zeros in all entries to the left of the pivot column.\n+        for j in range(k - 1, -1, -1):\n+            if A[i][j] != 0:\n+                # Replace cols j, k by lin combs of these cols such that, in row i,\n+                # col j has 0, while col k has the gcd of their row i entries. Note\n+                # that this ensures a nonzero entry in col k.\n+                u, v, d = _gcdex(A[i][k], A[i][j])\n+                r, s = A[i][k] // d, A[i][j] // d\n+                add_columns(A, k, j, u, v, -s, r)\n+        b = A[i][k]\n+        # Do not want the pivot entry to be negative.\n+        if b < 0:\n+            add_columns(A, k, k, -1, 0, -1, 0)\n+            b = -b\n+        # The pivot entry will be 0 iff the row was 0 from the pivot col all the\n+        # way to the left. In this case, we are still working on the same pivot\n+        # col for the next row. Therefore:\n+        if b == 0:\n+            k += 1\n+        # If the pivot entry is nonzero, then we want to reduce all entries to its\n+        # right in the sense of the division algorithm, i.e. make them all remainders\n+        # w.r.t. the pivot as divisor.\n+        else:\n+            for j in range(k + 1, n):\n+                q = A[i][j] // b\n+                add_columns(A, j, k, 1, -q, 0, 1)\n+    # Finally, the HNF consists of those columns of A in which we succeeded in making\n+    # a nonzero pivot.\n+    return DomainMatrix.from_rep(A)[:, k:]\n+\n+\n+def _hermite_normal_form_modulo_D(A, D):\n+    r\"\"\"\n+    Perform the mod *D* Hermite Normal Form reduction algorithm on\n+    :py:class:`~.DomainMatrix` *A*.\n+\n+    Explanation\n+    ===========\n+\n+    If *A* is an $m \\times n$ matrix of rank $m$, having Hermite Normal Form\n+    $W$, and if *D* is any positive integer known in advance to be a multiple\n+    of $\\det(W)$, then the HNF of *A* can be computed by an algorithm that\n+    works mod *D* in order to prevent coefficient explosion.\n+\n+    Parameters\n+    ==========\n+\n+    A : :py:class:`~.DomainMatrix` over :ref:`ZZ`\n+        $m \\times n$ matrix, having rank $m$.\n+    D : :ref:`ZZ`\n+        Positive integer, known to be a multiple of the determinant of the\n+        HNF of *A*.\n+\n+    Returns\n+    =======\n+\n+    :py:class:`~.DomainMatrix`\n+        The HNF of matrix *A*.\n+\n+    Raises\n+    ======\n+\n+    DMDomainError\n+        If the domain of the matrix is not :ref:`ZZ`, or\n+        if *D* is given but is not in :ref:`ZZ`.\n+\n+    DMShapeError\n+        If the matrix has more rows than columns.\n+\n+    References\n+    ==========\n+\n+    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n+       (See Algorithm 2.4.8.)\n+\n+    \"\"\"\n+    if not A.domain.is_ZZ:\n+        raise DMDomainError('Matrix must be over domain ZZ.')\n+    if not ZZ.of_type(D) or D < 1:\n+        raise DMDomainError('Modulus D must be positive element of domain ZZ.')\n+\n+    def add_columns_mod_R(m, R, i, j, a, b, c, d):\n+        # replace m[:, i] by (a*m[:, i] + b*m[:, j]) % R\n+        # and m[:, j] by (c*m[:, i] + d*m[:, j]) % R\n+        for k in range(len(m)):\n+            e = m[k][i]\n+            m[k][i] = symmetric_residue((a * e + b * m[k][j]) % R, R)\n+            m[k][j] = symmetric_residue((c * e + d * m[k][j]) % R, R)\n+\n+    W = defaultdict(dict)\n+\n+    m, n = A.shape\n+    if n < m:\n+        raise DMShapeError('Matrix must have at least as many columns as rows.')\n+    A = A.to_dense().rep.copy()\n+    k = n\n+    R = D\n+    for i in range(m - 1, -1, -1):\n+        k -= 1\n+        for j in range(k - 1, -1, -1):\n+            if A[i][j] != 0:\n+                u, v, d = _gcdex(A[i][k], A[i][j])\n+                r, s = A[i][k] // d, A[i][j] // d\n+                add_columns_mod_R(A, R, k, j, u, v, -s, r)\n+        b = A[i][k]\n+        if b == 0:\n+            A[i][k] = b = R\n+        u, v, d = _gcdex(b, R)\n+        for ii in range(m):\n+            W[ii][i] = u*A[ii][k] % R\n+        if W[i][i] == 0:\n+            W[i][i] = R\n+        for j in range(i + 1, m):\n+            q = W[i][j] // W[i][i]\n+            add_columns(W, j, i, 1, -q, 0, 1)\n+        R //= d\n+    return DomainMatrix(W, (m, m), ZZ).to_dense()\n+\n+\n+def hermite_normal_form(A, *, D=None, check_rank=False):\n+    r\"\"\"\n+    Compute the Hermite Normal Form of :py:class:`~.DomainMatrix` *A* over\n+    :ref:`ZZ`.\n+\n+    Examples\n+    ========\n+\n+    >>> from sympy import ZZ\n+    >>> from sympy.polys.matrices import DomainMatrix\n+    >>> from sympy.polys.matrices.normalforms import hermite_normal_form\n+    >>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n+    ...                   [ZZ(3), ZZ(9), ZZ(6)],\n+    ...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n+    >>> print(hermite_normal_form(m).to_Matrix())\n+    Matrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]])\n+\n+    Parameters\n+    ==========\n+\n+    A : $m \\times n$ ``DomainMatrix`` over :ref:`ZZ`.\n+\n+    D : :ref:`ZZ`, optional\n+        Let $W$ be the HNF of *A*. If known in advance, a positive integer *D*\n+        being any multiple of $\\det(W)$ may be provided. In this case, if *A*\n+        also has rank $m$, then we may use an alternative algorithm that works\n+        mod *D* in order to prevent coefficient explosion.\n+\n+    check_rank : boolean, optional (default=False)\n+        The basic assumption is that, if you pass a value for *D*, then\n+        you already believe that *A* has rank $m$, so we do not waste time\n+        checking it for you. If you do want this to be checked (and the\n+        ordinary, non-modulo *D* algorithm to be used if the check fails), then\n+        set *check_rank* to ``True``.\n+\n+    Returns\n+    =======\n+\n+    :py:class:`~.DomainMatrix`\n+        The HNF of matrix *A*.\n+\n+    Raises\n+    ======\n+\n+    DMDomainError\n+        If the domain of the matrix is not :ref:`ZZ`, or\n+        if *D* is given but is not in :ref:`ZZ`.\n+\n+    DMShapeError\n+        If the mod *D* algorithm is used but the matrix has more rows than\n+        columns.\n+\n+    References\n+    ==========\n+\n+    .. [1] Cohen, H. *A Course in Computational Algebraic Number Theory.*\n+       (See Algorithms 2.4.5 and 2.4.8.)\n+\n+    \"\"\"\n+    if not A.domain.is_ZZ:\n+        raise DMDomainError('Matrix must be over domain ZZ.')\n+    if D is not None and (not check_rank or A.convert_to(QQ).rank() == A.shape[0]):\n+        return _hermite_normal_form_modulo_D(A, D)\n+    else:\n+        return _hermite_normal_form(A)\ndiff --git a/test_hnf_fix.py b/test_hnf_fix.py\nnew file mode 100644\nindex 0000000000..67779d58c1\n--- /dev/null\n+++ b/test_hnf_fix.py\n@@ -0,0 +1,71 @@\n+#!/usr/bin/env python3\n+\"\"\"Test that the HNF row-dropping bug is fixed.\"\"\"\n+\n+from sympy import Matrix\n+from sympy.matrices.normalforms import hermite_normal_form\n+\n+\n+def test_hnf_no_row_dropping():\n+    \"\"\"Test that HNF doesn't drop rows when m > n.\"\"\"\n+    # Test case from the bug report\n+    # When flipping and transposing [[5, 8, 12], [0, 0, 1]], we get a 3x2 matrix\n+    # The HNF should preserve all rows, not drop any\n+    \n+    # Direct test of the case that was failing\n+    A = Matrix([[0, 5], [0, 8], [1, 12]])\n+    hnf = hermite_normal_form(A)\n+    assert hnf.shape == (3, 2), f\"Expected shape (3, 2), got {hnf.shape}\"\n+    \n+    # Test the full scenario from the bug report\n+    input_matrix = [[5, 8, 12], [0, 0, 1]]\n+    \n+    # Flip (reverse rows and columns)\n+    flipped = []\n+    for row in reversed(input_matrix):\n+        flipped.append(list(reversed(row)))\n+    \n+    # Transpose\n+    sympy_matrix = Matrix(flipped)\n+    transposed = sympy_matrix.T\n+    \n+    # HNF\n+    hnf = hermite_normal_form(transposed)\n+    \n+    # Transpose back\n+    final = hnf.T\n+    \n+    # Check that we have the same number of rows as input\n+    assert final.shape[0] == len(input_matrix), \\\n+        f\"Expected {len(input_matrix)} rows, got {final.shape[0]}\"\n+    \n+    print(\"All tests passed!\")\n+\n+\n+def test_hnf_general_cases():\n+    \"\"\"Test HNF for various matrix sizes.\"\"\"\n+    # Test m < n (more columns than rows)\n+    A = Matrix([[1, 2, 3], [4, 5, 6]])\n+    hnf = hermite_normal_form(A)\n+    assert hnf.shape[0] == A.shape[0], \"HNF changed number of rows for m < n\"\n+    \n+    # Test m = n (square matrix)  \n+    A = Matrix([[1, 2], [3, 4]])\n+    hnf = hermite_normal_form(A)\n+    assert hnf.shape[0] == A.shape[0], \"HNF changed number of rows for m = n\"\n+    \n+    # Test m > n (more rows than columns) - this was the bug\n+    A = Matrix([[1, 2], [3, 4], [5, 6]])\n+    hnf = hermite_normal_form(A)\n+    assert hnf.shape == A.shape, f\"HNF changed shape for m > n: {A.shape} -> {hnf.shape}\"\n+    \n+    # Test rank-deficient case\n+    A = Matrix([[1, 2], [2, 4], [3, 6]])  # All rows are multiples\n+    hnf = hermite_normal_form(A)\n+    assert hnf.shape == A.shape, f\"HNF changed shape for rank-deficient: {A.shape} -> {hnf.shape}\"\n+    \n+    print(\"General tests passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_hnf_no_row_dropping()\n+    test_hnf_general_cases()\n", "gold_standard_diff": "From fa59c52a6ee65184f44099433df19aeaa0fa0921 Mon Sep 17 00:00:00 2001\nFrom: Steve Kieffer <sk@skieffer.info>\nDate: Sat, 23 Apr 2022 18:46:30 -0400\nSubject: [PATCH] Repair HNF algorithm.\n\n---\n sympy/matrices/tests/test_normalforms.py       |  8 +++++++-\n sympy/polys/matrices/normalforms.py            | 11 +++++++----\n sympy/polys/matrices/tests/test_normalforms.py |  2 +-\n 3 files changed, 15 insertions(+), 6 deletions(-)\n\ndiff --git a/sympy/matrices/tests/test_normalforms.py b/sympy/matrices/tests/test_normalforms.py\nindex 8e7dc0469d85..0dbc484d6de7 100644\n--- a/sympy/matrices/tests/test_normalforms.py\n+++ b/sympy/matrices/tests/test_normalforms.py\n@@ -77,5 +77,11 @@ def test_hermite_normal():\n     assert hermite_normal_form(m) == hnf\n \n     m = Matrix([[2, 7], [0, 0], [0, 0]])\n-    hnf = Matrix(3, 0, [])\n+    hnf = Matrix([[1], [0], [0]])\n     assert hermite_normal_form(m) == hnf\n+\n+\n+def test_issue_23410():\n+    A = Matrix([[1, 12], [0, 8], [0, 5]])\n+    H = Matrix([[1, 0], [0, 8], [0, 5]])\n+    assert hermite_normal_form(A) == H\ndiff --git a/sympy/polys/matrices/normalforms.py b/sympy/polys/matrices/normalforms.py\nindex 30f5534b0851..e2c0546857e2 100644\n--- a/sympy/polys/matrices/normalforms.py\n+++ b/sympy/polys/matrices/normalforms.py\n@@ -205,16 +205,19 @@ def _hermite_normal_form(A):\n     if not A.domain.is_ZZ:\n         raise DMDomainError('Matrix must be over domain ZZ.')\n     # We work one row at a time, starting from the bottom row, and working our\n-    # way up. The total number of rows we will consider is min(m, n), where\n-    # A is an m x n matrix.\n+    # way up.\n     m, n = A.shape\n-    rows = min(m, n)\n     A = A.to_dense().rep.copy()\n     # Our goal is to put pivot entries in the rightmost columns.\n     # Invariant: Before processing each row, k should be the index of the\n     # leftmost column in which we have so far put a pivot.\n     k = n\n-    for i in range(m - 1, m - 1 - rows, -1):\n+    for i in range(m - 1, -1, -1):\n+        if k == 0:\n+            # This case can arise when n < m and we've already found n pivots.\n+            # We don't need to consider any more rows, because this is already\n+            # the maximum possible number of pivots.\n+            break\n         k -= 1\n         # k now points to the column in which we want to put a pivot.\n         # We want zeros in all entries to the left of the pivot column.\ndiff --git a/sympy/polys/matrices/tests/test_normalforms.py b/sympy/polys/matrices/tests/test_normalforms.py\nindex 1b6bdd0d6bbc..a3471400c877 100644\n--- a/sympy/polys/matrices/tests/test_normalforms.py\n+++ b/sympy/polys/matrices/tests/test_normalforms.py\n@@ -62,7 +62,7 @@ def test_hermite_normal():\n     assert hermite_normal_form(m) == hnf\n \n     m = DM([[2, 7], [0, 0], [0, 0]], ZZ)\n-    hnf = DM([[], [], []], ZZ)\n+    hnf = DM([[1], [0], [0]], ZZ)\n     assert hermite_normal_form(m) == hnf\n \n     m = DM([[-2, 1], [0, 1]], ZZ)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/23413"}