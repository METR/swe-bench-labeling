{"instance_id": "sympy__sympy-21379", "score": "I", "diff": "diff --git a/sympy/functions/elementary/hyperbolic.py b/sympy/functions/elementary/hyperbolic.py\nindex 860989f7c1..b9b60e5cde 100644\n--- a/sympy/functions/elementary/hyperbolic.py\n+++ b/sympy/functions/elementary/hyperbolic.py\n@@ -248,7 +248,20 @@ def _eval_is_real(self):\n         # if `im` is of the form n*pi\n         # else, check if it is a number\n         re, im = arg.as_real_imag()\n-        return (im%pi).is_zero\n+        # Check if im is zero directly to avoid unnecessary polynomial operations\n+        if im.is_zero:\n+            return True\n+        # Also check if im equals zero to handle cases where is_zero is None\n+        if im == 0:\n+            return True\n+        # Try to compute (im % pi).is_zero, but if it fails due to polynomial\n+        # issues with Piecewise, return None (undetermined)\n+        from sympy.polys.polyerrors import PolynomialError\n+        try:\n+            return (im%pi).is_zero\n+        except PolynomialError:\n+            # Can't determine if it's real when Piecewise is involved\n+            return None\n \n     def _eval_is_extended_real(self):\n         if self.args[0].is_extended_real:\n@@ -437,7 +450,14 @@ def _eval_is_real(self):\n         # the imaginary part can be an expression like n*pi\n         # if not, check if the imaginary part is a number\n         re, im = arg.as_real_imag()\n-        return (im%pi).is_zero\n+        # Try to compute (im % pi).is_zero, but if it fails due to polynomial\n+        # issues with Piecewise, return None (undetermined)\n+        from sympy.polys.polyerrors import PolynomialError\n+        try:\n+            return (im%pi).is_zero\n+        except PolynomialError:\n+            # Can't determine if it's real when Piecewise is involved\n+            return None\n \n     def _eval_is_positive(self):\n         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)\n@@ -448,27 +468,35 @@ def _eval_is_positive(self):\n         z = self.args[0]\n \n         x, y = z.as_real_imag()\n-        ymod = y % (2*pi)\n-\n-        yzero = ymod.is_zero\n-        # shortcut if ymod is zero\n-        if yzero:\n-            return True\n-\n-        xzero = x.is_zero\n-        # shortcut x is not zero\n-        if xzero is False:\n-            return yzero\n-\n-        return fuzzy_or([\n-                # Case 1:\n-                yzero,\n-                # Case 2:\n-                fuzzy_and([\n-                    xzero,\n-                    fuzzy_or([ymod < pi/2, ymod > 3*pi/2])\n+        \n+        # Try to compute ymod, but if it fails due to polynomial\n+        # issues with Piecewise, return None (undetermined)\n+        from sympy.polys.polyerrors import PolynomialError\n+        try:\n+            ymod = y % (2*pi)\n+\n+            yzero = ymod.is_zero\n+            # shortcut if ymod is zero\n+            if yzero:\n+                return True\n+\n+            xzero = x.is_zero\n+            # shortcut x is not zero\n+            if xzero is False:\n+                return yzero\n+\n+            return fuzzy_or([\n+                    # Case 1:\n+                    yzero,\n+                    # Case 2:\n+                    fuzzy_and([\n+                        xzero,\n+                        fuzzy_or([ymod < pi/2, ymod > 3*pi/2])\n+                    ])\n                 ])\n-            ])\n+        except PolynomialError:\n+            # Can't determine when Piecewise is involved\n+            return None\n \n \n     def _eval_is_nonnegative(self):\n@@ -657,14 +685,21 @@ def _eval_is_real(self):\n \n         re, im = arg.as_real_imag()\n \n-        # if denom = 0, tanh(arg) = zoo\n-        if re == 0 and im % pi == pi/2:\n+        # Try to handle modulo operations, but if they fail due to polynomial\n+        # issues with Piecewise, return None (undetermined)\n+        from sympy.polys.polyerrors import PolynomialError\n+        try:\n+            # if denom = 0, tanh(arg) = zoo\n+            if re == 0 and im % pi == pi/2:\n+                return None\n+\n+            # check if im is of the form n*pi/2 to make sin(2*im) = 0\n+            # if not, im could be a number, return False in that case\n+            return (im % (pi/2)).is_zero\n+        except PolynomialError:\n+            # Can't determine if it's real when Piecewise is involved\n             return None\n \n-        # check if im is of the form n*pi/2 to make sin(2*im) = 0\n-        # if not, im could be a number, return False in that case\n-        return (im % (pi/2)).is_zero\n-\n     def _eval_is_extended_real(self):\n         if self.args[0].is_extended_real:\n             return True\n", "gold_standard_diff": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex b4f3de25234b..ebe7862aef6e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n         from sympy.core.exprtools import gcd_terms\n+        from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n \n         def doit(p, q):\n@@ -166,10 +167,13 @@ def doit(p, q):\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n-        G = gcd(p, q)\n-        if G != 1:\n-            p, q = [\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n+        try:\n+            G = gcd(p, q)\n+            if G != 1:\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\n+                        for i in (p, q)]\n+        except PolynomialError:  # issue 21373\n+            G = S.One\n         pwas, qwas = p, q\n \n         # simplify terms\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 2dc6589f8c67..f19cfeeaa2d8 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1913,6 +1913,16 @@ def test_Mod():\n     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n+    # issue 21373\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    expr.subs({1: 1.0})\n+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n+\n \n def test_Mod_Pow():\n     # modular exponentiation\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/21379"}