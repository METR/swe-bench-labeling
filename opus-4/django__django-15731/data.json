{"instance_id": "django__django-15731", "score": "C", "diff": "diff --git a/django/db/models/manager.py b/django/db/models/manager.py\nindex e37e56cd17..e147af1795 100644\n--- a/django/db/models/manager.py\n+++ b/django/db/models/manager.py\n@@ -1,4 +1,5 @@\n import copy\n+import functools\n import inspect\n from importlib import import_module\n \n@@ -81,11 +82,9 @@ class BaseManager:\n     @classmethod\n     def _get_queryset_methods(cls, queryset_class):\n         def create_method(name, method):\n+            @functools.wraps(method)\n             def manager_method(self, *args, **kwargs):\n                 return getattr(self.get_queryset(), name)(*args, **kwargs)\n-\n-            manager_method.__name__ = method.__name__\n-            manager_method.__doc__ = method.__doc__\n             return manager_method\n \n         new_methods = {}\ndiff --git a/test_complete_fix.py b/test_complete_fix.py\nnew file mode 100644\nindex 0000000000..c6dc8898d4\n--- /dev/null\n+++ b/test_complete_fix.py\n@@ -0,0 +1,72 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+import inspect\n+from django.db import models\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test various QuerySet methods to ensure signatures are preserved\n+methods_to_test = ['bulk_create', 'filter', 'exclude', 'get', 'create', 'update_or_create', 'get_or_create']\n+\n+print(\"Testing signature preservation for manager methods:\")\n+print(\"-\" * 50)\n+\n+for method_name in methods_to_test:\n+    manager_method = getattr(TestModel.objects, method_name)\n+    queryset_method = getattr(models.QuerySet, method_name)\n+    \n+    manager_sig = inspect.signature(manager_method)\n+    queryset_sig = inspect.signature(queryset_method)\n+    \n+    # Remove 'self' from queryset signature for comparison\n+    queryset_params = list(queryset_sig.parameters.values())[1:]\n+    expected_sig = inspect.Signature(parameters=queryset_params)\n+    \n+    print(f\"\\n{method_name}:\")\n+    print(f\"  Manager signature:  {manager_sig}\")\n+    print(f\"  Expected signature: {expected_sig}\")\n+    print(f\"  Match: {str(manager_sig) == str(expected_sig)}\")\n+\n+# Test that docstrings are also preserved\n+print(\"\\n\\nTesting docstring preservation:\")\n+print(\"-\" * 50)\n+print(f\"\\nManager bulk_create docstring exists: {TestModel.objects.bulk_create.__doc__ is not None}\")\n+print(f\"QuerySet bulk_create docstring exists: {models.QuerySet.bulk_create.__doc__ is not None}\")\n+print(f\"Docstrings match: {TestModel.objects.bulk_create.__doc__ == models.QuerySet.bulk_create.__doc__}\")\n+\n+# Test that the methods still work correctly\n+print(\"\\n\\nTesting functionality:\")\n+print(\"-\" * 50)\n+try:\n+    # Create some test objects\n+    objs = [TestModel(name=f\"Test {i}\") for i in range(3)]\n+    created = TestModel.objects.bulk_create(objs)\n+    print(f\"bulk_create worked: Created {len(created)} objects\")\n+    \n+    # Test filter\n+    filtered = TestModel.objects.filter(name__startswith=\"Test\")\n+    print(f\"filter worked: Found {filtered.count()} objects\")\n+    \n+    print(\"\\nAll tests passed!\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..d7b27bb287\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,89 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+import inspect\n+from django.db import models\n+\n+# Test edge case: Custom manager with overridden method\n+class CustomQuerySet(models.QuerySet):\n+    def custom_method(self, param1, param2='default'):\n+        \"\"\"Custom method docstring\"\"\"\n+        return self.filter(name=param1)\n+\n+class CustomManager(models.Manager):\n+    def get_queryset(self):\n+        return CustomQuerySet(self.model, using=self._db)\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    objects = CustomManager.from_queryset(CustomQuerySet)()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the custom method\n+print(\"Testing custom QuerySet method:\")\n+print(\"-\" * 50)\n+custom_method_sig = inspect.signature(TestModel.objects.custom_method)\n+print(f\"Signature: {custom_method_sig}\")\n+print(f\"Docstring: {TestModel.objects.custom_method.__doc__}\")\n+\n+# Test method with complex annotations\n+from typing import List, Optional\n+\n+class AnnotatedQuerySet(models.QuerySet):\n+    def typed_method(self, items: List[str], optional: Optional[int] = None) -> models.QuerySet:\n+        \"\"\"Method with type annotations\"\"\"\n+        return self.filter(name__in=items)\n+\n+class AnnotatedModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    objects = models.Manager.from_queryset(AnnotatedQuerySet)()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+print(\"\\n\\nTesting method with type annotations:\")\n+print(\"-\" * 50)\n+typed_method_sig = inspect.signature(AnnotatedModel.objects.typed_method)\n+print(f\"Signature: {typed_method_sig}\")\n+print(f\"Annotations preserved: {AnnotatedModel.objects.typed_method.__annotations__}\")\n+\n+# Test that private methods are not copied\n+class PrivateMethodQuerySet(models.QuerySet):\n+    def public_method(self):\n+        \"\"\"Public method\"\"\"\n+        pass\n+    \n+    def _private_method(self):\n+        \"\"\"Private method\"\"\"\n+        pass\n+\n+class PrivateMethodModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    objects = models.Manager.from_queryset(PrivateMethodQuerySet)()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+print(\"\\n\\nTesting private method exclusion:\")\n+print(\"-\" * 50)\n+print(f\"Has public_method: {hasattr(PrivateMethodModel.objects, 'public_method')}\")\n+print(f\"Has _private_method: {hasattr(PrivateMethodModel.objects, '_private_method')}\")\n+\n+print(\"\\n\\nAll edge case tests passed!\")\ndiff --git a/test_ipython_compatibility.py b/test_ipython_compatibility.py\nnew file mode 100644\nindex 0000000000..063ba89f89\n--- /dev/null\n+++ b/test_ipython_compatibility.py\n@@ -0,0 +1,55 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+import inspect\n+from django.db import models\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test that all metadata is preserved (what IPython uses)\n+print(\"Testing metadata preservation for IPython/Jupyter compatibility:\")\n+print(\"-\" * 60)\n+\n+bulk_create_manager = Person.objects.bulk_create\n+bulk_create_queryset = models.QuerySet.bulk_create\n+\n+# Check various attributes that IPython might use\n+attributes_to_check = ['__name__', '__doc__', '__annotations__', '__module__', '__qualname__']\n+\n+for attr in attributes_to_check:\n+    manager_value = getattr(bulk_create_manager, attr, '<not found>')\n+    queryset_value = getattr(bulk_create_queryset, attr, '<not found>')\n+    print(f\"\\n{attr}:\")\n+    print(f\"  Manager:  {repr(manager_value)}\")\n+    print(f\"  QuerySet: {repr(queryset_value)}\")\n+    if attr == '__doc__':\n+        print(f\"  Match: {manager_value == queryset_value}\")\n+    \n+# Most importantly, check the signature\n+print(f\"\\n__signature__:\")\n+print(f\"  Manager:  {inspect.signature(bulk_create_manager)}\")\n+print(f\"  QuerySet: {inspect.signature(bulk_create_queryset)}\")\n+\n+# Check wrapped attribute (functools.wraps adds this)\n+print(f\"\\n__wrapped__ attribute exists: {hasattr(bulk_create_manager, '__wrapped__')}\")\n+if hasattr(bulk_create_manager, '__wrapped__'):\n+    print(f\"__wrapped__ points to original: {bulk_create_manager.__wrapped__ == bulk_create_queryset}\")\ndiff --git a/test_signature_issue.py b/test_signature_issue.py\nnew file mode 100644\nindex 0000000000..8ab17d0262\n--- /dev/null\n+++ b/test_signature_issue.py\n@@ -0,0 +1,35 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+import inspect\n+from django.db import models\n+\n+class Person(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the issue\n+print(\"Current signature of Person.objects.bulk_create:\")\n+print(inspect.signature(Person.objects.bulk_create))\n+\n+# Let's also check the actual signature of QuerySet.bulk_create\n+from django.db.models.query import QuerySet\n+print(\"\\nActual signature of QuerySet.bulk_create:\")\n+print(inspect.signature(QuerySet.bulk_create))\n", "gold_standard_diff": "diff --git a/django/db/models/manager.py b/django/db/models/manager.py\nindex e37e56cd17ac..467e79f9b9f7 100644\n--- a/django/db/models/manager.py\n+++ b/django/db/models/manager.py\n@@ -1,5 +1,6 @@\n import copy\n import inspect\n+from functools import wraps\n from importlib import import_module\n \n from django.db import router\n@@ -81,11 +82,10 @@ def check(self, **kwargs):\n     @classmethod\n     def _get_queryset_methods(cls, queryset_class):\n         def create_method(name, method):\n+            @wraps(method)\n             def manager_method(self, *args, **kwargs):\n                 return getattr(self.get_queryset(), name)(*args, **kwargs)\n \n-            manager_method.__name__ = method.__name__\n-            manager_method.__doc__ = method.__doc__\n             return manager_method\n \n         new_methods = {}\ndiff --git a/tests/basic/tests.py b/tests/basic/tests.py\nindex e27fb66e3d93..44ace3d68497 100644\n--- a/tests/basic/tests.py\n+++ b/tests/basic/tests.py\n@@ -1,3 +1,4 @@\n+import inspect\n import threading\n from datetime import datetime, timedelta\n from unittest import mock\n@@ -736,6 +737,17 @@ def test_manager_methods(self):\n             sorted(self.QUERYSET_PROXY_METHODS),\n         )\n \n+    def test_manager_method_attributes(self):\n+        self.assertEqual(Article.objects.get.__doc__, models.QuerySet.get.__doc__)\n+        self.assertEqual(Article.objects.count.__name__, models.QuerySet.count.__name__)\n+\n+    def test_manager_method_signature(self):\n+        self.assertEqual(\n+            str(inspect.signature(Article.objects.bulk_create)),\n+            \"(objs, batch_size=None, ignore_conflicts=False, update_conflicts=False, \"\n+            \"update_fields=None, unique_fields=None)\",\n+        )\n+\n \n class SelectOnSaveTests(TestCase):\n     def test_select_on_save(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15731"}