{"instance_id": "django__django-15930", "score": "C", "diff": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef56..aa6fe52159 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ class When(Expression):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Handle the case where the condition compiles to an empty string\n+        # (e.g., ~Q(pk__in=[]) which means \"not in empty list\" = matches everything)\n+        if not condition_sql:\n+            # Use a SQL expression that always evaluates to true\n+            condition_sql = \"1=1\"\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\ndiff --git a/test_case_empty_q.py b/test_case_empty_q.py\nnew file mode 100644\nindex 0000000000..195aa431d6\n--- /dev/null\n+++ b/test_case_empty_q.py\n@@ -0,0 +1,83 @@\n+\"\"\"\n+Test case for the fix to handle ~Q(pk__in=[]) in Case/When expressions.\n+This test should be added to tests/expressions_case/tests.py\n+\"\"\"\n+\n+from django.db.models import Case, When, Value, BooleanField, Q, IntegerField\n+from django.test import TestCase\n+from .models import CaseTestModel\n+\n+\n+class EmptyQInCaseTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        CaseTestModel.objects.create(integer=1, string='one')\n+        CaseTestModel.objects.create(integer=2, string='two')\n+        CaseTestModel.objects.create(integer=3, string='three')\n+\n+    def test_negated_empty_in_lookup(self):\n+        \"\"\"\n+        Test that ~Q(pk__in=[]) in a When clause matches all records.\n+        This is a regression test for the issue where ~Q(pk__in=[])\n+        would produce invalid SQL: \"CASE WHEN THEN ...\"\n+        \"\"\"\n+        # ~Q(pk__in=[]) should match all records\n+        result = CaseTestModel.objects.annotate(\n+            matches=Case(\n+                When(~Q(pk__in=[]), then=Value(True)),\n+                default=Value(False),\n+                output_field=BooleanField(),\n+            )\n+        ).values_list('matches', flat=True)\n+        \n+        # All records should match\n+        self.assertEqual(list(result), [True, True, True])\n+        \n+    def test_empty_in_lookup(self):\n+        \"\"\"\n+        Test that Q(pk__in=[]) in a When clause matches no records.\n+        \"\"\"\n+        # Q(pk__in=[]) should match no records\n+        result = CaseTestModel.objects.annotate(\n+            matches=Case(\n+                When(Q(pk__in=[]), then=Value(True)),\n+                default=Value(False),\n+                output_field=BooleanField(),\n+            )\n+        ).values_list('matches', flat=True)\n+        \n+        # No records should match\n+        self.assertEqual(list(result), [False, False, False])\n+        \n+    def test_negated_empty_in_lookup_with_other_conditions(self):\n+        \"\"\"\n+        Test that ~Q(pk__in=[]) works correctly when combined with other When clauses.\n+        \"\"\"\n+        result = CaseTestModel.objects.annotate(\n+            category=Case(\n+                When(integer=1, then=Value(1)),\n+                When(~Q(pk__in=[]), then=Value(2)),  # Should match integer=2 and integer=3\n+                default=Value(3),\n+                output_field=IntegerField(),\n+            )\n+        ).order_by('integer').values_list('integer', 'category')\n+        \n+        # First record matches the first When clause, others match the second\n+        self.assertEqual(list(result), [(1, 1), (2, 2), (3, 2)])\n+        \n+    def test_order_by_negated_empty_in_lookup(self):\n+        \"\"\"\n+        Test ordering by a Case expression with ~Q(pk__in=[]).\n+        This was the original reported issue - it would fail with a syntax error.\n+        \"\"\"\n+        # This should not raise a database error\n+        result = list(CaseTestModel.objects.annotate(\n+            _a=Case(\n+                When(~Q(pk__in=[]), then=Value(True)),\n+                default=Value(False),\n+                output_field=BooleanField(),\n+            )\n+        ).order_by(\"-_a\").values(\"pk\"))\n+        \n+        # Should return all 3 records\n+        self.assertEqual(len(result), 3)\ndiff --git a/test_case_issue.py b/test_case_issue.py\nnew file mode 100644\nindex 0000000000..f8270b8f80\n--- /dev/null\n+++ b/test_case_issue.py\n@@ -0,0 +1,63 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.models import User\n+from django.db.models import Case, When, Value, BooleanField, Q\n+from django.db import connection\n+\n+# Test the issue\n+print(\"Testing ~Q(pk__in=[]) issue...\")\n+\n+# First let's see what ~Q(pk__in=[]) produces\n+negated_q = ~Q(pk__in=[])\n+print(f\"~Q(pk__in=[]): {negated_q}\")\n+print(f\"~Q(pk__in=[]).children: {negated_q.children}\")\n+\n+query = User.objects.annotate(\n+    _a=Case(\n+        When(~Q(pk__in=[]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+)\n+\n+print(\"\\nQuery SQL:\")\n+print(query.query)\n+\n+# Get the compiled SQL without executing\n+from django.db.models.sql.compiler import SQLCompiler\n+compiler = query.query.get_compiler(using='default')\n+sql, params = compiler.as_sql()\n+print(f\"\\nCompiled SQL: {sql}\")\n+print(f\"Params: {params}\")\n+\n+# Let's also test with a normal Q object that's not empty\n+print(\"\\n\\nComparing with Q(pk__in=[1, 2]):\")\n+query2 = User.objects.annotate(\n+    _a=Case(\n+        When(~Q(pk__in=[1, 2]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+)\n+print(query2.query)\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..c0cd708ee1\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,100 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.models import User\n+from django.db.models import Case, When, Value, BooleanField, Q, IntegerField\n+from django.db import connection\n+\n+# Create the table\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(User)\n+\n+# Insert some test data\n+User.objects.create(username='user1')\n+User.objects.create(username='user2')\n+User.objects.create(username='user3')\n+\n+print(\"Testing various Case/When scenarios with empty Q objects...\")\n+\n+# Test 1: ~Q(pk__in=[]) - should match all records\n+print(\"\\n1. Testing ~Q(pk__in=[]):\")\n+result = User.objects.annotate(\n+    matches=Case(\n+        When(~Q(pk__in=[]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+).values('username', 'matches').order_by('username')\n+for r in result:\n+    print(f\"  {r['username']}: matches={r['matches']}\")\n+    \n+# Test 2: Q(pk__in=[]) - should match no records\n+print(\"\\n2. Testing Q(pk__in=[]):\")\n+result = User.objects.annotate(\n+    matches=Case(\n+        When(Q(pk__in=[]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+).values('username', 'matches').order_by('username')\n+for r in result:\n+    print(f\"  {r['username']}: matches={r['matches']}\")\n+    \n+# Test 3: ~Q(username__in=[]) - should match all records\n+print(\"\\n3. Testing ~Q(username__in=[]):\")\n+result = User.objects.annotate(\n+    matches=Case(\n+        When(~Q(username__in=[]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+).values('username', 'matches').order_by('username')\n+for r in result:\n+    print(f\"  {r['username']}: matches={r['matches']}\")\n+    \n+# Test 4: Multiple When clauses including ~Q(pk__in=[])\n+print(\"\\n4. Testing multiple When clauses:\")\n+result = User.objects.annotate(\n+    category=Case(\n+        When(username='user1', then=Value(1)),\n+        When(~Q(pk__in=[]), then=Value(2)),  # This should match user2 and user3\n+        default=Value(3),\n+        output_field=IntegerField(),\n+    )\n+).values('username', 'category').order_by('username')\n+for r in result:\n+    print(f\"  {r['username']}: category={r['category']}\")\n+    \n+# Test 5: Order by Case with ~Q(pk__in=[])\n+print(\"\\n5. Testing ORDER BY with Case/~Q(pk__in=[]):\")\n+result = User.objects.annotate(\n+    _a=Case(\n+        When(~Q(pk__in=[]), then=Value(True)),\n+        default=Value(False),\n+        output_field=BooleanField(),\n+    )\n+).order_by(\"-_a\").values(\"username\")\n+for r in result:\n+    print(f\"  {r['username']}\")\n+    \n+print(\"\\nAll tests completed successfully!\")\ndiff --git a/test_deeper.py b/test_deeper.py\nnew file mode 100644\nindex 0000000000..72792e5980\n--- /dev/null\n+++ b/test_deeper.py\n@@ -0,0 +1,69 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db.models import Case, When, Value, BooleanField, Q\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db import connection\n+from django.contrib.auth.models import User\n+from django.core.exceptions import EmptyResultSet\n+\n+# Let's trace how the When clause compiles\n+print(\"Testing When clause compilation...\")\n+\n+# Create a When clause with ~Q(pk__in=[])\n+when_clause = When(~Q(pk__in=[]), then=Value(True))\n+\n+# Create a dummy query for compilation context\n+dummy_query = User.objects.all().query\n+\n+# Resolve the expression\n+resolved_when = when_clause.resolve_expression(dummy_query)\n+\n+# Get a compiler\n+compiler = dummy_query.get_compiler(using='default')\n+\n+# Try to compile the When clause\n+try:\n+    sql, params = compiler.compile(resolved_when)\n+    print(f\"When SQL: {sql}\")\n+    print(f\"Params: {params}\")\n+except EmptyResultSet as e:\n+    print(f\"EmptyResultSet raised: {e}\")\n+except Exception as e:\n+    print(f\"Other error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Let's also check the condition directly\n+print(\"\\nTesting condition compilation...\")\n+condition = ~Q(pk__in=[])\n+try:\n+    sql, params = compiler.compile(condition)\n+    print(f\"Condition SQL: {sql}\")\n+    print(f\"Params: {params}\")\n+except EmptyResultSet as e:\n+    print(f\"EmptyResultSet raised during condition compilation\")\n+except Exception as e:\n+    print(f\"Other error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_detailed.py b/test_detailed.py\nnew file mode 100644\nindex 0000000000..b0d79d6176\n--- /dev/null\n+++ b/test_detailed.py\n@@ -0,0 +1,110 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db.models import Case, When, Value, BooleanField, Q\n+from django.db.models.sql.where import WhereNode\n+from django.db import connection\n+from django.contrib.auth.models import User\n+from django.core.exceptions import EmptyResultSet\n+\n+# Let's trace how Q object resolution works\n+print(\"Testing Q object resolution...\")\n+\n+# Create a Q object with ~Q(pk__in=[])\n+q_obj = ~Q(pk__in=[])\n+print(f\"Q object: {q_obj}\")\n+print(f\"Q object negated: {q_obj.negated}\")\n+print(f\"Q object children: {q_obj.children}\")\n+\n+# Create a query to resolve against\n+query = User.objects.all().query\n+\n+# Create a When clause\n+when_clause = When(q_obj, then=Value(True))\n+print(f\"\\nWhen clause condition: {when_clause.condition}\")\n+\n+# Resolve the when clause\n+resolved_when = when_clause.resolve_expression(query)\n+print(f\"Resolved When condition type: {type(resolved_when.condition)}\")\n+print(f\"Resolved When condition: {resolved_when.condition}\")\n+\n+# Check if it's a WhereNode\n+if hasattr(resolved_when.condition, 'as_sql'):\n+    compiler = query.get_compiler(using='default')\n+    try:\n+        sql, params = resolved_when.condition.as_sql(compiler, connection)\n+        print(f\"Condition SQL: {sql}\")\n+        print(f\"Condition params: {params}\")\n+    except EmptyResultSet:\n+        print(\"EmptyResultSet raised when compiling condition!\")\n+        # This is the issue - when EmptyResultSet is raised, the WHEN clause has no condition\n+        \n+print(\"\\n\\nLet's trace through the When.as_sql process...\")\n+\n+# Override When.as_sql temporarily to add logging\n+from django.db.models.expressions import When as OriginalWhen\n+\n+class DebugWhen(OriginalWhen):\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        print(\"=== When.as_sql called ===\")\n+        print(f\"Condition: {self.condition}\")\n+        print(f\"Result: {self.result}\")\n+        \n+        template_params = extra_context\n+        sql_params = []\n+        \n+        try:\n+            condition_sql, condition_params = compiler.compile(self.condition)\n+            print(f\"Condition compiled to SQL: '{condition_sql}'\")\n+            print(f\"Condition params: {condition_params}\")\n+        except EmptyResultSet:\n+            print(\"!!! EmptyResultSet raised during condition compilation !!!\")\n+            # This is where the problem happens - condition_sql would be undefined\n+            raise\n+        except Exception as e:\n+            print(f\"Other error during condition compilation: {type(e).__name__}: {e}\")\n+            raise\n+            \n+        template_params[\"condition\"] = condition_sql\n+        sql_params.extend(condition_params)\n+        \n+        result_sql, result_params = compiler.compile(self.result)\n+        template_params[\"result\"] = result_sql\n+        sql_params.extend(result_params)\n+        \n+        template = template or self.template\n+        final_sql = template % template_params\n+        print(f\"Final When SQL: '{final_sql}'\")\n+        \n+        return final_sql, sql_params\n+\n+# Test with debug When\n+debug_when = DebugWhen(~Q(pk__in=[]), then=Value(True))\n+resolved_debug_when = debug_when.resolve_expression(query)\n+compiler = query.get_compiler(using='default')\n+\n+try:\n+    sql, params = compiler.compile(resolved_debug_when)\n+    print(f\"\\nFinal result: SQL='{sql}', params={params}\")\n+except Exception as e:\n+    print(f\"\\nError: {type(e).__name__}: {e}\")\n", "gold_standard_diff": "From 036bb2b74afb50a71e7a945e8dd83499b603ac3a Mon Sep 17 00:00:00 2001\nFrom: David Wobrock <david.wobrock@gmail.com>\nDate: Sun, 7 Aug 2022 17:25:43 +0200\nSubject: [PATCH] Fixed #33895 -- Fixed Case() crash with filters that match\n everything in When().\n\nThanks shukryzablah for the report.\n---\n django/db/models/expressions.py |  5 +++++\n tests/expressions_case/tests.py | 10 ++++++++++\n 2 files changed, 15 insertions(+)\n\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 822968ef566e..ba836024e5ca 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1299,6 +1299,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n         template_params = extra_context\n         sql_params = []\n         condition_sql, condition_params = compiler.compile(self.condition)\n+        # Filters that match everything are handled as empty strings in the\n+        # WHERE clause, but in a CASE WHEN expression they must use a predicate\n+        # that's always True.\n+        if condition_sql == \"\":\n+            condition_sql, condition_params = compiler.compile(Value(True))\n         template_params[\"condition\"] = condition_sql\n         sql_params.extend(condition_params)\n         result_sql, result_params = compiler.compile(self.result)\ndiff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py\nindex 9bad0b87471f..221806c93376 100644\n--- a/tests/expressions_case/tests.py\n+++ b/tests/expressions_case/tests.py\n@@ -415,6 +415,16 @@ def test_annotate_with_empty_when(self):\n         self.assertEqual(len(objects), CaseTestModel.objects.count())\n         self.assertTrue(all(obj.selected == \"not selected\" for obj in objects))\n \n+    def test_annotate_with_full_when(self):\n+        objects = CaseTestModel.objects.annotate(\n+            selected=Case(\n+                When(~Q(pk__in=[]), then=Value(\"selected\")),\n+                default=Value(\"not selected\"),\n+            )\n+        )\n+        self.assertEqual(len(objects), CaseTestModel.objects.count())\n+        self.assertTrue(all(obj.selected == \"selected\" for obj in objects))\n+\n     def test_combined_expression(self):\n         self.assertQuerysetEqual(\n             CaseTestModel.objects.annotate(\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15930"}