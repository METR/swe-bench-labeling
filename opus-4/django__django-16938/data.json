{"instance_id": "django__django-16938", "score": "I", "diff": "diff --git a/django/core/serializers/python.py b/django/core/serializers/python.py\nindex 36048601af..4ad563ba43 100644\n--- a/django/core/serializers/python.py\n+++ b/django/core/serializers/python.py\n@@ -79,7 +79,7 @@ class Serializer(base.Serializer):\n                     return self._value_from_field(value, value._meta.pk)\n \n                 def queryset_iterator(obj, field):\n-                    return getattr(obj, field.name).only(\"pk\").iterator()\n+                    return getattr(obj, field.name).select_related(None).only(\"pk\").iterator()\n \n             m2m_iter = getattr(obj, \"_prefetched_objects_cache\", {}).get(\n                 field.name,\ndiff --git a/test_fix_demo.py b/test_fix_demo.py\nnew file mode 100644\nindex 0000000000..d6f1d62d4a\n--- /dev/null\n+++ b/test_fix_demo.py\n@@ -0,0 +1,93 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Demonstration that the fix works for the issue described in the ticket.\n+\"\"\"\n+import os\n+import sys\n+import django\n+\n+# Add Django to path\n+sys.path.insert(0, '/testbed')\n+\n+# Configure Django settings\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+    INSTALLED_APPS=['django.contrib.contenttypes'],\n+    USE_TZ=False,\n+)\n+django.setup()\n+\n+# Now we can import Django modules\n+from django.db import models, connection\n+from django.db.models import Manager\n+from django.core import serializers\n+\n+\n+class TestTagManager(Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        qs = qs.select_related(\"master\")  # follow master when retrieving object by default\n+        return qs\n+\n+\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+\n+class TestTag(models.Model):\n+    objects = TestTagManager()\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+\n+class Test(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+\n+# Create tables (drop first if they exist)\n+with connection.cursor() as cursor:\n+    cursor.execute(\"DROP TABLE IF EXISTS contenttypes_test_tags\")\n+    cursor.execute(\"DROP TABLE IF EXISTS contenttypes_test\")\n+    cursor.execute(\"DROP TABLE IF EXISTS contenttypes_testtag\")\n+    cursor.execute(\"DROP TABLE IF EXISTS contenttypes_testtagmaster\")\n+\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(TestTagMaster)\n+    schema_editor.create_model(TestTag)\n+    schema_editor.create_model(Test)\n+    # Create M2M table\n+    m2m_field = Test._meta.get_field('tags')\n+    schema_editor.create_model(m2m_field.remote_field.through)\n+\n+# Create test data\n+print(\"Creating test data...\")\n+tag_master = TestTagMaster.objects.create(name=\"master\")\n+tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+test = Test.objects.create(name=\"test\")\n+test.tags.add(tag)\n+test.save()\n+\n+# Try to serialize\n+print(\"\\nTesting serialization with our fix...\")\n+try:\n+    result = serializers.serialize(\"json\", [test])\n+    print(\"\u2713 SUCCESS: Serialization works correctly!\")\n+    print(f\"\\nSerialized result:\\n{result}\")\n+except Exception as e:\n+    print(f\"\u2717 FAILED: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\nDone!\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..6352421e28\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,69 @@\n+import django\n+import os\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"django.conf.global_settings\")\n+\n+from django.conf import settings\n+settings.configure(\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=False,\n+)\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Manager\n+from django.core import serializers\n+\n+class TestTagManager(Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        qs = qs.select_related(\"master\")  # follow master when retrieving object by default\n+        return qs\n+\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+class TestTag(models.Model):\n+    objects = TestTagManager()\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+class Test(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+\n+# Test case\n+if __name__ == \"__main__\":\n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(TestTagMaster)\n+        schema_editor.create_model(TestTag)\n+        schema_editor.create_model(Test)\n+        # Create M2M table\n+        m2m_field = Test._meta.get_field('tags')\n+        schema_editor.create_model(m2m_field.remote_field.through)\n+    \n+    # Create test data\n+    tag_master = TestTagMaster.objects.create(name=\"master\")\n+    tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+    test = Test.objects.create(name=\"test\")\n+    test.tags.add(tag)\n+    test.save()\n+    \n+    # Try to serialize\n+    try:\n+        result = serializers.serialize(\"json\", [test])\n+        print(\"Serialization successful!\")\n+        print(result)\n+    except Exception as e:\n+        print(f\"Error: {type(e).__name__}: {e}\")\ndiff --git a/test_issue_simple.py b/test_issue_simple.py\nnew file mode 100644\nindex 0000000000..0b90a0fa3b\n--- /dev/null\n+++ b/test_issue_simple.py\n@@ -0,0 +1,84 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test.utils import get_runner\n+\n+if __name__ == \"__main__\":\n+    os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+    django.setup()\n+    \n+    # Import after setup\n+    from django.db import models, connection\n+    from django.db.models import Manager\n+    from django.core import serializers\n+    from django.test import TestCase\n+    \n+    # Define models\n+    class TestTagManager(Manager):\n+        def get_queryset(self):\n+            qs = super().get_queryset()\n+            qs = qs.select_related(\"master\")\n+            return qs\n+    \n+    class TestTagMaster(models.Model):\n+        name = models.CharField(max_length=120)\n+        \n+        class Meta:\n+            app_label = 'serializers'\n+    \n+    class TestTag(models.Model):\n+        objects = TestTagManager()\n+        name = models.CharField(max_length=120)\n+        master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+        \n+        class Meta:\n+            app_label = 'serializers'\n+    \n+    class Test(models.Model):\n+        name = models.CharField(max_length=120)\n+        tags = models.ManyToManyField(TestTag, blank=True)\n+        \n+        class Meta:\n+            app_label = 'serializers'\n+    \n+    # Create tables\n+    try:\n+        with connection.schema_editor() as schema_editor:\n+            try:\n+                schema_editor.create_model(TestTagMaster)\n+            except:\n+                pass\n+            try:\n+                schema_editor.create_model(TestTag)\n+            except:\n+                pass\n+            try:\n+                schema_editor.create_model(Test)\n+            except:\n+                pass\n+            try:\n+                m2m_field = Test._meta.get_field('tags')\n+                schema_editor.create_model(m2m_field.remote_field.through)\n+            except:\n+                pass\n+    except:\n+        pass\n+    \n+    # Create test data\n+    tag_master = TestTagMaster.objects.create(name=\"master\")\n+    tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+    test = Test.objects.create(name=\"test\")\n+    test.tags.add(tag)\n+    test.save()\n+    \n+    # Try to serialize - this should fail with the original code\n+    try:\n+        result = serializers.serialize(\"json\", [test])\n+        print(\"Serialization successful!\")\n+        print(result)\n+    except Exception as e:\n+        import traceback\n+        print(f\"Error: {type(e).__name__}: {e}\")\n+        traceback.print_exc()\ndiff --git a/test_m2m_serialization.py b/test_m2m_serialization.py\nnew file mode 100644\nindex 0000000000..5e5c4168a1\n--- /dev/null\n+++ b/test_m2m_serialization.py\n@@ -0,0 +1,153 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test script to verify the fix for m2m serialization with custom managers using select_related\n+\"\"\"\n+import os\n+import sys\n+import django\n+\n+# Ensure we're in the right directory\n+sys.path.insert(0, '/testbed')\n+\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import Manager\n+from django.core import serializers\n+from django.test import TestCase\n+\n+\n+class TestTagManager(Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        qs = qs.select_related(\"master\")  # follow master when retrieving object by default\n+        return qs\n+\n+\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+    \n+    class Meta:\n+        app_label = 'serializers'\n+        db_table = 'test_tag_master'\n+\n+\n+class TestTag(models.Model):\n+    objects = TestTagManager()\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+    \n+    class Meta:\n+        app_label = 'serializers'\n+        db_table = 'test_tag'\n+\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n+    \n+    class Meta:\n+        app_label = 'serializers'\n+        db_table = 'test_model'\n+\n+\n+# Create tables in test database\n+with connection.schema_editor() as schema_editor:\n+    try:\n+        schema_editor.create_model(TestTagMaster)\n+    except:\n+        pass\n+    try:\n+        schema_editor.create_model(TestTag)\n+    except:\n+        pass\n+    try:\n+        schema_editor.create_model(TestModel)\n+    except:\n+        pass\n+    try:\n+        # Create M2M table\n+        m2m_field = TestModel._meta.get_field('tags')\n+        schema_editor.create_model(m2m_field.remote_field.through)\n+    except:\n+        pass\n+\n+# Clean up any existing data\n+TestModel.objects.all().delete()\n+TestTag.objects.all().delete()\n+TestTagMaster.objects.all().delete()\n+\n+# Create test data\n+print(\"Creating test data...\")\n+tag_master = TestTagMaster.objects.create(name=\"master\")\n+tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+test_obj = TestModel.objects.create(name=\"test\")\n+test_obj.tags.add(tag)\n+test_obj.save()\n+\n+# Test serialization\n+print(\"\\nTesting serialization...\")\n+try:\n+    result = serializers.serialize(\"json\", [test_obj])\n+    print(\"\u2713 Serialization successful!\")\n+    print(f\"Result: {result}\")\n+except Exception as e:\n+    print(f\"\u2717 Error: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Test with workaround (using default manager)\n+print(\"\\nTesting workaround with default manager...\")\n+\n+class TestTag2(models.Model):\n+    default = Manager()  # Simple default manager\n+    objects = TestTagManager()  # Custom manager\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+    \n+    class Meta:\n+        app_label = 'serializers'\n+        db_table = 'test_tag2'\n+\n+\n+class TestModel2(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag2, blank=True)\n+    \n+    class Meta:\n+        app_label = 'serializers'\n+        db_table = 'test_model2'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    try:\n+        schema_editor.create_model(TestTag2)\n+    except:\n+        pass\n+    try:\n+        schema_editor.create_model(TestModel2)\n+    except:\n+        pass\n+    try:\n+        # Create M2M table\n+        m2m_field = TestModel2._meta.get_field('tags')\n+        schema_editor.create_model(m2m_field.remote_field.through)\n+    except:\n+        pass\n+\n+# Create test data\n+tag2 = TestTag2.objects.create(name=\"tag2\", master=tag_master)\n+test_obj2 = TestModel2.objects.create(name=\"test2\")\n+test_obj2.tags.add(tag2)\n+test_obj2.save()\n+\n+# Test serialization with workaround\n+try:\n+    result = serializers.serialize(\"json\", [test_obj2])\n+    print(\"\u2713 Workaround serialization successful!\")\n+    print(f\"Result: {result}\")\n+except Exception as e:\n+    print(f\"\u2717 Workaround Error: {type(e).__name__}: {e}\")\n+\n+print(\"\\nDone!\")\ndiff --git a/tests/serializers/test_m2m_select_related.py b/tests/serializers/test_m2m_select_related.py\nnew file mode 100644\nindex 0000000000..21b8ee629f\n--- /dev/null\n+++ b/tests/serializers/test_m2m_select_related.py\n@@ -0,0 +1,75 @@\n+\"\"\"\n+Tests for serialization with M2M relations that have custom managers using select_related.\n+\"\"\"\n+\n+from django.core import serializers\n+from django.db import models\n+from django.test import TestCase\n+\n+\n+class TestTagManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        qs = qs.select_related(\"master\")\n+        return qs\n+\n+\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+\n+\n+class TestTag(models.Model):\n+    objects = TestTagManager()\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+\n+\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n+\n+\n+class M2MSerializationWithSelectRelatedTest(TestCase):\n+    \"\"\"Test serialization of M2M relations with custom managers using select_related.\"\"\"\n+    \n+    def test_m2m_serialization_with_select_related_manager(self):\n+        \"\"\"\n+        Test that M2M serialization works even when the related model \n+        has a custom manager that uses select_related.\n+        \"\"\"\n+        # Create test data\n+        tag_master = TestTagMaster.objects.create(name=\"master\")\n+        tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+        test_obj = TestModel.objects.create(name=\"test\")\n+        test_obj.tags.add(tag)\n+        \n+        # This should not raise a FieldError anymore\n+        result = serializers.serialize(\"json\", [test_obj])\n+        \n+        # Verify the result is correct\n+        self.assertIn('\"tags\": [' + str(tag.pk) + ']', result)\n+        self.assertIn('\"name\": \"test\"', result)\n+    \n+    def test_m2m_serialization_with_natural_keys(self):\n+        \"\"\"\n+        Test that M2M serialization with natural keys doesn't have issues \n+        with select_related managers.\n+        \"\"\"\n+        # Add natural_key method to TestTag\n+        TestTag.natural_key = lambda self: (self.name,)\n+        \n+        # Create test data\n+        tag_master = TestTagMaster.objects.create(name=\"master\")\n+        tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+        test_obj = TestModel.objects.create(name=\"test\")\n+        test_obj.tags.add(tag)\n+        \n+        # Test with natural keys - should not use select_related/only\n+        result = serializers.serialize(\"json\", [test_obj], use_natural_foreign_keys=True)\n+        \n+        # Verify the result is correct\n+        self.assertIn('\"tags\": [[\"tag\"]]', result)\n+        self.assertIn('\"name\": \"test\"', result)\n+        \n+        # Clean up\n+        delattr(TestTag, 'natural_key')\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 0000000000..ded99d388a\n--- /dev/null\n+++ b/verify_fix.py\n@@ -0,0 +1,42 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Verify that the fix is working correctly by checking the source code.\n+\"\"\"\n+\n+# Read the fixed file\n+with open('/testbed/django/core/serializers/python.py', 'r') as f:\n+    content = f.read()\n+\n+# Check if our fix is present\n+if '.select_related(None).only(\"pk\")' in content:\n+    print(\"\u2713 SUCCESS: The fix has been applied correctly!\")\n+    print(\"\\nThe fix adds .select_related(None) before .only('pk') to clear any existing\")\n+    print(\"select_related calls from custom managers, preventing the FieldError.\")\n+    \n+    # Show the relevant code section\n+    lines = content.split('\\n')\n+    for i, line in enumerate(lines):\n+        if 'select_related(None).only(\"pk\")' in line:\n+            print(f\"\\nFixed code at line {i+1}:\")\n+            print(f\"{i:4d}: {lines[i-1]}\")\n+            print(f\"{i+1:4d}: {line}\")\n+            print(f\"{i+2:4d}: {lines[i+1]}\")\n+else:\n+    print(\"\u2717 ERROR: The fix was not found in the file!\")\n+\n+# Also verify the logic\n+print(\"\\n\" + \"=\"*60)\n+print(\"EXPLANATION OF THE FIX:\")\n+print(\"=\"*60)\n+print(\"\"\"\n+The issue occurred because:\n+1. Custom managers can use select_related() to eagerly load related fields\n+2. During M2M serialization, Django calls .only('pk') to optimize queries\n+3. These two operations conflict - you can't both select_related a field \n+   and defer it with only() at the same time\n+\n+The fix:\n+- Adds .select_related(None) before .only('pk') \n+- This clears any existing select_related calls from the custom manager\n+- Allows serialization to work correctly without the FieldError\n+\"\"\")\n", "gold_standard_diff": "From a14a86a9b5af23566f99bba1c54e145943ce603c Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Sat, 3 Jun 2023 13:08:33 +0200\nSubject: [PATCH] Fixed #34620 -- Fixed serialization crash on m2m fields\n without natural keys when base querysets use select_related().\n\nRegression in 19e0587ee596debf77540d6a08ccb6507e60b6a7.\n\nThanks Martin Svoboda for the report.\n---\n django/core/serializers/python.py         |  4 +++-\n django/core/serializers/xml_serializer.py |  4 +++-\n docs/releases/4.2.2.txt                   |  4 ++++\n tests/serializers/models/base.py          | 12 ++++++++++++\n tests/serializers/test_json.py            |  3 ++-\n tests/serializers/test_jsonl.py           |  3 ++-\n tests/serializers/test_xml.py             |  1 +\n tests/serializers/test_yaml.py            |  1 +\n tests/serializers/tests.py                | 16 ++++++++++------\n 9 files changed, 38 insertions(+), 10 deletions(-)\n\ndiff --git a/django/core/serializers/python.py b/django/core/serializers/python.py\nindex 36048601afd2..0dc504aa34e1 100644\n--- a/django/core/serializers/python.py\n+++ b/django/core/serializers/python.py\n@@ -79,7 +79,9 @@ def m2m_value(value):\n                     return self._value_from_field(value, value._meta.pk)\n \n                 def queryset_iterator(obj, field):\n-                    return getattr(obj, field.name).only(\"pk\").iterator()\n+                    return (\n+                        getattr(obj, field.name).select_related().only(\"pk\").iterator()\n+                    )\n \n             m2m_iter = getattr(obj, \"_prefetched_objects_cache\", {}).get(\n                 field.name,\ndiff --git a/django/core/serializers/xml_serializer.py b/django/core/serializers/xml_serializer.py\nindex 1d3269c41a5c..e0129a59bb80 100644\n--- a/django/core/serializers/xml_serializer.py\n+++ b/django/core/serializers/xml_serializer.py\n@@ -155,7 +155,9 @@ def handle_m2m(value):\n                     self.xml.addQuickElement(\"object\", attrs={\"pk\": str(value.pk)})\n \n                 def queryset_iterator(obj, field):\n-                    return getattr(obj, field.name).only(\"pk\").iterator()\n+                    return (\n+                        getattr(obj, field.name).select_related().only(\"pk\").iterator()\n+                    )\n \n             m2m_iter = getattr(obj, \"_prefetched_objects_cache\", {}).get(\n                 field.name,\ndiff --git a/docs/releases/4.2.2.txt b/docs/releases/4.2.2.txt\nindex 1bada4073baa..9b7d6c1b66e6 100644\n--- a/docs/releases/4.2.2.txt\n+++ b/docs/releases/4.2.2.txt\n@@ -43,3 +43,7 @@ Bugfixes\n * Fixed a regression in Django 4.2 that caused a crash of querysets on SQLite\n   when filtering on ``DecimalField`` against values outside of the defined\n   range (:ticket:`34590`).\n+\n+* Fixed a regression in Django 4.2 that caused a serialization crash on a\n+  ``ManyToManyField`` without a natural key when its ``Manager``\u2019s base\n+  ``QuerySet`` used ``select_related()`` (:ticket:`34620`).\ndiff --git a/tests/serializers/models/base.py b/tests/serializers/models/base.py\nindex af9ca2b20a5d..e9f548ad3c64 100644\n--- a/tests/serializers/models/base.py\n+++ b/tests/serializers/models/base.py\n@@ -53,12 +53,24 @@ def __str__(self):\n         return self.name\n \n \n+class TopicManager(models.Manager):\n+    def get_queryset(self):\n+        return super().get_queryset().select_related(\"category\")\n+\n+\n+class Topic(models.Model):\n+    name = models.CharField(max_length=255)\n+    category = models.ForeignKey(Category, models.CASCADE, null=True)\n+    objects = TopicManager()\n+\n+\n class Article(models.Model):\n     author = models.ForeignKey(Author, models.CASCADE)\n     headline = models.CharField(max_length=50)\n     pub_date = models.DateTimeField()\n     categories = models.ManyToManyField(Category)\n     meta_data = models.ManyToManyField(CategoryMetaData)\n+    topics = models.ManyToManyField(Topic)\n \n     class Meta:\n         ordering = (\"pub_date\",)\ndiff --git a/tests/serializers/test_json.py b/tests/serializers/test_json.py\nindex 0c625684acad..65d521faacb1 100644\n--- a/tests/serializers/test_json.py\n+++ b/tests/serializers/test_json.py\n@@ -38,7 +38,8 @@ class JsonSerializerTestCase(SerializersTestBase, TestCase):\n       %(first_category_pk)s,\n       %(second_category_pk)s\n     ],\n-    \"meta_data\": []\n+    \"meta_data\": [],\n+    \"topics\": []\n   }\n }\n ]\ndiff --git a/tests/serializers/test_jsonl.py b/tests/serializers/test_jsonl.py\nindex 16a0759e7439..3137b037a982 100644\n--- a/tests/serializers/test_jsonl.py\n+++ b/tests/serializers/test_jsonl.py\n@@ -27,7 +27,8 @@ class JsonlSerializerTestCase(SerializersTestBase, TestCase):\n         '\"headline\": \"Poker has no place on ESPN\",'\n         '\"pub_date\": \"2006-06-16T11:00:00\",'\n         '\"categories\": [%(first_category_pk)s,%(second_category_pk)s],'\n-        '\"meta_data\": []}}\\n'\n+        '\"meta_data\": [],'\n+        '\"topics\": []}}\\n'\n     )\n \n     @staticmethod\ndiff --git a/tests/serializers/test_xml.py b/tests/serializers/test_xml.py\nindex 5d8b9c04ccce..c9df2f2a5bc5 100644\n--- a/tests/serializers/test_xml.py\n+++ b/tests/serializers/test_xml.py\n@@ -26,6 +26,7 @@ class XmlSerializerTestCase(SerializersTestBase, TestCase):\n     <field name=\"pub_date\" type=\"DateTimeField\">2006-06-16T11:00:00</field>\n     <field name=\"categories\" rel=\"ManyToManyRel\" to=\"serializers.category\"><object pk=\"%(first_category_pk)s\"></object><object pk=\"%(second_category_pk)s\"></object></field>\n     <field name=\"meta_data\" rel=\"ManyToManyRel\" to=\"serializers.categorymetadata\"></field>\n+    <field name=\"topics\" rel=\"ManyToManyRel\" to=\"serializers.topic\"></field>\n   </object>\n </django-objects>\"\"\"  # NOQA\n \ndiff --git a/tests/serializers/test_yaml.py b/tests/serializers/test_yaml.py\nindex 683e0e06889f..6db6f046fd49 100644\n--- a/tests/serializers/test_yaml.py\n+++ b/tests/serializers/test_yaml.py\n@@ -113,6 +113,7 @@ class YamlSerializerTestCase(SerializersTestBase, TestCase):\n         )\n         + \"\"\"\n     meta_data: []\n+    topics: []\n \"\"\"\n     )\n \ndiff --git a/tests/serializers/tests.py b/tests/serializers/tests.py\nindex 67ae8f43de35..58bd74d3269b 100644\n--- a/tests/serializers/tests.py\n+++ b/tests/serializers/tests.py\n@@ -277,14 +277,14 @@ def test_serialize_superfluous_queries(self):\n     def test_serialize_prefetch_related_m2m(self):\n         # One query for the Article table and one for each prefetched m2m\n         # field.\n-        with self.assertNumQueries(3):\n+        with self.assertNumQueries(4):\n             serializers.serialize(\n                 self.serializer_name,\n-                Article.objects.prefetch_related(\"categories\", \"meta_data\"),\n+                Article.objects.prefetch_related(\"categories\", \"meta_data\", \"topics\"),\n             )\n-        # One query for the Article table, and two m2m queries for each\n+        # One query for the Article table, and three m2m queries for each\n         # article.\n-        with self.assertNumQueries(5):\n+        with self.assertNumQueries(7):\n             serializers.serialize(self.serializer_name, Article.objects.all())\n \n     def test_serialize_with_null_pk(self):\n@@ -409,7 +409,7 @@ def test_serialize_inherited_fields(self):\n         self.assertEqual(self._get_field_values(child_data, \"parent_data\"), [])\n \n     def test_serialize_only_pk(self):\n-        with self.assertNumQueries(5) as ctx:\n+        with self.assertNumQueries(7) as ctx:\n             serializers.serialize(\n                 self.serializer_name,\n                 Article.objects.all(),\n@@ -420,9 +420,11 @@ def test_serialize_only_pk(self):\n         self.assertNotIn(connection.ops.quote_name(\"meta_data_id\"), categories_sql)\n         meta_data_sql = ctx[2][\"sql\"]\n         self.assertNotIn(connection.ops.quote_name(\"kind\"), meta_data_sql)\n+        topics_data_sql = ctx[3][\"sql\"]\n+        self.assertNotIn(connection.ops.quote_name(\"category_id\"), topics_data_sql)\n \n     def test_serialize_no_only_pk_with_natural_keys(self):\n-        with self.assertNumQueries(5) as ctx:\n+        with self.assertNumQueries(7) as ctx:\n             serializers.serialize(\n                 self.serializer_name,\n                 Article.objects.all(),\n@@ -434,6 +436,8 @@ def test_serialize_no_only_pk_with_natural_keys(self):\n         # CategoryMetaData has natural_key().\n         meta_data_sql = ctx[2][\"sql\"]\n         self.assertIn(connection.ops.quote_name(\"kind\"), meta_data_sql)\n+        topics_data_sql = ctx[3][\"sql\"]\n+        self.assertNotIn(connection.ops.quote_name(\"category_id\"), topics_data_sql)\n \n \n class SerializerAPITests(SimpleTestCase):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16938"}