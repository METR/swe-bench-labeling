{"instance_id": "pydata__xarray-6744", "score": "I", "diff": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..7459ddc1 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -268,12 +268,42 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         self.window_labels = self.obj[self.dim[0]]\n \n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+        \"\"\"\n+        Iterate over the rolling windows.\n+\n+        Yields\n+        ------\n+        label : RollingKey\n+            The label of the window. When center is True, this is the label of the center\n+            element of the window. When center is False, this is the label of the last\n+            element in the window.\n+        window : DataArray\n+            A DataArray containing the data in the current window.\n+\n+        Notes\n+        -----\n+        The iteration accounts for the 'center' parameter, adjusting the window positions\n+        and labels accordingly.\n+        \"\"\"\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window_size = int(self.window[0])\n+        half_window = window_size // 2\n+        data_size = len(self.window_labels)\n+        \n+        if self.center:\n+            stops = np.arange(window_size, data_size + half_window + 1)\n+            starts = stops - window_size\n+            starts = np.maximum(starts, 0)\n+            stops = np.minimum(stops, data_size)\n+            labels = self.window_labels[half_window:data_size]\n+        else:\n+            stops = np.arange(1, data_size + 1)\n+            starts = stops - window_size\n+            starts = np.maximum(starts, 0)\n+            labels = self.window_labels\n+\n+        for (label, start, stop) in zip(labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n             counts = window.count(dim=self.dim[0])\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex f0b1c341668..9f6f3622f71 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -54,6 +54,9 @@ Bug fixes\n - :py:meth:`open_dataset` with dask and ``~`` in the path now resolves the home directory\n   instead of raising an error. (:issue:`6707`, :pull:`6710`)\n   By `Michael Niklas <https://github.com/headtr1ck>`_.\n+- :py:meth:`DataArrayRolling.__iter__` with ``center=True`` now works correctly.\n+  (:issue:`6739`, :pull:`6744`)\n+  By `Michael Niklas <https://github.com/headtr1ck>`_.\n \n Documentation\n ~~~~~~~~~~~~~\ndiff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6d7f..43a941b90d3 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,16 +267,21 @@ def __init__(\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    def __iter__(self) -> Iterator[tuple[DataArray, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+\n+        dim0 = self.dim[0]\n+        window0 = int(self.window[0])\n+        offset = (window0 + 1) // 2 if self.center[0] else 1\n+        stops = np.arange(offset, self.obj.sizes[dim0] + offset)\n+        starts = stops - window0\n+        starts[: window0 - offset] = 0\n+\n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+            window = self.obj.isel({dim0: slice(start, stop)})\n \n-            counts = window.count(dim=self.dim[0])\n+            counts = window.count(dim=dim0)\n             window = window.where(counts >= self.min_periods)\n \n             yield (label, window)\ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 2d6efff7411..e751ea4be64 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -27,8 +27,10 @@\n \n class TestDataArrayRolling:\n     @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-    def test_rolling_iter(self, da) -> None:\n-        rolling_obj = da.rolling(time=7)\n+    @pytest.mark.parametrize(\"center\", [True, False])\n+    @pytest.mark.parametrize(\"size\", [1, 2, 3, 7])\n+    def test_rolling_iter(self, da: DataArray, center: bool, size: int) -> None:\n+        rolling_obj = da.rolling(time=size, center=center)\n         rolling_obj_mean = rolling_obj.mean()\n \n         assert len(rolling_obj.window_labels) == len(da[\"time\"])\n@@ -40,14 +42,7 @@ def test_rolling_iter(self, da) -> None:\n             actual = rolling_obj_mean.isel(time=i)\n             expected = window_da.mean(\"time\")\n \n-            # TODO add assert_allclose_with_nan, which compares nan position\n-            # as well as the closeness of the values.\n-            assert_array_equal(actual.isnull(), expected.isnull())\n-            if (~actual.isnull()).sum() > 0:\n-                np.allclose(\n-                    actual.values[actual.values.nonzero()],\n-                    expected.values[expected.values.nonzero()],\n-                )\n+            np.testing.assert_allclose(actual.values, expected.values)\n \n     @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n     def test_rolling_repr(self, da) -> None:\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/6744"}