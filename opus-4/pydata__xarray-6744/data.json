{"instance_id": "pydata__xarray-6744", "score": "C", "diff": "diff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 00000000..db8d5530\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,46 @@\n+import xarray as xr\n+import numpy as np\n+\n+print(\"Testing edge cases for rolling window with centering...\")\n+\n+# Edge case 1: Small array with large window\n+data1 = xr.DataArray([1, 2, 3], dims=\"x\")\n+r1 = data1.rolling(x=5, center=True)\n+result1a = r1.mean().values\n+result1b = [w.mean().values.item() for _, w in r1]\n+print(f\"\\nSmall array (3) with large window (5):\")\n+print(f\"  Built-in: {result1a}\")\n+print(f\"  Manual:   {result1b}\")\n+print(f\"  Match:    {np.allclose(result1a, result1b, equal_nan=True)}\")\n+\n+# Edge case 2: Window size equals array size\n+data2 = xr.DataArray(np.arange(1, 6), dims=\"x\")\n+r2 = data2.rolling(x=5, center=True)\n+result2a = r2.mean().values\n+result2b = [w.mean().values.item() for _, w in r2]\n+print(f\"\\nWindow size equals array size:\")\n+print(f\"  Built-in: {result2a}\")\n+print(f\"  Manual:   {result2b}\")\n+print(f\"  Match:    {np.allclose(result2a, result2b, equal_nan=True)}\")\n+\n+# Edge case 3: Single element array\n+data3 = xr.DataArray([42], dims=\"x\")\n+r3 = data3.rolling(x=1, center=True)  # Changed window size to 1\n+result3a = r3.mean().values\n+result3b = [w.mean().values.item() for _, w in r3]\n+print(f\"\\nSingle element array with window size 1:\")\n+print(f\"  Built-in: {result3a}\")\n+print(f\"  Manual:   {result3b}\")\n+print(f\"  Match:    {np.allclose(result3a, result3b, equal_nan=True)}\")\n+\n+# Edge case 4: Window size 2 (even) with small array\n+data4 = xr.DataArray([1, 2, 3, 4], dims=\"x\")\n+r4 = data4.rolling(x=2, center=True)\n+result4a = r4.mean().values\n+result4b = [w.mean().values.item() for _, w in r4]\n+print(f\"\\nEven window size (2) with small array:\")\n+print(f\"  Built-in: {result4a}\")\n+print(f\"  Manual:   {result4b}\")\n+print(f\"  Match:    {np.allclose(result4a, result4b, equal_nan=True)}\")\n+\n+print(\"\\nAll edge case tests completed!\")\ndiff --git a/test_rolling_center_issue.py b/test_rolling_center_issue.py\nnew file mode 100644\nindex 00000000..4f7ad4ad\n--- /dev/null\n+++ b/test_rolling_center_issue.py\n@@ -0,0 +1,19 @@\n+import xarray as xr\n+import numpy as np\n+\n+# Test the issue\n+my_data = xr.DataArray(np.arange(1,10), dims=\"x\")\n+\n+# Option 1: take a center-justified rolling average\n+result1 = my_data.rolling(x=3, center=True).mean().values\n+print(\"Result 1 (center=True with .mean()):\", result1)\n+\n+# Option 2: try to manually iterate, but the result is not centered\n+my_data_rolling = my_data.rolling(x=3, center=True)\n+result2 = [window.mean().values.item() for label, window in my_data_rolling]\n+print(\"Result 2 (center=True with manual iteration):\", result2)\n+\n+# Let's also check what windows are being generated\n+print(\"\\nWindows from manual iteration:\")\n+for i, (label, window) in enumerate(my_data.rolling(x=3, center=True)):\n+    print(f\"Window {i} (label={label.values}): {window.values}\")\ndiff --git a/test_rolling_center_iter.py b/test_rolling_center_iter.py\nnew file mode 100644\nindex 00000000..e732fb47\n--- /dev/null\n+++ b/test_rolling_center_iter.py\n@@ -0,0 +1,37 @@\n+import xarray as xr\n+import numpy as np\n+import pytest\n+\n+\n+def test_rolling_center_iteration():\n+    \"\"\"Test that center parameter is respected when manually iterating over DataArrayRolling\"\"\"\n+    my_data = xr.DataArray(np.arange(1, 10), dims=\"x\")\n+    \n+    # Option 1: take a center-justified rolling average\n+    result1 = my_data.rolling(x=3, center=True).mean().values\n+    \n+    # Option 2: manually iterate\n+    my_data_rolling = my_data.rolling(x=3, center=True)\n+    result2 = [window.mean().values.item() for label, window in my_data_rolling]\n+    \n+    # Check that results are the same\n+    np.testing.assert_allclose(result1, result2, equal_nan=True)\n+    \n+    # Check that the expected values are correct\n+    expected = np.array([np.nan, 2., 3., 4., 5., 6., 7., 8., np.nan])\n+    np.testing.assert_allclose(result1, expected, equal_nan=True)\n+    \n+    # Also test with center=False to ensure backward compatibility\n+    result3 = my_data.rolling(x=3, center=False).mean().values\n+    result4 = [window.mean().values.item() for label, window in my_data.rolling(x=3, center=False)]\n+    np.testing.assert_allclose(result3, result4, equal_nan=True)\n+    \n+    # Test with even window size\n+    result5 = my_data.rolling(x=4, center=True).mean().values\n+    result6 = [window.mean().values.item() for label, window in my_data.rolling(x=4, center=True)]\n+    np.testing.assert_allclose(result5, result6, equal_nan=True)\n+\n+\n+if __name__ == \"__main__\":\n+    test_rolling_center_iteration()\n+    print(\"All tests passed!\")\ndiff --git a/test_rolling_comprehensive.py b/test_rolling_comprehensive.py\nnew file mode 100644\nindex 00000000..aa1a5fb2\n--- /dev/null\n+++ b/test_rolling_comprehensive.py\n@@ -0,0 +1,52 @@\n+import xarray as xr\n+import numpy as np\n+\n+# Test 1: Basic test with window size 3\n+print(\"=== Test 1: Window size 3 ===\")\n+my_data = xr.DataArray(np.arange(1, 10), dims=\"x\")\n+\n+# Compare centered results\n+result1 = my_data.rolling(x=3, center=True).mean().values\n+result2 = [window.mean().values.item() for label, window in my_data.rolling(x=3, center=True)]\n+print(f\"Built-in mean with center=True: {result1}\")\n+print(f\"Manual iteration with center=True: {result2}\")\n+print(f\"Results match: {np.allclose(result1, result2, equal_nan=True)}\")\n+\n+# Compare non-centered results\n+result3 = my_data.rolling(x=3, center=False).mean().values\n+result4 = [window.mean().values.item() for label, window in my_data.rolling(x=3, center=False)]\n+print(f\"\\nBuilt-in mean with center=False: {result3}\")\n+print(f\"Manual iteration with center=False: {result4}\")\n+print(f\"Results match: {np.allclose(result3, result4, equal_nan=True)}\")\n+\n+# Test 2: Even window size\n+print(\"\\n=== Test 2: Window size 4 (even) ===\")\n+result5 = my_data.rolling(x=4, center=True).mean().values\n+result6 = [window.mean().values.item() for label, window in my_data.rolling(x=4, center=True)]\n+print(f\"Built-in mean with center=True: {result5}\")\n+print(f\"Manual iteration with center=True: {result6}\")\n+print(f\"Results match: {np.allclose(result5, result6, equal_nan=True)}\")\n+\n+# Test 3: Larger window\n+print(\"\\n=== Test 3: Window size 5 ===\")\n+result7 = my_data.rolling(x=5, center=True).mean().values\n+result8 = [window.mean().values.item() for label, window in my_data.rolling(x=5, center=True)]\n+print(f\"Built-in mean with center=True: {result7}\")\n+print(f\"Manual iteration with center=True: {result8}\")\n+print(f\"Results match: {np.allclose(result7, result8, equal_nan=True)}\")\n+\n+# Test 4: With min_periods\n+print(\"\\n=== Test 4: Window size 3, min_periods=2 ===\")\n+result9 = my_data.rolling(x=3, center=True, min_periods=2).mean().values\n+result10 = [window.mean().values.item() for label, window in my_data.rolling(x=3, center=True, min_periods=2)]\n+print(f\"Built-in mean with center=True: {result9}\")\n+print(f\"Manual iteration with center=True: {result10}\")\n+print(f\"Results match: {np.allclose(result9, result10, equal_nan=True)}\")\n+\n+# Test 5: Edge case - window size 1\n+print(\"\\n=== Test 5: Window size 1 ===\")\n+result11 = my_data.rolling(x=1, center=True).mean().values\n+result12 = [window.mean().values.item() for label, window in my_data.rolling(x=1, center=True)]\n+print(f\"Built-in mean with center=True: {result11}\")\n+print(f\"Manual iteration with center=True: {result12}\")\n+print(f\"Results match: {np.allclose(result11, result12, equal_nan=True)}\")\ndiff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..12031b1f 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -270,16 +270,44 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n-\n-            counts = window.count(dim=self.dim[0])\n-            window = window.where(counts >= self.min_periods)\n-\n-            yield (label, window)\n+        \n+        window_size = int(self.window[0])\n+        n_labels = len(self.window_labels)\n+        \n+        if self.center[0]:\n+            # For centered windows, we need to adjust the start/stop positions\n+            offset = window_size // 2\n+            \n+            for i, label in enumerate(self.window_labels):\n+                # Calculate centered window positions\n+                start = i - offset\n+                stop = i + window_size - offset\n+                \n+                # Handle boundaries\n+                if start < 0:\n+                    start = 0\n+                if stop > n_labels:\n+                    stop = n_labels\n+                    \n+                window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+                \n+                counts = window.count(dim=self.dim[0])\n+                window = window.where(counts >= self.min_periods)\n+                \n+                yield (label, window)\n+        else:\n+            # Original logic for non-centered windows\n+            stops = np.arange(1, n_labels + 1)\n+            starts = stops - window_size\n+            starts[: window_size] = 0\n+            \n+            for (label, start, stop) in zip(self.window_labels, starts, stops):\n+                window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+\n+                counts = window.count(dim=self.dim[0])\n+                window = window.where(counts >= self.min_periods)\n+\n+                yield (label, window)\n \n     def construct(\n         self,\ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 2d6efff7..0257ba7f 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -49,6 +49,34 @@ class TestDataArrayRolling:\n                     expected.values[expected.values.nonzero()],\n                 )\n \n+    def test_rolling_iter_center(self) -> None:\n+        \"\"\"Test that center parameter is respected when manually iterating over DataArrayRolling\"\"\"\n+        my_data = DataArray(np.arange(1, 10), dims=\"x\")\n+        \n+        # Option 1: take a center-justified rolling average\n+        result1 = my_data.rolling(x=3, center=True).mean().values\n+        \n+        # Option 2: manually iterate\n+        my_data_rolling = my_data.rolling(x=3, center=True)\n+        result2 = [window.mean().values.item() for label, window in my_data_rolling]\n+        \n+        # Check that results are the same\n+        np.testing.assert_allclose(result1, result2, equal_nan=True)\n+        \n+        # Check that the expected values are correct\n+        expected = np.array([np.nan, 2., 3., 4., 5., 6., 7., 8., np.nan])\n+        np.testing.assert_allclose(result1, expected, equal_nan=True)\n+        \n+        # Also test with center=False to ensure backward compatibility\n+        result3 = my_data.rolling(x=3, center=False).mean().values\n+        result4 = [window.mean().values.item() for label, window in my_data.rolling(x=3, center=False)]\n+        np.testing.assert_allclose(result3, result4, equal_nan=True)\n+        \n+        # Test with even window size\n+        result5 = my_data.rolling(x=4, center=True).mean().values\n+        result6 = [window.mean().values.item() for label, window in my_data.rolling(x=4, center=True)]\n+        np.testing.assert_allclose(result5, result6, equal_nan=True)\n+\n     @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n     def test_rolling_repr(self, da) -> None:\n         rolling_obj = da.rolling(time=7)\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex f0b1c341668..9f6f3622f71 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -54,6 +54,9 @@ Bug fixes\n - :py:meth:`open_dataset` with dask and ``~`` in the path now resolves the home directory\n   instead of raising an error. (:issue:`6707`, :pull:`6710`)\n   By `Michael Niklas <https://github.com/headtr1ck>`_.\n+- :py:meth:`DataArrayRolling.__iter__` with ``center=True`` now works correctly.\n+  (:issue:`6739`, :pull:`6744`)\n+  By `Michael Niklas <https://github.com/headtr1ck>`_.\n \n Documentation\n ~~~~~~~~~~~~~\ndiff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6d7f..43a941b90d3 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,16 +267,21 @@ def __init__(\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    def __iter__(self) -> Iterator[tuple[DataArray, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+\n+        dim0 = self.dim[0]\n+        window0 = int(self.window[0])\n+        offset = (window0 + 1) // 2 if self.center[0] else 1\n+        stops = np.arange(offset, self.obj.sizes[dim0] + offset)\n+        starts = stops - window0\n+        starts[: window0 - offset] = 0\n+\n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+            window = self.obj.isel({dim0: slice(start, stop)})\n \n-            counts = window.count(dim=self.dim[0])\n+            counts = window.count(dim=dim0)\n             window = window.where(counts >= self.min_periods)\n \n             yield (label, window)\ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 2d6efff7411..e751ea4be64 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -27,8 +27,10 @@\n \n class TestDataArrayRolling:\n     @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-    def test_rolling_iter(self, da) -> None:\n-        rolling_obj = da.rolling(time=7)\n+    @pytest.mark.parametrize(\"center\", [True, False])\n+    @pytest.mark.parametrize(\"size\", [1, 2, 3, 7])\n+    def test_rolling_iter(self, da: DataArray, center: bool, size: int) -> None:\n+        rolling_obj = da.rolling(time=size, center=center)\n         rolling_obj_mean = rolling_obj.mean()\n \n         assert len(rolling_obj.window_labels) == len(da[\"time\"])\n@@ -40,14 +42,7 @@ def test_rolling_iter(self, da) -> None:\n             actual = rolling_obj_mean.isel(time=i)\n             expected = window_da.mean(\"time\")\n \n-            # TODO add assert_allclose_with_nan, which compares nan position\n-            # as well as the closeness of the values.\n-            assert_array_equal(actual.isnull(), expected.isnull())\n-            if (~actual.isnull()).sum() > 0:\n-                np.allclose(\n-                    actual.values[actual.values.nonzero()],\n-                    expected.values[expected.values.nonzero()],\n-                )\n+            np.testing.assert_allclose(actual.values, expected.values)\n \n     @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n     def test_rolling_repr(self, da) -> None:\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/6744"}