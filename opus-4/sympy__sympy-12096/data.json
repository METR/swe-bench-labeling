{"instance_id": "sympy__sympy-12096", "score": "I", "diff": "diff --git a/sympy/core/function.py b/sympy/core/function.py\nindex 1b8005e1d2..58e95ec105 100644\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -507,7 +507,21 @@ def _eval_evalf(self, prec):\n             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n             try:\n-                return Float(self._imp_(*self.args), prec)\n+                # Evaluate arguments first before passing to _imp_\n+                evaled_args = []\n+                for arg in self.args:\n+                    evaled = arg.evalf(prec)\n+                    # If evalf didn't change the arg (e.g., for symbolic expressions),\n+                    # we can't evaluate numerically\n+                    if evaled == arg:\n+                        return None\n+                    evaled_args.append(evaled)\n+                \n+                result = self._imp_(*evaled_args)\n+                # Use sympify to handle both real and complex results\n+                result_sym = sympify(result)\n+                # Now evalf the sympified result to ensure proper precision\n+                return result_sym.evalf(prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n \ndiff --git a/test_complex.py b/test_complex.py\nnew file mode 100644\nindex 0000000000..bec1f6e9f8\n--- /dev/null\n+++ b/test_complex.py\n@@ -0,0 +1,24 @@\n+from sympy.utilities.lambdify import implemented_function\n+from sympy import Float, I\n+import math\n+\n+# Test complex return values\n+fc = implemented_function('fc', lambda x: x**2 + 1j*x)\n+result = fc._imp_(2)\n+print(f\"fc._imp_(2) = {result}\")\n+print(f\"type(result) = {type(result)}\")\n+\n+# Let's try to understand how Float handles this\n+try:\n+    f = Float(result, 15)\n+    print(f\"Float(result, 15) = {f}\")\n+except Exception as e:\n+    print(f\"Error converting to Float: {e}\")\n+\n+# Test with real result\n+f_real = implemented_function('f_real', lambda x: x**2)\n+result_real = f_real._imp_(2)\n+print(f\"\\nf_real._imp_(2) = {result_real}\")\n+print(f\"type(result_real) = {type(result_real)}\")\n+f = Float(result_real, 15)\n+print(f\"Float(result_real, 15) = {f}\")\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..6f605bd165\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,55 @@\n+from sympy.utilities.lambdify import implemented_function\n+from sympy import Function, sin, cos, exp, log, sqrt, symbols, pi, I\n+import math\n+\n+# Test 1: Original issue - nested implemented functions\n+print(\"Test 1: Nested implemented functions\")\n+f = implemented_function('f', lambda x: x ** 2)\n+g = implemented_function('g', lambda x: 2 * x)\n+print(f\"f(g(2)).evalf() = {f(g(2)).evalf()}\")  # Should be 16.0\n+print(f\"f(g(3)).evalf() = {f(g(3)).evalf()}\")  # Should be 36.0\n+\n+# Test 2: Triple nesting\n+print(\"\\nTest 2: Triple nesting\")\n+h = implemented_function('h', lambda x: x + 1)\n+print(f\"f(g(h(1))).evalf() = {f(g(h(1))).evalf()}\")  # h(1)=2, g(2)=4, f(4)=16\n+\n+# Test 3: Complex values\n+print(\"\\nTest 3: Complex values\")\n+fc = implemented_function('fc', lambda x: x**2 + 1j*x)\n+print(f\"fc(2).evalf() = {fc(2).evalf()}\")  # Should be 4 + 2*I\n+print(f\"fc(g(1)).evalf() = {fc(g(1)).evalf()}\")  # g(1)=2, fc(2)=4+2*I\n+\n+# Test 4: Symbolic arguments (should not evaluate)\n+print(\"\\nTest 4: Symbolic arguments\")\n+x = symbols('x')\n+print(f\"f(x) = {f(x)}\")\n+print(f\"f(x).evalf() = {f(x).evalf()}\")  # Should still be f(x)\n+\n+# Test 5: Mixed with built-in functions\n+print(\"\\nTest 5: Mixed with built-in functions\")\n+print(f\"sin(1).evalf() = {sin(1).evalf()}\")\n+fs = implemented_function('fs', lambda x: math.sin(x))\n+print(f\"fs(1).evalf() = {fs(1).evalf()}\")\n+print(f\"f(sin(1)).evalf() = {f(sin(1)).evalf()}\")  # sin(1)^2\n+\n+# Test 6: Ensure regular mpmath functions still work\n+print(\"\\nTest 6: Regular functions\")\n+print(f\"exp(1).evalf() = {exp(1).evalf()}\")\n+print(f\"log(10).evalf() = {log(10).evalf()}\")\n+print(f\"sqrt(2).evalf() = {sqrt(2).evalf()}\")\n+print(f\"cos(pi).evalf() = {cos(pi).evalf()}\")\n+\n+# Test 7: Error handling\n+print(\"\\nTest 7: Error handling\")\n+try:\n+    bad_func = implemented_function('bad', lambda x: 1/0)\n+    print(f\"bad_func(1).evalf() = {bad_func(1).evalf()}\")\n+except:\n+    print(\"Error caught as expected\")\n+\n+# Test 8: Multiple arguments\n+print(\"\\nTest 8: Multiple arguments\")\n+f2 = implemented_function('f2', lambda x, y: x + y)\n+print(f\"f2(2, 3).evalf() = {f2(2, 3).evalf()}\")  # Should be 5.0\n+print(f\"f2(g(1), h(2)).evalf() = {f2(g(1), h(2)).evalf()}\")  # g(1)=2, h(2)=3, f2(2,3)=5\ndiff --git a/test_evalf_check.py b/test_evalf_check.py\nnew file mode 100644\nindex 0000000000..cb8dc999e8\n--- /dev/null\n+++ b/test_evalf_check.py\n@@ -0,0 +1,15 @@\n+from sympy import Integer, symbols\n+\n+# Check evalf behavior\n+x = symbols('x')\n+two = Integer(2)\n+\n+print(f\"two = {two}\")\n+print(f\"two.evalf() = {two.evalf()}\")\n+print(f\"two == two.evalf() = {two == two.evalf()}\")\n+print(f\"type(two) = {type(two)}\")\n+print(f\"type(two.evalf()) = {type(two.evalf())}\")\n+\n+print(f\"\\nx = {x}\")\n+print(f\"x.evalf() = {x.evalf()}\")\n+print(f\"x == x.evalf() = {x == x.evalf()}\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..bf94f71b65\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,21 @@\n+from sympy.utilities.lambdify import implemented_function\n+from sympy import Function\n+\n+# Create the test case from the issue\n+f = implemented_function('f', lambda x: x ** 2)\n+g = implemented_function('g', lambda x: 2 * x)\n+\n+print(\"Testing individual functions:\")\n+print(f\"f(2).evalf() = {f(2).evalf()}\")  # Should print 4.00000000000000\n+print(f\"g(2).evalf() = {g(2).evalf()}\")  # Should print 4.00000000000000\n+\n+print(\"\\nTesting composition:\")\n+print(f\"f(g(2)).evalf() = {f(g(2)).evalf()}\")  # Currently prints f(g(2)), should print 16.00000000000000\n+\n+# Let's also test what g(2) evaluates to\n+print(f\"\\ng(2) = {g(2)}\")\n+print(f\"type(g(2)) = {type(g(2))}\")\n+\n+# Test the _imp_ method directly\n+print(f\"\\nf._imp_(4) = {f._imp_(4)}\")  # Should be 16\n+print(f\"g._imp_(2) = {g._imp_(2)}\")  # Should be 4\ndiff --git a/test_symbolic.py b/test_symbolic.py\nnew file mode 100644\nindex 0000000000..dd56b5262e\n--- /dev/null\n+++ b/test_symbolic.py\n@@ -0,0 +1,27 @@\n+from sympy import symbols, sin, exp\n+from sympy.utilities.lambdify import implemented_function\n+\n+x = symbols('x')\n+\n+# Test regular functions with symbolic args\n+print(\"Regular functions with symbolic args:\")\n+print(f\"sin(x).evalf() = {sin(x).evalf()}\")\n+print(f\"exp(x).evalf() = {exp(x).evalf()}\")\n+\n+# Test implemented function with symbolic arg\n+f = implemented_function('f', lambda x: x**2)\n+print(f\"\\nImplemented function with symbolic arg:\")\n+print(f\"f(x) = {f(x)}\")\n+print(f\"f(x).evalf() = {f(x).evalf()}\")\n+\n+# Test if _imp_ is being called with symbolic arg\n+print(f\"\\nDirect _imp_ call with symbolic arg:\")\n+try:\n+    result = f._imp_(x)\n+    print(f\"f._imp_(x) = {result}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+# Test evaluation with substitution\n+print(f\"\\nWith substitution:\")\n+print(f\"f(x).evalf(subs={{x: 2}}) = {f(x).evalf(subs={x: 2})}\")\ndiff --git a/test_sympify_complex.py b/test_sympify_complex.py\nnew file mode 100644\nindex 0000000000..1b531f01dc\n--- /dev/null\n+++ b/test_sympify_complex.py\n@@ -0,0 +1,19 @@\n+from sympy import sympify, Float, I\n+import math\n+\n+# Test how sympify handles complex numbers\n+c = 4 + 2j\n+print(f\"c = {c}\")\n+print(f\"type(c) = {type(c)}\")\n+\n+s = sympify(c)\n+print(f\"\\nsympify(c) = {s}\")\n+print(f\"type(sympify(c)) = {type(s)}\")\n+\n+# Now try evalf on it\n+print(f\"\\nsympify(c).evalf() = {s.evalf()}\")\n+\n+# Direct check\n+from sympy import re, im\n+print(f\"\\nre(s) = {re(s)}\")\n+print(f\"im(s) = {im(s)}\")\n", "gold_standard_diff": "diff --git a/sympy/core/function.py b/sympy/core/function.py\nindex 1b8005e1d230..c730d8c9c869 100644\n--- a/sympy/core/function.py\n+++ b/sympy/core/function.py\n@@ -507,7 +507,7 @@ def _eval_evalf(self, prec):\n             func = getattr(mpmath, fname)\n         except (AttributeError, KeyError):\n             try:\n-                return Float(self._imp_(*self.args), prec)\n+                return Float(self._imp_(*[i.evalf(prec) for i in self.args]), prec)\n             except (AttributeError, TypeError, ValueError):\n                 return\n \ndiff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex d8a1a68a2207..7c8dc3dd1034 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -751,6 +751,9 @@ def test_issue_2790():\n     assert lambdify((x, (y, (w, z))), w + x + y + z)(1, (2, (3, 4))) == 10\n     assert lambdify(x, x + 1, dummify=False)(1) == 2\n \n+def test_issue_12092():\n+    f = implemented_function('f', lambda x: x**2)\n+    assert f(f(2)).evalf() == Float(16)\n \n def test_ITE():\n     assert lambdify((x, y, z), ITE(x, y, z))(True, 5, 3) == 5\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/12096"}