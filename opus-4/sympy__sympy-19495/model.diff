diff --git a/analyze_test_failure.py b/analyze_test_failure.py
new file mode 100644
index 0000000000..fd779383a0
--- /dev/null
+++ b/analyze_test_failure.py
@@ -0,0 +1,44 @@
+from sympy import *
+from sympy.abc import x, y, z, w, n
+
+# Let's trace the specific test case more carefully
+p = Symbol('p', positive=True)
+cs = ConditionSet(n, n < x, Interval(0, oo))
+print(f"Original: {cs}")
+
+# What happens after substituting x with p?
+result = cs.subs(x, p)
+print(f"After subs(x, p): {result}")
+
+# Actually, I'm reading the test wrong. Let me look again.
+# The test at line 125-126 says:
+# assert ConditionSet(n, n < x, Interval(0, oo)).subs(x, p) == Interval(0, oo)
+
+# This means the test expects that when we substitute x with p (positive),
+# the ConditionSet should evaluate to just Interval(0, oo).
+
+# Let's think: if n is in [0, oo) and n < p where p is positive,
+# what values of n satisfy this?
+# - If p = 0.1, then n must be in [0, 0.1)
+# - If p = 100, then n must be in [0, 100)
+# - Since p is just "positive", we don't know its value
+
+# Actually, wait. Let me check if positive means > 0 or >= 0
+print(f"\np > 0: {p > 0}")
+print(f"p >= 0: {p >= 0}")
+
+# Also the test at line 127-128:
+# assert ConditionSet(n, n < x, Interval(-oo, 0)).subs(x, p) == S.EmptySet
+
+# This expects that when n is in (-oo, 0] and n < p (positive), the result is empty.
+# This makes sense because all n in (-oo, 0] are negative or 0, and p is positive,
+# so n < p is always true for all n in the interval.
+
+# Wait, that doesn't make sense. If n < p is always true, then the ConditionSet
+# should return the whole interval, not the empty set.
+
+# Actually, I think I'm misreading. Let me look at the interval notation:
+print(f"\nInterval(0, oo) = {Interval(0, oo)}")  # [0, oo)
+print(f"Interval(-oo, 0) = {Interval(-oo, 0)}")  # (-oo, 0]
+print(f"0 in Interval(0, oo): {0 in Interval(0, oo)}")
+print(f"0 in Interval(-oo, 0): {0 in Interval(-oo, 0)}")
diff --git a/debug_subs.py b/debug_subs.py
new file mode 100644
index 0000000000..7dbecc714d
--- /dev/null
+++ b/debug_subs.py
@@ -0,0 +1,26 @@
+from sympy import *
+from sympy.abc import x, y, n
+
+# Let's debug what happens step by step
+imageset_expr = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+cond_set = ConditionSet(x, Contains(y, Interval(-1,1)), imageset_expr)
+
+print("Original ConditionSet:")
+print(f"  sym: {cond_set.sym}")
+print(f"  condition: {cond_set.condition}")
+print(f"  base_set: {cond_set.base_set}")
+
+# Let's see what happens when we substitute y with 1/3 in the condition
+cond_after_sub = cond_set.condition.subs(y, Rational(1,3))
+print(f"\nCondition after subs: {cond_after_sub}")
+print(f"Condition evaluates to: {cond_after_sub.simplify()}")
+print(f"Is condition S.true? {cond_after_sub.simplify() == S.true}")
+
+# Let's check what the base set looks like after substitution
+base_after_sub = cond_set.base_set.subs(y, Rational(1,3))
+print(f"\nBase set after subs: {base_after_sub}")
+
+# Let's see what the _eval_subs method should return
+print("\nWhat _eval_subs should return when condition becomes True:")
+print("Since the condition is True, it should just return the base_set with y substituted")
+print(f"Expected: {base_after_sub}")
diff --git a/debug_test.py b/debug_test.py
new file mode 100644
index 0000000000..48e17eeb97
--- /dev/null
+++ b/debug_test.py
@@ -0,0 +1,20 @@
+from sympy import *
+from sympy.abc import x, y, z, w, n
+
+p = Symbol('p', positive=True)
+
+# Test case from line 125-126
+cond_set = ConditionSet(n, n < x, Interval(0, oo))
+print(f"Original: {cond_set}")
+
+result = cond_set.subs(x, p)
+print(f"After subs(x, p): {result}")
+print(f"Expected: Interval(0, oo)")
+
+# Let's understand what's happening
+print(f"\nCondition n < x after subs(x, p): {(n < x).subs(x, p)}")
+print(f"Since p is positive, what happens to the condition n < p for n in Interval(0, oo)?")
+
+# The condition n < p where p is positive and n is in [0, oo) doesn't simplify to True
+# because we don't know the value of p - it could be 0.5, in which case only n in [0, 0.5) would satisfy
+# So the expectation in the test might be wrong
diff --git a/investigate_failing_test.py b/investigate_failing_test.py
new file mode 100644
index 0000000000..a5b81800de
--- /dev/null
+++ b/investigate_failing_test.py
@@ -0,0 +1,43 @@
+from sympy import *
+from sympy.abc import x, y, z, w, n
+
+# Let's see what the condition evaluates to in the failing test case
+p = Symbol('p', positive=True)
+cs = ConditionSet(n, n < x, Interval(0, oo))
+print(f"Original ConditionSet: {cs}")
+
+# After substitution
+result = cs.subs(x, p)
+print(f"\nAfter subs(x, p):")
+print(f"  Result: {result}")
+print(f"  Expected: Interval(0, oo)")
+
+# Let's check what the condition becomes
+print(f"\nCondition n < x after subs(x, p): {(n < x).subs(x, p)}")
+print(f"Does (n < p) evaluate to True? {(n < p) is S.true}")
+print(f"Simplified: {(n < p).simplify()}")
+
+# OK so the condition doesn't evaluate to True, which means our code is correct
+# The test expectation seems wrong. Let me check if there's special handling for
+# positive symbols that I'm missing
+
+# Let's also check the other failing test case
+cs2 = ConditionSet(n, n < x, Interval(-oo, 0))
+result2 = cs2.subs(x, p)
+print(f"\n\nSecond test case:")
+print(f"Original: {cs2}")
+print(f"After subs(x, p): {result2}")
+print(f"Expected: EmptySet")
+
+# For this case, if n is in (-oo, 0] and p is positive,
+# then n < p is always true for all n in the interval
+# So the ConditionSet should return the whole interval, not EmptySet
+
+# Unless... let me check if intervals work differently
+print(f"\nIs Interval(-oo, 0) empty? {Interval(-oo, 0) is S.EmptySet}")
+print(f"Elements in Interval(-oo, 0): {Interval(-oo, 0)}")
+
+# Actually, I think I understand now. Let me check something else
+# Maybe the old behavior was specifically checking if the new value 
+# causes the condition to always be true or always be false
+# based on the assumptions
diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py
index 118eda6f77..c8c70929d9 100644
--- a/sympy/sets/conditionset.py
+++ b/sympy/sets/conditionset.py
@@ -243,7 +243,7 @@ def _eval_subs(self, old, new):
         cond = self.condition.subs(old, new)
         base = self.base_set.subs(old, new)
         if cond is S.true:
-            return ConditionSet(new, Contains(new, base), base)
+            return base
         return self.func(self.sym, cond, base)
 
     def dummy_eq(self, other, symbol=None):
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..23442a0607
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,36 @@
+from sympy import *
+from sympy.abc import x, y, n
+from sympy.solvers.solveset import solveset_real
+
+# Test case from the issue
+print("Test 1: FiniteSet case (works correctly)")
+result1 = solveset_real(Abs(x) - y, x)
+print(f"solveset_real(Abs(x) - y, x) = {result1}")
+sub1 = result1.subs(y, Rational(1,3))
+print(f"_.subs(y, Rational(1,3)) = {sub1}")
+
+print("\nTest 2: ImageSet case (has the bug)")
+imageset_expr = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+print(f"imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers) = {imageset_expr}")
+
+cond_set = ConditionSet(x, Contains(y, Interval(-1,1)), imageset_expr)
+print(f"ConditionSet(x, Contains(y, Interval(-1,1)), imageset_expr) = {cond_set}")
+
+sub2 = cond_set.subs(y, Rational(1,3))
+print(f"_.subs(y, Rational(1,3)) = {sub2}")
+
+# Expected output should be the imageset with y substituted
+print("\nExpected output: {2*pi*n + asin(1/3) | n in Integers}")
+
+# Show that xreplace and subs with simultaneous=True work correctly
+print("\nWorking alternatives:")
+xreplace_result = cond_set.xreplace({y: Rational(1,3)})
+print(f"xreplace: {xreplace_result}")
+
+subs_sim_result = cond_set.subs({y: Rational(1,3)}, simultaneous=True)
+print(f"subs with simultaneous=True: {subs_sim_result}")
+
+# Let's also test the ImageSet directly
+print("\nDirect ImageSet substitution (works correctly):")
+direct_sub = imageset_expr.subs(y, Rational(1,3))
+print(f"imageset_expr.subs(y, Rational(1,3)) = {direct_sub}")
diff --git a/understand_old_logic.py b/understand_old_logic.py
new file mode 100644
index 0000000000..da16ebfc2e
--- /dev/null
+++ b/understand_old_logic.py
@@ -0,0 +1,32 @@
+from sympy import *
+from sympy.abc import x, y, z, w, n
+
+# Let's understand what the old logic was trying to do
+p = Symbol('p', positive=True)
+
+# For the first test case:
+# ConditionSet(n, n < x, Interval(0, oo)).subs(x, p)
+# After subs: ConditionSet(n, n < p, Interval(0, oo))
+# Old behavior when cond is True: ConditionSet(new, Contains(new, base), base)
+# Would give: ConditionSet(p, Contains(p, Interval(0, oo)), Interval(0, oo))
+
+# Let's check if p is in Interval(0, oo)
+print(f"Is p (positive symbol) in Interval(0, oo)? {p in Interval(0, oo)}")
+print(f"Contains(p, Interval(0, oo)): {Contains(p, Interval(0, oo))}")
+print(f"Evaluated: {Contains(p, Interval(0, oo)).simplify()}")
+
+# Ah! Since p is positive, it's in [0, ∞), so Contains evaluates to True
+# So ConditionSet(p, True, Interval(0, oo)) would return Interval(0, oo)
+
+# For the second test case:
+# ConditionSet(n, n < x, Interval(-oo, 0)).subs(x, p)
+# Would give: ConditionSet(p, Contains(p, Interval(-oo, 0)), Interval(-oo, 0))
+print(f"\nIs p (positive symbol) in Interval(-oo, 0)? {p in Interval(-oo, 0)}")
+print(f"Contains(p, Interval(-oo, 0)): {Contains(p, Interval(-oo, 0))}")
+print(f"Evaluated: {Contains(p, Interval(-oo, 0)).simplify()}")
+
+# Since p is positive, it's NOT in (-∞, 0], so Contains evaluates to False
+# So ConditionSet(p, False, Interval(-oo, 0)) would return EmptySet
+
+# But wait, the condition n < p doesn't evaluate to True in the first place
+# Let me check when exactly the old code path is triggered
diff --git a/understand_test.py b/understand_test.py
new file mode 100644
index 0000000000..e989166444
--- /dev/null
+++ b/understand_test.py
@@ -0,0 +1,22 @@
+from sympy import *
+from sympy.abc import x, y, z, w, n
+
+# Let's check if maybe the old code had special logic for certain conditions
+p = Symbol('p', positive=True)
+
+# Let me check __new__ method behavior
+result = ConditionSet.__new__(ConditionSet, n, n < p, Interval(0, oo))
+print(f"ConditionSet(n, n < p, Interval(0, oo)) = {result}")
+
+# Actually, let's just trace through the actual issue
+# The issue is about ImageSet in ConditionSet
+# Let's verify the original issue still exists
+imageset_expr = imageset(Lambda(n, 2*n*pi + asin(y)), S.Integers)
+cond_set = ConditionSet(x, Contains(y, Interval(-1,1)), imageset_expr)
+print(f"\nOriginal issue test:")
+print(f"ConditionSet: {cond_set}")
+print(f"After subs(y, 1/3): {cond_set.subs(y, Rational(1,3))}")
+
+# Let's see what ConditionSet returns when condition is True from the start
+trivial_cond = ConditionSet(x, S.true, Interval(0, 1))
+print(f"\nConditionSet(x, True, Interval(0, 1)) = {trivial_cond}")
