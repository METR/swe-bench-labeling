{"instance_id": "sympy__sympy-13615", "score": "I", "diff": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb74..0320cb09ae 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -1719,17 +1719,32 @@ def reduce(A, B):\n         Simplify a :class:`Complement`.\n \n         \"\"\"\n-        if B == S.UniversalSet or A.is_subset(B):\n+        if B == S.UniversalSet:\n             return EmptySet()\n \n         if isinstance(B, Union):\n             return Intersection(s.complement(A) for s in B.args)\n \n-        result = B._complement(A)\n-        if result != None:\n-            return result\n-        else:\n-            return Complement(A, B, evaluate=False)\n+        if isinstance(A, FiniteSet):\n+            # Handle the case where A contains both symbols and numbers\n+            numeric_elements = [elem for elem in A if elem.is_number]\n+            symbolic_elements = [elem for elem in A if not elem.is_number]\n+            \n+            if isinstance(B, Interval):\n+                numeric_complement = FiniteSet(*[elem for elem in numeric_elements if elem < B.start or elem > B.end])\n+            elif isinstance(B, FiniteSet):\n+                numeric_complement = FiniteSet(*[elem for elem in numeric_elements if elem not in B])\n+            else:\n+                # For other set types, we can't determine the complement of numeric elements\n+                numeric_complement = FiniteSet(*numeric_elements)\n+            \n+            if symbolic_elements:\n+                return Union(numeric_complement, FiniteSet(*symbolic_elements))\n+            else:\n+                return numeric_complement\n+\n+        # For all other cases, return the unevaluated Complement\n+        return Complement(A, B, evaluate=False)\n \n     def _contains(self, other):\n         A = self.args[0]\n", "gold_standard_diff": "diff --git a/sympy/sets/sets.py b/sympy/sets/sets.py\nindex 917717bb7429..659b778808ae 100644\n--- a/sympy/sets/sets.py\n+++ b/sympy/sets/sets.py\n@@ -217,7 +217,17 @@ def _complement(self, other):\n             return S.EmptySet\n \n         elif isinstance(other, FiniteSet):\n-            return FiniteSet(*[el for el in other if self.contains(el) != True])\n+            from sympy.utilities.iterables import sift\n+\n+            def ternary_sift(el):\n+                contains = self.contains(el)\n+                return contains if contains in [True, False] else None\n+\n+            sifted = sift(other, ternary_sift)\n+            # ignore those that are contained in self\n+            return Union(FiniteSet(*(sifted[False])),\n+                Complement(FiniteSet(*(sifted[None])), self, evaluate=False)\n+                if sifted[None] else S.EmptySet)\n \n     def symmetric_difference(self, other):\n         \"\"\"\ndiff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 8c59d85b2045..f4d0483197ed 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -187,6 +187,10 @@ def test_Complement():\n \n     assert S.Reals - Union(S.Naturals, FiniteSet(pi)) == \\\n             Intersection(S.Reals - S.Naturals, S.Reals - FiniteSet(pi))\n+    # isssue 12712\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n+            Complement(FiniteSet(x, y), Interval(-10, 10))\n+\n \n def test_complement():\n     assert Interval(0, 1).complement(S.Reals) == \\\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13615"}