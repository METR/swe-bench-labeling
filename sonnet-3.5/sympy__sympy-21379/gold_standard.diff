From 818864a2a35d273984535fad197d9e7e91c49101 Mon Sep 17 00:00:00 2001
From: Zach Carmichael <20629897+craymichael@users.noreply.github.com>
Date: Sat, 24 Apr 2021 15:31:21 -0400
Subject: [PATCH 1/3] Check for PolynomialError that arises from gcd with
 Piecewise

---
 sympy/core/mod.py             | 45 +++++++++++++++++++----------------
 sympy/core/tests/test_arit.py | 14 +++++++++++
 2 files changed, 39 insertions(+), 20 deletions(-)

diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index b4f3de25234b..a124b956804b 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -40,6 +40,7 @@ def eval(cls, p, q):
         from sympy.core.mul import Mul
         from sympy.core.singleton import S
         from sympy.core.exprtools import gcd_terms
+        from sympy.polys.polyerrors import PolynomialError
         from sympy.polys.polytools import gcd
 
         def doit(p, q):
@@ -56,7 +57,7 @@ def doit(p, q):
 
             if q.is_Number:
                 if p.is_Number:
-                    return p%q
+                    return p % q
                 if q == 2:
                     if p.is_even:
                         return S.Zero
@@ -69,7 +70,7 @@ def doit(p, q):
                     return rv
 
             # by ratio
-            r = p/q
+            r = p / q
             if r.is_integer:
                 return S.Zero
             try:
@@ -78,8 +79,8 @@ def doit(p, q):
                 pass
             else:
                 if isinstance(d, int):
-                    rv = p - d*q
-                    if (rv*q < 0) == True:
+                    rv = p - d * q
+                    if (rv * q < 0) == True:
                         rv += q
                     return rv
 
@@ -110,14 +111,14 @@ def doit(p, q):
             qinner = p.args[1]
             if qinner % q == 0:
                 return cls(p.args[0], q)
-            elif (qinner*(q - qinner)).is_nonnegative:
+            elif (qinner * (q - qinner)).is_nonnegative:
                 # |qinner| < |q| and have same sign
                 return p
         elif isinstance(-p, cls):
             qinner = (-p).args[1]
             if qinner % q == 0:
                 return cls(-(-p).args[0], q)
-            elif (qinner*(q + qinner)).is_nonpositive:
+            elif (qinner * (q + qinner)).is_nonpositive:
                 # |qinner| < |q| and have different sign
                 return p
         elif isinstance(p, Add):
@@ -149,14 +150,14 @@ def doit(p, q):
                 prod_mod = Mul(*mod)
                 prod_non_mod = Mul(*non_mod)
                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])
-                net = prod_mod1*prod_mod
-                return prod_non_mod*cls(net, q)
+                net = prod_mod1 * prod_mod
+                return prod_non_mod * cls(net, q)
 
             if q.is_Integer and q is not S.One:
                 _ = []
                 for i in non_mod_l:
                     if i.is_Integer and (i % q is not S.Zero):
-                        _.append(i%q)
+                        _.append(i % q)
                     else:
                         _.append(i)
                 non_mod_l = _
@@ -166,10 +167,14 @@ def doit(p, q):
         # XXX other possibilities?
 
         # extract gcd; any further simplification should be done by the user
-        G = gcd(p, q)
-        if G != 1:
-            p, q = [
-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]
+        try:
+            G = gcd(p, q)
+            if G != 1:
+                p, q = [
+                    gcd_terms(i / G, clear=False, fraction=False)
+                    for i in (p, q)]
+        except PolynomialError:  # issue 21373
+            G = S.One
         pwas, qwas = p, q
 
         # simplify terms
@@ -196,11 +201,11 @@ def doit(p, q):
                 r = cp % cq
                 if r == 0:
                     G *= cq
-                    p *= int(cp/cq)
+                    p *= int(cp / cq)
                     ok = True
             if not ok:
-                p = cp*p
-                q = cq*q
+                p = cp * p
+                q = cq * q
 
         # simple -1 extraction
         if p.could_extract_minus_sign() and q.could_extract_minus_sign():
@@ -209,16 +214,16 @@ def doit(p, q):
         # check again to see if p and q can now be handled as numbers
         rv = doit(p, q)
         if rv is not None:
-            return rv*G
+            return rv * G
 
         # put 1.0 from G on inside
         if G.is_Float and G == 1:
             p *= G
             return cls(p, q, evaluate=False)
         elif G.is_Mul and G.args[0].is_Float and G.args[0] == 1:
-            p = G.args[0]*p
+            p = G.args[0] * p
             G = Mul._from_args(G.args[1:])
-        return G*cls(p, q, evaluate=(p, q) != (pwas, qwas))
+        return G * cls(p, q, evaluate=(p, q) != (pwas, qwas))
 
     def _eval_is_integer(self):
         from sympy.core.logic import fuzzy_and, fuzzy_not
@@ -236,4 +241,4 @@ def _eval_is_nonpositive(self):
 
     def _eval_rewrite_as_floor(self, a, b, **kwargs):
         from sympy.functions.elementary.integers import floor
-        return a - b*floor(a/b)
+        return a - b * floor(a / b)
diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
index 2dc6589f8c67..b538e7031e23 100644
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1913,6 +1913,20 @@ def test_Mod():
     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)
     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)
 
+    # issue 21373
+    from sympy.core.cache import clear_cache
+    from sympy.functions.elementary.trigonometric import sinh
+    from sympy.functions.elementary.piecewise import Piecewise
+
+    x_r, y_r = symbols('x_r y_r', real=True)
+    clear_cache()
+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1
+    clear_cache()
+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))
+    expr.subs({1: 1.0})
+    clear_cache()
+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero
+
 
 def test_Mod_Pow():
     # modular exponentiation

From 35b717e173f8237e61d727296deb07b7e445200e Mon Sep 17 00:00:00 2001
From: Zach Carmichael <20629897+craymichael@users.noreply.github.com>
Date: Sat, 24 Apr 2021 19:53:28 -0400
Subject: [PATCH 2/3] Undo editor formatting

---
 sympy/core/mod.py | 37 ++++++++++++++++++-------------------
 1 file changed, 18 insertions(+), 19 deletions(-)

diff --git a/sympy/core/mod.py b/sympy/core/mod.py
index a124b956804b..ebe7862aef6e 100644
--- a/sympy/core/mod.py
+++ b/sympy/core/mod.py
@@ -57,7 +57,7 @@ def doit(p, q):
 
             if q.is_Number:
                 if p.is_Number:
-                    return p % q
+                    return p%q
                 if q == 2:
                     if p.is_even:
                         return S.Zero
@@ -70,7 +70,7 @@ def doit(p, q):
                     return rv
 
             # by ratio
-            r = p / q
+            r = p/q
             if r.is_integer:
                 return S.Zero
             try:
@@ -79,8 +79,8 @@ def doit(p, q):
                 pass
             else:
                 if isinstance(d, int):
-                    rv = p - d * q
-                    if (rv * q < 0) == True:
+                    rv = p - d*q
+                    if (rv*q < 0) == True:
                         rv += q
                     return rv
 
@@ -111,14 +111,14 @@ def doit(p, q):
             qinner = p.args[1]
             if qinner % q == 0:
                 return cls(p.args[0], q)
-            elif (qinner * (q - qinner)).is_nonnegative:
+            elif (qinner*(q - qinner)).is_nonnegative:
                 # |qinner| < |q| and have same sign
                 return p
         elif isinstance(-p, cls):
             qinner = (-p).args[1]
             if qinner % q == 0:
                 return cls(-(-p).args[0], q)
-            elif (qinner * (q + qinner)).is_nonpositive:
+            elif (qinner*(q + qinner)).is_nonpositive:
                 # |qinner| < |q| and have different sign
                 return p
         elif isinstance(p, Add):
@@ -150,14 +150,14 @@ def doit(p, q):
                 prod_mod = Mul(*mod)
                 prod_non_mod = Mul(*non_mod)
                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])
-                net = prod_mod1 * prod_mod
-                return prod_non_mod * cls(net, q)
+                net = prod_mod1*prod_mod
+                return prod_non_mod*cls(net, q)
 
             if q.is_Integer and q is not S.One:
                 _ = []
                 for i in non_mod_l:
                     if i.is_Integer and (i % q is not S.Zero):
-                        _.append(i % q)
+                        _.append(i%q)
                     else:
                         _.append(i)
                 non_mod_l = _
@@ -170,9 +170,8 @@ def doit(p, q):
         try:
             G = gcd(p, q)
             if G != 1:
-                p, q = [
-                    gcd_terms(i / G, clear=False, fraction=False)
-                    for i in (p, q)]
+                p, q = [gcd_terms(i/G, clear=False, fraction=False)
+                        for i in (p, q)]
         except PolynomialError:  # issue 21373
             G = S.One
         pwas, qwas = p, q
@@ -201,11 +200,11 @@ def doit(p, q):
                 r = cp % cq
                 if r == 0:
                     G *= cq
-                    p *= int(cp / cq)
+                    p *= int(cp/cq)
                     ok = True
             if not ok:
-                p = cp * p
-                q = cq * q
+                p = cp*p
+                q = cq*q
 
         # simple -1 extraction
         if p.could_extract_minus_sign() and q.could_extract_minus_sign():
@@ -214,16 +213,16 @@ def doit(p, q):
         # check again to see if p and q can now be handled as numbers
         rv = doit(p, q)
         if rv is not None:
-            return rv * G
+            return rv*G
 
         # put 1.0 from G on inside
         if G.is_Float and G == 1:
             p *= G
             return cls(p, q, evaluate=False)
         elif G.is_Mul and G.args[0].is_Float and G.args[0] == 1:
-            p = G.args[0] * p
+            p = G.args[0]*p
             G = Mul._from_args(G.args[1:])
-        return G * cls(p, q, evaluate=(p, q) != (pwas, qwas))
+        return G*cls(p, q, evaluate=(p, q) != (pwas, qwas))
 
     def _eval_is_integer(self):
         from sympy.core.logic import fuzzy_and, fuzzy_not
@@ -241,4 +240,4 @@ def _eval_is_nonpositive(self):
 
     def _eval_rewrite_as_floor(self, a, b, **kwargs):
         from sympy.functions.elementary.integers import floor
-        return a - b * floor(a / b)
+        return a - b*floor(a/b)

From 209cba71b5da7c0667717419535fc91f1c2bdd47 Mon Sep 17 00:00:00 2001
From: Zach Carmichael <20629897+craymichael@users.noreply.github.com>
Date: Sat, 24 Apr 2021 19:57:36 -0400
Subject: [PATCH 3/3] No need to clear cache

---
 sympy/core/tests/test_arit.py | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
index b538e7031e23..f19cfeeaa2d8 100644
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1914,17 +1914,13 @@ def test_Mod():
     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)
 
     # issue 21373
-    from sympy.core.cache import clear_cache
     from sympy.functions.elementary.trigonometric import sinh
     from sympy.functions.elementary.piecewise import Piecewise
 
     x_r, y_r = symbols('x_r y_r', real=True)
-    clear_cache()
     (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1
-    clear_cache()
     expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))
     expr.subs({1: 1.0})
-    clear_cache()
     sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero
 
 
