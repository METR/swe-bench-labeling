{"instance_id": "sympy__sympy-15599", "score": "I", "diff": "diff --git a/check_test_expectation.py b/check_test_expectation.py\nnew file mode 100644\nindex 0000000000..8f157ac152\n--- /dev/null\n+++ b/check_test_expectation.py\n@@ -0,0 +1,30 @@\n+from sympy import Symbol, Mod, Float\n+\n+x = Symbol('x')\n+point3 = Float(3.3) % 1\n+\n+print(f\"point3 = {point3}\")\n+print(f\"1 - point3 = {1 - point3}\")\n+\n+# Test assertion says:\n+# assert (x - 3.3) % 1 == Mod(1.*x + 1 - point3, 1)\n+\n+left = (x - 3.3) % 1\n+right = Mod(1.*x + 1 - point3, 1)\n+\n+print(f\"\\nLeft side: (x - 3.3) % 1 = {left}\")\n+print(f\"Right side: Mod(1.*x + 1 - point3, 1) = {right}\")\n+\n+# But 1 - point3 = 1 - 0.3 = 0.7\n+print(f\"\\nSo right side is: Mod(1.0*x + 0.7, 1)\")\n+\n+# Are they equal?\n+print(f\"\\nAre they equal? {left == right}\")\n+print(f\"Left expanded: {left}\")\n+print(f\"Right expanded: {right}\")\n+\n+# Let's check the case without float\n+y = Symbol('y')\n+print(f\"\\n(y - 3) % 1 = {(y - 3) % 1}\")\n+print(f\"Mod(y + 1 - 3, 1) = {Mod(y + 1 - 3, 1)}\")\n+print(f\"Mod(y - 2, 1) = {Mod(y - 2, 1)}\")\ndiff --git a/debug_float_mod.py b/debug_float_mod.py\nnew file mode 100644\nindex 0000000000..6fb488105e\n--- /dev/null\n+++ b/debug_float_mod.py\n@@ -0,0 +1,27 @@\n+from sympy import Symbol, Mod, Float\n+\n+x = Symbol('x')\n+point3 = Float(3.3) % 1\n+print(f\"point3 = {point3}\")\n+\n+# The original expression\n+left = (x - 3.3) % 1\n+print(f\"(x - 3.3) % 1 = {left}\")\n+\n+# The expected expression\n+right = Mod(1.*x + 1 - point3, 1)\n+print(f\"Mod(1.*x + 1 - point3, 1) = {right}\")\n+\n+# Let's see what happens with our fix\n+print(f\"\\nDetailed analysis:\")\n+print(f\"x - 3.3 = {x - 3.3}\")\n+print(f\"Type: {type(x - 3.3)}\")\n+\n+# Test with concrete value\n+test_val = 5\n+left_val = left.subs(x, test_val)\n+right_val = right.subs(x, test_val)\n+print(f\"\\nWith x = {test_val}:\")\n+print(f\"Left: {left_val}\")\n+print(f\"Right: {right_val}\")\n+print(f\"Float values: {float(left_val)} vs {float(right_val)}\")\ndiff --git a/debug_mod_change.py b/debug_mod_change.py\nnew file mode 100644\nindex 0000000000..026b65dd5c\n--- /dev/null\n+++ b/debug_mod_change.py\n@@ -0,0 +1,31 @@\n+from sympy import Symbol, Mod, Float, Add\n+\n+x = Symbol('x')\n+\n+# Test case from failing test\n+expr = x - 3.3\n+print(f\"expr = {expr}\")\n+print(f\"type = {type(expr)}\")\n+print(f\"is_Add = {isinstance(expr, Add)}\")\n+\n+# Apply mod operation\n+result = expr % 1\n+print(f\"\\nexpr % 1 = {result}\")\n+print(f\"type = {type(result)}\")\n+\n+# Let's trace what happens step by step\n+print(\"\\n--- Tracing evaluation ---\")\n+\n+# expr is an Add: x + (-3.3)\n+# When we do % 1, it goes through simplify terms section\n+# Each term is evaluated: Mod(x, 1) and Mod(-3.3, 1)\n+\n+print(f\"Mod(x, 1) = {Mod(x, 1)}\")\n+print(f\"Mod(-3.3, 1) = {Mod(-3.3, 1)}\")\n+print(f\"Mod(Float(3.3), 1) = {Mod(Float(3.3), 1)}\")\n+\n+# Test with integer symbol\n+i = Symbol('i', integer=True)\n+print(f\"\\nWith integer symbol:\")\n+print(f\"Mod(3*i, 2) = {Mod(3*i, 2)}\")\n+print(f\"Mod(1.0*i, 2) = {Mod(1.0*i, 2)}\")\ndiff --git a/minimal_test.py b/minimal_test.py\nnew file mode 100644\nindex 0000000000..26a00de6a4\n--- /dev/null\n+++ b/minimal_test.py\n@@ -0,0 +1,24 @@\n+from sympy import Symbol, Mod\n+\n+# Simple case to understand the issue\n+x = Symbol('x')\n+\n+# This is what the test expects to remain unchanged\n+expr = Mod(1.0*x + 0.7, 1)\n+print(f\"Mod(1.0*x + 0.7, 1) = {expr}\")\n+\n+# But let's see what happens when we build it differently\n+result = (x - 3.3) % 1\n+print(f\"(x - 3.3) % 1 = {result}\")\n+\n+# The issue is that the test expects these to be equal:\n+# (x - 3.3) % 1 == Mod(1.0*x + 0.7, 1)\n+# But our change makes the right side simplify to 0.7\n+\n+# Let's test the integer case\n+i = Symbol('i', integer=True)\n+print(f\"\\nMod(3*i, 2) = {Mod(3*i, 2)}\")\n+\n+# And with float coefficient\n+print(f\"Mod(1.0*i, 1) = {Mod(1.0*i, 1)}\")\n+print(f\"Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex eae25630cc..0ef017ed6e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -123,9 +123,16 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if mod_l and all(inner.args[1] == q for inner in mod_l):\n+            # Check if we should apply the simplification\n+            # We need to be careful with float coefficients\n+            was = non_mod_l[:]\n+            non_mod_l_eval = [cls(x, q) for x in non_mod_l]\n+            changed = was != non_mod_l_eval\n+            \n+            # Only apply if we have integer terms or if mod_l has terms\n+            if changed or (mod_l and all(inner.args[1] == q for inner in mod_l)):\n                 # finding distributive term\n-                non_mod_l = [cls(x, q) for x in non_mod_l]\n+                non_mod_l = non_mod_l_eval\n                 mod = []\n                 non_mod = []\n                 for j in non_mod_l:\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 04d3b1ab9f..05e2d1979b 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1624,6 +1624,7 @@ def test_Mod():\n     i = Symbol('i', integer=True)\n     assert (3*i*x) % (2*i*y) == i*Mod(3*x, 2*y)\n     assert Mod(4*i, 4) == 0\n+    assert Mod(3*i, 2) == Mod(i, 2)\n \n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\ndiff --git a/test_mod_issue.py b/test_mod_issue.py\nnew file mode 100644\nindex 0000000000..45801c70a0\n--- /dev/null\n+++ b/test_mod_issue.py\n@@ -0,0 +1,20 @@\n+from sympy import Symbol, Mod\n+\n+# Create an integer symbol\n+i = Symbol('i', integer=True)\n+\n+# Test the current behavior\n+print(\"Current behavior:\")\n+print(f\"Mod(3*i, 2) = {Mod(3*i, 2)}\")\n+print(f\"Expected: Mod(i, 2)\")\n+\n+# Also test with regular symbols\n+k = Symbol('k')\n+print(f\"\\nWith regular symbol k:\")\n+print(f\"Mod(3*k, 2) = {Mod(3*k, 2)}\")\n+\n+# Test some related cases\n+print(f\"\\nRelated cases:\")\n+print(f\"Mod(4*i, 4) = {Mod(4*i, 4)}\")\n+print(f\"Mod(5*i, 3) = {Mod(5*i, 3)}\")\n+print(f\"Mod(7*i, 2) = {Mod(7*i, 2)}\")\ndiff --git a/trace_add_handling.py b/trace_add_handling.py\nnew file mode 100644\nindex 0000000000..57394a494d\n--- /dev/null\n+++ b/trace_add_handling.py\n@@ -0,0 +1,27 @@\n+from sympy import Symbol, Mod, Float, Add\n+\n+x = Symbol('x')\n+\n+# The issue is with Add handling\n+expr = 1.0*x + 0.7\n+print(f\"expr = {expr}\")\n+print(f\"type = {type(expr)}\")\n+print(f\"is Add? {isinstance(expr, Add)}\")\n+\n+# When Mod(1.0*x + 0.7, 1) is evaluated, it goes through Add handling\n+# The Add handling applies Mod to each term\n+print(f\"\\nAdd handling would do:\")\n+print(f\"  Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\n+print(f\"  Mod(0.7, 1) = {Mod(0.7, 1)}\")\n+print(f\"  Sum = {Mod(1.0*x, 1) + Mod(0.7, 1)}\")\n+\n+# But the test expects this to remain as Mod(1.0*x + 0.7, 1)\n+# Let's see what the test is actually checking\n+point3 = Float(3.3) % 1\n+print(f\"\\nTest case:\")\n+print(f\"  point3 = {point3}\")\n+print(f\"  1 - point3 = {1 - point3}\")\n+print(f\"  (x - 3.3) % 1 = {(x - 3.3) % 1}\")\n+print(f\"  Mod(1.*x + 1 - point3, 1) = {Mod(1.*x + 1 - point3, 1)}\")\n+\n+# The issue is that the right side simplifies because Mod(1.0*x, 1) = 0\ndiff --git a/trace_mod_eval.py b/trace_mod_eval.py\nnew file mode 100644\nindex 0000000000..68a0af1fbc\n--- /dev/null\n+++ b/trace_mod_eval.py\n@@ -0,0 +1,30 @@\n+from sympy import Symbol, Mod, Float, Add, Mul\n+\n+x = Symbol('x')\n+i = Symbol('i', integer=True)\n+\n+# Case 1: Mod(3*i, 2) - this should simplify\n+print(\"Case 1: Mod(3*i, 2)\")\n+expr1 = 3*i\n+print(f\"  expr = {expr1}, type = {type(expr1)}\")\n+print(f\"  isinstance(expr1, Mul) = {isinstance(expr1, Mul)}\")\n+print(f\"  Result: {Mod(expr1, 2)}\")\n+\n+# Case 2: Mod(1.0*x + 0.7, 1) - this should NOT simplify the 1.0*x part away\n+print(\"\\nCase 2: Mod(1.0*x + 0.7, 1)\")\n+expr2 = 1.0*x + 0.7\n+print(f\"  expr = {expr2}, type = {type(expr2)}\")\n+print(f\"  isinstance(expr2, Add) = {isinstance(expr2, Add)}\")\n+print(f\"  Result: {Mod(expr2, 1)}\")\n+\n+# The problem is in the Add handling, not Mul\n+# Let's see what happens with Add terms\n+print(\"\\nAdd term handling:\")\n+print(f\"  Mod(1.0*x, 1) = {Mod(1.0*x, 1)}\")\n+print(f\"  Mod(0.7, 1) = {Mod(0.7, 1)}\")\n+\n+# Check the mul case specifically\n+print(\"\\nMul case with float:\")\n+print(f\"  Mod(1.0*i, 2) = {Mod(1.0*i, 2)}\")\n+print(f\"  1.0*i is Mul? {isinstance(1.0*i, Mul)}\")\n+print(f\"  i has assumptions: {i.assumptions0}\")\n", "gold_standard_diff": "From ae4b6d621df6a919555e219470d241aa9eb128c3 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 6 Dec 2018 10:48:04 +0530\nSubject: [PATCH 01/15] modified mod\n\n---\n sympy/core/mod.py | 5 +++++\n 1 file changed, 5 insertions(+)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex eae25630cc21..6d035dbff2fd 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -123,6 +123,9 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n+            if q.is_Number:\n+                non_mod_l = [(x%q if x.is_Number else x) for x in non_mod_l]\n+\n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n                 # finding distributive term\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n@@ -138,6 +141,8 @@ def doit(p, q):\n                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n+            print(\"here\")\n+            return Mul(*non_mod_l)*cls(Mul(*mod_l), q)\n \n         # XXX other possibilities?\n \n\nFrom bb205305ba5214507d964895e3afd699c4e5f1f2 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 6 Dec 2018 11:15:55 +0530\nSubject: [PATCH 02/15] issue with Mod(e/2, 2)\n\n---\n sympy/core/mod.py | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 6d035dbff2fd..9ba8a26d2a8d 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -124,7 +124,7 @@ def doit(p, q):\n                 both_l[isinstance(arg, cls)].append(arg)\n \n             if q.is_Number:\n-                non_mod_l = [(x%q if x.is_Number else x) for x in non_mod_l]\n+                non_mod_l = [(x%q if x.is_Integer else x) for x in non_mod_l]\n \n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n                 # finding distributive term\n@@ -141,8 +141,8 @@ def doit(p, q):\n                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n-            print(\"here\")\n-            return Mul(*non_mod_l)*cls(Mul(*mod_l), q)\n+\n+            return cls(Mul(*non_mod_l), q)\n \n         # XXX other possibilities?\n \n\nFrom b3c0f9625574b550a467c6f99c1baa7851983207 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 6 Dec 2018 23:03:22 +0530\nSubject: [PATCH 03/15] added test into test_arit\n\n---\n sympy/core/tests/test_arit.py | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 04d3b1ab9fe5..314c85e62bb9 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1662,6 +1662,9 @@ def test_Mod():\n     assert Mod(Mod(x + 2, 4)*(x + 4), 4) == Mod(x*(x + 2), 4)\n     assert Mod(Mod(x + 2, 4)*4, 4) == 0\n \n+    # issue 15493\n+    assert Mod(3*i, 2) == Mod(i, 2)\n+\n \n def test_Mod_is_integer():\n     p = Symbol('p', integer=True)\n\nFrom 54377c89fb3985afbbc9fc47f7a87427eb4ba4c8 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 6 Dec 2018 23:04:31 +0530\nSubject: [PATCH 04/15] optimized function of Mod\n\n---\n sympy/core/mod.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 9ba8a26d2a8d..fd2b9c691400 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -142,7 +142,7 @@ def doit(p, q):\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n \n-            return cls(Mul(*non_mod_l), q)\n+            p = Mul(*non_mod_l)\n \n         # XXX other possibilities?\n \n\nFrom 2d51c4da3ddd9b61c973ed5d987d70a99ceceee6 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Sun, 16 Dec 2018 14:27:40 +0530\nSubject: [PATCH 05/15] bug with mod fixed\n\n---\n sympy/core/mod.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex fd2b9c691400..1eb0a0082442 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -123,7 +123,7 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if q.is_Number:\n+            if q is 2:\n                 non_mod_l = [(x%q if x.is_Integer else x) for x in non_mod_l]\n \n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n\nFrom 461af761b2e8cf7ddcd5d3e835ffe03d2cad9f02 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Wed, 19 Dec 2018 19:03:51 +0530\nSubject: [PATCH 06/15] bug with q as 1 fixed\n\n---\n sympy/core/mod.py | 15 ++++++++++-----\n 1 file changed, 10 insertions(+), 5 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 1eb0a0082442..6afe2e836832 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -44,8 +44,6 @@ def doit(p, q):\n                 return S.Zero\n \n             if q.is_Number:\n-                if p.is_Number:\n-                    return (p % q)\n                 if q == 2:\n                     if p.is_even:\n                         return S.Zero\n@@ -123,8 +121,15 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if q is 2:\n-                non_mod_l = [(x%q if x.is_Integer else x) for x in non_mod_l]\n+            if q.is_Integer and q is not S.One:\n+                _ = []\n+                for i in non_mod_l:\n+                    if i.is_Integer:\n+                        # and (i % q is not S.Zero)\n+                        _.append(i%q)\n+                    else:\n+                        _.append(i)\n+                non_mod_l = _\n \n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n                 # finding distributive term\n@@ -142,7 +147,7 @@ def doit(p, q):\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n \n-            p = Mul(*non_mod_l)\n+            p = Mul(*non_mod_l, *mod_l)\n \n         # XXX other possibilities?\n \n\nFrom 29906201099dfb2a32ef30148e94593648b11583 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Wed, 19 Dec 2018 23:56:49 +0530\nSubject: [PATCH 07/15] bug with Mul\n\n---\n sympy/core/mod.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 6afe2e836832..a5a024d9ae6c 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -147,7 +147,7 @@ def doit(p, q):\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n \n-            p = Mul(*non_mod_l, *mod_l)\n+            p = Mul(*non_mod_l)\n \n         # XXX other possibilities?\n \n\nFrom 83e2a00808a7cbfd024974d4122e032687b2bf33 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 20 Dec 2018 11:41:26 +0530\nSubject: [PATCH 08/15] resolved bug with unpacking of vars\n\n---\n sympy/core/mod.py | 22 +++++++++++-----------\n 1 file changed, 11 insertions(+), 11 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex a5a024d9ae6c..fc63babc0fbc 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -121,16 +121,6 @@ def doit(p, q):\n             for arg in p.args:\n                 both_l[isinstance(arg, cls)].append(arg)\n \n-            if q.is_Integer and q is not S.One:\n-                _ = []\n-                for i in non_mod_l:\n-                    if i.is_Integer:\n-                        # and (i % q is not S.Zero)\n-                        _.append(i%q)\n-                    else:\n-                        _.append(i)\n-                non_mod_l = _\n-\n             if mod_l and all(inner.args[1] == q for inner in mod_l):\n                 # finding distributive term\n                 non_mod_l = [cls(x, q) for x in non_mod_l]\n@@ -147,7 +137,17 @@ def doit(p, q):\n                 net = prod_mod1*prod_mod\n                 return prod_non_mod*cls(net, q)\n \n-            p = Mul(*non_mod_l)\n+            if q.is_Integer and q is not S.One:\n+                _ = []\n+                for i in non_mod_l:\n+                    if i.is_Integer:\n+                        # and (i % q is not S.Zero)\n+                        _.append(i%q)\n+                    else:\n+                        _.append(i)\n+                non_mod_l = _\n+\n+            p = Mul(* [*non_mod_l, *mod_l])\n \n         # XXX other possibilities?\n \n\nFrom 88167fba955a145e481f6f36ea72bf8d5be90c30 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Thu, 20 Dec 2018 21:39:29 +0530\nSubject: [PATCH 09/15] bug with concatination of list\n\n---\n sympy/core/mod.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex fc63babc0fbc..5c5ce3fc2463 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -147,7 +147,7 @@ def doit(p, q):\n                         _.append(i)\n                 non_mod_l = _\n \n-            p = Mul(* [*non_mod_l, *mod_l])\n+            p = Mul(*(non_mod_l + mod_l))\n \n         # XXX other possibilities?\n \n\nFrom cf02bc619981dc3edfbe71442a1ca5037232f0a7 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Sat, 22 Dec 2018 21:35:12 +0530\nSubject: [PATCH 10/15] bug with usage og long in python2.7\n\n---\n sympy/core/mod.py | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 5c5ce3fc2463..f2844602f661 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,6 +1,6 @@\n from __future__ import print_function, division\n \n-from sympy.core.numbers import nan\n+from sympy.core.numbers import nan, Integer\n from .function import Function\n \n \n@@ -62,7 +62,7 @@ def doit(p, q):\n             except TypeError:\n                 pass\n             else:\n-                if type(d) is int:\n+                if type(d) is int or type(d) is long:\n                     rv = p - d*q\n                     if (rv*q < 0) == True:\n                         rv += q\n\nFrom d82b63b4aee4eeaf6a9739dbb13185397b6a7519 Mon Sep 17 00:00:00 2001\nFrom: kunal <kunalgk1999@protonmail.com>\nDate: Wed, 2 Jan 2019 11:30:15 +0530\nSubject: [PATCH 11/15] quick exit if p and q both are numbers\n\n---\n sympy/core/mod.py | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex f2844602f661..6befbddc0a8a 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -44,6 +44,8 @@ def doit(p, q):\n                 return S.Zero\n \n             if q.is_Number:\n+                if p.is_Number:\n+                    return p%q\n                 if q == 2:\n                     if p.is_even:\n                         return S.Zero\n\nFrom 5864a845774f6c597dca3e96ad67a3b21b9ea57b Mon Sep 17 00:00:00 2001\nFrom: kunal <kunalgk1999@protonmail.com>\nDate: Wed, 2 Jan 2019 11:32:05 +0530\nSubject: [PATCH 12/15] conflict with long resolved\n\n---\n sympy/core/mod.py | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex 6befbddc0a8a..d38c30e11714 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -1,6 +1,7 @@\n from __future__ import print_function, division\n \n from sympy.core.numbers import nan, Integer\n+from sympy.core.compatibility import integer_types\n from .function import Function\n \n \n@@ -64,7 +65,7 @@ def doit(p, q):\n             except TypeError:\n                 pass\n             else:\n-                if type(d) is int or type(d) is long:\n+                if isinstance(d, integer_types):\n                     rv = p - d*q\n                     if (rv*q < 0) == True:\n                         rv += q\n\nFrom 32624236975a1ab0c4f677a5a974d1586ddded88 Mon Sep 17 00:00:00 2001\nFrom: Christopher Smith <smichr@gmail.com>\nDate: Thu, 3 Jan 2019 06:22:14 -0600\nSubject: [PATCH 13/15] Update test_arit.py\n\n---\n sympy/core/tests/test_arit.py | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 314c85e62bb9..c6c1b02c411a 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1663,7 +1663,9 @@ def test_Mod():\n     assert Mod(Mod(x + 2, 4)*4, 4) == 0\n \n     # issue 15493\n+    i, j = symbols('i j', integer=True, positive=True)\n     assert Mod(3*i, 2) == Mod(i, 2)\n+    assert Mod(8*i/j, 4) == 4*Mod(2*i/j, 1)\n \n \n def test_Mod_is_integer():\n\nFrom 595b35aad5b4938c2b4494041cbcd977d8784484 Mon Sep 17 00:00:00 2001\nFrom: rationa-kunal <kunalgk1999@gmail.com>\nDate: Sat, 5 Jan 2019 18:21:04 +0530\nSubject: [PATCH 14/15] multiplication with denom\n\n---\n sympy/core/mod.py | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex d38c30e11714..0498f7a75dbe 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -143,8 +143,7 @@ def doit(p, q):\n             if q.is_Integer and q is not S.One:\n                 _ = []\n                 for i in non_mod_l:\n-                    if i.is_Integer:\n-                        # and (i % q is not S.Zero)\n+                    if i.is_Integer and (i % q is not S.Zero):\n                         _.append(i%q)\n                     else:\n                         _.append(i)\n\nFrom 6858e5c6b47f323c07fa821ec559c8c2d7890b39 Mon Sep 17 00:00:00 2001\nFrom: Christopher Smith <smichr@gmail.com>\nDate: Sun, 6 Jan 2019 06:05:20 -0600\nSubject: [PATCH 15/15] Update test_arit.py\n\n---\n sympy/core/tests/test_arit.py | 1 +\n 1 file changed, 1 insertion(+)\n\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex c6c1b02c411a..5f58f9284c9a 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1666,6 +1666,7 @@ def test_Mod():\n     i, j = symbols('i j', integer=True, positive=True)\n     assert Mod(3*i, 2) == Mod(i, 2)\n     assert Mod(8*i/j, 4) == 4*Mod(2*i/j, 1)\n+    assert Mod(8*i, 4) == 0\n \n \n def test_Mod_is_integer():\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/15599"}