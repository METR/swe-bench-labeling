{"instance_id": "django__django-13417", "score": "C", "diff": "diff --git a/comprehensive_test.py b/comprehensive_test.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 85cd8311a7..a8940a560f 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1225,6 +1225,12 @@ class QuerySet:\n         if self.query.extra_order_by or self.query.order_by:\n             return True\n         elif self.query.default_ordering and self.query.get_meta().ordering:\n+            # Check if this query has a GROUP BY clause, which would remove\n+            # the default ordering coming from Meta.ordering\n+            if self.query.group_by is not None:\n+                # When there's a GROUP BY with only Meta.ordering (no explicit order_by),\n+                # the ORDER BY clause is removed by the compiler\n+                return False\n             return True\n         else:\n             return False\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_ordered_property.py b/test_ordered_property.py\nnew file mode 100644\nindex 0000000000..234cc5713d\n--- /dev/null\n+++ b/test_ordered_property.py\n@@ -0,0 +1,73 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Count\n+from django.test import TestCase\n+\n+\n+class Foo(models.Model):\n+    uuid = models.AutoField(primary_key=True)\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        ordering = ['name']\n+        db_table = 'test_foo'\n+        app_label = 'test_app'\n+\n+\n+def test_ordered_property_with_group_by():\n+    # Create the table\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Foo)\n+    \n+    # Create test data\n+    Foo.objects.create(name='B')\n+    Foo.objects.create(name='A')\n+    Foo.objects.create(name='C')\n+    \n+    # Test 1: Normal queryset should be ordered\n+    qs1 = Foo.objects.all()\n+    print(\"\\nTest 1 - Normal queryset:\")\n+    print(f\"SQL: {qs1.query}\")\n+    print(f\"qs.ordered: {qs1.ordered}\")\n+    print(f\"qs.query.default_ordering: {qs1.query.default_ordering}\")\n+    \n+    # Test 2: Annotated queryset with GROUP BY should not be ordered\n+    qs2 = Foo.objects.annotate(Count(\"pk\")).all()\n+    print(\"\\nTest 2 - Annotated queryset with GROUP BY:\")\n+    print(f\"SQL: {qs2.query}\")\n+    print(f\"qs.ordered: {qs2.ordered}\")\n+    print(f\"qs.query.default_ordering: {qs2.query.default_ordering}\")\n+    \n+    # Check if ORDER BY is actually in the SQL\n+    sql_str = str(qs2.query)\n+    has_order_by = 'ORDER BY' in sql_str\n+    print(f\"ORDER BY in SQL: {has_order_by}\")\n+    \n+    # Check actual SQL executed\n+    from django.db import connection\n+    with connection.cursor() as cursor:\n+        sql, params = qs2.query.sql_with_params()\n+        print(f\"\\nActual SQL that would be executed: {sql}\")\n+    \n+    print(f\"\\nThe bug: qs2.ordered returns {qs2.ordered} but should return False\")\n+    print(\"because GROUP BY removes the ORDER BY clause\")\n+\n+\n+if __name__ == '__main__':\n+    test_ordered_property_with_group_by()\n", "gold_standard_diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 85cd8311a7d2..67ffe7f0000a 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -1224,7 +1224,12 @@ def ordered(self):\n             return True\n         if self.query.extra_order_by or self.query.order_by:\n             return True\n-        elif self.query.default_ordering and self.query.get_meta().ordering:\n+        elif (\n+            self.query.default_ordering and\n+            self.query.get_meta().ordering and\n+            # A default ordering doesn't affect GROUP BY queries.\n+            not self.query.group_by\n+        ):\n             return True\n         else:\n             return False\ndiff --git a/docs/releases/3.1.2.txt b/docs/releases/3.1.2.txt\nindex 1243654bfb64..f9e45370ab94 100644\n--- a/docs/releases/3.1.2.txt\n+++ b/docs/releases/3.1.2.txt\n@@ -11,3 +11,8 @@ Bugfixes\n \n * Fixed a bug in Django 3.1 where ``FileField`` instances with a callable\n   storage were not correctly deconstructed (:ticket:`31941`).\n+\n+* Fixed a regression in Django 3.1 where the :attr:`.QuerySet.ordered`\n+  attribute returned incorrectly ``True`` for ``GROUP BY`` queries (e.g.\n+  ``.annotate().values()``) on models with ``Meta.ordering``. A model's\n+  ``Meta.ordering`` doesn't affect such queries (:ticket:`31990`).\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex f9a57b088a87..428153402fa6 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -2084,6 +2084,16 @@ def test_annotated_ordering(self):\n         self.assertIs(qs.ordered, False)\n         self.assertIs(qs.order_by('num_notes').ordered, True)\n \n+    def test_annotated_default_ordering(self):\n+        qs = Tag.objects.annotate(num_notes=Count('pk'))\n+        self.assertIs(qs.ordered, False)\n+        self.assertIs(qs.order_by('name').ordered, True)\n+\n+    def test_annotated_values_default_ordering(self):\n+        qs = Tag.objects.values('name').annotate(num_notes=Count('pk'))\n+        self.assertIs(qs.ordered, False)\n+        self.assertIs(qs.order_by('name').ordered, True)\n+\n \n @skipUnlessDBFeature('allow_sliced_subqueries_with_in')\n class SubqueryTests(TestCase):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13417"}