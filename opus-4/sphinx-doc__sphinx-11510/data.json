{"instance_id": "sphinx-doc__sphinx-11510", "score": "I", "diff": "diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8d..8c34a62cb 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -369,14 +369,69 @@ class Include(BaseInclude, SphinxDirective):\n     \"\"\"\n \n     def run(self) -> list[Node]:\n-        if self.arguments[0].startswith('<') and \\\n-           self.arguments[0].endswith('>'):\n-            # docutils \"standard\" includes, do not do path processing\n+        # Store the original method to restore it later\n+        original_insert_input = self.state_machine.insert_input\n+        \n+        # Create a wrapper that emits source-read event\n+        def insert_input_with_event(include_lines, source):\n+            # Check if this is being called for included content\n+            # We want to process only the actual content, not the end marker\n+            is_end_marker = (len(include_lines) == 2 and \n+                           include_lines[0] == '' and \n+                           include_lines[1].startswith('.. end of inclusion from'))\n+            \n+            if not is_end_marker:\n+                # Join the lines back into a string for the event\n+                content = '\\n'.join(include_lines)\n+                \n+                # Emit source-read event - we need to pass the included file's docname\n+                # Since the included file might not have a docname, we use the source path\n+                # Remove .rst extension if present to match docname format\n+                docname = source\n+                if docname.endswith('.rst'):\n+                    docname = docname[:-4]\n+                # Make it relative to source directory if possible\n+                try:\n+                    from pathlib import Path\n+                    source_dir = Path(self.env.srcdir)\n+                    source_path = Path(source)\n+                    if source_path.is_absolute():\n+                        try:\n+                            # Try to make it relative to source directory\n+                            docname = str(source_path.relative_to(source_dir))\n+                            if docname.endswith('.rst'):\n+                                docname = docname[:-4]\n+                        except ValueError:\n+                            # Path is not relative to source_dir\n+                            pass\n+                except Exception:\n+                    pass\n+                \n+                # Emit the event with the content\n+                arg = [content]\n+                self.env.events.emit('source-read', docname, arg)\n+                \n+                # Split the potentially modified content back into lines\n+                include_lines = arg[0].split('\\n')\n+            \n+            # Call the original method with potentially modified content\n+            return original_insert_input(include_lines, source)\n+        \n+        # Temporarily replace the method\n+        self.state_machine.insert_input = insert_input_with_event\n+        \n+        try:\n+            if self.arguments[0].startswith('<') and \\\n+               self.arguments[0].endswith('>'):\n+                # docutils \"standard\" includes, do not do path processing\n+                return super().run()\n+            rel_filename, filename = self.env.relfn2path(self.arguments[0])\n+            self.arguments[0] = filename\n+            self.env.note_included(filename)\n             return super().run()\n-        rel_filename, filename = self.env.relfn2path(self.arguments[0])\n-        self.arguments[0] = filename\n-        self.env.note_included(filename)\n-        return super().run()\n+        finally:\n+            # Restore the original method\n+            self.state_machine.insert_input = original_insert_input\n \n \n def setup(app: Sphinx) -> dict[str, Any]:\ndiff --git a/test_issue/conf.py b/test_issue/conf.py\nnew file mode 100644\nindex 000000000..de4440537\n--- /dev/null\n+++ b/test_issue/conf.py\n@@ -0,0 +1,8 @@\n+import sys\n+import os\n+\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+extensions = [\n+        'my-extension'\n+]\ndiff --git a/test_issue/index.rst b/test_issue/index.rst\nnew file mode 100644\nindex 000000000..f2dec1395\n--- /dev/null\n+++ b/test_issue/index.rst\n@@ -0,0 +1,6 @@\n+This is a test\n+==============\n+\n+.. include:: something-to-include.rst\n+\n+&REPLACE_ME;\ndiff --git a/test_issue/my-extension.py b/test_issue/my-extension.py\nnew file mode 100644\nindex 000000000..108bb6a84\n--- /dev/null\n+++ b/test_issue/my-extension.py\n@@ -0,0 +1,26 @@\n+#!/usr/bin/env python3\n+\n+from sphinx.application import Sphinx\n+\n+\n+__version__ = '1.0'\n+\n+\n+def subst_vars_replace(app: Sphinx, docname, source):\n+    print(f\"source-read event called for docname: {docname}\")\n+    print(f\"Original content: {repr(source[0][:100])}\")\n+    result = source[0]\n+    result = result.replace(\"&REPLACE_ME;\", \"REPLACED\")\n+    source[0] = result\n+    print(f\"Modified content: {repr(source[0][:100])}\")\n+\n+\n+def setup(app: Sphinx):\n+\n+    app.connect('source-read', subst_vars_replace)\n+\n+    return dict(\n+        version=__version__,\n+        parallel_read_safe=True,\n+        parallel_write_safe=True\n+    )\ndiff --git a/test_issue/something-to-include.rst b/test_issue/something-to-include.rst\nnew file mode 100644\nindex 000000000..e63253568\n--- /dev/null\n+++ b/test_issue/something-to-include.rst\n@@ -0,0 +1,4 @@\n+Testing\n+=======\n+\n+&REPLACE_ME;\ndiff --git a/test_issue_edge_cases.py b/test_issue_edge_cases.py\nnew file mode 100644\nindex 000000000..24a0ff8a8\n--- /dev/null\n+++ b/test_issue_edge_cases.py\n@@ -0,0 +1,185 @@\n+#!/usr/bin/env python3\n+\"\"\"Test edge cases for the include directive source-read event fix.\"\"\"\n+\n+import os\n+import tempfile\n+import shutil\n+from pathlib import Path\n+from sphinx.cmd.build import build_main\n+\n+\n+def test_include_source_read_event():\n+    \"\"\"Test that source-read event is properly triggered for included files.\"\"\"\n+    \n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create test structure\n+        srcdir = Path(tmpdir) / \"source\"\n+        builddir = Path(tmpdir) / \"build\"\n+        srcdir.mkdir()\n+        \n+        # Create conf.py with a custom extension\n+        conf_py = srcdir / \"conf.py\"\n+        conf_py.write_text(\"\"\"\n+import sys\n+sys.path.insert(0, '.')\n+\n+extensions = ['test_extension']\n+\"\"\")\n+        \n+        # Create the test extension\n+        ext_py = srcdir / \"test_extension.py\"\n+        ext_py.write_text(\"\"\"\n+from sphinx.application import Sphinx\n+\n+replacements = []\n+\n+def source_read_handler(app, docname, source):\n+    # Record what files were processed\n+    replacements.append(docname)\n+    # Do the replacement\n+    source[0] = source[0].replace(\"REPLACE_ME\", \"REPLACED\")\n+\n+def setup(app: Sphinx):\n+    app.connect('source-read', source_read_handler)\n+    return {\n+        'version': '1.0',\n+        'parallel_read_safe': True,\n+        'parallel_write_safe': True\n+    }\n+\"\"\")\n+        \n+        # Create main document\n+        index_rst = srcdir / \"index.rst\"\n+        index_rst.write_text(\"\"\"Test Include\n+============\n+\n+Before include: REPLACE_ME\n+\n+.. include:: included.rst\n+\n+After include: REPLACE_ME\n+\n+.. include:: subdir/nested.rst\n+\"\"\")\n+        \n+        # Create included document\n+        included_rst = srcdir / \"included.rst\"\n+        included_rst.write_text(\"\"\"Included Section\n+----------------\n+\n+In included file: REPLACE_ME\n+\"\"\")\n+        \n+        # Create nested included document\n+        subdir = srcdir / \"subdir\"\n+        subdir.mkdir()\n+        nested_rst = subdir / \"nested.rst\"\n+        nested_rst.write_text(\"\"\"Nested Section\n+--------------\n+\n+In nested file: REPLACE_ME\n+\"\"\")\n+        \n+        # Build the documentation\n+        result = build_main(['-b', 'html', '-q', str(srcdir), str(builddir)])\n+        \n+        # Check the build succeeded\n+        if result != 0:\n+            print(f\"Build failed with code {result}\")\n+            # Try to see what went wrong\n+            import subprocess\n+            subprocess.run(['sphinx-build', '-b', 'html', str(srcdir), str(builddir)])\n+        \n+        # Read the generated HTML\n+        with open(builddir / \"index.html\", 'r') as f:\n+            html_content = f.read()\n+        \n+        # Verify all REPLACE_ME instances were replaced\n+        assert \"REPLACE_ME\" not in html_content\n+        assert html_content.count(\"REPLACED\") == 4  # 2 in index + 1 in included + 1 in nested\n+        \n+        # Import the extension to check which files were processed\n+        import sys\n+        sys.path.insert(0, str(srcdir))\n+        import test_extension\n+        \n+        # Verify all files triggered the source-read event\n+        assert 'index' in test_extension.replacements\n+        assert 'included' in test_extension.replacements\n+        assert 'subdir/nested' in test_extension.replacements\n+        \n+        print(\"\u2713 All tests passed!\")\n+\n+\n+def test_include_with_options():\n+    \"\"\"Test that include directive with options still triggers source-read.\"\"\"\n+    \n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        srcdir = Path(tmpdir) / \"source\"\n+        builddir = Path(tmpdir) / \"build\"\n+        srcdir.mkdir()\n+        \n+        # Create conf.py\n+        conf_py = srcdir / \"conf.py\"\n+        conf_py.write_text(\"\"\"\n+import sys\n+sys.path.insert(0, '.')\n+\n+extensions = ['test_extension2']\n+\"\"\")\n+        \n+        # Create the test extension\n+        ext_py = srcdir / \"test_extension2.py\"\n+        ext_py.write_text(\"\"\"\n+from sphinx.application import Sphinx\n+\n+def source_read_handler(app, docname, source):\n+    source[0] = source[0].replace(\"LINE_TO_REPLACE\", \"REPLACED_LINE\")\n+\n+def setup(app: Sphinx):\n+    app.connect('source-read', source_read_handler)\n+    return {\n+        'version': '1.0',\n+        'parallel_read_safe': True,\n+        'parallel_write_safe': True\n+    }\n+\"\"\")\n+        \n+        # Create main document with include directive using options\n+        index_rst = srcdir / \"index.rst\"\n+        index_rst.write_text(\"\"\"Test Include with Options\n+=========================\n+\n+.. include:: data.txt\n+   :start-line: 1\n+   :end-line: 3\n+\"\"\")\n+        \n+        # Create data file\n+        data_txt = srcdir / \"data.txt\"\n+        data_txt.write_text(\"\"\"Line 0\n+LINE_TO_REPLACE\n+Another line\n+LINE_TO_REPLACE\n+Last line\n+\"\"\")\n+        \n+        # Build\n+        result = build_main(['-b', 'html', str(srcdir), str(builddir)])\n+        assert result == 0\n+        \n+        # Check output\n+        with open(builddir / \"index.html\", 'r') as f:\n+            html_content = f.read()\n+        \n+        # The include should contain the replaced text\n+        assert \"REPLACED_LINE\" in html_content\n+        assert \"LINE_TO_REPLACE\" not in html_content\n+        \n+        print(\"\u2713 Include with options test passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_include_source_read_event()\n+    test_include_with_options()\n+    print(\"\\n\u2705 All edge case tests passed!\")\ndiff --git a/test_literal_include/conf.py b/test_literal_include/conf.py\nnew file mode 100644\nindex 000000000..8b1378917\n--- /dev/null\n+++ b/test_literal_include/conf.py\n@@ -0,0 +1 @@\n+\ndiff --git a/tox.ini b/tox.ini\nindex a3dc56211..c76147de3 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -24,7 +24,7 @@ setenv =\n     PYTHONWARNINGS = error\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -X warn_default_encoding -m pytest --durations 25 {posargs}\n+    python -X dev -X warn_default_encoding -m pytest -rA --durations 25 {posargs}\n \n [testenv:docs]\n basepython = python3\n", "gold_standard_diff": "diff --git a/CHANGES b/CHANGES\nindex ce1185c767e..1ca5b16f386 100644\n--- a/CHANGES\n+++ b/CHANGES\n@@ -48,6 +48,9 @@ Features added\n * #11572: Improve ``debug`` logging of reasons why files are detected as out of\n   date.\n   Patch by Eric Larson.\n+* #10678: Emit \"source-read\" events for files read via\n+  the :dudir:`include` directive.\n+  Patch by Halldor Fannar.\n \n Bugs fixed\n ----------\ndiff --git a/sphinx/directives/other.py b/sphinx/directives/other.py\nindex 19f7c0a8dff..e65cbfdfe68 100644\n--- a/sphinx/directives/other.py\n+++ b/sphinx/directives/other.py\n@@ -8,6 +8,7 @@\n from docutils.parsers.rst.directives.admonitions import BaseAdmonition\n from docutils.parsers.rst.directives.misc import Class\n from docutils.parsers.rst.directives.misc import Include as BaseInclude\n+from docutils.statemachine import StateMachine\n \n from sphinx import addnodes\n from sphinx.domains.changeset import VersionChange  # noqa: F401  # for compatibility\n@@ -17,6 +18,7 @@\n from sphinx.util.docutils import SphinxDirective\n from sphinx.util.matching import Matcher, patfilter\n from sphinx.util.nodes import explicit_title_re\n+from sphinx.util.osutil import os_path\n \n if TYPE_CHECKING:\n     from docutils.nodes import Element, Node\n@@ -369,6 +371,40 @@ class Include(BaseInclude, SphinxDirective):\n     \"\"\"\n \n     def run(self) -> list[Node]:\n+\n+        # To properly emit \"source-read\" events from included RST text,\n+        # we must patch the ``StateMachine.insert_input()`` method.\n+        # In the future, docutils will hopefully offer a way for Sphinx\n+        # to provide the RST parser to use\n+        # when parsing RST text that comes in via Include directive.\n+        def _insert_input(include_lines, path):\n+            # First, we need to combine the lines back into text so that\n+            # we can send it with the source-read event.\n+            # In docutils 0.18 and later, there are two lines at the end\n+            # that act as markers.\n+            # We must preserve them and leave them out of the source-read event:\n+            text = \"\\n\".join(include_lines[:-2])\n+\n+            # The docname to pass into the source-read event\n+            docname = self.env.path2doc(os_path(path))\n+            # Emit the \"source-read\" event\n+            arg = [text]\n+            self.env.app.events.emit(\"source-read\", docname, arg)\n+            text = arg[0]\n+\n+            # Split back into lines and reattach the two marker lines\n+            include_lines = text.splitlines() + include_lines[-2:]\n+\n+            # Call the parent implementation.\n+            # Note that this snake does not eat its tail because we patch\n+            # the *Instance* method and this call is to the *Class* method.\n+            return StateMachine.insert_input(self.state_machine, include_lines, path)\n+\n+        # Only enable this patch if there are listeners for 'source-read'.\n+        if self.env.app.events.listeners.get('source-read'):\n+            # See https://github.com/python/mypy/issues/2427 for details on the mypy issue\n+            self.state_machine.insert_input = _insert_input  # type: ignore[method-assign]\n+\n         if self.arguments[0].startswith('<') and \\\n            self.arguments[0].endswith('>'):\n             # docutils \"standard\" includes, do not do path processing\ndiff --git a/tests/roots/test-directive-include/baz/baz.rst b/tests/roots/test-directive-include/baz/baz.rst\nnew file mode 100644\nindex 00000000000..d8207261afc\n--- /dev/null\n+++ b/tests/roots/test-directive-include/baz/baz.rst\n@@ -0,0 +1,6 @@\n+Baz\n+===\n+\n+.. include:: foo.rst\n+\n+Baz was here.\n\\ No newline at end of file\ndiff --git a/tests/roots/test-directive-include/conf.py b/tests/roots/test-directive-include/conf.py\nnew file mode 100644\nindex 00000000000..a4768582f36\n--- /dev/null\n+++ b/tests/roots/test-directive-include/conf.py\n@@ -0,0 +1,2 @@\n+project = 'test-directive-include'\n+exclude_patterns = ['_build']\ndiff --git a/tests/roots/test-directive-include/foo.rst b/tests/roots/test-directive-include/foo.rst\nnew file mode 100644\nindex 00000000000..0f82e661be4\n--- /dev/null\n+++ b/tests/roots/test-directive-include/foo.rst\n@@ -0,0 +1 @@\n+The #magical foo.\ndiff --git a/tests/roots/test-directive-include/text.txt b/tests/roots/test-directive-include/text.txt\nnew file mode 100644\nindex 00000000000..b7ea15d7b02\n--- /dev/null\n+++ b/tests/roots/test-directive-include/text.txt\n@@ -0,0 +1 @@\n+This is plain text.\ndiff --git a/tests/test_directive_other.py b/tests/test_directive_other.py\nindex f221db07578..45bd033045a 100644\n--- a/tests/test_directive_other.py\n+++ b/tests/test_directive_other.py\n@@ -148,3 +148,40 @@ def test_toctree_twice(app):\n     assert_node(doctree[0][0],\n                 entries=[(None, 'foo'), (None, 'foo')],\n                 includefiles=['foo', 'foo'])\n+\n+\n+@pytest.mark.sphinx(testroot='directive-include')\n+def test_include_source_read_event(app):\n+    sources_reported = {}\n+\n+    def source_read_handler(app, doc, source):\n+        sources_reported[doc] = source[0]\n+\n+    app.connect(\"source-read\", source_read_handler)\n+    text = (\".. include:: baz/baz.rst\\n\"\n+            \"   :start-line: 4\\n\\n\"\n+            \".. include:: text.txt\\n\"\n+            \"   :literal:    \\n\")\n+    app.env.find_files(app.config, app.builder)\n+    restructuredtext.parse(app, text, 'index')\n+    assert \"index\" in sources_reported\n+    assert \"text.txt\" not in sources_reported  # text was included as literal, no rst parsing\n+    assert \"baz/baz\" in sources_reported\n+    assert sources_reported[\"baz/baz\"] == \"\\nBaz was here.\"\n+\n+\n+@pytest.mark.sphinx(testroot='directive-include')\n+def test_include_source_read_event_nested_includes(app):\n+\n+    def source_read_handler(app, doc, source):\n+        text = source[0].replace(\"#magical\", \"amazing\")\n+        source[0] = text\n+\n+    app.connect(\"source-read\", source_read_handler)\n+    text = (\".. include:: baz/baz.rst\\n\")\n+    app.env.find_files(app.config, app.builder)\n+    doctree = restructuredtext.parse(app, text, 'index')\n+    assert_node(doctree, addnodes.document)\n+    assert len(doctree.children) == 3\n+    assert_node(doctree.children[1], nodes.paragraph)\n+    assert doctree.children[1].rawsource == \"The amazing foo.\"\n", "gold_standard_pr_link": "https://github.com/sphinx-doc/sphinx/pull/11510"}