{"instance_id": "django__django-15973", "score": "I", "diff": "diff --git a/test_m2m_debug.py b/test_m2m_debug.py\nnew file mode 100644\nindex 0000000000..0928a8df0c\n--- /dev/null\n+++ b/test_m2m_debug.py\n@@ -0,0 +1,101 @@\n+\"\"\"\n+Debug the ManyToMany through model issue\n+\"\"\"\n+\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Configure Django\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a custom schema editor to see what's happening\n+class DebugSchemaEditor(BaseDatabaseSchemaEditor):\n+    def create_model(self, model):\n+        \"\"\"Override to debug the issue\"\"\"\n+        print(f\"\\nDEBUG: Creating model {model._meta.label}\")\n+        \n+        # Check M2M fields\n+        for field in model._meta.local_many_to_many:\n+            print(f\"  M2M field: {field.name}\")\n+            print(f\"  Through: {field.remote_field.through}\")\n+            print(f\"  Through type: {type(field.remote_field.through)}\")\n+            \n+            # This is the problematic line from the original code\n+            if isinstance(field.remote_field.through, str):\n+                print(f\"  ERROR: through is still a string!\")\n+            else:\n+                print(f\"  Through _meta: {field.remote_field.through._meta}\")\n+                print(f\"  Auto created: {field.remote_field.through._meta.auto_created}\")\n+        \n+        # Call parent (skip for this test)\n+        print(\"  (Skipping actual table creation)\")\n+\n+\n+def test_with_debug_schema():\n+    \"\"\"Test with debug schema editor\"\"\"\n+    \n+    # Create the model state with M2M field referencing through as string\n+    from django.db import models\n+    \n+    # First, let's directly create a model with the issue\n+    class TestModel(models.Model):\n+        variaveis = models.ManyToManyField(\n+            'TestTarget',\n+            through='TestThrough'  # String reference\n+        )\n+        \n+        class Meta:\n+            app_label = 'test_app'\n+    \n+    class TestTarget(models.Model):\n+        name = models.CharField(max_length=100)\n+        \n+        class Meta:\n+            app_label = 'test_app'\n+    \n+    class TestThrough(models.Model):\n+        test = models.ForeignKey(TestModel, on_delete=models.CASCADE)\n+        target = models.ForeignKey(TestTarget, on_delete=models.CASCADE)\n+        \n+        class Meta:\n+            app_label = 'test_app'\n+    \n+    # Now let's see what happens when we try to create it\n+    with DebugSchemaEditor(connection) as editor:\n+        # This should fail with the string issue\n+        try:\n+            editor.create_model(TestModel)\n+        except Exception as e:\n+            print(f\"\\nException: {e}\")\n+    \n+    # Now let's test with the through model resolved\n+    print(\"\\n\\n--- Testing after manual resolution ---\")\n+    # Manually resolve the through model\n+    TestModel._meta.get_field('variaveis').remote_field.through = TestThrough\n+    \n+    with DebugSchemaEditor(connection) as editor:\n+        editor.create_model(TestModel)\n+\n+\n+if __name__ == \"__main__\":\n+    test_with_debug_schema()\ndiff --git a/test_m2m_through_bug.py b/test_m2m_through_bug.py\nnew file mode 100644\nindex 0000000000..ebd8820f0c\n--- /dev/null\n+++ b/test_m2m_through_bug.py\n@@ -0,0 +1,110 @@\n+\"\"\"\n+Test script to reproduce the ManyToMany through model bug\n+\"\"\"\n+\n+import django\n+from django.db import models, migrations, connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+from django.db.migrations.operations.models import CreateModel\n+\n+# First, let's create a test that simulates the problem\n+def test_m2m_through_string_reference():\n+    \"\"\"Test that ManyToMany field with string through reference works during migration\"\"\"\n+    \n+    # Create mock models similar to the issue\n+    fonte_fields = [\n+        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+        ('nome', models.TextField(unique=True)),\n+        ('descricao', models.TextField()),\n+        ('data_inicial', models.DateField()),\n+        ('data_final', models.DateField(blank=True, null=True)),\n+        ('variaveis', models.ManyToManyField('variavel.VariavelModel', through='fonte_variavel.FonteVariavelModel')),\n+    ]\n+    \n+    # Create the CreateModel operation\n+    create_fonte = CreateModel(\n+        name='FonteModel',\n+        fields=fonte_fields,\n+        options={\n+            'verbose_name': 'Fonte',\n+            'verbose_name_plural': 'Fontes',\n+            'db_table': 'fontes',\n+        },\n+    )\n+    \n+    # Create a mock project state\n+    project_state = ProjectState()\n+    \n+    # Add the variavel model state\n+    project_state.add_model(ModelState(\n+        app_label='variavel',\n+        name='VariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+        ],\n+        options={\n+            'db_table': 'variaveis',\n+            'verbose_name': 'Vari\u00e1vel',\n+            'verbose_name_plural': 'Vari\u00e1veis',\n+        }\n+    ))\n+    \n+    # Add the through model state\n+    project_state.add_model(ModelState(\n+        app_label='fonte_variavel',\n+        name='FonteVariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('variavel', models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)),\n+            ('fonte', models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)),\n+        ],\n+        options={\n+            'db_table': 'fontes_variaveis',\n+            'verbose_name': 'Fonte',\n+            'verbose_name_plural': 'Fontes',\n+        }\n+    ))\n+    \n+    # Apply the state\n+    new_state = project_state.clone()\n+    create_fonte.state_forwards('fonte', new_state)\n+    \n+    # Try to get the model - this should work\n+    apps = new_state.apps\n+    FonteModel = apps.get_model('fonte', 'FonteModel')\n+    \n+    # Check that the through field is properly resolved\n+    through_field = FonteModel._meta.get_field('variaveis')\n+    print(f\"Through field: {through_field.remote_field.through}\")\n+    print(f\"Through field type: {type(through_field.remote_field.through)}\")\n+    \n+    # The issue occurs when schema editor tries to create the model\n+    # Let's simulate what happens in schema.create_model\n+    for field in FonteModel._meta.local_many_to_many:\n+        print(f\"Field: {field.name}\")\n+        print(f\"Through: {field.remote_field.through}\")\n+        print(f\"Through type: {type(field.remote_field.through)}\")\n+        \n+        # This is where the error happens - trying to access _meta on a string\n+        try:\n+            auto_created = field.remote_field.through._meta.auto_created\n+            print(f\"Auto created: {auto_created}\")\n+        except AttributeError as e:\n+            print(f\"ERROR: {e}\")\n+            return False\n+    \n+    return True\n+\n+if __name__ == \"__main__\":\n+    # Initialize Django\n+    import os\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+    django.setup()\n+    \n+    # Run the test\n+    success = test_m2m_through_string_reference()\n+    print(f\"\\nTest {'PASSED' if success else 'FAILED'}\")\ndiff --git a/test_m2m_through_bug2.py b/test_m2m_through_bug2.py\nnew file mode 100644\nindex 0000000000..0c0f3450f6\n--- /dev/null\n+++ b/test_m2m_through_bug2.py\n@@ -0,0 +1,103 @@\n+\"\"\"\n+Test script to reproduce the ManyToMany through model bug\n+\"\"\"\n+\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.operations.models import CreateModel\n+\n+# Configure Django\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+def test_m2m_through_database_forwards():\n+    \"\"\"Test that ManyToMany field with string through reference works during migration database_forwards\"\"\"\n+    \n+    # Create project state\n+    project_state = ProjectState()\n+    \n+    # First add the through model - this is key, it needs to be in the state before we reference it\n+    project_state.add_model(ModelState(\n+        app_label='fonte_variavel',\n+        name='FonteVariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('variavel', models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)),\n+            ('fonte', models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)),\n+        ],\n+        options={\n+            'db_table': 'fontes_variaveis',\n+        }\n+    ))\n+    \n+    # Add the variavel model\n+    project_state.add_model(ModelState(\n+        app_label='variavel',\n+        name='VariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+        ],\n+        options={\n+            'db_table': 'variaveis',\n+        }\n+    ))\n+    \n+    # Now create the CreateModel operation for fonte with the through reference\n+    create_fonte = CreateModel(\n+        name='FonteModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+            ('data_inicial', models.DateField()),\n+            ('data_final', models.DateField(blank=True, null=True)),\n+            ('variaveis', models.ManyToManyField('variavel.VariavelModel', through='fonte_variavel.FonteVariavelModel')),\n+        ],\n+        options={\n+            'db_table': 'fontes',\n+        },\n+    )\n+    \n+    # Apply state_forwards\n+    new_state = project_state.clone()\n+    create_fonte.state_forwards('fonte', new_state)\n+    \n+    # Now test database_forwards - this is where the bug happens\n+    with connection.schema_editor() as schema_editor:\n+        try:\n+            create_fonte.database_forwards('fonte', schema_editor, project_state, new_state)\n+            print(\"Database forwards succeeded!\")\n+            return True\n+        except AttributeError as e:\n+            print(f\"ERROR during database_forwards: {e}\")\n+            # Let's debug what's happening\n+            model = new_state.apps.get_model('fonte', 'FonteModel')\n+            for field in model._meta.local_many_to_many:\n+                print(f\"Field name: {field.name}\")\n+                print(f\"Through value: {field.remote_field.through}\")\n+                print(f\"Through type: {type(field.remote_field.through)}\")\n+            return False\n+\n+if __name__ == \"__main__\":\n+    success = test_m2m_through_database_forwards()\n+    print(f\"\\nTest {'PASSED' if success else 'FAILED'}\")\ndiff --git a/test_migration_issue.py b/test_migration_issue.py\nnew file mode 100644\nindex 0000000000..33f48d1a15\n--- /dev/null\n+++ b/test_migration_issue.py\n@@ -0,0 +1,98 @@\n+\"\"\"\n+Test the exact migration scenario from the issue\n+\"\"\"\n+\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.operations.models import CreateModel\n+\n+# Configure Django\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+def test_exact_migration_scenario():\n+    \"\"\"Test the exact scenario from the issue\"\"\"\n+    \n+    # Create initial project state\n+    project_state = ProjectState()\n+    \n+    # First migration would be for variavel app\n+    project_state.add_model(ModelState(\n+        app_label='variavel',\n+        name='VariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+        ],\n+        options={\n+            'db_table': 'variaveis',\n+            'verbose_name': 'Vari\u00e1vel',\n+            'verbose_name_plural': 'Vari\u00e1veis',\n+        }\n+    ))\n+    \n+    # Create the operation that would happen in fonte's migration\n+    # This is the key - the through model doesn't exist yet in the state\n+    create_fonte = CreateModel(\n+        name='FonteModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+            ('data_inicial', models.DateField()),\n+            ('data_final', models.DateField(blank=True, null=True)),\n+            ('variaveis', models.ManyToManyField('variavel.VariavelModel', through='fonte_variavel.FonteVariavelModel')),\n+        ],\n+        options={\n+            'verbose_name': 'Fonte',\n+            'verbose_name_plural': 'Fontes',\n+            'db_table': 'fontes',\n+        },\n+    )\n+    \n+    # Apply state forward - this adds FonteModel to state\n+    new_state = project_state.clone()\n+    create_fonte.state_forwards('fonte', new_state)\n+    \n+    # Now try database_forwards WITHOUT the through model in state\n+    # This should trigger the error\n+    print(\"Testing database_forwards without through model in state...\")\n+    with connection.schema_editor() as schema_editor:\n+        try:\n+            create_fonte.database_forwards('fonte', schema_editor, project_state, new_state)\n+            print(\"ERROR: Expected AttributeError but operation succeeded!\")\n+            \n+            # Debug what happened\n+            model = new_state.apps.get_model('fonte', 'FonteModel')\n+            field = model._meta.get_field('variaveis')\n+            print(f\"Through: {field.remote_field.through}\")\n+            print(f\"Through type: {type(field.remote_field.through)}\")\n+            \n+        except AttributeError as e:\n+            print(f\"SUCCESS: Got expected AttributeError: {e}\")\n+            return True\n+    \n+    return False\n+\n+\n+if __name__ == \"__main__\":\n+    test_exact_migration_scenario()\ndiff --git a/test_real_issue.py b/test_real_issue.py\nnew file mode 100644\nindex 0000000000..ae1169439c\n--- /dev/null\n+++ b/test_real_issue.py\n@@ -0,0 +1,156 @@\n+\"\"\"\n+Test to reproduce the actual issue from the bug report\n+\"\"\"\n+\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.operations.models import CreateModel\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Configure Django\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Override create_model to inject our test\n+original_create_model = BaseDatabaseSchemaEditor.create_model\n+\n+def patched_create_model(self, model):\n+    \"\"\"Patched create_model that shows the issue\"\"\"\n+    print(f\"\\nCREATE_MODEL called for {model._meta.label}\")\n+    \n+    # This is the code from the original that causes the issue\n+    for field in model._meta.local_many_to_many:\n+        print(f\"  Checking M2M field: {field.name}\")\n+        print(f\"  Through: {field.remote_field.through}\")\n+        print(f\"  Through type: {type(field.remote_field.through)}\")\n+        \n+        # This line causes AttributeError when through is a string\n+        try:\n+            if field.remote_field.through._meta.auto_created:\n+                print(\"    Auto-created through model\")\n+        except AttributeError as e:\n+            print(f\"  ERROR: {e}\")\n+            raise\n+\n+BaseDatabaseSchemaEditor.create_model = patched_create_model\n+\n+def test_string_through_reference():\n+    \"\"\"Test that reproduces the string through reference issue\"\"\"\n+    \n+    # Create a fresh project state\n+    project_state = ProjectState()\n+    \n+    # Set up real_apps to include our test apps\n+    project_state.real_apps = {'fonte', 'variavel', 'fonte_variavel'}\n+    \n+    # Add all three models to the state in order\n+    # 1. VariavelModel\n+    project_state.add_model(ModelState(\n+        app_label='variavel',\n+        name='VariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+        ],\n+        options={\n+            'db_table': 'variaveis',\n+        }\n+    ))\n+    \n+    # 2. Create the FonteModel with through as string - this is crucial\n+    # The through model doesn't exist in state yet!\n+    from django.db.models.fields.related import ManyToManyField\n+    \n+    # Create a M2M field with unresolved string through\n+    m2m_field = ManyToManyField('variavel.VariavelModel', through='fonte_variavel.FonteVariavelModel')\n+    m2m_field.name = 'variaveis'\n+    \n+    # Keep the through as a string to simulate the issue\n+    m2m_field.remote_field.through = 'fonte_variavel.FonteVariavelModel'\n+    \n+    fonte_state = ModelState(\n+        app_label='fonte',\n+        name='FonteModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('nome', models.TextField(unique=True)),\n+            ('descricao', models.TextField()),\n+            ('data_inicial', models.DateField()),\n+            ('data_final', models.DateField(blank=True, null=True)),\n+            ('variaveis', m2m_field),\n+        ],\n+        options={\n+            'db_table': 'fontes',\n+        }\n+    )\n+    \n+    # Apply the state  \n+    new_state = project_state.clone()\n+    new_state.add_model(fonte_state)\n+    \n+    # 3. Add the through model\n+    new_state.add_model(ModelState(\n+        app_label='fonte_variavel',\n+        name='FonteVariavelModel',\n+        fields=[\n+            ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+            ('variavel', models.ForeignKey('variavel.VariavelModel', on_delete=models.CASCADE)),\n+            ('fonte', models.ForeignKey('fonte.FonteModel', on_delete=models.CASCADE)),\n+        ],\n+        options={\n+            'db_table': 'fontes_variaveis',\n+        }\n+    ))\n+    \n+    # Create the model from state - this should have the string through\n+    try:\n+        apps = new_state.apps\n+        model = apps.get_model('fonte', 'FonteModel')\n+        \n+        # Verify the through is still a string\n+        field = model._meta.get_field('variaveis')\n+        print(f\"\\nBefore schema editor:\")\n+        print(f\"Through: {field.remote_field.through}\")\n+        print(f\"Through type: {type(field.remote_field.through)}\")\n+        \n+        # Now use schema editor - this should fail\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(model)\n+            \n+    except AttributeError as e:\n+        print(f\"\\nSUCCESS: Reproduced the issue!\")\n+        print(f\"Error: {e}\")\n+        return True\n+    except Exception as e:\n+        print(f\"\\nUnexpected error: {type(e).__name__}: {e}\")\n+        return False\n+        \n+    print(\"\\nERROR: Issue was not reproduced\")\n+    return False\n+\n+if __name__ == \"__main__\":\n+    # Restore original after test\n+    try:\n+        success = test_string_through_reference()\n+        print(f\"\\nTest result: {'PASSED' if success else 'FAILED'}\")\n+    finally:\n+        BaseDatabaseSchemaEditor.create_model = original_create_model\n", "gold_standard_diff": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex ad3243763072..eae09eb65a36 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -1422,7 +1422,7 @@ def _get_dependencies_for_foreign_key(app_label, model_name, field, project_stat\n         dependencies = [(dep_app_label, dep_object_name, None, True)]\n         if getattr(field.remote_field, \"through\", None):\n             through_app_label, through_object_name = resolve_relation(\n-                remote_field_model,\n+                field.remote_field.through,\n                 app_label,\n                 model_name,\n             )\ndiff --git a/docs/releases/4.1.1.txt b/docs/releases/4.1.1.txt\nindex 39b1306234c5..2ae2ecfb1d05 100644\n--- a/docs/releases/4.1.1.txt\n+++ b/docs/releases/4.1.1.txt\n@@ -43,3 +43,6 @@ Bugfixes\n * Fixed a regression in Django 4.1 that caused a migration crash on PostgreSQL\n   when altering ``AutoField``, ``BigAutoField``, or ``SmallAutoField`` to\n   ``OneToOneField`` (:ticket:`33932`).\n+\n+* Fixed a migration crash on ``ManyToManyField`` fields with ``through``\n+  referencing models in different apps (:ticket:`33938`).\ndiff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 4911e4115076..dd153d2f0b86 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -3585,6 +3585,52 @@ def test_create_with_through_model(self):\n             changes, \"testapp\", 0, 3, model_name=\"author\", name=\"publishers\"\n         )\n \n+    def test_create_with_through_model_separate_apps(self):\n+        author_with_m2m_through = ModelState(\n+            \"authors\",\n+            \"Author\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\n+                    \"publishers\",\n+                    models.ManyToManyField(\n+                        \"testapp.Publisher\", through=\"contract.Contract\"\n+                    ),\n+                ),\n+            ],\n+        )\n+        contract = ModelState(\n+            \"contract\",\n+            \"Contract\",\n+            [\n+                (\"id\", models.AutoField(primary_key=True)),\n+                (\"author\", models.ForeignKey(\"authors.Author\", models.CASCADE)),\n+                (\"publisher\", models.ForeignKey(\"testapp.Publisher\", models.CASCADE)),\n+            ],\n+        )\n+        changes = self.get_changes(\n+            [], [author_with_m2m_through, self.publisher, contract]\n+        )\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+        self.assertNumberMigrations(changes, \"contract\", 1)\n+        self.assertNumberMigrations(changes, \"authors\", 2)\n+        self.assertMigrationDependencies(\n+            changes,\n+            \"authors\",\n+            1,\n+            {(\"authors\", \"auto_1\"), (\"contract\", \"auto_1\"), (\"testapp\", \"auto_1\")},\n+        )\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"testapp\", 0, 0, name=\"Publisher\")\n+        self.assertOperationTypes(changes, \"contract\", 0, [\"CreateModel\"])\n+        self.assertOperationAttributes(changes, \"contract\", 0, 0, name=\"Contract\")\n+        self.assertOperationTypes(changes, \"authors\", 0, [\"CreateModel\"])\n+        self.assertOperationTypes(changes, \"authors\", 1, [\"AddField\"])\n+        self.assertOperationAttributes(changes, \"authors\", 0, 0, name=\"Author\")\n+        self.assertOperationAttributes(\n+            changes, \"authors\", 1, 0, model_name=\"author\", name=\"publishers\"\n+        )\n+\n     def test_many_to_many_removed_before_through_model(self):\n         \"\"\"\n         Removing a ManyToManyField and the \"through\" model in the same change\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15973"}