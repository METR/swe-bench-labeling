diff --git a/debug_constraints.py b/debug_constraints.py
new file mode 100644
index 0000000000..624850f18f
--- /dev/null
+++ b/debug_constraints.py
@@ -0,0 +1,62 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models, connection
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+# Create a test model with both index_together and unique_together
+class TestModel(models.Model):
+    field1 = models.CharField(max_length=50)
+    field2 = models.CharField(max_length=50)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'test_model'
+
+def debug_constraints():
+    # Create the table
+    with connection.schema_editor() as editor:
+        editor.create_model(TestModel)
+        
+        # Add both index_together and unique_together
+        editor.alter_index_together(TestModel, [], [['field1', 'field2']])
+        editor.alter_unique_together(TestModel, [], [['field1', 'field2']])
+        
+        print("Created model with index_together and unique_together")
+        
+        # Check what constraints exist
+        with connection.cursor() as cursor:
+            constraints = connection.introspection.get_constraints(cursor, 'test_model')
+            print("\nAll constraints:")
+            for name, info in constraints.items():
+                print(f"  {name}: {info}")
+        
+        # Check what _constraint_names returns for index=True
+        columns = ['field1', 'field2']
+        constraint_names = editor._constraint_names(TestModel, columns, index=True)
+        print(f"\nConstraints with index=True: {constraint_names}")
+        
+        # Check what _constraint_names returns for unique=True
+        constraint_names = editor._constraint_names(TestModel, columns, unique=True)
+        print(f"Constraints with unique=True: {constraint_names}")
+
+if __name__ == '__main__':
+    debug_constraints()
diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py
index 61f88401ab..4a509c43df 100644
--- a/django/db/backends/base/schema.py
+++ b/django/db/backends/base/schema.py
@@ -407,6 +407,16 @@ class BaseDatabaseSchemaEditor:
             model, columns, exclude=meta_constraint_names | meta_index_names,
             **constraint_kwargs
         )
+        # When we're looking for an index to delete but not a unique constraint,
+        # we need to exclude unique constraints that also have index=True
+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):
+            # Filter out any constraints that are unique
+            with self.connection.cursor() as cursor:
+                constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
+            constraint_names = [
+                name for name in constraint_names
+                if not constraints.get(name, {}).get('unique', False)
+            ]
         if len(constraint_names) != 1:
             raise ValueError("Found wrong number (%s) of constraints for %s(%s)" % (
                 len(constraint_names),
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..7a24910fb3
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,54 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models, connection
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+# Create a test model with both index_together and unique_together
+class TestModel(models.Model):
+    field1 = models.CharField(max_length=50)
+    field2 = models.CharField(max_length=50)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'test_model'
+
+def reproduce_issue():
+    # Create the table
+    with connection.schema_editor() as editor:
+        editor.create_model(TestModel)
+        
+        # Add both index_together and unique_together
+        editor.alter_index_together(TestModel, [], [['field1', 'field2']])
+        editor.alter_unique_together(TestModel, [], [['field1', 'field2']])
+        
+        print("Successfully created model with index_together and unique_together")
+        
+        # Try to remove index_together - this should fail
+        try:
+            editor.alter_index_together(TestModel, [['field1', 'field2']], [])
+            print("Successfully removed index_together")
+        except ValueError as e:
+            print(f"ERROR: {e}")
+            print("This is the bug we need to fix!")
+
+if __name__ == '__main__':
+    reproduce_issue()
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_index_unique_together.py b/test_index_unique_together.py
new file mode 100644
index 0000000000..791cca826b
--- /dev/null
+++ b/test_index_unique_together.py
@@ -0,0 +1,48 @@
+from django.db import models, connection
+from django.db.migrations import Migration, CreateModel, AlterIndexTogether, AlterUniqueTogether
+from django.db.migrations.state import ProjectState
+from django.test import TestCase
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+# Test model
+class TestModel(models.Model):
+    field1 = models.CharField(max_length=50)
+    field2 = models.CharField(max_length=50)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'test_model'
+
+# Create a test to reproduce the issue
+def test_delete_index_together_with_unique_together():
+    # Create initial state with both index_together and unique_together
+    initial_state = ProjectState()
+    initial_state.add_model(TestModel._meta.object_name, 
+                           fields=[
+                               ('id', models.AutoField(primary_key=True)),
+                               ('field1', models.CharField(max_length=50)),
+                               ('field2', models.CharField(max_length=50)),
+                           ],
+                           options={
+                               'index_together': [['field1', 'field2']],
+                               'unique_together': [['field1', 'field2']],
+                               'db_table': 'test_model',
+                           },
+                           app_label='test_app')
+    
+    # Create migration to remove index_together
+    migration = Migration('test_migration', 'test_app')
+    migration.operations = [
+        AlterIndexTogether(
+            name='TestModel',
+            index_together=[],
+        ),
+    ]
+    
+    # Apply migration
+    with connection.schema_editor() as editor:
+        # This should fail with ValueError
+        migration.apply(initial_state, editor)
+
+if __name__ == '__main__':
+    test_delete_index_together_with_unique_together()
diff --git a/test_index_unique_together_fix.py b/test_index_unique_together_fix.py
new file mode 100644
index 0000000000..9974807c7d
--- /dev/null
+++ b/test_index_unique_together_fix.py
@@ -0,0 +1,120 @@
+"""
+Test case for the fix of deleting index_together when unique_together exists on the same fields.
+
+This test ensures that when both index_together and unique_together are defined on the same
+fields, we can successfully delete the index_together without getting a ValueError.
+
+This resolves the issue described in Django ticket where the deletion of index_together
+was failing with "Found wrong number (2) of constraints" error.
+"""
+
+import os
+import django
+from django.conf import settings
+from django.test import TestCase, TransactionTestCase
+from django.db import models, connection
+
+# Configure Django if not already configured
+if not settings.configured:
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],
+        USE_TZ=True,
+    )
+    django.setup()
+
+
+class TestModel(models.Model):
+    field1 = models.CharField(max_length=50)
+    field2 = models.CharField(max_length=50)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'test_model'
+
+
+class IndexUniqueTogetherTest(TransactionTestCase):
+    """Test case for index_together and unique_together interaction."""
+    
+    def test_delete_index_together_with_unique_together(self):
+        """Test that index_together can be deleted when unique_together exists on the same fields."""
+        # Disable FK checks for SQLite
+        with connection.cursor() as cursor:
+            cursor.execute("PRAGMA foreign_keys = OFF")
+        
+        with connection.schema_editor() as editor:
+            # Create the model
+            editor.create_model(TestModel)
+            
+            # Add both index_together and unique_together on the same fields
+            editor.alter_index_together(TestModel, [], [['field1', 'field2']])
+            editor.alter_unique_together(TestModel, [], [['field1', 'field2']])
+            
+            # This should not raise ValueError anymore
+            editor.alter_index_together(TestModel, [['field1', 'field2']], [])
+            
+            # Verify the unique constraint still exists
+            with connection.cursor() as cursor:
+                constraints = connection.introspection.get_constraints(cursor, 'test_model')
+                unique_constraints = [
+                    name for name, info in constraints.items()
+                    if info['unique'] and info['columns'] == ['field1', 'field2']
+                ]
+                self.assertEqual(len(unique_constraints), 1)
+            
+            # Clean up
+            editor.delete_model(TestModel)
+    
+    def test_delete_unique_together_with_index_together(self):
+        """Test that unique_together can be deleted when index_together exists on the same fields."""
+        # Disable FK checks for SQLite
+        with connection.cursor() as cursor:
+            cursor.execute("PRAGMA foreign_keys = OFF")
+        
+        with connection.schema_editor() as editor:
+            # Create the model
+            editor.create_model(TestModel)
+            
+            # Add both index_together and unique_together on the same fields
+            editor.alter_index_together(TestModel, [], [['field1', 'field2']])
+            editor.alter_unique_together(TestModel, [], [['field1', 'field2']])
+            
+            # This should work correctly
+            editor.alter_unique_together(TestModel, [['field1', 'field2']], [])
+            
+            # Verify the index still exists
+            with connection.cursor() as cursor:
+                constraints = connection.introspection.get_constraints(cursor, 'test_model')
+                index_constraints = [
+                    name for name, info in constraints.items()
+                    if info['index'] and not info['unique'] and info['columns'] == ['field1', 'field2']
+                ]
+                self.assertEqual(len(index_constraints), 1)
+            
+            # Clean up
+            editor.delete_model(TestModel)
+
+
+if __name__ == '__main__':
+    # Run as standalone test
+    from django.test import TestCase
+    import unittest
+    
+    # Create test suite
+    suite = unittest.TestSuite()
+    suite.addTest(IndexUniqueTogetherTest('test_delete_index_together_with_unique_together'))
+    suite.addTest(IndexUniqueTogetherTest('test_delete_unique_together_with_index_together'))
+    
+    # Run tests
+    runner = unittest.TextTestRunner(verbosity=2)
+    result = runner.run(suite)
+    
+    # Exit with appropriate code
+    exit(0 if result.wasSuccessful() else 1)
diff --git a/test_scenarios.py b/test_scenarios.py
new file mode 100644
index 0000000000..e69de29bb2
