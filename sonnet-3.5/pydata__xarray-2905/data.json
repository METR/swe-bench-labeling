{"instance_id": "pydata__xarray-2905", "score": "I", "diff": "diff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 45553eb9..8ceeb0d9 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -855,7 +855,12 @@ class Variable(\n         dims, index_tuple, new_order = self._broadcast_indexes(key)\n \n         if not isinstance(value, Variable):\n-            value = as_compatible_data(value)\n+            if hasattr(value, 'values') and not isinstance(value, (np.ndarray, pd.Index)):\n+                # If the value has a 'values' property but is not a numpy array or pandas Index,\n+                # use the object itself instead of its 'values' attribute\n+                value = np.array(value, dtype=object)\n+            else:\n+                value = as_compatible_data(value)\n             if value.ndim > len(dims):\n                 raise ValueError(\n                     \"shape mismatch: value array of shape %s could not be \"\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 277c32b1016..1e0873c628d 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -90,6 +90,10 @@ New Features\n \n Bug fixes\n ~~~~~~~~~\n+- Use specific type checks in\n+  :py:func:`~xarray.core.variable.as_compatible_data` instead of blanket\n+  access to ``values`` attribute (:issue:`2097`)\n+  By `Yunus Sevinchan <https://github.com/blsqr>`_.\n - :py:meth:`DataArray.resample` and :py:meth:`Dataset.resample` do not trigger computations anymore if :py:meth:`Dataset.weighted` or :py:meth:`DataArray.weighted` are applied (:issue:`4625`, :pull:`4668`). By `Julius Busecke <https://github.com/jbusecke>`_.\n - :py:func:`merge` with ``combine_attrs='override'`` makes a copy of the attrs (:issue:`4627`).\n - By default, when possible, xarray will now always use values of type ``int64`` when encoding\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 45553eb9b1e..7ca90d6b3c7 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -218,7 +218,8 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1ae3e1f258..0d4c8662d21 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2300,6 +2300,11 @@ def __init__(self, array):\n         class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n             pass\n \n+        # Type with data stored in values attribute\n+        class CustomWithValuesAttr:\n+            def __init__(self, array):\n+                self.values = array\n+\n         array = CustomArray(np.arange(3))\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, np.ndarray)  # should not be CustomArray\n@@ -2308,6 +2313,10 @@ class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, CustomIndexable)\n \n+        array = CustomWithValuesAttr(np.arange(3))\n+        orig = Variable(dims=(), data=array)\n+        assert isinstance(orig._data.item(), CustomWithValuesAttr)\n+\n \n def test_raise_no_warning_for_nan_in_binary_ops():\n     with pytest.warns(None) as record:\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/2905"}