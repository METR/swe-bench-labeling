{"instance_id": "sympy__sympy-22080", "score": "I", "diff": "diff --git a/analyze_expr.py b/analyze_expr.py\nnew file mode 100644\nindex 0000000000..c78b186282\n--- /dev/null\n+++ b/analyze_expr.py\n@@ -0,0 +1,24 @@\n+from sympy import Mod, symbols, srepr\n+\n+x, y = symbols('x y')\n+\n+# Analyze the structure of expressions\n+expr1 = -Mod(x, y)\n+print(f\"Expression: -Mod(x, y)\")\n+print(f\"srepr: {srepr(expr1)}\")\n+print(f\"args: {expr1.args}\")\n+print(f\"Type: {type(expr1)}\")\n+print()\n+\n+expr2 = 2 * Mod(x, y)\n+print(f\"Expression: 2 * Mod(x, y)\")\n+print(f\"srepr: {srepr(expr2)}\")\n+print(f\"args: {expr2.args}\")\n+print(f\"Type: {type(expr2)}\")\n+print()\n+\n+expr3 = (x + 1) * Mod(x, y)\n+print(f\"Expression: (x + 1) * Mod(x, y)\")\n+print(f\"srepr: {srepr(expr3)}\")\n+print(f\"args: {expr3.args}\")\n+print(f\"Type: {type(expr3)}\")\ndiff --git a/check_precedence.py b/check_precedence.py\nnew file mode 100644\nindex 0000000000..37102b4864\n--- /dev/null\n+++ b/check_precedence.py\n@@ -0,0 +1,14 @@\n+from sympy import Mod, symbols\n+from sympy.printing.precedence import precedence\n+\n+x, y = symbols('x y')\n+mod_expr = Mod(x, y)\n+\n+print(f\"Precedence of Mod(x, y): {precedence(mod_expr)}\")\n+print(f\"Precedence of Add: {precedence(x + y)}\")\n+print(f\"Precedence of Mul: {precedence(x * y)}\")\n+print(f\"Precedence of Pow: {precedence(x ** y)}\")\n+\n+# Check class hierarchy\n+print(f\"\\nMod class MRO: {Mod.__mro__}\")\n+print(f\"Is Mod a Function? {issubclass(Mod, __import__('sympy').Function)}\")\ndiff --git a/python_precedence.py b/python_precedence.py\nnew file mode 100644\nindex 0000000000..b6f2423c0f\n--- /dev/null\n+++ b/python_precedence.py\n@@ -0,0 +1,28 @@\n+# Python operator precedence reference\n+# From lowest to highest:\n+# 1. lambda\n+# 2. if-else (ternary)\n+# 3. or\n+# 4. and\n+# 5. not\n+# 6. in, not in, is, is not, <, <=, >, >=, !=, ==\n+# 7. |\n+# 8. ^\n+# 9. &\n+# 10. <<, >>\n+# 11. +, - (binary)\n+# 12. *, @, /, //, %\n+# 13. +, -, ~ (unary)\n+# 14. **\n+# 15. await\n+# 16. x[index], x[index:index], x(arguments...), x.attribute\n+# 17. (expressions...), [expressions...], {key: value...}, {expressions...}\n+\n+# So % has the same precedence as * and /, which is 50 in sympy's PRECEDENCE dict\n+# But unary - has higher precedence than %\n+\n+# Test cases to verify Python behavior:\n+print(\"-3 % 7 =\", -3 % 7)  # Should be 4 (Python evaluates as (-3) % 7)\n+print(\"-(3 % 7) =\", -(3 % 7))  # Should be -3\n+print(\"2 * 3 % 7 =\", 2 * 3 % 7)  # Should be 6 (Python evaluates as (2 * 3) % 7)\n+print(\"2 * (3 % 7) =\", 2 * (3 % 7))  # Should be 6 too\ndiff --git a/sympy/printing/pycode.py b/sympy/printing/pycode.py\nindex b669a2c783..1f377ff1c8 100644\n--- a/sympy/printing/pycode.py\n+++ b/sympy/printing/pycode.py\n@@ -233,8 +233,13 @@ def _print_ComplexInfinity(self, expr):\n         return self._print_NaN(expr)\n \n     def _print_Mod(self, expr):\n-        PREC = precedence(expr)\n-        return ('{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args)))\n+        # The % operator in Python has the same precedence as *, /, //\n+        # which is 50 (same as Mul)\n+        PREC = 50  # Use multiplication precedence for % operator\n+        result = '{} % {}'.format(*map(lambda x: self.parenthesize(x, PREC), expr.args))\n+        # Always wrap mod in parentheses to ensure correct evaluation order\n+        # when it's part of a larger expression (e.g., -Mod(x, y) or 2*Mod(x, y))\n+        return '({})'.format(result)\n \n     def _print_Piecewise(self, expr):\n         result = []\ndiff --git a/test_eval_order.py b/test_eval_order.py\nnew file mode 100644\nindex 0000000000..c1f9cafff8\n--- /dev/null\n+++ b/test_eval_order.py\n@@ -0,0 +1,24 @@\n+import ast\n+import dis\n+\n+# Test Python's evaluation order for % operator\n+code1 = \"-x % y\"\n+code2 = \"-(x % y)\"\n+code3 = \"2 * x % y\"\n+code4 = \"2 * (x % y)\"\n+\n+print(\"AST for '-x % y':\")\n+print(ast.dump(ast.parse(code1, mode='eval')))\n+print(\"\\nAST for '-(x % y)':\")\n+print(ast.dump(ast.parse(code2, mode='eval')))\n+print(\"\\nAST for '2 * x % y':\")\n+print(ast.dump(ast.parse(code3, mode='eval')))\n+print(\"\\nAST for '2 * (x % y)':\")\n+print(ast.dump(ast.parse(code4, mode='eval')))\n+\n+# Test evaluation\n+x, y = 3, 7\n+print(f\"\\n-x % y = {-x % y}\")  # Should be 4\n+print(f\"-(x % y) = {-(x % y)}\")  # Should be -3\n+print(f\"2 * x % y = {2 * x % y}\")  # Should be 6\n+print(f\"2 * (x % y) = {2 * (x % y)}\")  # Should be 6\ndiff --git a/test_mod_issue.py b/test_mod_issue.py\nnew file mode 100644\nindex 0000000000..f4c3ecb690\n--- /dev/null\n+++ b/test_mod_issue.py\n@@ -0,0 +1,38 @@\n+from sympy import Mod, lambdify, symbols\n+import inspect\n+\n+# Test case from the issue\n+x, y = symbols('x y')\n+expr = -Mod(x, y)\n+\n+# Test with default modules\n+f = lambdify([x, y], expr)\n+print(\"With default modules:\")\n+print(f\"f(3, 7) = {f(3, 7)}\")\n+print(f\"Source: {inspect.getsource(f)}\")\n+\n+# Test with empty modules\n+g = lambdify([x, y], expr, modules=[])\n+print(\"\\nWith modules=[]:\")\n+print(f\"g(3, 7) = {g(3, 7)}\")\n+print(f\"Source: {inspect.getsource(g)}\")\n+\n+# Expected result\n+print(f\"\\nExpected result: {-Mod(3, 7)}\")\n+\n+# More test cases\n+print(\"\\nAdditional test cases:\")\n+expr2 = 2 * Mod(x, y)\n+h = lambdify([x, y], expr2, modules=[])\n+print(f\"2 * Mod(3, 7), modules=[]: {h(3, 7)}\")\n+print(f\"Source: {inspect.getsource(h)}\")\n+\n+expr3 = Mod(x, y) * 2\n+i = lambdify([x, y], expr3, modules=[])\n+print(f\"Mod(3, 7) * 2, modules=[]: {i(3, 7)}\")\n+print(f\"Source: {inspect.getsource(i)}\")\n+\n+expr4 = (x + 1) * Mod(x, y)\n+j = lambdify([x, y], expr4, modules=[])\n+print(f\"(x + 1) * Mod(x, y) with x=3, y=7, modules=[]: {j(3, 7)}\")\n+print(f\"Source: {inspect.getsource(j)}\")\n", "gold_standard_diff": "diff --git a/sympy/codegen/tests/test_rewriting.py b/sympy/codegen/tests/test_rewriting.py\nindex c8af626b7e50..32dfa8395e7b 100644\n--- a/sympy/codegen/tests/test_rewriting.py\n+++ b/sympy/codegen/tests/test_rewriting.py\n@@ -266,10 +266,10 @@ def test_create_expand_pow_optimization():\n     # gh issue 15335\n     assert cc(x**(-4)) == '1.0/(x*x*x*x)'\n     assert cc(x**(-5)) == 'pow(x, -5)'\n-    assert cc(-x**4) == '-x*x*x*x'\n-    assert cc(x**4 - x**2) == '-x*x + x*x*x*x'\n+    assert cc(-x**4) == '-(x*x*x*x)'\n+    assert cc(x**4 - x**2) == '-(x*x) + x*x*x*x'\n     i = Symbol('i', integer=True)\n-    assert cc(x**i - x**2) == 'pow(x, i) - x*x'\n+    assert cc(x**i - x**2) == 'pow(x, i) - (x*x)'\n     # gh issue 20753\n     cc2 = lambda x: ccode(optimize(x, [create_expand_pow_optimization(\n         4, base_req=lambda b: b.is_Function)]))\ndiff --git a/sympy/printing/codeprinter.py b/sympy/printing/codeprinter.py\nindex ba0e746f5dac..4b300f4a2fed 100644\n--- a/sympy/printing/codeprinter.py\n+++ b/sympy/printing/codeprinter.py\n@@ -9,7 +9,7 @@\n from sympy.core.mul import _keep_coeff\n from sympy.core.symbol import Symbol\n from sympy.printing.str import StrPrinter\n-from sympy.printing.precedence import precedence\n+from sympy.printing.precedence import precedence, PRECEDENCE\n \n \n class requires:\n@@ -487,7 +487,14 @@ def _print_Mul(self, expr):\n \n         a = a or [S.One]\n \n-        a_str = [self.parenthesize(x, prec) for x in a]\n+        if len(a) == 1 and sign == \"-\":\n+            # Unary minus does not have a SymPy class, and hence there's no\n+            # precedence weight associated with it, Python's unary minus has\n+            # an operator precedence between multiplication and exponentiation,\n+            # so we use this to compute a weight.\n+            a_str = [self.parenthesize(a[0], 0.5*(PRECEDENCE[\"Pow\"]+PRECEDENCE[\"Mul\"]))]\n+        else:\n+            a_str = [self.parenthesize(x, prec) for x in a]\n         b_str = [self.parenthesize(x, prec) for x in b]\n \n         # To parenthesize Pow with exp = -1 and having more than one Symbol\ndiff --git a/sympy/printing/precedence.py b/sympy/printing/precedence.py\nindex 47ff463faf3f..bddc43048f1d 100644\n--- a/sympy/printing/precedence.py\n+++ b/sympy/printing/precedence.py\n@@ -40,6 +40,7 @@\n     \"MatAdd\": PRECEDENCE[\"Add\"],\n     \"MatPow\": PRECEDENCE[\"Pow\"],\n     \"MatrixSolve\": PRECEDENCE[\"Mul\"],\n+    \"Mod\": PRECEDENCE[\"Mul\"],\n     \"TensAdd\": PRECEDENCE[\"Add\"],\n     # As soon as `TensMul` is a subclass of `Mul`, remove this:\n     \"TensMul\": PRECEDENCE[\"Mul\"],\ndiff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex cf18825eb1b6..847ea41b12ff 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -30,6 +30,8 @@ def test_PythonCodePrinter():\n \n     assert prntr.doprint(x**y) == 'x**y'\n     assert prntr.doprint(Mod(x, 2)) == 'x % 2'\n+    assert prntr.doprint(-Mod(x, y)) == '-(x % y)'\n+    assert prntr.doprint(Mod(-x, y)) == '(-x) % y'\n     assert prntr.doprint(And(x, y)) == 'x and y'\n     assert prntr.doprint(Or(x, y)) == 'x or y'\n     assert not prntr.module_imports\ndiff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex e25986b4a00e..524e9d1220df 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -264,7 +264,15 @@ def test_issue_12984():\n         warnings.simplefilter(\"ignore\", RuntimeWarning)\n         assert str(func_numexpr(-1, 24, 42)) == 'nan'\n \n-#================== Test some functions ============================\n+\n+def test_empty_modules():\n+    x, y = symbols('x y')\n+    expr = -(x % y)\n+\n+    no_modules = lambdify([x, y], expr)\n+    empty_modules = lambdify([x, y], expr, modules=[])\n+    assert no_modules(3, 7) == empty_modules(3, 7)\n+    assert no_modules(3, 7) == -3\n \n \n def test_exponentiation():\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/22080"}