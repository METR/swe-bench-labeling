{"instance_id": "django__django-16100", "score": "C", "diff": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 5f07a4208a..088fec9f4d 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2011,14 +2011,15 @@ class ModelAdmin(BaseModelAdmin):\n             )\n             if formset.is_valid():\n                 changecount = 0\n-                for form in formset.forms:\n-                    if form.has_changed():\n-                        obj = self.save_form(request, form, change=True)\n-                        self.save_model(request, obj, form, change=True)\n-                        self.save_related(request, form, formsets=[], change=True)\n-                        change_msg = self.construct_change_message(request, form, None)\n-                        self.log_change(request, obj, change_msg)\n-                        changecount += 1\n+                with transaction.atomic(using=router.db_for_write(self.model)):\n+                    for form in formset.forms:\n+                        if form.has_changed():\n+                            obj = self.save_form(request, form, change=True)\n+                            self.save_model(request, obj, form, change=True)\n+                            self.save_related(request, form, formsets=[], change=True)\n+                            change_msg = self.construct_change_message(request, form, None)\n+                            self.log_change(request, obj, change_msg)\n+                            changecount += 1\n \n                 if changecount:\n                     msg = ngettext(\ndiff --git a/test_changelist_fix.py b/test_changelist_fix.py\nnew file mode 100644\nindex 0000000000..b527ead1a1\n--- /dev/null\n+++ b/test_changelist_fix.py\n@@ -0,0 +1,137 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django first\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+            'django.contrib.sessions',\n+            'django.contrib.messages',\n+            'django.contrib.admin',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+            'django.contrib.messages.middleware.MessageMiddleware',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+        USE_TZ=True,\n+    )\n+    \n+django.setup()\n+\n+# Now import Django modules\n+from django.test import TestCase, TransactionTestCase, RequestFactory\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+from django.contrib.admin import ModelAdmin\n+from django.db import models, transaction\n+from django.contrib import messages\n+from unittest.mock import patch, Mock\n+\n+# Define test model\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    value = models.IntegerField(default=0)\n+\n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Define admin class with list_editable\n+class TestModelAdmin(ModelAdmin):\n+    list_display = ['id', 'name', 'value']\n+    list_editable = ['name', 'value']\n+\n+class ChangelistTransactionTest(TransactionTestCase):\n+    def setUp(self):\n+        # Create tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(TestModel)\n+        \n+        self.factory = RequestFactory()\n+        self.site = AdminSite()\n+        self.admin = TestModelAdmin(TestModel, self.site)\n+        \n+        # Create a superuser\n+        self.user = User.objects.create_superuser('admin', 'admin@example.com', 'password')\n+        \n+        # Create test objects\n+        self.obj1 = TestModel.objects.create(name='Object 1', value=1)\n+        self.obj2 = TestModel.objects.create(name='Object 2', value=2)\n+    \n+    def tearDown(self):\n+        # Drop tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(TestModel)\n+    \n+    def test_save_model_raises_exception(self):\n+        \"\"\"Test behavior when save_model raises an exception during list_editable processing\"\"\"\n+        request = self.factory.post('/', {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2', \n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(self.obj1.id),\n+            'form-0-name': 'Updated Object 1',\n+            'form-0-value': '10',\n+            'form-1-id': str(self.obj2.id),\n+            'form-1-name': 'Updated Object 2',\n+            'form-1-value': '20',\n+            '_save': 'Save',\n+        })\n+        request.user = self.user\n+        request._messages = messages.storage.default_storage(request)\n+        \n+        # Mock save_model to raise exception on second object\n+        original_save_model = self.admin.save_model\n+        call_count = 0\n+        \n+        def mock_save_model(request, obj, form, change):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 2:\n+                raise Exception(\"Simulated database error\")\n+            return original_save_model(request, obj, form, change)\n+        \n+        with patch.object(self.admin, 'save_model', side_effect=mock_save_model):\n+            try:\n+                response = self.admin.changelist_view(request)\n+            except Exception as e:\n+                print(f\"Exception raised: {e}\")\n+        \n+        # Refresh from DB\n+        self.obj1.refresh_from_db()\n+        self.obj2.refresh_from_db()\n+        \n+        # Without transaction, obj1 might be updated but obj2 not\n+        print(f\"Object 1 after exception: name={self.obj1.name}, value={self.obj1.value}\")\n+        print(f\"Object 2 after exception: name={self.obj2.name}, value={self.obj2.value}\")\n+        \n+        # Without proper transaction handling, obj1 would be updated even though obj2 failed\n+        if self.obj1.name == 'Updated Object 1':\n+            print(\"WARNING: Partial update occurred! Object 1 was updated even though Object 2 failed.\")\n+        else:\n+            print(\"Good: No partial update occurred.\")\n+\n+\n+if __name__ == '__main__':\n+    # Run the test\n+    test = ChangelistTransactionTest()\n+    test.setUp()\n+    try:\n+        test.test_save_model_raises_exception()\n+    finally:\n+        test.tearDown()\ndiff --git a/test_changelist_transaction.py b/test_changelist_transaction.py\nnew file mode 100644\nindex 0000000000..79b6ea43f5\n--- /dev/null\n+++ b/test_changelist_transaction.py\n@@ -0,0 +1,153 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test import TestCase, TransactionTestCase, RequestFactory\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+from django.contrib.admin import ModelAdmin\n+from django.db import models, transaction\n+from django.contrib import messages\n+from unittest.mock import patch, Mock\n+\n+# Configure Django\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.auth',\n+            'django.contrib.contenttypes',\n+            'django.contrib.sessions',\n+            'django.contrib.messages',\n+            'django.contrib.admin',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+            'django.contrib.messages.middleware.MessageMiddleware',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+        USE_TZ=True,\n+    )\n+    django.setup()\n+\n+# Define test model\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    value = models.IntegerField(default=0)\n+\n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Define admin class with list_editable\n+class TestModelAdmin(ModelAdmin):\n+    list_display = ['id', 'name', 'value']\n+    list_editable = ['name', 'value']\n+\n+class ChangelistTransactionTest(TransactionTestCase):\n+    def setUp(self):\n+        # Create tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(TestModel)\n+        \n+        self.factory = RequestFactory()\n+        self.site = AdminSite()\n+        self.admin = TestModelAdmin(TestModel, self.site)\n+        \n+        # Create a superuser\n+        self.user = User.objects.create_superuser('admin', 'admin@example.com', 'password')\n+        \n+        # Create test objects\n+        self.obj1 = TestModel.objects.create(name='Object 1', value=1)\n+        self.obj2 = TestModel.objects.create(name='Object 2', value=2)\n+    \n+    def tearDown(self):\n+        # Drop tables\n+        from django.db import connection\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(TestModel)\n+    \n+    def test_list_editable_without_transaction_partial_failure(self):\n+        \"\"\"Test that without proper transaction handling, partial updates can occur\"\"\"\n+        request = self.factory.post('/', {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(self.obj1.id),\n+            'form-0-name': 'Updated Object 1',\n+            'form-0-value': '10',\n+            'form-1-id': str(self.obj2.id),\n+            'form-1-name': 'Updated Object 2',\n+            'form-1-value': 'invalid',  # This will cause a validation error\n+            '_save': 'Save',\n+        })\n+        request.user = self.user\n+        request._messages = messages.storage.default_storage(request)\n+        \n+        # Check current implementation behavior\n+        response = self.admin.changelist_view(request)\n+        \n+        # Refresh from DB\n+        self.obj1.refresh_from_db()\n+        self.obj2.refresh_from_db()\n+        \n+        # Print current behavior for debugging\n+        print(f\"Object 1 name after partial save attempt: {self.obj1.name}\")\n+        print(f\"Object 2 name after partial save attempt: {self.obj2.name}\")\n+    \n+    def test_save_model_raises_exception(self):\n+        \"\"\"Test behavior when save_model raises an exception during list_editable processing\"\"\"\n+        request = self.factory.post('/', {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2', \n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(self.obj1.id),\n+            'form-0-name': 'Updated Object 1',\n+            'form-0-value': '10',\n+            'form-1-id': str(self.obj2.id),\n+            'form-1-name': 'Updated Object 2',\n+            'form-1-value': '20',\n+            '_save': 'Save',\n+        })\n+        request.user = self.user\n+        request._messages = messages.storage.default_storage(request)\n+        \n+        # Mock save_model to raise exception on second object\n+        original_save_model = self.admin.save_model\n+        call_count = 0\n+        \n+        def mock_save_model(request, obj, form, change):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 2:\n+                raise Exception(\"Simulated database error\")\n+            return original_save_model(request, obj, form, change)\n+        \n+        with patch.object(self.admin, 'save_model', side_effect=mock_save_model):\n+            try:\n+                response = self.admin.changelist_view(request)\n+            except Exception:\n+                pass\n+        \n+        # Refresh from DB\n+        self.obj1.refresh_from_db()\n+        self.obj2.refresh_from_db()\n+        \n+        # Without transaction, obj1 might be updated but obj2 not\n+        print(f\"Object 1 after exception: name={self.obj1.name}, value={self.obj1.value}\")\n+        print(f\"Object 2 after exception: name={self.obj2.name}, value={self.obj2.value}\")\n+\n+\n+if __name__ == '__main__':\n+    # Run the test\n+    import unittest\n+    unittest.main()\ndiff --git a/test_manual.py b/test_manual.py\nnew file mode 100644\nindex 0000000000..c4215f289f\n--- /dev/null\n+++ b/test_manual.py\n@@ -0,0 +1,49 @@\n+\"\"\"Manual test to verify transaction behavior\"\"\"\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+\n+import django\n+django.setup()\n+\n+from django.db import connection, transaction\n+from tests.admin_changelist.models import Parent\n+\n+# Create test data\n+Parent.objects.all().delete()\n+p1 = Parent.objects.create(name='Test Parent 1')\n+p2 = Parent.objects.create(name='Test Parent 2')\n+\n+print(f\"Created parents: {p1.name} (id={p1.id}), {p2.name} (id={p2.id})\")\n+\n+# Simulate what happens in list_editable processing\n+try:\n+    with transaction.atomic():\n+        # Update first object\n+        p1.name = 'Updated Parent 1'\n+        p1.save()\n+        print(f\"Updated first parent to: {p1.name}\")\n+        \n+        # Simulate an error before updating second object\n+        raise Exception(\"Simulated error during list_editable processing\")\n+        \n+        # This would never be reached\n+        p2.name = 'Updated Parent 2'\n+        p2.save()\n+        \n+except Exception as e:\n+    print(f\"Exception occurred: {e}\")\n+\n+# Check if changes were rolled back\n+p1.refresh_from_db()\n+p2.refresh_from_db()\n+\n+print(f\"\\nAfter exception:\")\n+print(f\"Parent 1: {p1.name} (should be 'Test Parent 1' due to rollback)\")\n+print(f\"Parent 2: {p2.name} (should be 'Test Parent 2')\")\n+\n+if p1.name == 'Test Parent 1' and p2.name == 'Test Parent 2':\n+    print(\"\\n\u2705 SUCCESS: Transaction properly rolled back changes!\")\n+else:\n+    print(\"\\n\u274c FAILURE: Transaction did not roll back properly!\")\ndiff --git a/test_transaction_fix.py b/test_transaction_fix.py\nnew file mode 100644\nindex 0000000000..07cc8bde8b\n--- /dev/null\n+++ b/test_transaction_fix.py\n@@ -0,0 +1,114 @@\n+\"\"\"Test that list_editable processing is wrapped in a transaction.\"\"\"\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+\n+import django\n+django.setup()\n+\n+from django.test import TestCase, TransactionTestCase\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+from django.test.client import RequestFactory\n+from django.contrib import messages\n+from django.db import transaction\n+from unittest.mock import patch\n+\n+# Import the test models\n+from tests.admin_changelist.models import Parent\n+from tests.admin_changelist.admin import NoListDisplayLinksParentAdmin\n+\n+\n+class ListEditableTransactionTest(TransactionTestCase):\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.site = AdminSite()\n+        self.admin = NoListDisplayLinksParentAdmin(Parent, self.site)\n+        \n+        # Create a superuser\n+        self.user = User.objects.create_superuser('admin', 'admin@example.com', 'password')\n+        \n+        # Create test objects\n+        self.obj1 = Parent.objects.create(name='Parent 1')\n+        self.obj2 = Parent.objects.create(name='Parent 2')\n+    \n+    def test_list_editable_wrapped_in_transaction(self):\n+        \"\"\"Test that an exception during list_editable processing rolls back all changes.\"\"\"\n+        request = self.factory.post('/', {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(self.obj1.pk),\n+            'form-0-name': 'Updated Parent 1',\n+            'form-1-id': str(self.obj2.pk),\n+            'form-1-name': 'Updated Parent 2',\n+            '_save': 'Save',\n+        })\n+        request.user = self.user\n+        request._messages = messages.storage.default_storage(request)\n+        \n+        # Mock save_model to raise exception on second object\n+        original_save_model = self.admin.save_model\n+        call_count = 0\n+        \n+        def mock_save_model(request, obj, form, change):\n+            nonlocal call_count\n+            call_count += 1\n+            if call_count == 2:\n+                raise Exception(\"Simulated database error on second object\")\n+            return original_save_model(request, obj, form, change)\n+        \n+        with patch.object(self.admin, 'save_model', side_effect=mock_save_model):\n+            with self.assertRaises(Exception) as cm:\n+                self.admin.changelist_view(request)\n+            self.assertEqual(str(cm.exception), \"Simulated database error on second object\")\n+        \n+        # Refresh from DB\n+        self.obj1.refresh_from_db()\n+        self.obj2.refresh_from_db()\n+        \n+        # With transaction, neither object should be updated\n+        self.assertEqual(self.obj1.name, 'Parent 1', \n+                        \"First object should not be updated when second fails\")\n+        self.assertEqual(self.obj2.name, 'Parent 2',\n+                        \"Second object should not be updated when it fails\")\n+        \n+        print(\"\u2713 Transaction correctly rolled back all changes when an error occurred\")\n+    \n+    def test_list_editable_success_commits(self):\n+        \"\"\"Test that successful list_editable processing commits all changes.\"\"\"\n+        request = self.factory.post('/', {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(self.obj1.pk),\n+            'form-0-name': 'Successfully Updated Parent 1',\n+            'form-1-id': str(self.obj2.pk),\n+            'form-1-name': 'Successfully Updated Parent 2',\n+            '_save': 'Save',\n+        })\n+        request.user = self.user\n+        request._messages = messages.storage.default_storage(request)\n+        \n+        response = self.admin.changelist_view(request)\n+        \n+        # Should redirect after successful save\n+        self.assertEqual(response.status_code, 302)\n+        \n+        # Refresh from DB\n+        self.obj1.refresh_from_db()\n+        self.obj2.refresh_from_db()\n+        \n+        # Both objects should be updated\n+        self.assertEqual(self.obj1.name, 'Successfully Updated Parent 1')\n+        self.assertEqual(self.obj2.name, 'Successfully Updated Parent 2')\n+        \n+        print(\"\u2713 Successful updates are correctly committed\")\n+\n+\n+if __name__ == '__main__':\n+    import unittest\n+    unittest.main()\ndiff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex b85d5383cd..6bad5e9c78 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -1169,6 +1169,65 @@ class ChangeListTests(TestCase):\n             # Check only the first few characters since the UUID may have dashes.\n             self.assertIn(str(a.pk)[:8], context.captured_queries[4][\"sql\"])\n \n+    def test_list_editable_saves_in_transaction(self):\n+        \"\"\"Test that list_editable processing is wrapped in a transaction.\"\"\"\n+        from unittest.mock import patch\n+        from django.db import transaction\n+        \n+        # Create test objects\n+        parent1 = Parent.objects.create(name='Parent 1')\n+        parent2 = Parent.objects.create(name='Parent 2')\n+        \n+        # Prepare POST data for list_editable\n+        data = {\n+            'form-TOTAL_FORMS': '2',\n+            'form-INITIAL_FORMS': '2',\n+            'form-MIN_NUM_FORMS': '0',\n+            'form-MAX_NUM_FORMS': '1000',\n+            'form-0-id': str(parent1.pk),\n+            'form-0-name': 'Updated Parent 1',\n+            'form-1-id': str(parent2.pk),\n+            'form-1-name': 'Updated Parent 2',\n+            '_save': 'Save',\n+        }\n+        \n+        superuser = self._create_superuser(\"superuser\")\n+        self.client.force_login(superuser)\n+        \n+        # Simulate an error during save using a mock\n+        with patch.object(NoListDisplayLinksParentAdmin, 'save_model') as mock_save:\n+            call_count = 0\n+            \n+            def side_effect(request, obj, form, change):\n+                nonlocal call_count\n+                call_count += 1\n+                # Save the first object successfully\n+                if call_count == 1:\n+                    obj.save()\n+                else:\n+                    # Raise exception on second object\n+                    raise Exception(\"Simulated database error\")\n+            \n+            mock_save.side_effect = side_effect\n+            \n+            changelist_url = reverse(\"admin:admin_changelist_parent_changelist\")\n+            \n+            # The view should raise the exception\n+            with self.assertRaises(Exception) as cm:\n+                self.client.post(changelist_url, data=data)\n+            \n+            self.assertEqual(str(cm.exception), \"Simulated database error\")\n+        \n+        # Refresh objects from database\n+        parent1.refresh_from_db()\n+        parent2.refresh_from_db()\n+        \n+        # Due to transaction, neither object should be updated\n+        self.assertEqual(parent1.name, 'Parent 1', \n+                        \"First object should not be updated when second fails due to transaction rollback\")\n+        self.assertEqual(parent2.name, 'Parent 2',\n+                        \"Second object should not be updated when it fails\")\n+\n     def test_deterministic_order_for_unordered_model(self):\n         \"\"\"\n         The primary key is used in the ordering of the changelist's results to\n", "gold_standard_diff": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 5f07a4208a80..215df9a059f5 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -2011,15 +2011,17 @@ def changelist_view(self, request, extra_context=None):\n             )\n             if formset.is_valid():\n                 changecount = 0\n-                for form in formset.forms:\n-                    if form.has_changed():\n-                        obj = self.save_form(request, form, change=True)\n-                        self.save_model(request, obj, form, change=True)\n-                        self.save_related(request, form, formsets=[], change=True)\n-                        change_msg = self.construct_change_message(request, form, None)\n-                        self.log_change(request, obj, change_msg)\n-                        changecount += 1\n-\n+                with transaction.atomic(using=router.db_for_write(self.model)):\n+                    for form in formset.forms:\n+                        if form.has_changed():\n+                            obj = self.save_form(request, form, change=True)\n+                            self.save_model(request, obj, form, change=True)\n+                            self.save_related(request, form, formsets=[], change=True)\n+                            change_msg = self.construct_change_message(\n+                                request, form, None\n+                            )\n+                            self.log_change(request, obj, change_msg)\n+                            changecount += 1\n                 if changecount:\n                     msg = ngettext(\n                         \"%(count)s %(name)s was changed successfully.\",\ndiff --git a/docs/releases/4.2.txt b/docs/releases/4.2.txt\nindex 5a849cbbe5b8..5774bfef7ba8 100644\n--- a/docs/releases/4.2.txt\n+++ b/docs/releases/4.2.txt\n@@ -51,6 +51,9 @@ Minor features\n * The ``admin/base.html`` template now has a new block ``nav-breadcrumbs``\n   which contains the navigation landmark and the ``breadcrumbs`` block.\n \n+* :attr:`.ModelAdmin.list_editable` now uses atomic transactions when making\n+  edits.\n+\n :mod:`django.contrib.admindocs`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \ndiff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex b85d5383cd71..128fbb6aacda 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -1,4 +1,5 @@\n import datetime\n+from unittest import mock\n \n from django.contrib import admin\n from django.contrib.admin.models import LogEntry\n@@ -16,12 +17,12 @@\n from django.contrib.auth.models import User\n from django.contrib.contenttypes.models import ContentType\n from django.contrib.messages.storage.cookie import CookieStorage\n-from django.db import connection, models\n+from django.db import DatabaseError, connection, models\n from django.db.models import F, Field, IntegerField\n from django.db.models.functions import Upper\n from django.db.models.lookups import Contains, Exact\n from django.template import Context, Template, TemplateSyntaxError\n-from django.test import TestCase, override_settings\n+from django.test import TestCase, override_settings, skipUnlessDBFeature\n from django.test.client import RequestFactory\n from django.test.utils import CaptureQueriesContext, isolate_apps, register_lookup\n from django.urls import reverse\n@@ -400,6 +401,53 @@ def test_result_list_editable(self):\n         with self.assertRaises(IncorrectLookupParameters):\n             m.get_changelist_instance(request)\n \n+    @skipUnlessDBFeature(\"supports_transactions\")\n+    def test_list_editable_atomicity(self):\n+        a = Swallow.objects.create(origin=\"Swallow A\", load=4, speed=1)\n+        b = Swallow.objects.create(origin=\"Swallow B\", load=2, speed=2)\n+\n+        self.client.force_login(self.superuser)\n+        changelist_url = reverse(\"admin:admin_changelist_swallow_changelist\")\n+        data = {\n+            \"form-TOTAL_FORMS\": \"2\",\n+            \"form-INITIAL_FORMS\": \"2\",\n+            \"form-MIN_NUM_FORMS\": \"0\",\n+            \"form-MAX_NUM_FORMS\": \"1000\",\n+            \"form-0-uuid\": str(a.pk),\n+            \"form-1-uuid\": str(b.pk),\n+            \"form-0-load\": \"9.0\",\n+            \"form-0-speed\": \"3.0\",\n+            \"form-1-load\": \"5.0\",\n+            \"form-1-speed\": \"1.0\",\n+            \"_save\": \"Save\",\n+        }\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\", side_effect=DatabaseError\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n+\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\",\n+            side_effect=[None, DatabaseError],\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n+\n     def test_custom_paginator(self):\n         new_parent = Parent.objects.create(name=\"parent\")\n         for i in range(1, 201):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16100"}