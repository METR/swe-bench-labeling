{"instance_id": "sympy__sympy-12481", "score": "C", "diff": "diff --git a/final_test.py b/final_test.py\nnew file mode 100644\nindex 0000000000..10b8c1774f\n--- /dev/null\n+++ b/final_test.py\n@@ -0,0 +1,63 @@\n+#!/usr/bin/env python\n+\"\"\"Final comprehensive test for the non-disjoint cycles fix\"\"\"\n+\n+from sympy.combinatorics.permutations import Permutation\n+\n+print(\"Final test of non-disjoint cycles in Permutation constructor\\n\")\n+\n+# Test 1: Original issue case\n+print(\"Test 1: Original issue - Permutation([[0,1],[0,1]])\")\n+try:\n+    p = Permutation([[0, 1], [0, 1]])\n+    print(f\"\u2713 Success! Result: {p}\")\n+    print(f\"  Is identity: {p.is_Identity}\")\n+    print(f\"  Array form: {p.array_form}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\nTest 2: More complex non-disjoint cycles\")\n+test_cases = [\n+    ([[0, 1], [0, 2]], \"Should be (0 1 2)\"),\n+    ([[0, 1, 2], [1, 2, 3]], \"Should be (0 2)(1 3)\"),\n+    ([[0, 1], [1, 2], [2, 0]], \"Should be (1 2)\"),\n+    ([[0, 1, 2], [2, 3, 4], [4, 0]], \"Should map 0->1->3->4->0\"),\n+]\n+\n+for cycles, description in test_cases:\n+    try:\n+        p = Permutation(cycles)\n+        print(f\"\u2713 Permutation({cycles})\")\n+        print(f\"  Result: {p}\")\n+        print(f\"  Array form: {p.array_form}\")\n+        print(f\"  Note: {description}\")\n+    except Exception as e:\n+        print(f\"\u2717 Permutation({cycles}) failed: {e}\")\n+    print()\n+\n+# Test 3: Edge cases\n+print(\"Test 3: Edge cases\")\n+print(\"Empty cycles [[]] should work:\")\n+try:\n+    p = Permutation([[]])\n+    print(f\"\u2713 Success! Result: {p}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\nSingle element cycles [[0],[0]] should give identity:\")\n+try:\n+    p = Permutation([[0], [0]])\n+    print(f\"\u2713 Success! Result: {p}, is_Identity: {p.is_Identity}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\nTest 4: Verify docstring examples work\")\n+Permutation.print_cyclic = False\n+try:\n+    p1 = Permutation([[0, 1], [0, 1]])\n+    p2 = Permutation([[0, 1], [0, 2]])\n+    print(f\"\u2713 Permutation([[0, 1], [0, 1]]) = {p1}\")\n+    print(f\"\u2713 Permutation([[0, 1], [0, 2]]) = {p2}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/run_all_tests.py b/run_all_tests.py\nnew file mode 100644\nindex 0000000000..11bdfbe02e\n--- /dev/null\n+++ b/run_all_tests.py\n@@ -0,0 +1,34 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from sympy.combinatorics.tests.test_permutations import (\n+    test_Permutation, test_args, test_Cycle, test_from_sequence,\n+    test_printing_cyclic, test_printing_non_cyclic, test_josephus,\n+    test_ranking, test_mul\n+)\n+\n+tests = [\n+    (\"test_Permutation\", test_Permutation),\n+    (\"test_args\", test_args),\n+    (\"test_Cycle\", test_Cycle),\n+    (\"test_from_sequence\", test_from_sequence),\n+    (\"test_josephus\", test_josephus),\n+    (\"test_ranking\", test_ranking),\n+    (\"test_mul\", test_mul),\n+    (\"test_printing_cyclic\", test_printing_cyclic),\n+    (\"test_printing_non_cyclic\", test_printing_non_cyclic),\n+]\n+\n+failed = []\n+for name, test_func in tests:\n+    try:\n+        test_func()\n+        print(f\"\u2713 {name} passed\")\n+    except Exception as e:\n+        print(f\"\u2717 {name} failed: {e}\")\n+        failed.append(name)\n+\n+if failed:\n+    print(f\"\\nFailed tests: {', '.join(failed)}\")\n+else:\n+    print(\"\\nAll tests passed!\")\ndiff --git a/run_test.py b/run_test.py\nnew file mode 100644\nindex 0000000000..1e2fd99a40\n--- /dev/null\n+++ b/run_test.py\n@@ -0,0 +1,12 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from sympy.combinatorics.tests.test_permutations import test_args\n+\n+try:\n+    test_args()\n+    print(\"test_args passed!\")\n+except Exception as e:\n+    print(f\"test_args failed: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a478..03e1082a5a 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -802,7 +802,7 @@ def __new__(cls, *args, **kwargs):\n         \"\"\"\n         Constructor for the Permutation object from a list or a\n         list of lists in which all elements of the permutation may\n-        appear only once.\n+        appear only once (for array form) or multiple times (for cyclic form).\n \n         Examples\n         ========\n@@ -824,6 +824,13 @@ def __new__(cls, *args, **kwargs):\n         >>> Permutation([[4, 5, 6], [0, 1], [19]])\n         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)\n \n+        Non-disjoint cycles are allowed and are applied left-to-right:\n+\n+        >>> Permutation([[0, 1], [0, 1]])\n+        Permutation([0, 1])\n+        >>> Permutation([[0, 1], [0, 2]])\n+        Permutation([1, 2, 0])\n+\n         All manipulation of permutations assumes that the smallest element\n         is 0 (in keeping with 0-based indexing in Python) so if the 0 is\n         missing when entering a permutation in array form, an error will be\n@@ -897,8 +904,8 @@ def __new__(cls, *args, **kwargs):\n         temp = flatten(args)\n         if has_dups(temp):\n             if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n+                # For cycles, duplicates are allowed and will be composed left-to-right\n+                pass\n             else:\n                 raise ValueError('there were repeated elements.')\n         temp = set(temp)\ndiff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 7f8cd572e7..257dfac1ad 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -349,7 +349,12 @@ def test_args():\n     raises(ValueError, lambda: Permutation([[1, 2], 0]))\n            # enclosing brackets needed on 0\n     raises(ValueError, lambda: Permutation([1, 1, 0]))\n-    raises(ValueError, lambda: Permutation([[1], [1, 2]]))\n+    # Non-disjoint cycles are now allowed and composed left-to-right\n+    assert Permutation([[1], [1, 2]]) == Permutation([0, 2, 1])\n+    # Test the original issue case\n+    assert Permutation([[0, 1], [0, 1]]).is_Identity\n+    # Test more complex non-disjoint cycles\n+    assert Permutation([[0, 1, 2], [1, 2, 3]]).array_form == [2, 3, 0, 1]\n     raises(ValueError, lambda: Permutation([4, 5], size=10))  # where are 0-3?\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..20e2e37a44\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,65 @@\n+#!/usr/bin/env python\n+\"\"\"Comprehensive test for non-disjoint cycles in Permutation constructor\"\"\"\n+\n+from sympy.combinatorics.permutations import Permutation, Cycle\n+\n+print(\"Testing various non-disjoint cycle scenarios...\\n\")\n+\n+# Test 1: The original reported issue\n+print(\"Test 1: Permutation([[0,1],[0,1]]) - should give identity\")\n+p1 = Permutation([[0, 1], [0, 1]])\n+print(f\"Result: {p1}\")\n+print(f\"Array form: {p1.array_form}\")\n+print(f\"Is identity: {p1.is_Identity}\")\n+print()\n+\n+# Test 2: More complex non-disjoint cycles\n+print(\"Test 2: Permutation([[0,1,2],[1,2,3]]) - cycles share elements 1 and 2\")\n+p2 = Permutation([[0, 1, 2], [1, 2, 3]])\n+print(f\"Result: {p2}\")\n+print(f\"Array form: {p2.array_form}\")\n+print()\n+\n+# Test 3: Multiple overlapping cycles\n+print(\"Test 3: Permutation([[0,1],[1,2],[2,0]])\")\n+p3 = Permutation([[0, 1], [1, 2], [2, 0]])\n+print(f\"Result: {p3}\")\n+print(f\"Array form: {p3.array_form}\")\n+print()\n+\n+# Test 4: Verify left-to-right composition\n+print(\"Test 4: Verify left-to-right composition order\")\n+# (0 1) followed by (0 2) should give (0 2 1)\n+p4 = Permutation([[0, 1], [0, 2]])\n+print(f\"Permutation([[0,1],[0,2]]): {p4}\")\n+print(f\"Array form: {p4.array_form}\")\n+\n+# Verify manually:\n+# Start: [0, 1, 2]\n+# Apply (0 1): [1, 0, 2]\n+# Apply (0 2): [2, 0, 1]\n+print(\"Expected: [2, 0, 1]\")\n+print()\n+\n+# Test 5: Edge case - single element repeated\n+print(\"Test 5: Permutation([[0],[0]]) - should be identity\")\n+p5 = Permutation([[0], [0]])\n+print(f\"Result: {p5}\")\n+print(f\"Is identity: {p5.is_Identity}\")\n+print()\n+\n+# Test 6: Comparison with explicit Cycle composition\n+print(\"Test 6: Compare with explicit Cycle composition\")\n+c = Cycle()(0, 1, 2)(1, 2, 3)\n+p6 = Permutation([[0, 1, 2], [1, 2, 3]])\n+print(f\"Using Cycle: {c.list()}\")\n+print(f\"Using Permutation: {p6.array_form}\")\n+print(f\"Are they equal? {c.list() == p6.array_form}\")\n+print()\n+\n+# Test 7: Non-disjoint cycles should still work with size parameter\n+print(\"Test 7: Non-disjoint cycles with size parameter\")\n+p7 = Permutation([[0, 1], [0, 1]], size=5)\n+print(f\"Permutation([[0,1],[0,1]], size=5): {p7}\")\n+print(f\"Array form: {p7.array_form}\")\n+print(f\"Size: {p7.size}\")\ndiff --git a/test_cycle_order.py b/test_cycle_order.py\nnew file mode 100644\nindex 0000000000..9776ce07cd\n--- /dev/null\n+++ b/test_cycle_order.py\n@@ -0,0 +1,38 @@\n+#!/usr/bin/env python\n+\"\"\"Test cycle composition order\"\"\"\n+\n+from sympy.combinatorics.permutations import Cycle\n+\n+print(\"Testing cycle composition order...\")\n+\n+# Manual step-by-step\n+print(\"\\nManual composition of (0 1) then (0 2):\")\n+print(\"Start with identity: [0, 1, 2]\")\n+\n+# Apply (0 1)\n+c1 = Cycle(0, 1)\n+print(f\"After (0 1): {c1.list()}\")\n+\n+# Apply (0 2) to the result\n+c2 = c1(0, 2)\n+print(f\"After (0 2): {c2.list()}\")\n+\n+# Direct composition\n+print(\"\\nDirect composition:\")\n+c3 = Cycle()(0, 1)(0, 2)\n+print(f\"Cycle()(0, 1)(0, 2): {c3.list()}\")\n+\n+# Let's understand the composition\n+print(\"\\nDetailed analysis:\")\n+print(\"In cycle notation, composition is right-to-left for functions\")\n+print(\"But Cycle class applies them left-to-right as transformations\")\n+print()\n+\n+# Let's trace what happens to each element\n+print(\"Tracing elements through (0 1) then (0 2):\")\n+for i in range(3):\n+    # Where does i go after (0 1)?\n+    temp = c1[i]\n+    # Where does that go after (0 2)?\n+    final = Cycle(0, 2)[temp]\n+    print(f\"{i} -> {temp} -> {final}\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..6c6c0e1342\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,28 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to verify the issue with non-disjoint cycles\"\"\"\n+\n+from sympy.combinatorics.permutations import Permutation, Cycle\n+\n+print(\"Testing the reported issue...\")\n+try:\n+    # This should create the identity permutation\n+    p = Permutation([[0, 1], [0, 1]])\n+    print(\"Success! Created permutation:\", p)\n+except ValueError as e:\n+    print(\"Error:\", e)\n+    \n+print(\"\\nTesting how Cycle handles non-disjoint cycles...\")\n+# Test how individual cycles work\n+c1 = Cycle(0, 1)\n+print(\"c1 = Cycle(0, 1):\", c1)\n+print(\"c1.list():\", c1.list())\n+\n+# Test composition\n+c2 = Cycle()(0, 1)(0, 1)\n+print(\"\\nc2 = Cycle()(0, 1)(0, 1):\", c2)\n+print(\"c2.list():\", c2.list())\n+\n+# This should give identity\n+print(\"\\nComposing (0 1) with (0 1) should give identity...\")\n+print(\"Expected: [0, 1] (identity)\")\n+print(\"Actual:\", c2.list())\n", "gold_standard_diff": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a47822..4ac1c2ef3b48 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -895,12 +895,8 @@ def __new__(cls, *args, **kwargs):\n         # counting starts from 1.\n \n         temp = flatten(args)\n-        if has_dups(temp):\n-            if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n-            else:\n-                raise ValueError('there were repeated elements.')\n+        if has_dups(temp) and not is_cycle:\n+            raise ValueError('there were repeated elements.')\n         temp = set(temp)\n \n         if not is_cycle and \\\ndiff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 7f8cd572e749..968f046f8fb2 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -339,6 +339,7 @@ def test_args():\n     assert Permutation([[1], [4, 2]], size=1) == Permutation([0, 1, 4, 3, 2])\n     assert Permutation(\n         [[1], [4, 2]], size=6) == Permutation([0, 1, 4, 3, 2, 5])\n+    assert Permutation([[0, 1], [0, 2]]) == Permutation(0, 1, 2)\n     assert Permutation([], size=3) == Permutation([0, 1, 2])\n     assert Permutation(3).list(5) == [0, 1, 2, 3, 4]\n     assert Permutation(3).list(-1) == []\n@@ -349,7 +350,6 @@ def test_args():\n     raises(ValueError, lambda: Permutation([[1, 2], 0]))\n            # enclosing brackets needed on 0\n     raises(ValueError, lambda: Permutation([1, 1, 0]))\n-    raises(ValueError, lambda: Permutation([[1], [1, 2]]))\n     raises(ValueError, lambda: Permutation([4, 5], size=10))  # where are 0-3?\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/12481"}