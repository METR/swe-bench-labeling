{"instance_id": "django__django-12754", "score": "C", "diff": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 30616c0172..d80ddab0ae 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -563,6 +563,16 @@ class MigrationAutodetector:\n                 if isinstance(base, str) and \".\" in base:\n                     base_app_label, base_name = base.split(\".\", 1)\n                     dependencies.append((base_app_label, base_name, None, True))\n+                    # Check for field removals from parent models that would clash\n+                    # with this model's fields. If a field is being removed from a parent\n+                    # and exists in the child, we need to depend on that removal.\n+                    for field_name in model_state.fields:\n+                        removal_key = (base_app_label, base_name.lower(), field_name)\n+                        if (removal_key in self.old_field_keys and\n+                            removal_key not in self.new_field_keys):\n+                            # This field is being removed from the parent model\n+                            # Add a dependency on the field removal\n+                            dependencies.append((base_app_label, base_name.lower(), field_name, False))\n             # Depend on the other end of the primary key if it's a relation\n             if primary_key_rel:\n                 dependencies.append((\ndiff --git a/test_field_migration_comprehensive.py b/test_field_migration_comprehensive.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_field_migration_issue.py b/test_field_migration_issue.py\nnew file mode 100644\nindex 0000000000..0d54293ffa\n--- /dev/null\n+++ b/test_field_migration_issue.py\n@@ -0,0 +1,72 @@\n+\"\"\"Test script to reproduce the field migration issue when moving field to subclass\"\"\"\n+import os\n+import sys\n+import django\n+from django.db import models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.migration import Migration\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    SECRET_KEY='test-secret-key',\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}}\n+)\n+django.setup()\n+\n+# Define the old state with Readable having a title field\n+old_state = ProjectState()\n+old_state.add_model(ModelState(\n+    'testapp', \n+    'Readable',\n+    [('id', models.AutoField(primary_key=True)),\n+     ('title', models.CharField(max_length=200))],\n+    {},\n+    ()\n+))\n+\n+# Define the new state with Book inheriting from Readable and having the title field\n+new_state = ProjectState()\n+new_state.add_model(ModelState(\n+    'testapp', \n+    'Readable',\n+    [('id', models.AutoField(primary_key=True))],\n+    {},\n+    ()\n+))\n+new_state.add_model(ModelState(\n+    'testapp',\n+    'Book',\n+    [('readable_ptr', models.OneToOneField(\n+        auto_created=True,\n+        on_delete=models.CASCADE,\n+        parent_link=True,\n+        primary_key=True,\n+        serialize=False,\n+        to='testapp.Readable'\n+     )),\n+     ('title', models.CharField(max_length=200))],\n+    {},\n+    ('testapp.Readable',)\n+))\n+\n+# Create autodetector and generate migrations\n+autodetector = MigrationAutodetector(old_state, new_state)\n+changes = autodetector._detect_changes()\n+\n+# Print the generated operations\n+print(\"Generated operations:\")\n+for app_label, migrations in autodetector.migrations.items():\n+    print(f\"\\nApp: {app_label}\")\n+    for migration in migrations:\n+        print(f\"  Migration: {migration.name}\")\n+        for operation in migration.operations:\n+            print(f\"    - {operation.__class__.__name__}\")\n+            if hasattr(operation, 'name'):\n+                print(f\"      name: {operation.name}\")\n+            if hasattr(operation, 'model_name'):  \n+                print(f\"      model_name: {operation.model_name}\")\n+            if hasattr(operation, 'field') and hasattr(operation, 'name'):\n+                print(f\"      field_name: {operation.name}\")\n", "gold_standard_diff": "diff --git a/django/db/migrations/autodetector.py b/django/db/migrations/autodetector.py\nindex 30616c0172bc..85c301389757 100644\n--- a/django/db/migrations/autodetector.py\n+++ b/django/db/migrations/autodetector.py\n@@ -563,6 +563,16 @@ def generate_created_models(self):\n                 if isinstance(base, str) and \".\" in base:\n                     base_app_label, base_name = base.split(\".\", 1)\n                     dependencies.append((base_app_label, base_name, None, True))\n+                    # Depend on the removal of base fields if the new model has\n+                    # a field with the same name.\n+                    old_base_model_state = self.from_state.models.get((base_app_label, base_name))\n+                    new_base_model_state = self.to_state.models.get((base_app_label, base_name))\n+                    if old_base_model_state and new_base_model_state:\n+                        removed_base_fields = set(old_base_model_state.fields).difference(\n+                            new_base_model_state.fields,\n+                        ).intersection(model_state.fields)\n+                        for removed_base_field in removed_base_fields:\n+                            dependencies.append((base_app_label, base_name, removed_base_field, False))\n             # Depend on the other end of the primary key if it's a relation\n             if primary_key_rel:\n                 dependencies.append((\ndiff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex daff57fc2cfa..10af72561b44 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2454,3 +2454,28 @@ def test_mti_inheritance_model_removal(self):\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n         self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+\n+    def test_add_model_with_field_removed_from_base_model(self):\n+        \"\"\"\n+        Removing a base field takes place before adding a new inherited model\n+        that has a field with the same name.\n+        \"\"\"\n+        before = [\n+            ModelState('app', 'readable', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('title', models.CharField(max_length=200)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'readable', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('app', 'book', [\n+                ('title', models.CharField(max_length=200)),\n+            ], bases=('app.readable',)),\n+        ]\n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RemoveField', 'CreateModel'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='title', model_name='readable')\n+        self.assertOperationAttributes(changes, 'app', 0, 1, name='book')\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12754"}