{"instance_id": "pytest-dev__pytest-7571", "score": "C", "diff": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 11031f2f2..1b4d9d385 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -346,6 +346,7 @@ class LogCaptureFixture:\n         self._item = item\n         # dict of log name -> log level\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n+        self._initial_handler_level = None  # type: Optional[int]\n \n     def _finalize(self) -> None:\n         \"\"\"Finalizes the fixture.\n@@ -356,6 +357,9 @@ class LogCaptureFixture:\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n+        # restore handler level\n+        if self._initial_handler_level is not None:\n+            self.handler.setLevel(self._initial_handler_level)\n \n     @property\n     def handler(self) -> LogCaptureHandler:\n@@ -434,6 +438,9 @@ class LogCaptureFixture:\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\n+        # save the original handler level to restore it during teardown\n+        if self._initial_handler_level is None:\n+            self._initial_handler_level = self.handler.level\n         self.handler.setLevel(level)\n \n     @contextmanager\ndiff --git a/test_caplog_comprehensive.py b/test_caplog_comprehensive.py\nnew file mode 100644\nindex 000000000..0331e5c8b\n--- /dev/null\n+++ b/test_caplog_comprehensive.py\n@@ -0,0 +1,48 @@\n+import logging\n+\n+def test_multiple_set_level_calls(caplog):\n+    \"\"\"Test that multiple set_level calls only save the initial handler level once\"\"\"\n+    print(f\"Initial handler level: {caplog.handler.level}\")\n+    \n+    # First set_level\n+    caplog.set_level(10)\n+    print(f\"After first set_level(10): {caplog.handler.level}\")\n+    \n+    # Second set_level \n+    caplog.set_level(20)\n+    print(f\"After second set_level(20): {caplog.handler.level}\")\n+    \n+    # Third set_level\n+    caplog.set_level(30)\n+    print(f\"After third set_level(30): {caplog.handler.level}\")\n+\n+def test_after_multiple_calls(caplog):\n+    \"\"\"Verify handler level is properly restored after multiple set_level calls\"\"\"\n+    print(f\"Handler level should be 0: {caplog.handler.level}\")\n+    assert caplog.handler.level == 0\n+\n+def test_with_logger_name(caplog):\n+    \"\"\"Test set_level with specific logger name\"\"\"\n+    logger_name = \"test.logger\"\n+    logger = logging.getLogger(logger_name)\n+    \n+    initial_handler_level = caplog.handler.level\n+    initial_logger_level = logger.level\n+    \n+    print(f\"Initial handler level: {initial_handler_level}\")\n+    print(f\"Initial logger '{logger_name}' level: {initial_logger_level}\")\n+    \n+    caplog.set_level(25, logger=logger_name)\n+    \n+    print(f\"After set_level(25, logger='{logger_name}')\")\n+    print(f\"  Handler level: {caplog.handler.level}\")\n+    print(f\"  Logger level: {logger.level}\")\n+\n+def test_after_logger_name(caplog):\n+    \"\"\"Verify levels are restored after test with specific logger\"\"\"\n+    logger_name = \"test.logger\"\n+    logger = logging.getLogger(logger_name)\n+    \n+    print(f\"Handler level should be 0: {caplog.handler.level}\")\n+    print(f\"Logger '{logger_name}' level: {logger.level}\")\n+    assert caplog.handler.level == 0\ndiff --git a/test_caplog_handler_level_regression.py b/test_caplog_handler_level_regression.py\nnew file mode 100644\nindex 000000000..19e60a358\n--- /dev/null\n+++ b/test_caplog_handler_level_regression.py\n@@ -0,0 +1,14 @@\n+\"\"\"\n+Regression test for the caplog fixture handler level restoration bug.\n+From GitHub issue: caplog fixture doesn't restore log level after test\n+\"\"\"\n+\n+def test_foo(caplog):\n+    \"\"\"First test that sets a custom handler level\"\"\"\n+    assert caplog.handler.level == 0  # Should start at 0\n+    caplog.set_level(42)\n+    assert caplog.handler.level == 42  # Should be set to 42\n+\n+def test_bar(caplog):\n+    \"\"\"Second test that should see the handler level restored to 0\"\"\"\n+    assert caplog.handler.level == 0  # Should be restored to 0, not 42\ndiff --git a/test_caplog_issue.py b/test_caplog_issue.py\nnew file mode 100644\nindex 000000000..655d56a56\n--- /dev/null\n+++ b/test_caplog_issue.py\n@@ -0,0 +1,7 @@\n+def test_foo(caplog):\n+    print(f\"test_foo: handler level before set_level: {caplog.handler.level}\")\n+    caplog.set_level(42)\n+    print(f\"test_foo: handler level after set_level: {caplog.handler.level}\")\n+\n+def test_bar(caplog):\n+    print(f\"test_bar: handler level at start: {caplog.handler.level}\")\n", "gold_standard_diff": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 11031f2f229..0ee9457ea72 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -345,6 +345,7 @@ def __init__(self, item: nodes.Node) -> None:\n         \"\"\"Creates a new funcarg.\"\"\"\n         self._item = item\n         # dict of log name -> log level\n+        self._initial_handler_level = None  # type: Optional[int]\n         self._initial_logger_levels = {}  # type: Dict[Optional[str], int]\n \n     def _finalize(self) -> None:\n@@ -353,6 +354,8 @@ def _finalize(self) -> None:\n         This restores the log levels changed by :meth:`set_level`.\n         \"\"\"\n         # restore log levels\n+        if self._initial_handler_level is not None:\n+            self.handler.setLevel(self._initial_handler_level)\n         for logger_name, level in self._initial_logger_levels.items():\n             logger = logging.getLogger(logger_name)\n             logger.setLevel(level)\n@@ -434,6 +437,7 @@ def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> Non\n         # save the original log-level to restore it during teardown\n         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n         logger_obj.setLevel(level)\n+        self._initial_handler_level = self.handler.level\n         self.handler.setLevel(level)\n \n     @contextmanager\ndiff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex da5303302b6..6e5e9c2b42a 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -2,6 +2,7 @@\n \n import pytest\n from _pytest.logging import caplog_records_key\n+from _pytest.pytester import Testdir\n \n logger = logging.getLogger(__name__)\n sublogger = logging.getLogger(__name__ + \".baz\")\n@@ -27,8 +28,11 @@ def test_change_level(caplog):\n     assert \"CRITICAL\" in caplog.text\n \n \n-def test_change_level_undo(testdir):\n-    \"\"\"Ensure that 'set_level' is undone after the end of the test\"\"\"\n+def test_change_level_undo(testdir: Testdir) -> None:\n+    \"\"\"Ensure that 'set_level' is undone after the end of the test.\n+\n+    Tests the logging output themselves (affacted both by logger and handler levels).\n+    \"\"\"\n     testdir.makepyfile(\n         \"\"\"\n         import logging\n@@ -50,6 +54,33 @@ def test2(caplog):\n     result.stdout.no_fnmatch_line(\"*log from test2*\")\n \n \n+def test_change_level_undos_handler_level(testdir: Testdir) -> None:\n+    \"\"\"Ensure that 'set_level' is undone after the end of the test (handler).\n+\n+    Issue #7569. Tests the handler level specifically.\n+    \"\"\"\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+\n+        def test1(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(41)\n+            assert caplog.handler.level == 41\n+\n+        def test2(caplog):\n+            assert caplog.handler.level == 0\n+\n+        def test3(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(43)\n+            assert caplog.handler.level == 43\n+    \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.assert_outcomes(passed=3)\n+\n+\n def test_with_statement(caplog):\n     with caplog.at_level(logging.INFO):\n         logger.debug(\"handler DEBUG level\")\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/7571"}