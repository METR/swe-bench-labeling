diff --git a/sympy/core/function.py b/sympy/core/function.py
index 1b8005e1d2..58e95ec105 100644
--- a/sympy/core/function.py
+++ b/sympy/core/function.py
@@ -507,7 +507,21 @@ def _eval_evalf(self, prec):
             func = getattr(mpmath, fname)
         except (AttributeError, KeyError):
             try:
-                return Float(self._imp_(*self.args), prec)
+                # Evaluate arguments first before passing to _imp_
+                evaled_args = []
+                for arg in self.args:
+                    evaled = arg.evalf(prec)
+                    # If evalf didn't change the arg (e.g., for symbolic expressions),
+                    # we can't evaluate numerically
+                    if evaled == arg:
+                        return None
+                    evaled_args.append(evaled)
+                
+                result = self._imp_(*evaled_args)
+                # Use sympify to handle both real and complex results
+                result_sym = sympify(result)
+                # Now evalf the sympified result to ensure proper precision
+                return result_sym.evalf(prec)
             except (AttributeError, TypeError, ValueError):
                 return
 
diff --git a/test_complex.py b/test_complex.py
new file mode 100644
index 0000000000..bec1f6e9f8
--- /dev/null
+++ b/test_complex.py
@@ -0,0 +1,24 @@
+from sympy.utilities.lambdify import implemented_function
+from sympy import Float, I
+import math
+
+# Test complex return values
+fc = implemented_function('fc', lambda x: x**2 + 1j*x)
+result = fc._imp_(2)
+print(f"fc._imp_(2) = {result}")
+print(f"type(result) = {type(result)}")
+
+# Let's try to understand how Float handles this
+try:
+    f = Float(result, 15)
+    print(f"Float(result, 15) = {f}")
+except Exception as e:
+    print(f"Error converting to Float: {e}")
+
+# Test with real result
+f_real = implemented_function('f_real', lambda x: x**2)
+result_real = f_real._imp_(2)
+print(f"\nf_real._imp_(2) = {result_real}")
+print(f"type(result_real) = {type(result_real)}")
+f = Float(result_real, 15)
+print(f"Float(result_real, 15) = {f}")
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..6f605bd165
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,55 @@
+from sympy.utilities.lambdify import implemented_function
+from sympy import Function, sin, cos, exp, log, sqrt, symbols, pi, I
+import math
+
+# Test 1: Original issue - nested implemented functions
+print("Test 1: Nested implemented functions")
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+print(f"f(g(2)).evalf() = {f(g(2)).evalf()}")  # Should be 16.0
+print(f"f(g(3)).evalf() = {f(g(3)).evalf()}")  # Should be 36.0
+
+# Test 2: Triple nesting
+print("\nTest 2: Triple nesting")
+h = implemented_function('h', lambda x: x + 1)
+print(f"f(g(h(1))).evalf() = {f(g(h(1))).evalf()}")  # h(1)=2, g(2)=4, f(4)=16
+
+# Test 3: Complex values
+print("\nTest 3: Complex values")
+fc = implemented_function('fc', lambda x: x**2 + 1j*x)
+print(f"fc(2).evalf() = {fc(2).evalf()}")  # Should be 4 + 2*I
+print(f"fc(g(1)).evalf() = {fc(g(1)).evalf()}")  # g(1)=2, fc(2)=4+2*I
+
+# Test 4: Symbolic arguments (should not evaluate)
+print("\nTest 4: Symbolic arguments")
+x = symbols('x')
+print(f"f(x) = {f(x)}")
+print(f"f(x).evalf() = {f(x).evalf()}")  # Should still be f(x)
+
+# Test 5: Mixed with built-in functions
+print("\nTest 5: Mixed with built-in functions")
+print(f"sin(1).evalf() = {sin(1).evalf()}")
+fs = implemented_function('fs', lambda x: math.sin(x))
+print(f"fs(1).evalf() = {fs(1).evalf()}")
+print(f"f(sin(1)).evalf() = {f(sin(1)).evalf()}")  # sin(1)^2
+
+# Test 6: Ensure regular mpmath functions still work
+print("\nTest 6: Regular functions")
+print(f"exp(1).evalf() = {exp(1).evalf()}")
+print(f"log(10).evalf() = {log(10).evalf()}")
+print(f"sqrt(2).evalf() = {sqrt(2).evalf()}")
+print(f"cos(pi).evalf() = {cos(pi).evalf()}")
+
+# Test 7: Error handling
+print("\nTest 7: Error handling")
+try:
+    bad_func = implemented_function('bad', lambda x: 1/0)
+    print(f"bad_func(1).evalf() = {bad_func(1).evalf()}")
+except:
+    print("Error caught as expected")
+
+# Test 8: Multiple arguments
+print("\nTest 8: Multiple arguments")
+f2 = implemented_function('f2', lambda x, y: x + y)
+print(f"f2(2, 3).evalf() = {f2(2, 3).evalf()}")  # Should be 5.0
+print(f"f2(g(1), h(2)).evalf() = {f2(g(1), h(2)).evalf()}")  # g(1)=2, h(2)=3, f2(2,3)=5
diff --git a/test_evalf_check.py b/test_evalf_check.py
new file mode 100644
index 0000000000..cb8dc999e8
--- /dev/null
+++ b/test_evalf_check.py
@@ -0,0 +1,15 @@
+from sympy import Integer, symbols
+
+# Check evalf behavior
+x = symbols('x')
+two = Integer(2)
+
+print(f"two = {two}")
+print(f"two.evalf() = {two.evalf()}")
+print(f"two == two.evalf() = {two == two.evalf()}")
+print(f"type(two) = {type(two)}")
+print(f"type(two.evalf()) = {type(two.evalf())}")
+
+print(f"\nx = {x}")
+print(f"x.evalf() = {x.evalf()}")
+print(f"x == x.evalf() = {x == x.evalf()}")
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..bf94f71b65
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,21 @@
+from sympy.utilities.lambdify import implemented_function
+from sympy import Function
+
+# Create the test case from the issue
+f = implemented_function('f', lambda x: x ** 2)
+g = implemented_function('g', lambda x: 2 * x)
+
+print("Testing individual functions:")
+print(f"f(2).evalf() = {f(2).evalf()}")  # Should print 4.00000000000000
+print(f"g(2).evalf() = {g(2).evalf()}")  # Should print 4.00000000000000
+
+print("\nTesting composition:")
+print(f"f(g(2)).evalf() = {f(g(2)).evalf()}")  # Currently prints f(g(2)), should print 16.00000000000000
+
+# Let's also test what g(2) evaluates to
+print(f"\ng(2) = {g(2)}")
+print(f"type(g(2)) = {type(g(2))}")
+
+# Test the _imp_ method directly
+print(f"\nf._imp_(4) = {f._imp_(4)}")  # Should be 16
+print(f"g._imp_(2) = {g._imp_(2)}")  # Should be 4
diff --git a/test_symbolic.py b/test_symbolic.py
new file mode 100644
index 0000000000..dd56b5262e
--- /dev/null
+++ b/test_symbolic.py
@@ -0,0 +1,27 @@
+from sympy import symbols, sin, exp
+from sympy.utilities.lambdify import implemented_function
+
+x = symbols('x')
+
+# Test regular functions with symbolic args
+print("Regular functions with symbolic args:")
+print(f"sin(x).evalf() = {sin(x).evalf()}")
+print(f"exp(x).evalf() = {exp(x).evalf()}")
+
+# Test implemented function with symbolic arg
+f = implemented_function('f', lambda x: x**2)
+print(f"\nImplemented function with symbolic arg:")
+print(f"f(x) = {f(x)}")
+print(f"f(x).evalf() = {f(x).evalf()}")
+
+# Test if _imp_ is being called with symbolic arg
+print(f"\nDirect _imp_ call with symbolic arg:")
+try:
+    result = f._imp_(x)
+    print(f"f._imp_(x) = {result}")
+except Exception as e:
+    print(f"Error: {e}")
+
+# Test evaluation with substitution
+print(f"\nWith substitution:")
+print(f"f(x).evalf(subs={{x: 2}}) = {f(x).evalf(subs={x: 2})}")
diff --git a/test_sympify_complex.py b/test_sympify_complex.py
new file mode 100644
index 0000000000..1b531f01dc
--- /dev/null
+++ b/test_sympify_complex.py
@@ -0,0 +1,19 @@
+from sympy import sympify, Float, I
+import math
+
+# Test how sympify handles complex numbers
+c = 4 + 2j
+print(f"c = {c}")
+print(f"type(c) = {type(c)}")
+
+s = sympify(c)
+print(f"\nsympify(c) = {s}")
+print(f"type(sympify(c)) = {type(s)}")
+
+# Now try evalf on it
+print(f"\nsympify(c).evalf() = {s.evalf()}")
+
+# Direct check
+from sympy import re, im
+print(f"\nre(s) = {re(s)}")
+print(f"im(s) = {im(s)}")
