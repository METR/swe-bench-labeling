{"instance_id": "pylint-dev__pylint-6903", "score": "C", "diff": "diff --git a/pylint/lint/run.py b/pylint/lint/run.py\nindex a7e5d5574..c23565b1a 100644\n--- a/pylint/lint/run.py\n+++ b/pylint/lint/run.py\n@@ -52,12 +52,12 @@ def _query_cpu() -> int | None:\n         with open(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\", encoding=\"utf-8\") as file:\n             cpu_period = int(file.read().rstrip())\n         # Divide quota by period and you should get num of allotted CPU to the container, rounded down if fractional.\n-        avail_cpu = int(cpu_quota / cpu_period)\n+        avail_cpu = int(cpu_quota / cpu_period) or 1\n     elif Path(\"/sys/fs/cgroup/cpu/cpu.shares\").is_file():\n         with open(\"/sys/fs/cgroup/cpu/cpu.shares\", encoding=\"utf-8\") as file:\n             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\n-        avail_cpu = int(cpu_shares / 1024)\n+        avail_cpu = int(cpu_shares / 1024) or 1\n     return avail_cpu\n \n \n@@ -76,8 +76,8 @@ def _cpu_count() -> int:\n     else:\n         cpu_count = 1\n     if cpu_share is not None:\n-        return min(cpu_share, cpu_count)\n-    return cpu_count\n+        return max(1, min(cpu_share, cpu_count))\n+    return max(1, cpu_count)\n \n \n UNUSED_PARAM_SENTINEL = object()\ndiff --git a/tests/lint/test_run_cpu_count.py b/tests/lint/test_run_cpu_count.py\nnew file mode 100644\nindex 000000000..458f74e99\n--- /dev/null\n+++ b/tests/lint/test_run_cpu_count.py\n@@ -0,0 +1,109 @@\n+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n+# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n+# Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n+\n+\"\"\"Tests for CPU count detection in containerized environments.\"\"\"\n+\n+from pathlib import Path\n+from unittest.mock import mock_open, patch\n+\n+import pytest\n+\n+from pylint.lint.run import _cpu_count, _query_cpu\n+\n+\n+class TestCPUCount:\n+    \"\"\"Test CPU count detection.\"\"\"\n+\n+    def test_query_cpu_kubernetes_low_shares(self):\n+        \"\"\"Test that _query_cpu returns at least 1 when cpu.shares is very low (Kubernetes case).\"\"\"\n+        mock_files = {\n+            \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\": \"-1\",\n+            \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\": \"100000\",\n+            \"/sys/fs/cgroup/cpu/cpu.shares\": \"2\",\n+        }\n+\n+        def mock_path_is_file(self):\n+            return str(self) in mock_files\n+\n+        def mock_open_file(filename, *args, **kwargs):\n+            if filename in mock_files:\n+                return mock_open(read_data=mock_files[filename])()\n+            raise FileNotFoundError(filename)\n+\n+        with patch.object(Path, \"is_file\", mock_path_is_file):\n+            with patch(\"builtins.open\", mock_open_file):\n+                result = _query_cpu()\n+                # Should return 1 instead of 0 (2/1024 = 0.00195 -> int() = 0 -> fixed to 1)\n+                assert result == 1\n+\n+    def test_query_cpu_low_quota_period_ratio(self):\n+        \"\"\"Test that _query_cpu returns at least 1 when quota/period ratio is less than 1.\"\"\"\n+        mock_files = {\n+            \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\": \"50000\",\n+            \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\": \"100000\",\n+            \"/sys/fs/cgroup/cpu/cpu.shares\": \"1024\",\n+        }\n+\n+        def mock_path_is_file(self):\n+            return str(self) in mock_files\n+\n+        def mock_open_file(filename, *args, **kwargs):\n+            if filename in mock_files:\n+                return mock_open(read_data=mock_files[filename])()\n+            raise FileNotFoundError(filename)\n+\n+        with patch.object(Path, \"is_file\", mock_path_is_file):\n+            with patch(\"builtins.open\", mock_open_file):\n+                result = _query_cpu()\n+                # Should return 1 instead of 0 (50000/100000 = 0.5 -> int() = 0 -> fixed to 1)\n+                assert result == 1\n+\n+    def test_cpu_count_never_returns_zero(self):\n+        \"\"\"Test that _cpu_count never returns 0, even when _query_cpu would return 0.\"\"\"\n+        # Mock a scenario where both _query_cpu would return None and cpu_count would be 0\n+        with patch(\"pylint.lint.run._query_cpu\", return_value=None):\n+            # Remove sched_getaffinity from os module\n+            with patch(\"os.sched_getaffinity\", new=None):\n+                with patch(\"pylint.lint.run.multiprocessing\") as mock_mp:\n+                    mock_mp.cpu_count.return_value = 0\n+                    result = _cpu_count()\n+                    # Should return 1 as a fallback\n+                    assert result == 1\n+\n+    def test_cpu_count_respects_query_cpu_minimum(self):\n+        \"\"\"Test that _cpu_count returns at least 1 even when query_cpu returns 0.\"\"\"\n+        # This shouldn't happen with our fix, but let's ensure the safety net works\n+        with patch(\"pylint.lint.run._query_cpu\", return_value=0):\n+            with patch(\"os.sched_getaffinity\", return_value={0, 1}):  # 2 CPUs\n+                result = _cpu_count()\n+                # Should return 1 (max(1, min(0, 2)) = 1)\n+                assert result == 1\n+\n+    def test_normal_cpu_shares(self):\n+        \"\"\"Test normal cpu.shares values work as expected.\"\"\"\n+        test_cases = [\n+            (1024, 1),   # 1024 shares = 1 CPU\n+            (2048, 2),   # 2048 shares = 2 CPUs\n+            (4096, 4),   # 4096 shares = 4 CPUs\n+        ]\n+\n+        for shares, expected in test_cases:\n+            mock_files = {\n+                \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\": \"-1\",\n+                \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\": \"100000\",\n+                \"/sys/fs/cgroup/cpu/cpu.shares\": str(shares),\n+            }\n+\n+            def mock_path_is_file(self):\n+                return str(self) in mock_files\n+\n+            def mock_open_file(filename, *args, **kwargs):\n+                if filename in mock_files:\n+                    return mock_open(read_data=mock_files[filename])()\n+                raise FileNotFoundError(filename)\n+\n+            with patch.object(Path, \"is_file\", mock_path_is_file):\n+                with patch(\"builtins.open\", mock_open_file):\n+                    result = _query_cpu()\n+                    assert result == expected\n", "gold_standard_diff": "diff --git a/doc/whatsnew/2/2.14/full.rst b/doc/whatsnew/2/2.14/full.rst\nindex d39bc4b828..97cc20d252 100644\n--- a/doc/whatsnew/2/2.14/full.rst\n+++ b/doc/whatsnew/2/2.14/full.rst\n@@ -5,6 +5,11 @@ What's New in Pylint 2.14.2?\n ----------------------------\n Release date: TBA\n \n+* Don't crash if ``lint.run._query_cpu()`` is run within a Kubernetes Pod, that has only\n+  a fraction of a cpu core assigned. Just go with one process then.\n+\n+  Closes #6902\n+\n * Fixed a false positive in ``consider-using-f-string`` if the left side of a ``%`` is not a string.\n \n   Closes #6689\ndiff --git a/pylint/lint/run.py b/pylint/lint/run.py\nindex a7e5d55744..27a4d9d84d 100644\n--- a/pylint/lint/run.py\n+++ b/pylint/lint/run.py\n@@ -58,6 +58,13 @@ def _query_cpu() -> int | None:\n             cpu_shares = int(file.read().rstrip())\n         # For AWS, gives correct value * 1024.\n         avail_cpu = int(cpu_shares / 1024)\n+\n+    # In K8s Pods also a fraction of a single core could be available\n+    # As multiprocessing is not able to run only a \"fraction\" of process\n+    # assume we have 1 CPU available\n+    if avail_cpu == 0:\n+        avail_cpu = 1\n+\n     return avail_cpu\n \n \ndiff --git a/tests/test_pylint_runners.py b/tests/test_pylint_runners.py\nindex b06046e225..9764ddbfdd 100644\n--- a/tests/test_pylint_runners.py\n+++ b/tests/test_pylint_runners.py\n@@ -6,14 +6,17 @@\n from __future__ import annotations\n \n import os\n+import pathlib\n import sys\n from collections.abc import Callable\n-from unittest.mock import patch\n+from unittest.mock import MagicMock, mock_open, patch\n \n import pytest\n from py._path.local import LocalPath  # type: ignore[import]\n \n from pylint import run_epylint, run_pylint, run_pyreverse, run_symilar\n+from pylint.lint import Run\n+from pylint.testutils import GenericTestReporter as Reporter\n \n \n @pytest.mark.parametrize(\n@@ -40,3 +43,35 @@ def test_runner_with_arguments(runner: Callable, tmpdir: LocalPath) -> None:\n         with pytest.raises(SystemExit) as err:\n             runner(testargs)\n         assert err.value.code == 0\n+\n+\n+def test_pylint_run_jobs_equal_zero_dont_crash_with_cpu_fraction(\n+    tmpdir: LocalPath,\n+) -> None:\n+    \"\"\"Check that the pylint runner does not crash if `pylint.lint.run._query_cpu`\n+    determines only a fraction of a CPU core to be available.\n+    \"\"\"\n+    builtin_open = open\n+\n+    def _mock_open(*args, **kwargs):\n+        if args[0] == \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\":\n+            return mock_open(read_data=b\"-1\")(*args, **kwargs)\n+        if args[0] == \"/sys/fs/cgroup/cpu/cpu.shares\":\n+            return mock_open(read_data=b\"2\")(*args, **kwargs)\n+        return builtin_open(*args, **kwargs)\n+\n+    pathlib_path = pathlib.Path\n+\n+    def _mock_path(*args, **kwargs):\n+        if args[0] == \"/sys/fs/cgroup/cpu/cpu.shares\":\n+            return MagicMock(is_file=lambda: True)\n+        return pathlib_path(*args, **kwargs)\n+\n+    filepath = os.path.abspath(__file__)\n+    testargs = [filepath, \"--jobs=0\"]\n+    with tmpdir.as_cwd():\n+        with pytest.raises(SystemExit) as err:\n+            with patch(\"builtins.open\", _mock_open):\n+                with patch(\"pylint.lint.run.Path\", _mock_path):\n+                    Run(testargs, reporter=Reporter())\n+        assert err.value.code == 0\n", "gold_standard_pr_link": "https://github.com/pylint-dev/pylint/pull/6903"}