diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py
index 4d8ddf3ee5..695a3dc123 100644
--- a/lib/matplotlib/dates.py
+++ b/lib/matplotlib/dates.py
@@ -769,194 +769,6 @@ class ConciseDateFormatter(ticker.Formatter):
         self._usetex = (usetex if usetex is not None else
                         mpl.rcParams['text.usetex'])
 
-    def __call__(self, x, pos=None):
-        formatter = DateFormatter(self.defaultfmt, self._tz,
-                                  usetex=self._usetex)
-        return formatter(x, pos=pos)
-
-    def format_ticks(self, values):
-        tickdatetime = [num2date(value, tz=self._tz) for value in values]
-        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])
-
-        # basic algorithm:
-        # 1) only display a part of the date if it changes over the ticks.
-        # 2) don't display the smaller part of the date if:
-        #    it is always the same or if it is the start of the
-        #    year, month, day etc.
-        # fmt for most ticks at this level
-        fmts = self.formats
-        # format beginnings of days, months, years, etc.
-        zerofmts = self.zero_formats
-        # offset fmt are for the offset in the upper left of the
-        # or lower right of the axis.
-        offsetfmts = self.offset_formats
-        show_offset = self.show_offset
-
-        # determine the level we will label at:
-        # mostly 0: years,  1: months,  2: days,
-        # 3: hours, 4: minutes, 5: seconds, 6: microseconds
-        for level in range(5, -1, -1):
-            if len(np.unique(tickdate[:, level])) > 1:
-                if level < 2:
-                    show_offset = False
-                break
-            elif level == 0:
-                # all tickdate are the same, so only micros might be different
-                # set to the most precise (6: microseconds doesn't exist...)
-                level = 5
-
-        # level is the basic level we will label at.
-        # now loop through and decide the actual ticklabels
-        zerovals = [0, 1, 1, 0, 0, 0, 0]
-        labels = [''] * len(tickdate)
-        for nn in range(len(tickdate)):
-            if level < 5:
-                if tickdate[nn][level] == zerovals[level]:
-                    fmt = zerofmts[level]
-                else:
-                    fmt = fmts[level]
-            else:
-                # special handling for seconds + microseconds
-                if (tickdatetime[nn].second == tickdatetime[nn].microsecond
-                        == 0):
-                    fmt = zerofmts[level]
-                else:
-                    fmt = fmts[level]
-            labels[nn] = tickdatetime[nn].strftime(fmt)
-
-        # special handling of seconds and microseconds:
-        # strip extra zeros and decimal if possible.
-        # this is complicated by two factors.  1) we have some level-4 strings
-        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the
-        # same number of decimals for each string (i.e. 0.5 and 1.0).
-        if level >= 5:
-            trailing_zeros = min(
-                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),
-                default=None)
-            if trailing_zeros:
-                for nn in range(len(labels)):
-                    if '.' in labels[nn]:
-                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')
-
-        if show_offset:
-            # set the offset string:
-            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])
-            if self._usetex:
-                self.offset_string = _wrap_in_tex(self.offset_string)
-        else:
-            self.offset_string = ''
-
-        if self._usetex:
-            return [_wrap_in_tex(l) for l in labels]
-        else:
-            return labels
-
-    def get_offset(self):
-        return self.offset_string
-
-    def format_data_short(self, value):
-        return num2date(value, tz=self._tz).strftime('%Y-%m-%d %H:%M:%S')
-
-
-class AutoDateFormatter(ticker.Formatter):
-    """
-    A `.Formatter` which attempts to figure out the best format to use.  This
-    is most useful when used with the `AutoDateLocator`.
-
-    `.AutoDateFormatter` has a ``.scale`` dictionary that maps tick scales (the
-    interval in days between one major tick) to format strings; this dictionary
-    defaults to ::
-
-        self.scaled = {
-            DAYS_PER_YEAR: rcParams['date.autoformat.year'],
-            DAYS_PER_MONTH: rcParams['date.autoformat.month'],
-            1: rcParams['date.autoformat.day'],
-            1 / HOURS_PER_DAY: rcParams['date.autoformat.hour'],
-            1 / MINUTES_PER_DAY: rcParams['date.autoformat.minute'],
-            1 / SEC_PER_DAY: rcParams['date.autoformat.second'],
-            1 / MUSECONDS_PER_DAY: rcParams['date.autoformat.microsecond'],
-        }
-
-    The formatter uses the format string corresponding to the lowest key in
-    the dictionary that is greater or equal to the current scale.  Dictionary
-    entries can be customized::
-
-        locator = AutoDateLocator()
-        formatter = AutoDateFormatter(locator)
-        formatter.scaled[1/(24*60)] = '%M:%S' # only show min and sec
-
-    Custom callables can also be used instead of format strings.  The following
-    example shows how to use a custom format function to strip trailing zeros
-    from decimal seconds and adds the date to the first ticklabel::
-
-        def my_format_function(x, pos=None):
-            x = matplotlib.dates.num2date(x)
-            if pos == 0:
-                fmt = '%D %H:%M:%S.%f'
-            else:
-                fmt = '%H:%M:%S.%f'
-            label = x.strftime(fmt)
-            label = label.rstrip("0")
-            label = label.rstrip(".")
-            return label
-
-        formatter.scaled[1/(24*60)] = my_format_function
-    """
-
-    # This can be improved by providing some user-level direction on
-    # how to choose the best format (precedence, etc.).
-
-    # Perhaps a 'struct' that has a field for each time-type where a
-    # zero would indicate "don't show" and a number would indicate
-    # "show" with some sort of priority.  Same priorities could mean
-    # show all with the same priority.
-
-    # Or more simply, perhaps just a format string for each
-    # possibility...
-
-    def __init__(self, locator, tz=None, defaultfmt='%Y-%m-%d', *,
-                 usetex=None):
-        """
-        Autoformat the date labels.
-
-        Parameters
-        ----------
-        locator : `.ticker.Locator`
-            Locator that this axis is using.
-
-        tz : str or `~datetime.tzinfo`, optional
-            Passed to `.dates.num2date`.
-
-        defaultfmt : str
-            The default format to use if none of the values in ``self.scaled``
-            are greater than the unit returned by ``locator._get_unit()``.
-
-        usetex : bool, default: :rc:`text.usetex`
-            To enable/disable the use of TeX's math mode for rendering the
-            results of the formatter. If any entries in ``self.scaled`` are set
-            as functions, then it is up to the customized function to enable or
-            disable TeX's math mode itself.
-        """
-        self._locator = locator
-        self._tz = tz
-        self.defaultfmt = defaultfmt
-        self._formatter = DateFormatter(self.defaultfmt, tz)
-        rcParams = mpl.rcParams
-        self._usetex = (usetex if usetex is not None else
-                        mpl.rcParams['text.usetex'])
-        self.scaled = {
-            DAYS_PER_YEAR: rcParams['date.autoformatter.year'],
-            DAYS_PER_MONTH: rcParams['date.autoformatter.month'],
-            1: rcParams['date.autoformatter.day'],
-            1 / HOURS_PER_DAY: rcParams['date.autoformatter.hour'],
-            1 / MINUTES_PER_DAY: rcParams['date.autoformatter.minute'],
-            1 / SEC_PER_DAY: rcParams['date.autoformatter.second'],
-            1 / MUSECONDS_PER_DAY: rcParams['date.autoformatter.microsecond']
-        }
-
-    def _set_locator(self, locator):
-        self._locator = locator
-
     def __call__(self, x, pos=None):
         try:
             locator_unit_scale = float(self._locator._get_unit())
@@ -966,6 +778,13 @@ class AutoDateFormatter(ticker.Formatter):
         fmt = next((fmt for scale, fmt in sorted(self.scaled.items())
                     if scale >= locator_unit_scale),
                    self.defaultfmt)
+        
+        # Check if the date range is less than 12 months
+        dmin, dmax = self.axis.get_data_interval()
+        if dmax - dmin < 365 * 24 * 60 * 60:  # Less than a year in seconds
+            # Ensure the year is included in the format string
+            if "%Y" not in fmt:
+                fmt = "%Y\n" + fmt
 
         if isinstance(fmt, str):
             self._formatter = DateFormatter(fmt, self._tz, usetex=self._usetex)
