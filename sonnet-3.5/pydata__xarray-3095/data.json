{"instance_id": "pydata__xarray-3095", "score": "I", "diff": "diff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex b00dad96..b6b2e33d 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -933,8 +933,12 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n         pandas.DataFrame.copy\n         \"\"\"  # noqa\n         if data is None:\n-            variables = OrderedDict((k, v.copy(deep=deep))\n-                                    for k, v in self._variables.items())\n+            variables = OrderedDict()\n+            for k, v in self._variables.items():\n+                if isinstance(v, IndexVariable):\n+                    variables[k] = IndexVariable(v.dims, v.values, v.attrs, v.encoding)\n+                else:\n+                    variables[k] = v.copy(deep=deep)\n         elif not utils.is_dict_like(data):\n             raise ValueError('Data must be dict-like')\n         else:\n@@ -952,8 +956,12 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n                     'Data must contain all variables in original '\n                     'dataset. Data is missing {}'\n                     .format(keys_missing_from_data))\n-            variables = OrderedDict((k, v.copy(deep=deep, data=data.get(k)))\n-                                    for k, v in self._variables.items())\n+            variables = OrderedDict()\n+            for k, v in self._variables.items():\n+                if isinstance(v, IndexVariable):\n+                    variables[k] = IndexVariable(v.dims, data.get(k, v.values), v.attrs, v.encoding)\n+                else:\n+                    variables[k] = v.copy(deep=deep, data=data.get(k))\n \n         attrs = copy.deepcopy(self._attrs) if deep else copy.copy(self._attrs)\n \n", "gold_standard_diff": "From 262581f1c2e79b4a9cfb09b3e640472be1e1d80c Mon Sep 17 00:00:00 2001\nFrom: Guido Imperiale <guido.imperiale@amphorainc.com>\nDate: Thu, 11 Jul 2019 14:13:19 +0100\nSubject: [PATCH 1/5] Fix regression: IndexVariable.copy(deep=True) casts\n dtype=U to object\n\n---\n xarray/core/indexing.py       | 49 ++++++++++++++++++++++++++++-------\n xarray/core/variable.py       |  9 +------\n xarray/tests/test_variable.py |  5 ++--\n 3 files changed, 44 insertions(+), 19 deletions(-)\n\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 02953b74fa4..01b24a72fa4 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -3,12 +3,13 @@\n from collections import defaultdict\n from contextlib import suppress\n from datetime import timedelta\n-from typing import Sequence\n+from typing import Any, Tuple, Sequence, Union\n \n import numpy as np\n import pandas as pd\n \n from . import duck_array_ops, nputils, utils\n+from .npcompat import DTypeLike\n from .pycompat import dask_array_type, integer_types\n from .utils import is_dict_like\n \n@@ -1219,9 +1220,10 @@ def transpose(self, order):\n \n \n class PandasIndexAdapter(ExplicitlyIndexedNDArrayMixin):\n-    \"\"\"Wrap a pandas.Index to preserve dtypes and handle explicit indexing.\"\"\"\n+    \"\"\"Wrap a pandas.Index to preserve dtypes and handle explicit indexing.\n+    \"\"\"\n \n-    def __init__(self, array, dtype=None):\n+    def __init__(self, array: Any, dtype: DTypeLike = None):\n         self.array = utils.safe_cast_to_index(array)\n         if dtype is None:\n             if isinstance(array, pd.PeriodIndex):\n@@ -1233,13 +1235,15 @@ def __init__(self, array, dtype=None):\n                 dtype = np.dtype('O')\n             else:\n                 dtype = array.dtype\n+        else:\n+            dtype = np.dtype(dtype)\n         self._dtype = dtype\n \n     @property\n-    def dtype(self):\n+    def dtype(self) -> np.dtype:\n         return self._dtype\n \n-    def __array__(self, dtype=None):\n+    def __array__(self, dtype: DTypeLike = None) -> np.ndarray:\n         if dtype is None:\n             dtype = self.dtype\n         array = self.array\n@@ -1250,11 +1254,18 @@ def __array__(self, dtype=None):\n         return np.asarray(array.values, dtype=dtype)\n \n     @property\n-    def shape(self):\n+    def shape(self) -> Tuple[int]:\n         # .shape is broken on pandas prior to v0.15.2\n         return (len(self.array),)\n \n-    def __getitem__(self, indexer):\n+    def __getitem__(\n+            self, indexer\n+    ) -> Union[\n+        NumpyIndexingAdapter,\n+        np.ndarray,\n+        np.datetime64,\n+        np.timedelta64,\n+    ]:\n         key = indexer.tuple\n         if isinstance(key, tuple) and len(key) == 1:\n             # unpack key so it can index a pandas.Index object (pandas.Index\n@@ -1291,9 +1302,29 @@ def __getitem__(self, indexer):\n \n         return result\n \n-    def transpose(self, order):\n+    def transpose(self, order) -> pd.Index:\n         return self.array  # self.array should be always one-dimensional\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return ('%s(array=%r, dtype=%r)'\n                 % (type(self).__name__, self.array, self.dtype))\n+\n+    def copy(self, deep: bool = True) -> 'PandasIndexAdapter':\n+        obj = object.__new__(PandasIndexAdapter)\n+        # Not the same as just writing `self.array.copy(deep=deep)`, as\n+        # shallow copies of the underlying numpy.ndarrays become deep ones\n+        # upon pickling\n+        if deep:\n+            obj.array = self.array.copy(deep=True)\n+        else:\n+            obj.array = self.array\n+        obj._dtype = self._dtype\n+        return obj\n+\n+    def __copy__(self) -> 'PandasIndexAdapter':\n+        return self.copy(deep=False)\n+\n+    def __deepcopy__(self, memo=None) -> 'PandasIndexAdapter':\n+        # memo does nothing but is required for compatibility with\n+        # copy.deepcopy\n+        return self.copy(deep=True)\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 379be8f5db2..5c6a3ad0f30 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1942,14 +1942,7 @@ def copy(self, deep=True, data=None):\n             data copied from original.\n         \"\"\"\n         if data is None:\n-            if deep:\n-                # self._data should be a `PandasIndexAdapter` instance at this\n-                # point, which doesn't have a copy method, so make a deep copy\n-                # of the underlying `pandas.MultiIndex` and create a new\n-                # `PandasIndexAdapter` instance with it.\n-                data = PandasIndexAdapter(self._data.array.copy(deep=True))\n-            else:\n-                data = self._data\n+            data = self._data.copy(deep=deep)\n         else:\n             data = as_compatible_data(data)\n             if self.shape != data.shape:\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex 73d2a40b650..3978d1c43c3 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -477,8 +477,9 @@ def test_concat_mixed_dtypes(self):\n         assert actual.dtype == object\n \n     @pytest.mark.parametrize('deep', [True, False])\n-    def test_copy(self, deep):\n-        v = self.cls('x', 0.5 * np.arange(10), {'foo': 'bar'})\n+    @pytest.mark.parametrize('astype', [float, int, str])\n+    def test_copy(self, deep, astype):\n+        v = self.cls('x', (0.5 * np.arange(10)).astype(astype), {'foo': 'bar'})\n         w = v.copy(deep=deep)\n         assert type(v) is type(w)\n         assert_identical(v, w)\n\nFrom ab6960f623017afdc99c34bcbb69b402aea3f7d4 Mon Sep 17 00:00:00 2001\nFrom: Guido Imperiale <guido.imperiale@amphorainc.com>\nDate: Thu, 11 Jul 2019 14:15:51 +0100\nSubject: [PATCH 2/5] What's New\n\n---\n doc/whats-new.rst | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex a1b3e5416ca..8c0d25e9aae 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -26,6 +26,10 @@ Enhancements\n \n Bug fixes\n ~~~~~~~~~\n+- Fix regression introduced in v0.12.2 where ``copy(deep=True)`` would convert\n+  unicode indices to dtype=object (:issue:`3094`).\n+  By `Guido Imperiale <https://github.com/crusaderky>`_.\n+\n \n .. _whats-new.0.12.3:\n \n\nFrom 678e82b6b63e4677112b2e93c641683ff752b2d6 Mon Sep 17 00:00:00 2001\nFrom: Guido Imperiale <crusaderky@gmail.com>\nDate: Sat, 13 Jul 2019 15:43:44 +0100\nSubject: [PATCH 3/5] Simplify copy()\n\n---\n xarray/core/indexing.py | 8 +++-----\n 1 file changed, 3 insertions(+), 5 deletions(-)\n\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 01b24a72fa4..79efd602c83 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -1310,16 +1310,14 @@ def __repr__(self) -> str:\n                 % (type(self).__name__, self.array, self.dtype))\n \n     def copy(self, deep: bool = True) -> 'PandasIndexAdapter':\n-        obj = object.__new__(PandasIndexAdapter)\n         # Not the same as just writing `self.array.copy(deep=deep)`, as\n         # shallow copies of the underlying numpy.ndarrays become deep ones\n         # upon pickling\n         if deep:\n-            obj.array = self.array.copy(deep=True)\n+            array = self.array.copy(deep=True)\n         else:\n-            obj.array = self.array\n-        obj._dtype = self._dtype\n-        return obj\n+            array = self.array\n+        return PandasIndexAdapter(array, self._dtype)\n \n     def __copy__(self) -> 'PandasIndexAdapter':\n         return self.copy(deep=False)\n\nFrom ae212a0f257d823ad73916184a3b30cfc01b3625 Mon Sep 17 00:00:00 2001\nFrom: Guido Imperiale <crusaderky@gmail.com>\nDate: Wed, 24 Jul 2019 23:53:40 +0100\nSubject: [PATCH 4/5] Cosmetic\n\n---\n doc/whats-new.rst | 4 +---\n 1 file changed, 1 insertion(+), 3 deletions(-)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex df5b50919c1..31e5e6d8816 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -36,9 +36,7 @@ Bug fixes\n - Fix regression introduced in v0.12.2 where ``copy(deep=True)`` would convert\n   unicode indices to dtype=object (:issue:`3094`).\n   By `Guido Imperiale <https://github.com/crusaderky>`_.\n-\n-\n-- Improved error handling and documentation for `.expand_dims()` \n+- Improved error handling and documentation for `.expand_dims()`\n   read-only view.\n - Fix tests for big-endian systems (:issue:`3125`).\n   By `Graham Inggs <https://github.com/ginggs>`_.\n\nFrom da45c3b7c902b19cff83b5c9a7df22ff31490e2a Mon Sep 17 00:00:00 2001\nFrom: Guido Imperiale <guido.imperiale@amphorainc.com>\nDate: Fri, 2 Aug 2019 14:18:57 +0100\nSubject: [PATCH 5/5] Code review\n\n---\n xarray/core/indexing.py | 17 +++++------------\n 1 file changed, 5 insertions(+), 12 deletions(-)\n\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex 595130552bc..14f62c533da 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -1321,16 +1321,9 @@ def copy(self, deep: bool = True) -> 'PandasIndexAdapter':\n         # Not the same as just writing `self.array.copy(deep=deep)`, as\n         # shallow copies of the underlying numpy.ndarrays become deep ones\n         # upon pickling\n-        if deep:\n-            array = self.array.copy(deep=True)\n-        else:\n-            array = self.array\n+        # >>> len(pickle.dumps((self.array, self.array)))\n+        # 4000281\n+        # >>> len(pickle.dumps((self.array, self.array.copy(deep=False))))\n+        # 8000341\n+        array = self.array.copy(deep=True) if deep else self.array\n         return PandasIndexAdapter(array, self._dtype)\n-\n-    def __copy__(self) -> 'PandasIndexAdapter':\n-        return self.copy(deep=False)\n-\n-    def __deepcopy__(self, memo=None) -> 'PandasIndexAdapter':\n-        # memo does nothing but is required for compatibility with\n-        # copy.deepcopy\n-        return self.copy(deep=True)\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/3095"}