{"instance_id": "django__django-15280", "score": "I", "diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex fb6639793a..2860031328 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -14,7 +14,7 @@ from django.db import (\n     DJANGO_VERSION_PICKLE_KEY, IntegrityError, NotSupportedError, connections,\n     router, transaction,\n )\n-from django.db.models import AutoField, DateField, DateTimeField, sql\n+from django.db.models import AutoField, DateField, DateTimeField, sql, DeferredAttribute\n from django.db.models.constants import LOOKUP_SEP\n from django.db.models.deletion import Collector\n from django.db.models.expressions import Case, Expression, F, Ref, Value, When\n@@ -84,10 +84,36 @@ class ModelIterable(BaseIterable):\n                 except KeyError:\n                     pass  # May happen in qs1 | qs2 scenarios.\n                 else:\n-                    setattr(obj, field.name, rel_obj)\n+                    # Check if the field is deferred before setting it\n+                    if field.name not in obj.get_deferred_fields():\n+                        setattr(obj, field.name, rel_obj)\n+                    else:\n+                        # If the field is deferred, use a custom descriptor to handle lazy loading\n+                        setattr(obj.__class__, field.name, DeferredRelatedDescriptor(field, rel_obj))\n \n             yield obj\n \n+class DeferredRelatedDescriptor:\n+    def __init__(self, field, related_obj):\n+        self.field = field\n+        self.related_obj = related_obj\n+\n+    def __get__(self, instance, owner=None):\n+        if instance is None:\n+            return self\n+        # Load the deferred field when accessed\n+        instance.refresh_from_db(fields=[self.field.name])\n+        # Replace this descriptor with the actual value\n+        setattr(instance, self.field.name, self.related_obj)\n+        return self.related_obj\n+\n+    def __set__(self, instance, value):\n+        # Update the related object and set the field value\n+        self.related_obj = value\n+        setattr(instance, self.field.name, value)\n+        # Remove this descriptor, as the field is no longer deferred\n+        delattr(instance.__class__, self.field.name)\n+\n \n class ValuesIterable(BaseIterable):\n     \"\"\"\n@@ -1760,6 +1786,27 @@ def prefetch_related_objects(model_instances, *related_lookups):\n                                  \"prefetching - this is an invalid parameter to \"\n                                  \"prefetch_related().\" % lookup.prefetch_through)\n \n+            # Handle deferred fields\n+            if isinstance(descriptor, DeferredAttribute):\n+                for obj in obj_list:\n+                    if through_attr not in obj.get_deferred_fields():\n+                        continue\n+                    field = obj.__class__._meta.get_field(through_attr)\n+                    if not hasattr(obj.__class__, through_attr):\n+                        setattr(obj.__class__, through_attr, DeferredRelatedDescriptor(field, None))\n+                    getattr(obj.__class__, through_attr).__set__(obj, None)\n+\n+            if descriptor is None:\n+                # We don't have a descriptor, so we need to use getattr() to\n+                # fetch the value from the object. This is slower, but allows\n+                # us to fetch values from non-model instances.\n+                def getter(obj):\n+                    return getattr(obj, through_attr)\n+                setter = None\n+            else:\n+                getter = descriptor.__get__\n+                setter = descriptor.__set__\n+\n             obj_to_fetch = None\n             if prefetcher is not None:\n                 obj_to_fetch = [obj for obj in obj_list if not is_fetched(obj)]\n", "gold_standard_diff": "diff --git a/AUTHORS b/AUTHORS\nindex 3ca8ad40f523..77053c9568ac 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -423,6 +423,7 @@ answer newbie questions, and generally made Django that much better:\n     James Timmins <jameshtimmins@gmail.com>\n     James Turk <dev@jamesturk.net>\n     James Wheare <django@sparemint.com>\n+    Jamie Matthews <jamie@mtth.org>\n     Jannis Leidel <jannis@leidel.info>\n     Janos Guljas\n     Jan Pazdziora\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex d5aa9684003f..9c50ef16ce7a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -646,8 +646,9 @@ def get_prefetch_queryset(self, instances, queryset=None):\n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n             for rel_obj in queryset:\n-                instance = instances_dict[rel_obj_attr(rel_obj)]\n-                setattr(rel_obj, self.field.name, instance)\n+                if not self.field.is_cached(rel_obj):\n+                    instance = instances_dict[rel_obj_attr(rel_obj)]\n+                    setattr(rel_obj, self.field.name, instance)\n             cache_name = self.field.remote_field.get_cache_name()\n             return queryset, rel_obj_attr, instance_attr, False, cache_name, False\n \ndiff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 4ea7fccd5e6a..5040f3d88693 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1614,3 +1614,29 @@ def test_retrieves_results_from_prefetched_objects_cache(self):\n         with self.assertNumQueries(4):\n             # AuthorWithAge -> Author -> FavoriteAuthors, Book\n             self.assertSequenceEqual(authors, [self.author1, self.author2])\n+\n+\n+class NestedPrefetchTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        house = House.objects.create(name='Big house', address='123 Main St')\n+        cls.room = Room.objects.create(name='Kitchen', house=house)\n+\n+    def test_nested_prefetch_is_not_overwritten_by_related_object(self):\n+        \"\"\"\n+        The prefetched relationship is used rather than populating the reverse\n+        relationship from the parent, when prefetching a set of child objects\n+        related to a set of parent objects and the child queryset itself\n+        specifies a prefetch back to the parent.\n+        \"\"\"\n+        queryset = House.objects.only('name').prefetch_related(\n+            Prefetch('rooms', queryset=Room.objects.prefetch_related(\n+                Prefetch('house', queryset=House.objects.only('address')),\n+            )),\n+        )\n+        with self.assertNumQueries(3):\n+            house = queryset.first()\n+\n+        self.assertIs(Room.house.is_cached(self.room), True)\n+        with self.assertNumQueries(0):\n+            house.rooms.first().house.address\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15280"}