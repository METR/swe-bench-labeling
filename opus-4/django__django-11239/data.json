{"instance_id": "django__django-11239", "score": "C", "diff": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex cf4df76882..c771623c68 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -30,6 +30,21 @@ class DatabaseClient(BaseDatabaseClient):\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\n+        \n+        # SSL parameters\n+        sslmode = conn_params.get('sslmode')\n+        if sslmode:\n+            subprocess_env['PGSSLMODE'] = str(sslmode)\n+        sslrootcert = conn_params.get('sslrootcert')\n+        if sslrootcert:\n+            subprocess_env['PGSSLROOTCERT'] = str(sslrootcert)\n+        sslcert = conn_params.get('sslcert')\n+        if sslcert:\n+            subprocess_env['PGSSLCERT'] = str(sslcert)\n+        sslkey = conn_params.get('sslkey')\n+        if sslkey:\n+            subprocess_env['PGSSLKEY'] = str(sslkey)\n+        \n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\ndiff --git a/ssl_documentation.md b/ssl_documentation.md\nnew file mode 100644\nindex 0000000000..7ef983a2a1\n--- /dev/null\n+++ b/ssl_documentation.md\n@@ -0,0 +1,42 @@\n+# PostgreSQL SSL Support in dbshell\n+\n+The Django `dbshell` management command now supports PostgreSQL SSL/TLS parameters. When you have SSL configuration in your database settings, these parameters will be automatically passed to the `psql` command-line client.\n+\n+## Supported SSL Parameters\n+\n+The following SSL-related parameters from your database `OPTIONS` are supported:\n+\n+- `sslmode`: Controls the SSL connection mode (e.g., 'require', 'verify-ca', 'verify-full')\n+- `sslrootcert`: Path to the root certificate file for server certificate verification\n+- `sslcert`: Path to the client certificate file for mutual TLS authentication\n+- `sslkey`: Path to the client private key file\n+\n+## Example Configuration\n+\n+```python\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.postgresql',\n+        'NAME': 'mydatabase',\n+        'USER': 'myuser',\n+        'PASSWORD': 'mypassword',\n+        'HOST': 'localhost',\n+        'PORT': '5432',\n+        'OPTIONS': {\n+            'sslmode': 'verify-ca',\n+            'sslrootcert': '/path/to/ca-cert.pem',\n+            'sslcert': '/path/to/client-cert.pem',\n+            'sslkey': '/path/to/client-key.pem',\n+        }\n+    }\n+}\n+```\n+\n+When you run `python manage.py dbshell` with this configuration, the SSL parameters will be passed to `psql` via environment variables:\n+\n+- `PGSSLMODE` (from `sslmode`)\n+- `PGSSLROOTCERT` (from `sslrootcert`) \n+- `PGSSLCERT` (from `sslcert`)\n+- `PGSSLKEY` (from `sslkey`)\n+\n+This ensures that the interactive shell connection uses the same SSL/TLS settings as your Django application.\ndiff --git a/test_dbshell_ssl.py b/test_dbshell_ssl.py\nnew file mode 100644\nindex 0000000000..9bdac7f795\n--- /dev/null\n+++ b/test_dbshell_ssl.py\n@@ -0,0 +1,89 @@\n+\"\"\"Test script to verify SSL parameters are passed to dbshell.\"\"\"\n+import os\n+import unittest\n+from unittest.mock import patch, MagicMock\n+from django.db.backends.postgresql.client import DatabaseClient\n+\n+\n+class TestPostgreSQLDbshellSSL(unittest.TestCase):\n+    \n+    def test_ssl_parameters_in_environment(self):\n+        \"\"\"Test that SSL parameters are properly set in the subprocess environment.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'password': 'test_pass',\n+            'host': 'localhost',\n+            'port': '5432',\n+            'sslmode': 'verify-ca',\n+            'sslrootcert': '/path/to/ca.crt',\n+            'sslcert': '/path/to/client_cert_chain.crt',\n+            'sslkey': '/path/to/client_key.key'\n+        }\n+        \n+        with patch('subprocess.run') as mock_run:\n+            with patch('os.environ.copy') as mock_env_copy:\n+                # Create a mock environment dict\n+                mock_env = {}\n+                mock_env_copy.return_value = mock_env\n+                \n+                # Call the method\n+                DatabaseClient.runshell_db(conn_params)\n+                \n+                # Verify subprocess.run was called\n+                mock_run.assert_called_once()\n+                \n+                # Get the environment passed to subprocess.run\n+                call_args = mock_run.call_args\n+                env = call_args[1]['env']\n+                \n+                # Verify all SSL parameters are in the environment\n+                self.assertEqual(env['PGPASSWORD'], 'test_pass')\n+                self.assertEqual(env['PGSSLMODE'], 'verify-ca')\n+                self.assertEqual(env['PGSSLROOTCERT'], '/path/to/ca.crt')\n+                self.assertEqual(env['PGSSLCERT'], '/path/to/client_cert_chain.crt')\n+                self.assertEqual(env['PGSSLKEY'], '/path/to/client_key.key')\n+                \n+                # Verify the command line arguments\n+                args = call_args[0][0]\n+                self.assertEqual(args[0], 'psql')\n+                self.assertIn('-U', args)\n+                self.assertIn('test_user', args)\n+                self.assertIn('-h', args)\n+                self.assertIn('localhost', args)\n+                self.assertIn('-p', args)\n+                self.assertIn('5432', args)\n+                self.assertEqual(args[-1], 'test_db')\n+    \n+    def test_ssl_parameters_optional(self):\n+        \"\"\"Test that SSL parameters are optional and only set when provided.\"\"\"\n+        conn_params = {\n+            'database': 'test_db',\n+            'user': 'test_user',\n+            'host': 'localhost',\n+            'sslmode': 'require',  # Only set sslmode\n+        }\n+        \n+        with patch('subprocess.run') as mock_run:\n+            with patch('os.environ.copy') as mock_env_copy:\n+                # Create a mock environment dict\n+                mock_env = {}\n+                mock_env_copy.return_value = mock_env\n+                \n+                # Call the method\n+                DatabaseClient.runshell_db(conn_params)\n+                \n+                # Get the environment passed to subprocess.run\n+                call_args = mock_run.call_args\n+                env = call_args[1]['env']\n+                \n+                # Verify only sslmode is set\n+                self.assertEqual(env['PGSSLMODE'], 'require')\n+                self.assertNotIn('PGPASSWORD', env)\n+                self.assertNotIn('PGSSLROOTCERT', env)\n+                self.assertNotIn('PGSSLCERT', env)\n+                self.assertNotIn('PGSSLKEY', env)\n+\n+\n+if __name__ == '__main__':\n+    unittest.main()\ndiff --git a/test_integrated_ssl.py b/test_integrated_ssl.py\nnew file mode 100644\nindex 0000000000..078f1ea457\n--- /dev/null\n+++ b/test_integrated_ssl.py\n@@ -0,0 +1,71 @@\n+\"\"\"Test integrated SSL parameters passing from Django settings to dbshell.\"\"\"\n+import os\n+from unittest import mock\n+from django.conf import settings\n+from django.db import connection\n+from django.test import TestCase, override_settings\n+\n+# Minimal Django settings for the test\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.postgresql',\n+            'NAME': 'test_db',\n+            'USER': 'test_user',\n+            'PASSWORD': 'test_pass',\n+            'HOST': 'localhost',\n+            'PORT': '5432',\n+            'OPTIONS': {\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': '/path/to/ca.crt',\n+                'sslcert': '/path/to/client_cert.crt',\n+                'sslkey': '/path/to/client_key.key',\n+            }\n+        }\n+    },\n+    SECRET_KEY='test-secret-key',\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+)\n+\n+import django\n+django.setup()\n+\n+from django.db.backends.postgresql.client import DatabaseClient\n+\n+\n+class TestIntegratedSSL(TestCase):\n+    \n+    def test_ssl_options_from_django_settings(self):\n+        \"\"\"Test that SSL options from Django settings are passed to psql.\"\"\"\n+        \n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            self.subprocess_args = list(*args)\n+            self.env = env\n+            return mock.Mock()\n+        \n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            # Get the client from the connection\n+            client = connection.client\n+            # Get connection params from the connection\n+            conn_params = connection.get_connection_params()\n+            \n+            # Run the shell command\n+            DatabaseClient.runshell_db(conn_params)\n+            \n+            # Verify SSL parameters are in the environment\n+            self.assertEqual(self.env.get('PGSSLMODE'), 'verify-ca')\n+            self.assertEqual(self.env.get('PGSSLROOTCERT'), '/path/to/ca.crt')\n+            self.assertEqual(self.env.get('PGSSLCERT'), '/path/to/client_cert.crt')\n+            self.assertEqual(self.env.get('PGSSLKEY'), '/path/to/client_key.key')\n+            \n+            # Verify basic connection parameters\n+            self.assertEqual(self.env.get('PGPASSWORD'), 'test_pass')\n+            \n+            # Verify command line\n+            self.assertEqual(self.subprocess_args[0], 'psql')\n+            self.assertIn('test_db', self.subprocess_args)\n+\n+\n+if __name__ == '__main__':\n+    import unittest\n+    unittest.main()\ndiff --git a/test_ssl_simple.py b/test_ssl_simple.py\nnew file mode 100644\nindex 0000000000..18dd64bae5\n--- /dev/null\n+++ b/test_ssl_simple.py\n@@ -0,0 +1,51 @@\n+\"\"\"Simple test to verify SSL parameters are passed correctly.\"\"\"\n+import subprocess\n+from unittest import mock\n+\n+# Import the client module directly\n+from django.db.backends.postgresql.client import DatabaseClient\n+\n+# Simulate the connection parameters that would come from Django settings\n+conn_params = {\n+    'database': 'test_db',\n+    'user': 'test_user',\n+    'password': 'test_pass',\n+    'host': 'localhost',\n+    'port': '5432',\n+    'sslmode': 'verify-ca',\n+    'sslrootcert': '/path/to/ca.crt',\n+    'sslcert': '/path/to/client_cert.crt',\n+    'sslkey': '/path/to/client_key.key',\n+}\n+\n+# Mock subprocess.run to capture the environment\n+captured_env = None\n+captured_args = None\n+\n+def mock_subprocess_run(args, **kwargs):\n+    global captured_env, captured_args\n+    captured_args = args\n+    captured_env = kwargs.get('env', {})\n+    return subprocess.CompletedProcess(args, 0)\n+\n+# Patch subprocess.run and run the command\n+with mock.patch('subprocess.run', side_effect=mock_subprocess_run):\n+    DatabaseClient.runshell_db(conn_params)\n+\n+# Verify the results\n+print(\"Command arguments:\", captured_args)\n+print(\"\\nEnvironment variables:\")\n+print(f\"  PGPASSWORD: {captured_env.get('PGPASSWORD')}\")\n+print(f\"  PGSSLMODE: {captured_env.get('PGSSLMODE')}\")\n+print(f\"  PGSSLROOTCERT: {captured_env.get('PGSSLROOTCERT')}\")\n+print(f\"  PGSSLCERT: {captured_env.get('PGSSLCERT')}\")\n+print(f\"  PGSSLKEY: {captured_env.get('PGSSLKEY')}\")\n+\n+# Verify all SSL parameters are present\n+assert captured_env.get('PGPASSWORD') == 'test_pass'\n+assert captured_env.get('PGSSLMODE') == 'verify-ca'\n+assert captured_env.get('PGSSLROOTCERT') == '/path/to/ca.crt'\n+assert captured_env.get('PGSSLCERT') == '/path/to/client_cert.crt'\n+assert captured_env.get('PGSSLKEY') == '/path/to/client_key.key'\n+\n+print(\"\\nAll SSL parameters are correctly passed to psql!\")\ndiff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex a33e7f6482..f8474eed68 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -94,3 +94,61 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             DatabaseClient.runshell_db({})\n         # dbshell restores the original handler.\n         self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n+\n+\n+    def test_ssl_parameters(self):\n+        \"\"\"Test that SSL parameters are properly passed as environment variables.\"\"\"\n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            self.subprocess_args = list(*args)\n+            self.env = env\n+            return subprocess.CompletedProcess(self.subprocess_args, 0)\n+        \n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'password': 'somepassword',\n+                'host': 'somehost',\n+                'port': '5432',\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': '/path/to/ca.crt',\n+                'sslcert': '/path/to/client_cert.crt',\n+                'sslkey': '/path/to/client_key.key',\n+            })\n+        \n+        # Check command line arguments\n+        self.assertEqual(\n+            self.subprocess_args,\n+            ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '5432', 'dbname']\n+        )\n+        \n+        # Check environment variables\n+        self.assertEqual(self.env.get('PGPASSWORD'), 'somepassword')\n+        self.assertEqual(self.env.get('PGSSLMODE'), 'verify-ca')\n+        self.assertEqual(self.env.get('PGSSLROOTCERT'), '/path/to/ca.crt')\n+        self.assertEqual(self.env.get('PGSSLCERT'), '/path/to/client_cert.crt')\n+        self.assertEqual(self.env.get('PGSSLKEY'), '/path/to/client_key.key')\n+\n+    def test_partial_ssl_parameters(self):\n+        \"\"\"Test that only provided SSL parameters are set.\"\"\"\n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            self.subprocess_args = list(*args)\n+            self.env = env\n+            return subprocess.CompletedProcess(self.subprocess_args, 0)\n+        \n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'host': 'somehost',\n+                'sslmode': 'require',\n+                'sslrootcert': '/path/to/ca.crt',\n+                # No sslcert or sslkey\n+            })\n+        \n+        # Check that only specified SSL parameters are in the environment\n+        self.assertEqual(self.env.get('PGSSLMODE'), 'require')\n+        self.assertEqual(self.env.get('PGSSLROOTCERT'), '/path/to/ca.crt')\n+        self.assertNotIn('PGSSLCERT', self.env)\n+        self.assertNotIn('PGSSLKEY', self.env)\n+        self.assertNotIn('PGPASSWORD', self.env)\n", "gold_standard_diff": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex cf4df7688229..0efe0d47f0a7 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -17,6 +17,10 @@ def runshell_db(cls, conn_params):\n         dbname = conn_params.get('database', '')\n         user = conn_params.get('user', '')\n         passwd = conn_params.get('password', '')\n+        sslmode = conn_params.get('sslmode', '')\n+        sslrootcert = conn_params.get('sslrootcert', '')\n+        sslcert = conn_params.get('sslcert', '')\n+        sslkey = conn_params.get('sslkey', '')\n \n         if user:\n             args += ['-U', user]\n@@ -30,6 +34,14 @@ def runshell_db(cls, conn_params):\n         subprocess_env = os.environ.copy()\n         if passwd:\n             subprocess_env['PGPASSWORD'] = str(passwd)\n+        if sslmode:\n+            subprocess_env['PGSSLMODE'] = str(sslmode)\n+        if sslrootcert:\n+            subprocess_env['PGSSLROOTCERT'] = str(sslrootcert)\n+        if sslcert:\n+            subprocess_env['PGSSLCERT'] = str(sslcert)\n+        if sslkey:\n+            subprocess_env['PGSSLKEY'] = str(sslkey)\n         try:\n             # Allow SIGINT to pass to psql to abort queries.\n             signal.signal(signal.SIGINT, signal.SIG_IGN)\ndiff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt\nindex 44656b11cd75..7e32da32fa0c 100644\n--- a/docs/releases/3.0.txt\n+++ b/docs/releases/3.0.txt\n@@ -172,6 +172,8 @@ Management Commands\n * :option:`showmigrations --list` now shows the applied datetimes when\n   ``--verbosity`` is 2 and above.\n \n+* On PostgreSQL, :djadmin:`dbshell` now supports client-side TLS certificates.\n+\n Migrations\n ~~~~~~~~~~\n \ndiff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex a33e7f648246..40d2deae6235 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -14,15 +14,16 @@ def _run_it(self, dbinfo):\n         That function invokes the runshell command, while mocking\n         subprocess.run(). It returns a 2-tuple with:\n         - The command line list\n-        - The the value of the PGPASSWORD environment variable, or None.\n+        - The dictionary of PG* environment variables, or {}.\n         \"\"\"\n         def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n             self.subprocess_args = list(*args)\n-            self.pgpassword = env.get('PGPASSWORD')\n+            # PostgreSQL environment variables.\n+            self.pg_env = {key: env[key] for key in env if key.startswith('PG')}\n             return subprocess.CompletedProcess(self.subprocess_args, 0)\n         with mock.patch('subprocess.run', new=_mock_subprocess_run):\n             DatabaseClient.runshell_db(dbinfo)\n-        return self.subprocess_args, self.pgpassword\n+        return self.subprocess_args, self.pg_env\n \n     def test_basic(self):\n         self.assertEqual(\n@@ -34,7 +35,7 @@ def test_basic(self):\n                 'port': '444',\n             }), (\n                 ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n-                'somepassword',\n+                {'PGPASSWORD': 'somepassword'},\n             )\n         )\n \n@@ -47,7 +48,29 @@ def test_nopass(self):\n                 'port': '444',\n             }), (\n                 ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n-                None,\n+                {},\n+            )\n+        )\n+\n+    def test_ssl_certificate(self):\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'host': 'somehost',\n+                'port': '444',\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': 'root.crt',\n+                'sslcert': 'client.crt',\n+                'sslkey': 'client.key',\n+            }), (\n+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n+                {\n+                    'PGSSLCERT': 'client.crt',\n+                    'PGSSLKEY': 'client.key',\n+                    'PGSSLMODE': 'verify-ca',\n+                    'PGSSLROOTCERT': 'root.crt',\n+                },\n             )\n         )\n \n@@ -61,7 +84,7 @@ def test_column(self):\n                 'port': '444',\n             }), (\n                 ['psql', '-U', 'some:user', '-h', '::1', '-p', '444', 'dbname'],\n-                'some:password',\n+                {'PGPASSWORD': 'some:password'},\n             )\n         )\n \n@@ -77,7 +100,7 @@ def test_accent(self):\n                 'port': '444',\n             }), (\n                 ['psql', '-U', username, '-h', 'somehost', '-p', '444', 'dbname'],\n-                password,\n+                {'PGPASSWORD': password},\n             )\n         )\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/11239"}