{"instance_id": "django__django-13033", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d65141b834..74c1afd7a1 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1894,8 +1894,12 @@ class Query(BaseExpression):\n         expressions.\n \n         If 'ordering' is empty, clear all ordering from the query.\n+\n+        For self-referencing foreign keys, this method appends '__id' to the\n+        field name to ensure correct ordering.\n         \"\"\"\n         errors = []\n+        new_ordering = []\n         for item in ordering:\n             if isinstance(item, str):\n                 if '.' in item:\n@@ -1908,18 +1912,37 @@ class Query(BaseExpression):\n                     )\n                     continue\n                 if item == '?':\n+                    new_ordering.append(item)\n                     continue\n-                if item.startswith('-'):\n+                desc = item.startswith('-')\n+                if desc:\n                     item = item[1:]\n                 if item in self.annotations:\n+                    new_ordering.append(item if not desc else '-' + item)\n                     continue\n                 if self.extra and item in self.extra:\n+                    new_ordering.append(item if not desc else '-' + item)\n                     continue\n+                # Handle self-referencing foreign key\n+                parts = item.split(LOOKUP_SEP)\n+                if len(parts) > 1:\n+                    field_name = parts[-1]\n+                    try:\n+                        field = self.model._meta.get_field(field_name)\n+                        if field.remote_field and field.remote_field.model == self.model:\n+                            new_item = f\"{item}__id\"\n+                            new_ordering.append(new_item if not desc else '-' + new_item)\n+                            continue\n+                    except FieldDoesNotExist:\n+                        pass\n                 # names_to_path() validates the lookup. A descriptive\n-                # FieldError will be raise if it's not.\n-                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n+                # FieldError will be raised if it's not.\n+                self.names_to_path(parts, self.model._meta)\n+                new_ordering.append(item if not desc else '-' + item)\n             elif not hasattr(item, 'resolve_expression'):\n                 errors.append(item)\n+            else:\n+                new_ordering.append(item)\n             if getattr(item, 'contains_aggregate', False):\n                 raise FieldError(\n                     'Using an aggregate in order_by() without also including '\n@@ -1927,8 +1950,8 @@ class Query(BaseExpression):\n                 )\n         if errors:\n             raise FieldError('Invalid order_by arguments: %s' % errors)\n-        if ordering:\n-            self.order_by += ordering\n+        if new_ordering:\n+            self.order_by += tuple(new_ordering)\n         else:\n             self.default_ordering = False\n \n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex abbb1e37cb87..686e75c979d0 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -727,7 +727,12 @@ def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n         # If we get to this point and the field is a relation to another model,\n         # append the default ordering for that model unless it is the pk\n         # shortcut or the attribute name of the field that is specified.\n-        if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name and name != 'pk':\n+        if (\n+            field.is_relation and\n+            opts.ordering and\n+            getattr(field, 'attname', None) != pieces[-1] and\n+            name != 'pk'\n+        ):\n             # Firstly, avoid infinite loops.\n             already_seen = already_seen or set()\n             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)\ndiff --git a/tests/ordering/models.py b/tests/ordering/models.py\nindex 2efb743e44b6..95780c6a16c8 100644\n--- a/tests/ordering/models.py\n+++ b/tests/ordering/models.py\n@@ -18,6 +18,7 @@\n \n class Author(models.Model):\n     name = models.CharField(max_length=63, null=True, blank=True)\n+    editor = models.ForeignKey('self', models.CASCADE, null=True)\n \n     class Meta:\n         ordering = ('-pk',)\ndiff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex a9cc729c4513..61ec3a859224 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,22 @@ def test_order_by_fk_attname(self):\n             attrgetter(\"headline\")\n         )\n \n+    def test_order_by_self_referential_fk(self):\n+        self.a1.author = Author.objects.create(editor=self.author_1)\n+        self.a1.save()\n+        self.a2.author = Author.objects.create(editor=self.author_2)\n+        self.a2.save()\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13033"}