{"instance_id": "django__django-15503", "score": "I", "diff": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9d..9543ffcbd1 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -139,6 +139,18 @@ def compile_json_path(key_transforms, include_root=True):\n     return \"\".join(path)\n \n \n+def compile_json_path_for_object_keys(key_transforms, include_root=True):\n+    \"\"\"\n+    Compile a JSON path that treats all keys as object keys (not array indices).\n+    This is used for has_key lookups where we're always checking object keys.\n+    \"\"\"\n+    path = [\"$\"] if include_root else []\n+    for key_transform in key_transforms:\n+        path.append(\".\")\n+        path.append(json.dumps(str(key_transform)))\n+    return \"\".join(path)\n+\n+\n class DataContains(PostgresOperatorLookup):\n     lookup_name = \"contains\"\n     postgres_operator = \"@>\"\n@@ -191,15 +203,24 @@ class HasKeyLookup(PostgresOperatorLookup):\n         for key in rhs:\n             if isinstance(key, KeyTransform):\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n+                # Use regular compile_json_path for KeyTransform as it might contain array indices\n+                rhs_params.append(\n+                    \"%s%s\"\n+                    % (\n+                        lhs_json_path,\n+                        compile_json_path(rhs_key_transforms, include_root=False),\n+                    )\n+                )\n             else:\n+                # For simple string keys, treat them as object keys\n                 rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n+                rhs_params.append(\n+                    \"%s%s\"\n+                    % (\n+                        lhs_json_path,\n+                        compile_json_path_for_object_keys(rhs_key_transforms, include_root=False),\n+                    )\n                 )\n-            )\n         # Add condition for each key.\n         if self.logical_operator:\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\ndiff --git a/test_has_keys.py b/test_has_keys.py\nnew file mode 100644\nindex 0000000000..3d022d6a29\n--- /dev/null\n+++ b/test_has_keys.py\n@@ -0,0 +1,67 @@\n+import os\n+import django\n+from django.db import models\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+# Create test settings\n+with open('/testbed/test_settings.py', 'w') as f:\n+    f.write(\"\"\"\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+SECRET_KEY = 'test'\n+USE_TZ = False\n+\"\"\")\n+\n+django.setup()\n+\n+# Define test model\n+class JsonFieldHasKeyTest(models.Model):\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(JsonFieldHasKeyTest)\n+\n+# Test has_keys and has_any_keys\n+print(\"Creating test data...\")\n+test1 = JsonFieldHasKeyTest(data={'123': 'value1', '456': 'value2', 'foo': 'bar'})\n+test2 = JsonFieldHasKeyTest(data={'789': 'value3', 'abc': 'value4'})\n+test3 = JsonFieldHasKeyTest(data={'123': 'value5', 'def': 'value6'})\n+test1.save()\n+test2.save()\n+test3.save()\n+\n+print(\"\\nTesting has_keys (AND logic)...\")\n+# Should find only test1 since it has both '123' and '456'\n+count = JsonFieldHasKeyTest.objects.filter(data__has_keys=['123', '456']).count()\n+print(f\"Count with keys ['123', '456']: {count} (expected: 1)\")\n+\n+# Should find test1 and test3 since both have '123' \n+print(\"\\nTesting has_any_keys (OR logic)...\")\n+count = JsonFieldHasKeyTest.objects.filter(data__has_any_keys=['123', '456']).count()\n+print(f\"Count with any keys ['123', '456']: {count} (expected: 2)\")\n+\n+# Mixed numeric and non-numeric keys\n+count = JsonFieldHasKeyTest.objects.filter(data__has_any_keys=['123', 'abc']).count()\n+print(f\"Count with any keys ['123', 'abc']: {count} (expected: 3)\")\n+\n+# Check SQL queries\n+print(\"\\nChecking SQL queries...\")\n+queries = JsonFieldHasKeyTest.objects.filter(data__has_keys=['123', '456']).query\n+print(f\"Query for has_keys ['123', '456']: {queries}\")\n+\n+queries2 = JsonFieldHasKeyTest.objects.filter(data__has_any_keys=['123', '456']).query\n+print(f\"Query for has_any_keys ['123', '456']: {queries2}\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..4654a55d2c\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,58 @@\n+import os\n+import django\n+from django.test import TestCase\n+from django.db import models\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+# Create test settings matching the issue\n+with open('/testbed/test_settings.py', 'w') as f:\n+    f.write(\"\"\"\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': 'db.sqlite3',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+SECRET_KEY = 'test'\n+USE_TZ = False\n+\"\"\")\n+\n+django.setup()\n+\n+# Define test model\n+class JsonFieldHasKeyTest(models.Model):\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(JsonFieldHasKeyTest)\n+\n+\n+class JsonFieldHasKeyTestCase(TestCase):\n+    def setUp(self) -> None:\n+        test = JsonFieldHasKeyTest(data={'foo': 'bar'})\n+        test2 = JsonFieldHasKeyTest(data={'1111': 'bar'})\n+        test.save()\n+        test2.save()\n+\n+    def test_json_field_has_key(self):\n+        c1 = JsonFieldHasKeyTest.objects.filter(data__has_key='foo').count()\n+        c2 = JsonFieldHasKeyTest.objects.filter(data__has_key='1111').count()\n+        self.assertEqual(c1, 1, \"Should have found 1 entry with key 'foo'\")\n+        self.assertEqual(c2, 1, \"Should have found 1 entry with key '1111'\")\n+\n+\n+# Run the test\n+test_case = JsonFieldHasKeyTestCase()\n+test_case.setUp()\n+test_case.test_json_field_has_key()\n+print(\"Test passed!\")\ndiff --git a/test_json_debug.py b/test_json_debug.py\nnew file mode 100644\nindex 0000000000..435ed338b7\n--- /dev/null\n+++ b/test_json_debug.py\n@@ -0,0 +1,40 @@\n+import os\n+import django\n+import json\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+django.setup()\n+\n+from django.db import connection\n+\n+# Test the JSON path syntax directly in SQLite\n+with connection.cursor() as cursor:\n+    # Create a test table\n+    cursor.execute(\"CREATE TABLE test_json (data TEXT)\")\n+    \n+    # Insert test data\n+    cursor.execute(\"INSERT INTO test_json VALUES (?)\", [json.dumps({'1111': 'bar'})])\n+    cursor.execute(\"INSERT INTO test_json VALUES (?)\", [json.dumps({'foo': 'bar'})])\n+    \n+    # Test different JSON path syntaxes\n+    print(\"Testing different JSON path syntaxes...\")\n+    \n+    # This should fail (treating '1111' as array index)\n+    cursor.execute(\"SELECT data, JSON_TYPE(data, '$[1111]') FROM test_json WHERE data LIKE ?\", ['%1111%'])\n+    result = cursor.fetchone()\n+    print(f\"JSON_TYPE(data, '$[1111]') for {result[0]}: {result[1]}\")\n+    \n+    # This should work (treating '1111' as object key)\n+    cursor.execute(\"SELECT data, JSON_TYPE(data, '$.\\\"1111\\\"') FROM test_json WHERE data LIKE ?\", ['%1111%']) \n+    result = cursor.fetchone()\n+    print(f\"JSON_TYPE(data, '$.\\\"1111\\\"') for {result[0]}: {result[1]}\")\n+    \n+    # Test with regular string key\n+    cursor.execute(\"SELECT data, JSON_TYPE(data, '$.foo') FROM test_json WHERE data LIKE ?\", ['%foo%'])\n+    result = cursor.fetchone()\n+    print(f\"JSON_TYPE(data, '$.foo') for {result[0]}: {result[1]}\")\n+    \n+    # Test with quoted regular key\n+    cursor.execute(\"SELECT data, JSON_TYPE(data, '$.\\\"foo\\\"') FROM test_json WHERE data LIKE ?\", ['%foo%'])\n+    result = cursor.fetchone()\n+    print(f\"JSON_TYPE(data, '$.\\\"foo\\\"') for {result[0]}: {result[1]}\")\ndiff --git a/test_json_numeric_keys.py b/test_json_numeric_keys.py\nnew file mode 100644\nindex 0000000000..9fe2715bed\n--- /dev/null\n+++ b/test_json_numeric_keys.py\n@@ -0,0 +1,64 @@\n+import os\n+import django\n+from django.test import TestCase\n+from django.db import models\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+# Create test settings\n+with open('/testbed/test_settings.py', 'w') as f:\n+    f.write(\"\"\"\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+SECRET_KEY = 'test'\n+USE_TZ = False\n+\"\"\")\n+\n+django.setup()\n+\n+# Define test model\n+class JsonFieldHasKeyTest(models.Model):\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(JsonFieldHasKeyTest)\n+\n+# Run tests\n+print(\"Creating test data...\")\n+test1 = JsonFieldHasKeyTest(data={'foo': 'bar'})\n+test2 = JsonFieldHasKeyTest(data={'1111': 'bar'})\n+test3 = JsonFieldHasKeyTest(data={'123': 'value'})\n+test4 = JsonFieldHasKeyTest(data={'key123': 'value'})\n+test1.save()\n+test2.save()\n+test3.save()\n+test4.save()\n+\n+print(\"\\nTesting has_key lookups...\")\n+print(f\"Count with key 'foo': {JsonFieldHasKeyTest.objects.filter(data__has_key='foo').count()}\")\n+print(f\"Count with key '1111': {JsonFieldHasKeyTest.objects.filter(data__has_key='1111').count()}\")\n+print(f\"Count with key '123': {JsonFieldHasKeyTest.objects.filter(data__has_key='123').count()}\")\n+print(f\"Count with key 'key123': {JsonFieldHasKeyTest.objects.filter(data__has_key='key123').count()}\")\n+\n+print(\"\\nChecking SQL queries...\")\n+from django.db import connection\n+with connection.cursor() as cursor:\n+    # Let's see what the actual SQL looks like\n+    queries = JsonFieldHasKeyTest.objects.filter(data__has_key='1111').query\n+    print(f\"Query for numeric key '1111': {queries}\")\n+    \n+    queries2 = JsonFieldHasKeyTest.objects.filter(data__has_key='foo').query  \n+    print(f\"Query for text key 'foo': {queries2}\")\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..833d089dbb\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,13 @@\n+\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+SECRET_KEY = 'test'\n+USE_TZ = False\n", "gold_standard_diff": "From a88fab1bca33c037bd1a12459c215d7bc1247735 Mon Sep 17 00:00:00 2001\nFrom: Sage Abdullah <me@laymonage.com>\nDate: Sat, 12 Mar 2022 13:16:08 +0700\nSubject: [PATCH] Fixed #33552 -- Fixed JSONField has key lookups with numeric\n keys on MariaDB, MySQL, Oracle, and SQLite.\n\n---\n django/db/models/fields/json.py      | 26 ++++++++++++++++----------\n tests/model_fields/test_jsonfield.py | 27 +++++++++++++++++++++++++++\n 2 files changed, 43 insertions(+), 10 deletions(-)\n\ndiff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fdca700c9da9..7424f46e660c 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -172,6 +172,10 @@ def as_sql(self, compiler, connection):\n class HasKeyLookup(PostgresOperatorLookup):\n     logical_operator = None\n \n+    def compile_json_path_final_key(self, key_transform):\n+        # Compile the final key without interpreting ints as array elements.\n+        return \".%s\" % json.dumps(key_transform)\n+\n     def as_sql(self, compiler, connection, template=None):\n         # Process JSON path from the left-hand side.\n         if isinstance(self.lhs, KeyTransform):\n@@ -193,13 +197,10 @@ def as_sql(self, compiler, connection, template=None):\n                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n             else:\n                 rhs_key_transforms = [key]\n-            rhs_params.append(\n-                \"%s%s\"\n-                % (\n-                    lhs_json_path,\n-                    compile_json_path(rhs_key_transforms, include_root=False),\n-                )\n-            )\n+            *rhs_key_transforms, final_key = rhs_key_transforms\n+            rhs_json_path = compile_json_path(rhs_key_transforms, include_root=False)\n+            rhs_json_path += self.compile_json_path_final_key(final_key)\n+            rhs_params.append(lhs_json_path + rhs_json_path)\n         # Add condition for each key.\n         if self.logical_operator:\n             sql = \"(%s)\" % self.logical_operator.join([sql] * len(rhs_params))\n@@ -253,6 +254,11 @@ class HasAnyKeys(HasKeys):\n     logical_operator = \" OR \"\n \n \n+class HasKeyOrArrayIndex(HasKey):\n+    def compile_json_path_final_key(self, key_transform):\n+        return compile_json_path([key_transform], include_root=False)\n+\n+\n class CaseInsensitiveMixin:\n     \"\"\"\n     Mixin to allow case-insensitive comparison of JSON values on MySQL.\n@@ -387,7 +393,7 @@ def __init__(self, key_transform, *args, **kwargs):\n class KeyTransformIsNull(lookups.IsNull):\n     # key__isnull=False is the same as has_key='key'\n     def as_oracle(self, compiler, connection):\n-        sql, params = HasKey(\n+        sql, params = HasKeyOrArrayIndex(\n             self.lhs.lhs,\n             self.lhs.key_name,\n         ).as_oracle(compiler, connection)\n@@ -401,7 +407,7 @@ def as_sqlite(self, compiler, connection):\n         template = \"JSON_TYPE(%s, %%s) IS NULL\"\n         if not self.rhs:\n             template = \"JSON_TYPE(%s, %%s) IS NOT NULL\"\n-        return HasKey(self.lhs.lhs, self.lhs.key_name).as_sql(\n+        return HasKeyOrArrayIndex(self.lhs.lhs, self.lhs.key_name).as_sql(\n             compiler,\n             connection,\n             template=template,\n@@ -466,7 +472,7 @@ def as_oracle(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n         if rhs_params == [\"null\"]:\n             # Field has key and it's NULL.\n-            has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\n+            has_key_expr = HasKeyOrArrayIndex(self.lhs.lhs, self.lhs.key_name)\n             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)\n             is_null_expr = self.lhs.get_lookup(\"isnull\")(self.lhs, True)\n             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex dfd00f4745c6..38c92fc51802 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -576,6 +576,33 @@ def test_has_any_keys(self):\n             [self.objs[3], self.objs[4], self.objs[6]],\n         )\n \n+    def test_has_key_number(self):\n+        obj = NullableJSONModel.objects.create(\n+            value={\n+                \"123\": \"value\",\n+                \"nested\": {\"456\": \"bar\", \"lorem\": \"abc\", \"999\": True},\n+                \"array\": [{\"789\": \"baz\", \"777\": \"def\", \"ipsum\": 200}],\n+                \"000\": \"val\",\n+            }\n+        )\n+        tests = [\n+            Q(value__has_key=\"123\"),\n+            Q(value__nested__has_key=\"456\"),\n+            Q(value__array__0__has_key=\"789\"),\n+            Q(value__has_keys=[\"nested\", \"123\", \"array\", \"000\"]),\n+            Q(value__nested__has_keys=[\"lorem\", \"999\", \"456\"]),\n+            Q(value__array__0__has_keys=[\"789\", \"ipsum\", \"777\"]),\n+            Q(value__has_any_keys=[\"000\", \"nonexistent\"]),\n+            Q(value__nested__has_any_keys=[\"999\", \"nonexistent\"]),\n+            Q(value__array__0__has_any_keys=[\"777\", \"nonexistent\"]),\n+        ]\n+        for condition in tests:\n+            with self.subTest(condition=condition):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(condition),\n+                    [obj],\n+                )\n+\n     @skipUnlessDBFeature(\"supports_json_field_contains\")\n     def test_contains(self):\n         tests = [\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15503"}