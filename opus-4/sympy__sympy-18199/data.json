{"instance_id": "sympy__sympy-18199", "score": "I", "diff": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3..2717876196 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -775,6 +775,11 @@ def nthroot_mod(a, n, p, all_roots=False):\n         return None\n     if not isprime(p):\n         raise NotImplementedError(\"Not implemented for composite p\")\n+    \n+    # Special case: when a % p == 0, the only solution is x = 0 (mod p)\n+    # This is because for prime p, if p | x^n, then p | x\n+    if a % p == 0:\n+        return [0] if all_roots else 0\n \n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\ndiff --git a/sympy/ntheory/tests/test_residue.py b/sympy/ntheory/tests/test_residue.py\nindex d4854547be..d94567f41a 100644\n--- a/sympy/ntheory/tests/test_residue.py\n+++ b/sympy/ntheory/tests/test_residue.py\n@@ -172,6 +172,18 @@ def test_residue():\n     assert nthroot_mod(11, 3, 109) is None\n     raises(NotImplementedError, lambda: nthroot_mod(16, 5, 36))\n     raises(NotImplementedError, lambda: nthroot_mod(9, 16, 36))\n+    \n+    # Test case for issue: nthroot_mod should handle a % p == 0 correctly\n+    # When a % p == 0, the only solution is x = 0 (mod p) for prime p\n+    assert nthroot_mod(17*17, 5, 17) == 0\n+    assert nthroot_mod(17*17, 5, 17, all_roots=True) == [0]\n+    assert nthroot_mod(0, 4, 17) == 0\n+    assert nthroot_mod(0, 4, 17, all_roots=True) == [0]\n+    for n in [2, 3, 4, 5, 6, 7, 8]:\n+        assert nthroot_mod(0, n, 17) == 0\n+        assert nthroot_mod(0, n, 17, all_roots=True) == [0]\n+        assert nthroot_mod(17, n, 17) == 0\n+        assert nthroot_mod(17, n, 17, all_roots=True) == [0]\n \n     for p in primerange(5, 100):\n         qv = range(3, p, 4)\ndiff --git a/test_issue_fix.py b/test_issue_fix.py\nnew file mode 100644\nindex 0000000000..b8d67ff5bd\n--- /dev/null\n+++ b/test_issue_fix.py\n@@ -0,0 +1,53 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test script to demonstrate the fix for the nthroot_mod issue.\n+\n+Issue: nthroot_mod function misses one root of x = 0 mod p.\n+When in the equation x**n = a mod p, when a % p == 0, then x = 0 mod p is also a root.\n+\"\"\"\n+\n+from sympy.ntheory import nthroot_mod\n+\n+print(\"Testing the fix for nthroot_mod with a % p == 0\")\n+print(\"=\" * 50)\n+\n+# Original issue case\n+print(\"\\nOriginal issue case: nthroot_mod(17*17, 5, 17)\")\n+print(f\"17*17 = {17*17}, and {17*17} mod 17 = {(17*17) % 17}\")\n+result = nthroot_mod(17*17, 5, 17)\n+print(f\"nthroot_mod(17*17, 5, 17) = {result}\")\n+print(f\"Verification: {result}^5 mod 17 = {pow(result, 5, 17)}\")\n+\n+result_all = nthroot_mod(17*17, 5, 17, all_roots=True)\n+print(f\"nthroot_mod(17*17, 5, 17, all_roots=True) = {result_all}\")\n+\n+# Test case that was failing before the fix\n+print(\"\\n\\nTest case that was failing (n=4):\")\n+print(\"nthroot_mod(0, 4, 17)\")\n+try:\n+    result = nthroot_mod(0, 4, 17)\n+    print(f\"Result: {result}\")\n+    print(f\"Verification: {result}^4 mod 17 = {pow(result, 4, 17)}\")\n+except Exception as e:\n+    print(f\"ERROR: {e}\")\n+\n+# More test cases\n+print(\"\\n\\nAdditional test cases with a % p == 0:\")\n+test_cases = [\n+    (0, 3, 17, \"Direct zero\"),\n+    (17, 5, 17, \"a = p\"),\n+    (34, 7, 17, \"a = 2*p\"),\n+    (51, 6, 17, \"a = 3*p\"),\n+]\n+\n+for a, n, p, desc in test_cases:\n+    print(f\"\\n{desc}: x^{n} = {a} mod {p} (where {a} mod {p} = {a % p})\")\n+    result = nthroot_mod(a, n, p, all_roots=True)\n+    print(f\"Roots: {result}\")\n+    if result:\n+        for x in result:\n+            print(f\"  Verify: {x}^{n} mod {p} = {pow(x, n, p)}\")\n+\n+print(\"\\n\\nConclusion: The fix correctly handles the case when a % p == 0.\")\n+print(\"For prime p, when a % p == 0, the equation x^n = a (mod p) has\")\n+print(\"exactly one solution: x = 0 (mod p).\")\n", "gold_standard_diff": "diff --git a/sympy/ntheory/residue_ntheory.py b/sympy/ntheory/residue_ntheory.py\nindex 9a3052d4c3b7..fd0acecd59ca 100644\n--- a/sympy/ntheory/residue_ntheory.py\n+++ b/sympy/ntheory/residue_ntheory.py\n@@ -2,6 +2,7 @@\n \n from sympy.core.compatibility import as_int, range\n from sympy.core.function import Function\n+from sympy.utilities.iterables import cartes\n from sympy.core.numbers import igcd, igcdex, mod_inverse\n from sympy.core.power import isqrt\n from sympy.core.singleton import S\n@@ -742,6 +743,48 @@ def _nthroot_mod1(s, q, p, all_roots):\n         return res\n     return min(res)\n \n+def _nthroot_mod_composite(a, n, m):\n+    \"\"\"\n+    Find the solutions to ``x**n = a mod m`` when m is not prime.\n+    \"\"\"\n+    from sympy.ntheory.modular import crt\n+    f = factorint(m)\n+    dd = {}\n+    for p, e in f.items():\n+        tot_roots = set()\n+        if e == 1:\n+            tot_roots.update(nthroot_mod(a, n, p, True) or [])\n+        else:\n+            for root in nthroot_mod(a, n, p, True) or []:\n+                rootn = pow(root, n)\n+                diff = (rootn // (root or 1) * n) % p\n+                if diff != 0:\n+                    ppow = p\n+                    for j in range(1, e):\n+                        ppow *= p\n+                        root = (root - (rootn - a) * mod_inverse(diff, p)) % ppow\n+                    tot_roots.add(root)\n+                else:\n+                    new_base = p\n+                    roots_in_base = {root}\n+                    while new_base < pow(p, e):\n+                        new_base *= p\n+                        new_roots = set()\n+                        for k in roots_in_base:\n+                            if (pow(k, n) - a) % (new_base) != 0:\n+                                continue\n+                            while k not in new_roots:\n+                                new_roots.add(k)\n+                                k = (k + (new_base // p)) % new_base\n+                        roots_in_base = new_roots\n+                    tot_roots = tot_roots | roots_in_base\n+        dd[pow(p, e)] = tot_roots\n+    a = []\n+    m = []\n+    for x, y in dd.items():\n+        m.append(x)\n+        a.append(list(y))\n+    return sorted(set(crt(m, list(i))[0] for i in cartes(*a)))\n \n def nthroot_mod(a, n, p, all_roots=False):\n     \"\"\"\n@@ -771,11 +814,12 @@ def nthroot_mod(a, n, p, all_roots=False):\n     if n == 2:\n         return sqrt_mod(a, p, all_roots)\n     # see Hackman \"Elementary Number Theory\" (2009), page 76\n+    if not isprime(p):\n+        return _nthroot_mod_composite(a, n, p)\n+    if a % p == 0:\n+        return [0]\n     if not is_nthpow_residue(a, n, p):\n         return None\n-    if not isprime(p):\n-        raise NotImplementedError(\"Not implemented for composite p\")\n-\n     if (p - 1) % n == 0:\n         return _nthroot_mod1(a, n, p, all_roots)\n     # The roots of ``x**n - a = 0 (mod p)`` are roots of\ndiff --git a/sympy/ntheory/tests/test_residue.py b/sympy/ntheory/tests/test_residue.py\nindex d4854547bee3..fdc09e3e715a 100644\n--- a/sympy/ntheory/tests/test_residue.py\n+++ b/sympy/ntheory/tests/test_residue.py\n@@ -162,7 +162,8 @@ def test_residue():\n     assert is_nthpow_residue(31, 4, 41)\n     assert not is_nthpow_residue(2, 2, 5)\n     assert is_nthpow_residue(8547, 12, 10007)\n-    raises(NotImplementedError, lambda: nthroot_mod(29, 31, 74))\n+\n+    assert nthroot_mod(29, 31, 74) == [45]\n     assert nthroot_mod(1801, 11, 2663) == 44\n     for a, q, p in [(51922, 2, 203017), (43, 3, 109), (1801, 11, 2663),\n           (26118163, 1303, 33333347), (1499, 7, 2663), (595, 6, 2663),\n@@ -170,8 +171,12 @@ def test_residue():\n         r = nthroot_mod(a, q, p)\n         assert pow(r, q, p) == a\n     assert nthroot_mod(11, 3, 109) is None\n-    raises(NotImplementedError, lambda: nthroot_mod(16, 5, 36))\n-    raises(NotImplementedError, lambda: nthroot_mod(9, 16, 36))\n+    assert nthroot_mod(16, 5, 36, True) == [4, 22]\n+    assert nthroot_mod(9, 16, 36, True) == [3, 9, 15, 21, 27, 33]\n+    assert nthroot_mod(4, 3, 3249000) == []\n+    assert nthroot_mod(36010, 8, 87382, True) == [40208, 47174]\n+    assert nthroot_mod(0, 12, 37, True) == [0]\n+    assert nthroot_mod(0, 7, 100, True) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n \n     for p in primerange(5, 100):\n         qv = range(3, p, 4)\ndiff --git a/sympy/solvers/tests/test_solveset.py b/sympy/solvers/tests/test_solveset.py\nindex 47eeebabd815..9cec0839aaef 100644\n--- a/sympy/solvers/tests/test_solveset.py\n+++ b/sympy/solvers/tests/test_solveset.py\n@@ -2242,11 +2242,12 @@ def test_solve_modular():\n     assert solveset(Mod(3**(3**x), 4) - 3, x, S.Integers) == \\\n             Intersection(ImageSet(Lambda(n, Intersection({log(2*n + 1)/log(3)},\n             S.Integers)), S.Naturals0), S.Integers)\n-    # Not Implemented for m without primitive root\n+    # Implemented for m without primitive root\n     assert solveset(Mod(x**3, 8) - 1, x, S.Integers) == \\\n-            ConditionSet(x, Eq(Mod(x**3, 8) - 1, 0), S.Integers)\n+            ImageSet(Lambda(n, 8*n + 1), S.Integers)\n     assert solveset(Mod(x**4, 9) - 4, x, S.Integers) == \\\n-            ConditionSet(x, Eq(Mod(x**4, 9) - 4, 0), S.Integers)\n+            Union(ImageSet(Lambda(n, 9*n + 4), S.Integers),\n+            ImageSet(Lambda(n, 9*n + 5), S.Integers))\n     # domain intersection\n     assert solveset(3 - Mod(5*x - 8, 7), x, S.Naturals0) == \\\n             Intersection(ImageSet(Lambda(n, 7*n + 5), S.Integers), S.Naturals0)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/18199"}