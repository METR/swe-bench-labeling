{"instance_id": "pydata__xarray-3305", "score": "C", "diff": "diff --git a/test_quantile_attrs.py b/test_quantile_attrs.py\nnew file mode 100644\nindex 00000000..b649f68b\n--- /dev/null\n+++ b/test_quantile_attrs.py\n@@ -0,0 +1,20 @@\n+import xarray as xr\n+\n+# Test case from the issue\n+da = xr.DataArray([0, 0], dims=\"x\", attrs={'units':'K'})\n+print(\"Original attrs:\", da.attrs)\n+\n+# Test with keep_attrs=True\n+out = da.quantile(.9, dim='x', keep_attrs=True)\n+print(\"After quantile with keep_attrs=True:\", out.attrs)\n+print(\"Expected: OrderedDict([('units', 'K')])\")\n+\n+# Test with keep_attrs=False\n+out2 = da.quantile(.9, dim='x', keep_attrs=False)\n+print(\"\\nAfter quantile with keep_attrs=False:\", out2.attrs)\n+print(\"Expected: OrderedDict()\")\n+\n+# Test with keep_attrs=None (default)\n+out3 = da.quantile(.9, dim='x')\n+print(\"\\nAfter quantile with keep_attrs=None (default):\", out3.attrs)\n+print(\"Expected: OrderedDict() (default behavior)\")\ndiff --git a/test_quantile_attrs_comprehensive.py b/test_quantile_attrs_comprehensive.py\nnew file mode 100644\nindex 00000000..f6cca717\n--- /dev/null\n+++ b/test_quantile_attrs_comprehensive.py\n@@ -0,0 +1,51 @@\n+import xarray as xr\n+import numpy as np\n+\n+print(\"Test 1: Single quantile with attributes\")\n+da = xr.DataArray([0, 1, 2, 3, 4], dims=\"x\", attrs={'units': 'K', 'description': 'temperature'})\n+print(\"Original attrs:\", da.attrs)\n+out = da.quantile(0.5, dim='x', keep_attrs=True)\n+print(\"After quantile(0.5) with keep_attrs=True:\", out.attrs)\n+print(\"Expected: same as original\\n\")\n+\n+print(\"Test 2: Multiple quantiles with attributes\") \n+da = xr.DataArray([0, 1, 2, 3, 4], dims=\"x\", attrs={'units': 'K'})\n+out = da.quantile([0.25, 0.5, 0.75], dim='x', keep_attrs=True)\n+print(\"After quantile([0.25, 0.5, 0.75]) with keep_attrs=True:\", out.attrs)\n+print(\"Expected: OrderedDict([('units', 'K')])\\n\")\n+\n+print(\"Test 3: No dimension reduction (quantile over all dims)\")\n+da = xr.DataArray([[0, 1], [2, 3]], dims=[\"x\", \"y\"], attrs={'units': 'K'})\n+out = da.quantile(0.5, keep_attrs=True)\n+print(\"After quantile(0.5) over all dims with keep_attrs=True:\", out.attrs)\n+print(\"Expected: OrderedDict([('units', 'K')])\\n\")\n+\n+print(\"Test 4: Dataset quantile preserving DataArray attributes\")\n+ds = xr.Dataset({\n+    'temp': xr.DataArray([0, 1, 2], dims='x', attrs={'units': 'K'}),\n+    'pressure': xr.DataArray([100, 101, 102], dims='x', attrs={'units': 'Pa'})\n+})\n+print(\"Original dataset variable attrs:\")\n+print(\"  temp:\", ds['temp'].attrs)\n+print(\"  pressure:\", ds['pressure'].attrs)\n+\n+out_ds = ds.quantile(0.5, dim='x', keep_attrs=True)\n+print(\"After dataset quantile with keep_attrs=True:\")\n+print(\"  temp:\", out_ds['temp'].attrs)\n+print(\"  pressure:\", out_ds['pressure'].attrs)\n+print(\"Expected: same as original\\n\")\n+\n+print(\"Test 5: Test with coordinates having attributes\")\n+da = xr.DataArray(\n+    [0, 1, 2, 3, 4], \n+    dims=\"x\",\n+    coords={'x': xr.DataArray(range(5), dims='x', attrs={'units': 'meters'})},\n+    attrs={'units': 'K'}\n+)\n+print(\"Original data attrs:\", da.attrs)\n+print(\"Original coord attrs:\", da.coords['x'].attrs)\n+out = da.quantile(0.5, dim='x', keep_attrs=True)\n+print(\"After quantile:\")\n+print(\"  data attrs:\", out.attrs)\n+# Note: coordinate attributes behavior might be different\n+print(\"Expected data attrs: OrderedDict([('units', 'K')])\")\ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex d6f0da42..015b99e8 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -4768,7 +4768,8 @@ class Dataset(Mapping, ImplementsDatasetReduce, DataWithCoords):\n                             # the former is often more efficient\n                             reduce_dims = None\n                         variables[name] = var.quantile(\n-                            q, dim=reduce_dims, interpolation=interpolation\n+                            q, dim=reduce_dims, interpolation=interpolation, \n+                            keep_attrs=keep_attrs\n                         )\n \n             else:\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 2e9906ce..4937aa34 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1592,7 +1592,7 @@ class Variable(\n         \"\"\"\n         return self.broadcast_equals(other, equiv=duck_array_ops.array_notnull_equiv)\n \n-    def quantile(self, q, dim=None, interpolation=\"linear\"):\n+    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):\n         \"\"\"Compute the qth quantile of the data along the specified dimension.\n \n         Returns the qth quantiles(s) of the array elements.\n@@ -1615,6 +1615,10 @@ class Variable(\n                 * higher: ``j``.\n                 * nearest: ``i`` or ``j``, whichever is nearest.\n                 * midpoint: ``(i + j) / 2``.\n+        keep_attrs : bool, optional\n+            If True, the variable's attributes (`attrs`) will be copied from\n+            the original object to the new one.  If False (default), the new\n+            object will be returned without attributes.\n \n         Returns\n         -------\n@@ -1658,7 +1662,12 @@ class Variable(\n         qs = np.nanpercentile(\n             self.data, q * 100.0, axis=axis, interpolation=interpolation\n         )\n-        return Variable(new_dims, qs)\n+        \n+        if keep_attrs is None:\n+            keep_attrs = _get_keep_attrs(default=False)\n+        attrs = self._attrs if keep_attrs else None\n+        \n+        return Variable(new_dims, qs, attrs=attrs)\n \n     def rank(self, dim, pct=False):\n         \"\"\"Ranks the data.\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex d81986cb948..ab4b17ff16d 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -26,8 +26,8 @@ Breaking changes\n \n - The ``isel_points`` and ``sel_points`` methods are removed, having been deprecated\n   since v0.10.0. These are redundant with the ``isel`` / ``sel`` methods.\n-  See :ref:`vectorized_indexing` for the details \n-  By `Maximilian Roos <https://github.com/max-sixty>`_ \n+  See :ref:`vectorized_indexing` for the details\n+  By `Maximilian Roos <https://github.com/max-sixty>`_\n - The ``inplace`` kwarg for public methods now raises an error, having been deprecated\n   since v0.11.0.\n   By `Maximilian Roos <https://github.com/max-sixty>`_\n@@ -52,12 +52,12 @@ Breaking changes\n     error in a later release.\n \n   (:issue:`3250`) by `Guido Imperiale <https://github.com/crusaderky>`_.\n-- :py:meth:`~Dataset.to_dataset` requires ``name`` to be passed as a kwarg (previously ambiguous \n+- :py:meth:`~Dataset.to_dataset` requires ``name`` to be passed as a kwarg (previously ambiguous\n   positional arguments were deprecated)\n - Reindexing with variables of a different dimension now raise an error (previously deprecated)\n-- :py:func:`~xarray.broadcast_array` is removed (previously deprecated in favor of \n+- :py:func:`~xarray.broadcast_array` is removed (previously deprecated in favor of\n   :py:func:`~xarray.broadcast`)\n-- :py:meth:`~Variable.expand_dims` is removed (previously deprecated in favor of \n+- :py:meth:`~Variable.expand_dims` is removed (previously deprecated in favor of\n   :py:meth:`~Variable.set_dims`)\n \n New functions/methods\n@@ -90,7 +90,7 @@ New functions/methods\n   and `Maximilian Roos <https://github.com/max-sixty>`_.\n \n - Added :py:meth:`DataArray.broadcast_like` and :py:meth:`Dataset.broadcast_like`.\n-  By `Deepak Cherian <https://github.com/dcherian>`_ and `David Mertz \n+  By `Deepak Cherian <https://github.com/dcherian>`_ and `David Mertz\n   <http://github.com/DavidMertz>`_.\n \n - Dataset plotting API for visualizing dependencies between two `DataArray`s!\n@@ -131,14 +131,14 @@ Enhancements\n   :py:meth:`DataArray.set_index`, as well are more specific error messages\n   when the user passes invalid arguments (:issue:`3176`).\n   By `Gregory Gundersen <https://github.com/gwgundersen>`_.\n-  \n+\n - :py:func:`filter_by_attrs` now filters the coordinates as well as the variables. By `Spencer Jones <https://github.com/cspencerjones>`_.\n \n Bug fixes\n ~~~~~~~~~\n \n-- Improve \"missing dimensions\" error message for :py:func:`~xarray.apply_ufunc` \n-  (:issue:`2078`). \n+- Improve \"missing dimensions\" error message for :py:func:`~xarray.apply_ufunc`\n+  (:issue:`2078`).\n   By `Rick Russotto <https://github.com/rdrussotto>`_.\n - :py:meth:`~xarray.DataArray.assign_coords` now supports dictionary arguments\n   (:issue:`3231`).\n@@ -170,6 +170,8 @@ Bug fixes\n   dask compute (:issue:`3237`). By `Ulrich Herter <https://github.com/ulijh>`_.\n - Plots in 2 dimensions (pcolormesh, contour) now allow to specify levels as numpy\n   array (:issue:`3284`). By `Mathias Hauser <https://github.com/mathause>`_.\n+- Fixed bug in :meth:`DataArray.quantile` failing to keep attributes when\n+  `keep_attrs` was True (:issue:`3304`). By David Huard <https://github.com/huard>`_.\n \n .. _whats-new.0.12.3:\n \ndiff --git a/xarray/core/dataset.py b/xarray/core/dataset.py\nindex d6f0da42722..fae086e85ac 100644\n--- a/xarray/core/dataset.py\n+++ b/xarray/core/dataset.py\n@@ -4768,7 +4768,10 @@ def quantile(\n                             # the former is often more efficient\n                             reduce_dims = None\n                         variables[name] = var.quantile(\n-                            q, dim=reduce_dims, interpolation=interpolation\n+                            q,\n+                            dim=reduce_dims,\n+                            interpolation=interpolation,\n+                            keep_attrs=keep_attrs,\n                         )\n \n             else:\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 2e9906ce5ae..b4b01f7ee49 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -1592,7 +1592,7 @@ def no_conflicts(self, other):\n         \"\"\"\n         return self.broadcast_equals(other, equiv=duck_array_ops.array_notnull_equiv)\n \n-    def quantile(self, q, dim=None, interpolation=\"linear\"):\n+    def quantile(self, q, dim=None, interpolation=\"linear\", keep_attrs=None):\n         \"\"\"Compute the qth quantile of the data along the specified dimension.\n \n         Returns the qth quantiles(s) of the array elements.\n@@ -1615,6 +1615,10 @@ def quantile(self, q, dim=None, interpolation=\"linear\"):\n                 * higher: ``j``.\n                 * nearest: ``i`` or ``j``, whichever is nearest.\n                 * midpoint: ``(i + j) / 2``.\n+        keep_attrs : bool, optional\n+            If True, the variable's attributes (`attrs`) will be copied from\n+            the original object to the new one.  If False (default), the new\n+            object will be returned without attributes.\n \n         Returns\n         -------\n@@ -1623,7 +1627,7 @@ def quantile(self, q, dim=None, interpolation=\"linear\"):\n             is a scalar. If multiple percentiles are given, first axis of\n             the result corresponds to the quantile and a quantile dimension\n             is added to the return array. The other dimensions are the\n-             dimensions that remain after the reduction of the array.\n+            dimensions that remain after the reduction of the array.\n \n         See Also\n         --------\n@@ -1651,14 +1655,19 @@ def quantile(self, q, dim=None, interpolation=\"linear\"):\n             axis = None\n             new_dims = []\n \n-        # only add the quantile dimension if q is array like\n+        # Only add the quantile dimension if q is array-like\n         if q.ndim != 0:\n             new_dims = [\"quantile\"] + new_dims\n \n         qs = np.nanpercentile(\n             self.data, q * 100.0, axis=axis, interpolation=interpolation\n         )\n-        return Variable(new_dims, qs)\n+\n+        if keep_attrs is None:\n+            keep_attrs = _get_keep_attrs(default=False)\n+        attrs = self._attrs if keep_attrs else None\n+\n+        return Variable(new_dims, qs, attrs)\n \n     def rank(self, dim, pct=False):\n         \"\"\"Ranks the data.\ndiff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex 8c01ef9a68c..dd6d7f8fefc 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -2298,17 +2298,17 @@ def test_reduce_out(self):\n         with pytest.raises(TypeError):\n             orig.mean(out=np.ones(orig.shape))\n \n-    # skip due to bug in older versions of numpy.nanpercentile\n     def test_quantile(self):\n         for q in [0.25, [0.50], [0.25, 0.75]]:\n             for axis, dim in zip(\n                 [None, 0, [0], [0, 1]], [None, \"x\", [\"x\"], [\"x\", \"y\"]]\n             ):\n-                actual = self.dv.quantile(q, dim=dim)\n+                actual = DataArray(self.va).quantile(q, dim=dim, keep_attrs=True)\n                 expected = np.nanpercentile(\n                     self.dv.values, np.array(q) * 100, axis=axis\n                 )\n                 np.testing.assert_allclose(actual.values, expected)\n+                assert actual.attrs == self.attrs\n \n     def test_reduce_keep_attrs(self):\n         # Test dropped attrs\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/3305"}