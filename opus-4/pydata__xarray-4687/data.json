{"instance_id": "pydata__xarray-4687", "score": "I", "diff": "diff --git a/debug_merge_attrs.py b/debug_merge_attrs.py\nnew file mode 100644\nindex 00000000..5c7cd860\n--- /dev/null\n+++ b/debug_merge_attrs.py\n@@ -0,0 +1,32 @@\n+import xarray as xr\n+from xarray.core.merge import merge_attrs\n+\n+# Test 1: Test with empty attrs first \n+attrs_list = [{}, {'foo': 'bar'}, {'baz': 'qux'}]\n+print(\"Test 1: Empty attrs first\")\n+print(f\"attrs_list: {attrs_list}\")\n+print(f\"override: {merge_attrs(attrs_list, 'override')}\")\n+print()\n+\n+# Test 2: Test with attrs in first position\n+attrs_list = [{'foo': 'bar'}, {}, {'baz': 'qux'}]\n+print(\"Test 2: Attrs in first position\")\n+print(f\"attrs_list: {attrs_list}\")\n+print(f\"override: {merge_attrs(attrs_list, 'override')}\")\n+print()\n+\n+# Test 3: Test the actual case for where function\n+# In xr.where(cond, x, y), the arguments are ordered as cond, x, y\n+# The condition typically has no attrs\n+cond = xr.DataArray(True)\n+x = xr.DataArray(5)\n+x.attrs['x_attr'] = 'x_value'\n+y = xr.DataArray(0)\n+y.attrs['y_attr'] = 'y_value'\n+\n+attrs_list = [cond.attrs, x.attrs, y.attrs]\n+print(\"Test 3: Simulating xr.where case\")\n+print(f\"cond.attrs: {cond.attrs}\")\n+print(f\"x.attrs: {x.attrs}\")\n+print(f\"y.attrs: {y.attrs}\")\n+print(f\"merge_attrs with override: {merge_attrs(attrs_list, 'override')}\")\ndiff --git a/test_where_attrs.py b/test_where_attrs.py\nnew file mode 100644\nindex 00000000..16a82bed\n--- /dev/null\n+++ b/test_where_attrs.py\n@@ -0,0 +1,81 @@\n+import numpy as np\n+import xarray as xr\n+\n+# Test case 1: Basic test from the issue\n+print(\"Test 1: Basic DataArray\")\n+data = xr.DataArray(np.ones([10,10], dtype=np.int8))\n+data.attrs[\"attr_1\"] = \"test1\"\n+data.attrs[\"attr_2\"] = \"test2\"\n+print(f\"Original attrs: {data.attrs}\")\n+\n+data2 = xr.where(data == 1, 5, 0)\n+print(f\"After where attrs: {data2.attrs}\")\n+print(f\"Original dtype: {data.dtype}, After where dtype: {data2.dtype}\")\n+print()\n+\n+# Test case 2: Simple test from second issue report\n+print(\"Test 2: Simple scalar DataArray\")\n+da = xr.DataArray(1)\n+da.attrs['foo'] = 'bar'\n+print(f\"Original attrs: {da.attrs}\")\n+result = xr.where(da==0, -1, da)\n+print(f\"After where attrs: {result.attrs}\")\n+print()\n+\n+# Test case 3: Test with keep_attrs option (if we add it)\n+print(\"Test 3: Testing if keep_attrs works in apply_ufunc\")\n+from xarray.core import duck_array_ops\n+from xarray import apply_ufunc\n+\n+da = xr.DataArray(1)\n+da.attrs['foo'] = 'bar'\n+print(f\"Original attrs: {da.attrs}\")\n+\n+# Try with keep_attrs=True - all DataArrays\n+x_da = xr.DataArray(-1)\n+result_with_attrs = apply_ufunc(\n+    duck_array_ops.where,\n+    da==0,\n+    x_da,\n+    da,\n+    join=\"exact\",\n+    dataset_join=\"exact\",\n+    dask=\"allowed\",\n+    keep_attrs=True\n+)\n+print(f\"With keep_attrs=True (all DataArrays): {result_with_attrs.attrs}\")\n+\n+# Also test what happens if we give attrs to x\n+x_da.attrs['x_attr'] = 'x_value'\n+result_with_attrs = apply_ufunc(\n+    duck_array_ops.where,\n+    da==0,\n+    x_da,\n+    da,\n+    join=\"exact\",\n+    dataset_join=\"exact\",\n+    dask=\"allowed\",\n+    keep_attrs=True\n+)\n+print(f\"With keep_attrs=True (x has attrs too): {result_with_attrs.attrs}\")\n+\n+print()\n+print(\"Test 4: Debug - check argument order\")\n+# The issue might be that the condition comes first\n+cond = xr.DataArray(True)\n+x = xr.DataArray(5)\n+x.attrs['x_attr'] = 'x_value'\n+y = xr.DataArray(0)\n+y.attrs['y_attr'] = 'y_value'\n+\n+result = apply_ufunc(\n+    duck_array_ops.where,\n+    cond,\n+    x,\n+    y,\n+    join=\"exact\",\n+    dataset_join=\"exact\",\n+    dask=\"allowed\",\n+    keep_attrs=True\n+)\n+print(f\"cond has no attrs, x has attrs, y has attrs: {result.attrs}\")\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88..f0e57580 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,7 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+def where(cond, x, y, keep_attrs=None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1743,6 +1743,9 @@ def where(cond, x, y):\n         values to choose from where `cond` is True\n     y : scalar, array, Variable, DataArray or Dataset\n         values to choose from where `cond` is False\n+    keep_attrs : bool or None, optional\n+        If True, the attributes (``attrs``) will be copied from the first input to the\n+        output one. If False (default), the output will be given a new empty ``attrs``.\n \n     Returns\n     -------\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex cb0e9b654bd..89040c6dc5b 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -23,7 +23,8 @@ New Features\n ~~~~~~~~~~~~\n - New top-level function :py:func:`cross`. (:issue:`3279`, :pull:`5365`).\n   By `Jimmy Westling <https://github.com/illviljan>`_.\n-\n+- ``keep_attrs`` support for :py:func:`where` (:issue:`4141`, :issue:`4682`, :pull:`4687`).\n+  By `Justus Magin <https://github.com/keewis>`_.\n - Enable the limit option for dask array in the following methods :py:meth:`DataArray.ffill`, :py:meth:`DataArray.bfill`, :py:meth:`Dataset.ffill` and :py:meth:`Dataset.bfill` (:issue:`6112`)\n   By `Joseph Nowak <https://github.com/josephnowak>`_.\n \ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 9fe93c88734..5e6340feed2 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1727,7 +1727,7 @@ def dot(*arrays, dims=None, **kwargs):\n     return result.transpose(*all_dims, missing_dims=\"ignore\")\n \n \n-def where(cond, x, y):\n+def where(cond, x, y, keep_attrs=None):\n     \"\"\"Return elements from `x` or `y` depending on `cond`.\n \n     Performs xarray-like broadcasting across input arguments.\n@@ -1743,6 +1743,8 @@ def where(cond, x, y):\n         values to choose from where `cond` is True\n     y : scalar, array, Variable, DataArray or Dataset\n         values to choose from where `cond` is False\n+    keep_attrs : bool or str or callable, optional\n+        How to treat attrs. If True, keep the attrs of `x`.\n \n     Returns\n     -------\n@@ -1808,6 +1810,14 @@ def where(cond, x, y):\n     Dataset.where, DataArray.where :\n         equivalent methods\n     \"\"\"\n+    if keep_attrs is None:\n+        keep_attrs = _get_keep_attrs(default=False)\n+\n+    if keep_attrs is True:\n+        # keep the attributes of x, the second parameter, by default to\n+        # be consistent with the `where` method of `DataArray` and `Dataset`\n+        keep_attrs = lambda attrs, context: attrs[1]\n+\n     # alignment for three arguments is complicated, so don't support it yet\n     return apply_ufunc(\n         duck_array_ops.where,\n@@ -1817,6 +1827,7 @@ def where(cond, x, y):\n         join=\"exact\",\n         dataset_join=\"exact\",\n         dask=\"allowed\",\n+        keep_attrs=keep_attrs,\n     )\n \n \ndiff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex c9a10b7cc43..a51bfb03641 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1922,6 +1922,15 @@ def test_where() -> None:\n     assert_identical(expected, actual)\n \n \n+def test_where_attrs() -> None:\n+    cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"cond\"})\n+    x = xr.DataArray([1, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    y = xr.DataArray([0, 0], dims=\"x\", attrs={\"attr\": \"y\"})\n+    actual = xr.where(cond, x, y, keep_attrs=True)\n+    expected = xr.DataArray([1, 0], dims=\"x\", attrs={\"attr\": \"x\"})\n+    assert_identical(expected, actual)\n+\n+\n @pytest.mark.parametrize(\"use_dask\", [True, False])\n @pytest.mark.parametrize(\"use_datetime\", [True, False])\n def test_polyval(use_dask, use_datetime) -> None:\ndiff --git a/xarray/tests/test_units.py b/xarray/tests/test_units.py\nindex f36143c52c3..1225ecde5fb 100644\n--- a/xarray/tests/test_units.py\n+++ b/xarray/tests/test_units.py\n@@ -2429,10 +2429,7 @@ def test_binary_operations(self, func, dtype):\n         (\n             pytest.param(operator.lt, id=\"less_than\"),\n             pytest.param(operator.ge, id=\"greater_equal\"),\n-            pytest.param(\n-                operator.eq,\n-                id=\"equal\",\n-            ),\n+            pytest.param(operator.eq, id=\"equal\"),\n         ),\n     )\n     @pytest.mark.parametrize(\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/4687"}