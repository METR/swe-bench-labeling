diff --git a/django/utils/html.py b/django/utils/html.py
index 9c519978f5..b4a546df46 100644
--- a/django/utils/html.py
+++ b/django/utils/html.py
@@ -1,5 +1,6 @@
 """HTML utilities suitable for global use."""
 
+import html
 import json
 import re
 from html.parser import HTMLParser
@@ -24,14 +25,6 @@ word_split_re = re.compile(r'''([\s<>"']+)''')
 simple_url_re = re.compile(r'^https?://\[?\w', re.IGNORECASE)
 simple_url_2_re = re.compile(r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)
 
-_html_escapes = {
-    ord('&'): '&amp;',
-    ord('<'): '&lt;',
-    ord('>'): '&gt;',
-    ord('"'): '&quot;',
-    ord("'"): '&#39;',
-}
-
 
 @keep_lazy(str, SafeString)
 def escape(text):
@@ -43,7 +36,7 @@ def escape(text):
     This may result in double-escaping. If this is a concern, use
     conditional_escape() instead.
     """
-    return mark_safe(str(text).translate(_html_escapes))
+    return mark_safe(html.escape(str(text)))
 
 
 _js_escapes = {
diff --git a/django/utils/html.py.backup b/django/utils/html.py.backup
new file mode 100644
index 0000000000..9c519978f5
--- /dev/null
+++ b/django/utils/html.py.backup
@@ -0,0 +1,390 @@
+"""HTML utilities suitable for global use."""
+
+import json
+import re
+from html.parser import HTMLParser
+from urllib.parse import (
+    parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,
+)
+
+from django.utils.functional import Promise, keep_lazy, keep_lazy_text
+from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS
+from django.utils.safestring import SafeData, SafeString, mark_safe
+from django.utils.text import normalize_newlines
+
+# Configuration for urlize() function.
+TRAILING_PUNCTUATION_CHARS = '.,:;!'
+WRAPPING_PUNCTUATION = [('(', ')'), ('[', ']')]
+
+# List of possible strings used for bullets in bulleted lists.
+DOTS = ['&middot;', '*', '\u2022', '&#149;', '&bull;', '&#8226;']
+
+unencoded_ampersands_re = re.compile(r'&(?!(\w+|#\d+);)')
+word_split_re = re.compile(r'''([\s<>"']+)''')
+simple_url_re = re.compile(r'^https?://\[?\w', re.IGNORECASE)
+simple_url_2_re = re.compile(r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)
+
+_html_escapes = {
+    ord('&'): '&amp;',
+    ord('<'): '&lt;',
+    ord('>'): '&gt;',
+    ord('"'): '&quot;',
+    ord("'"): '&#39;',
+}
+
+
+@keep_lazy(str, SafeString)
+def escape(text):
+    """
+    Return the given text with ampersands, quotes and angle brackets encoded
+    for use in HTML.
+
+    Always escape input, even if it's already escaped and marked as such.
+    This may result in double-escaping. If this is a concern, use
+    conditional_escape() instead.
+    """
+    return mark_safe(str(text).translate(_html_escapes))
+
+
+_js_escapes = {
+    ord('\\'): '\\u005C',
+    ord('\''): '\\u0027',
+    ord('"'): '\\u0022',
+    ord('>'): '\\u003E',
+    ord('<'): '\\u003C',
+    ord('&'): '\\u0026',
+    ord('='): '\\u003D',
+    ord('-'): '\\u002D',
+    ord(';'): '\\u003B',
+    ord('`'): '\\u0060',
+    ord('\u2028'): '\\u2028',
+    ord('\u2029'): '\\u2029'
+}
+
+# Escape every ASCII character with a value less than 32.
+_js_escapes.update((ord('%c' % z), '\\u%04X' % z) for z in range(32))
+
+
+@keep_lazy(str, SafeString)
+def escapejs(value):
+    """Hex encode characters for use in JavaScript strings."""
+    return mark_safe(str(value).translate(_js_escapes))
+
+
+_json_script_escapes = {
+    ord('>'): '\\u003E',
+    ord('<'): '\\u003C',
+    ord('&'): '\\u0026',
+}
+
+
+def json_script(value, element_id):
+    """
+    Escape all the HTML/XML special characters with their unicode escapes, so
+    value is safe to be output anywhere except for inside a tag attribute. Wrap
+    the escaped JSON in a script tag.
+    """
+    from django.core.serializers.json import DjangoJSONEncoder
+    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)
+    return format_html(
+        '<script id="{}" type="application/json">{}</script>',
+        element_id, mark_safe(json_str)
+    )
+
+
+def conditional_escape(text):
+    """
+    Similar to escape(), except that it doesn't operate on pre-escaped strings.
+
+    This function relies on the __html__ convention used both by Django's
+    SafeData class and by third-party libraries like markupsafe.
+    """
+    if isinstance(text, Promise):
+        text = str(text)
+    if hasattr(text, '__html__'):
+        return text.__html__()
+    else:
+        return escape(text)
+
+
+def format_html(format_string, *args, **kwargs):
+    """
+    Similar to str.format, but pass all arguments through conditional_escape(),
+    and call mark_safe() on the result. This function should be used instead
+    of str.format or % interpolation to build up small HTML fragments.
+    """
+    args_safe = map(conditional_escape, args)
+    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}
+    return mark_safe(format_string.format(*args_safe, **kwargs_safe))
+
+
+def format_html_join(sep, format_string, args_generator):
+    """
+    A wrapper of format_html, for the common case of a group of arguments that
+    need to be formatted using the same format string, and then joined using
+    'sep'. 'sep' is also passed through conditional_escape.
+
+    'args_generator' should be an iterator that returns the sequence of 'args'
+    that will be passed to format_html.
+
+    Example:
+
+      format_html_join('\n', "<li>{} {}</li>", ((u.first_name, u.last_name)
+                                                  for u in users))
+    """
+    return mark_safe(conditional_escape(sep).join(
+        format_html(format_string, *args)
+        for args in args_generator
+    ))
+
+
+@keep_lazy_text
+def linebreaks(value, autoescape=False):
+    """Convert newlines into <p> and <br>s."""
+    value = normalize_newlines(value)
+    paras = re.split('\n{2,}', str(value))
+    if autoescape:
+        paras = ['<p>%s</p>' % escape(p).replace('\n', '<br>') for p in paras]
+    else:
+        paras = ['<p>%s</p>' % p.replace('\n', '<br>') for p in paras]
+    return '\n\n'.join(paras)
+
+
+class MLStripper(HTMLParser):
+    def __init__(self):
+        super().__init__(convert_charrefs=False)
+        self.reset()
+        self.fed = []
+
+    def handle_data(self, d):
+        self.fed.append(d)
+
+    def handle_entityref(self, name):
+        self.fed.append('&%s;' % name)
+
+    def handle_charref(self, name):
+        self.fed.append('&#%s;' % name)
+
+    def get_data(self):
+        return ''.join(self.fed)
+
+
+def _strip_once(value):
+    """
+    Internal tag stripping utility used by strip_tags.
+    """
+    s = MLStripper()
+    s.feed(value)
+    s.close()
+    return s.get_data()
+
+
+@keep_lazy_text
+def strip_tags(value):
+    """Return the given HTML with all tags stripped."""
+    # Note: in typical case this loop executes _strip_once once. Loop condition
+    # is redundant, but helps to reduce number of executions of _strip_once.
+    value = str(value)
+    while '<' in value and '>' in value:
+        new_value = _strip_once(value)
+        if len(new_value) >= len(value):
+            # _strip_once was not able to detect more tags
+            break
+        value = new_value
+    return value
+
+
+@keep_lazy_text
+def strip_spaces_between_tags(value):
+    """Return the given HTML with spaces between tags removed."""
+    return re.sub(r'>\s+<', '><', str(value))
+
+
+def smart_urlquote(url):
+    """Quote a URL if it isn't already quoted."""
+    def unquote_quote(segment):
+        segment = unquote(segment)
+        # Tilde is part of RFC3986 Unreserved Characters
+        # https://tools.ietf.org/html/rfc3986#section-2.3
+        # See also https://bugs.python.org/issue16285
+        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + '~')
+
+    # Handle IDN before quoting.
+    try:
+        scheme, netloc, path, query, fragment = urlsplit(url)
+    except ValueError:
+        # invalid IPv6 URL (normally square brackets in hostname part).
+        return unquote_quote(url)
+
+    try:
+        netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE
+    except UnicodeError:  # invalid domain part
+        return unquote_quote(url)
+
+    if query:
+        # Separately unquoting key/value, so as to not mix querystring separators
+        # included in query values. See #22267.
+        query_parts = [(unquote(q[0]), unquote(q[1]))
+                       for q in parse_qsl(query, keep_blank_values=True)]
+        # urlencode will take care of quoting
+        query = urlencode(query_parts)
+
+    path = unquote_quote(path)
+    fragment = unquote_quote(fragment)
+
+    return urlunsplit((scheme, netloc, path, query, fragment))
+
+
+@keep_lazy_text
+def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):
+    """
+    Convert any URLs in text into clickable links.
+
+    Works on http://, https://, www. links, and also on links ending in one of
+    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).
+    Links can have trailing punctuation (periods, commas, close-parens) and
+    leading punctuation (opening parens) and it'll still do the right thing.
+
+    If trim_url_limit is not None, truncate the URLs in the link text longer
+    than this limit to trim_url_limit - 1 characters and append an ellipsis.
+
+    If nofollow is True, give the links a rel="nofollow" attribute.
+
+    If autoescape is True, autoescape the link text and URLs.
+    """
+    safe_input = isinstance(text, SafeData)
+
+    def trim_url(x, limit=trim_url_limit):
+        if limit is None or len(x) <= limit:
+            return x
+        return '%sâ€¦' % x[:max(0, limit - 1)]
+
+    def unescape(text):
+        """
+        If input URL is HTML-escaped, unescape it so that it can be safely fed
+        to smart_urlquote. For example:
+        http://example.com?x=1&amp;y=&lt;2&gt; => http://example.com?x=1&y=<2>
+        """
+        return text.replace('&amp;', '&').replace('&lt;', '<').replace(
+            '&gt;', '>').replace('&quot;', '"').replace('&#39;', "'")
+
+    def trim_punctuation(lead, middle, trail):
+        """
+        Trim trailing and wrapping punctuation from `middle`. Return the items
+        of the new state.
+        """
+        # Continue trimming until middle remains unchanged.
+        trimmed_something = True
+        while trimmed_something:
+            trimmed_something = False
+            # Trim wrapping punctuation.
+            for opening, closing in WRAPPING_PUNCTUATION:
+                if middle.startswith(opening):
+                    middle = middle[len(opening):]
+                    lead += opening
+                    trimmed_something = True
+                # Keep parentheses at the end only if they're balanced.
+                if (middle.endswith(closing) and
+                        middle.count(closing) == middle.count(opening) + 1):
+                    middle = middle[:-len(closing)]
+                    trail = closing + trail
+                    trimmed_something = True
+            # Trim trailing punctuation (after trimming wrapping punctuation,
+            # as encoded entities contain ';'). Unescape entites to avoid
+            # breaking them by removing ';'.
+            middle_unescaped = unescape(middle)
+            stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)
+            if middle_unescaped != stripped:
+                trail = middle[len(stripped):] + trail
+                middle = middle[:len(stripped) - len(middle_unescaped)]
+                trimmed_something = True
+        return lead, middle, trail
+
+    def is_email_simple(value):
+        """Return True if value looks like an email address."""
+        # An @ must be in the middle of the value.
+        if '@' not in value or value.startswith('@') or value.endswith('@'):
+            return False
+        try:
+            p1, p2 = value.split('@')
+        except ValueError:
+            # value contains more than one @.
+            return False
+        # Dot must be in p2 (e.g. example.com)
+        if '.' not in p2 or p2.startswith('.'):
+            return False
+        return True
+
+    words = word_split_re.split(str(text))
+    for i, word in enumerate(words):
+        if '.' in word or '@' in word or ':' in word:
+            # lead: Current punctuation trimmed from the beginning of the word.
+            # middle: Current state of the word.
+            # trail: Current punctuation trimmed from the end of the word.
+            lead, middle, trail = '', word, ''
+            # Deal with punctuation.
+            lead, middle, trail = trim_punctuation(lead, middle, trail)
+
+            # Make URL we want to point to.
+            url = None
+            nofollow_attr = ' rel="nofollow"' if nofollow else ''
+            if simple_url_re.match(middle):
+                url = smart_urlquote(unescape(middle))
+            elif simple_url_2_re.match(middle):
+                url = smart_urlquote('http://%s' % unescape(middle))
+            elif ':' not in middle and is_email_simple(middle):
+                local, domain = middle.rsplit('@', 1)
+                try:
+                    domain = domain.encode('idna').decode('ascii')
+                except UnicodeError:
+                    continue
+                url = 'mailto:%s@%s' % (local, domain)
+                nofollow_attr = ''
+
+            # Make link.
+            if url:
+                trimmed = trim_url(middle)
+                if autoescape and not safe_input:
+                    lead, trail = escape(lead), escape(trail)
+                    trimmed = escape(trimmed)
+                middle = '<a href="%s"%s>%s</a>' % (escape(url), nofollow_attr, trimmed)
+                words[i] = mark_safe('%s%s%s' % (lead, middle, trail))
+            else:
+                if safe_input:
+                    words[i] = mark_safe(word)
+                elif autoescape:
+                    words[i] = escape(word)
+        elif safe_input:
+            words[i] = mark_safe(word)
+        elif autoescape:
+            words[i] = escape(word)
+    return ''.join(words)
+
+
+def avoid_wrapping(value):
+    """
+    Avoid text wrapping in the middle of a phrase by adding non-breaking
+    spaces where there previously were normal spaces.
+    """
+    return value.replace(" ", "\xa0")
+
+
+def html_safe(klass):
+    """
+    A decorator that defines the __html__ method. This helps non-Django
+    templates to detect classes whose __str__ methods return SafeString.
+    """
+    if '__html__' in klass.__dict__:
+        raise ValueError(
+            "can't apply @html_safe to %s because it defines "
+            "__html__()." % klass.__name__
+        )
+    if '__str__' not in klass.__dict__:
+        raise ValueError(
+            "can't apply @html_safe to %s because it doesn't "
+            "define __str__()." % klass.__name__
+        )
+    klass_str = klass.__str__
+    klass.__str__ = lambda self: mark_safe(klass_str(self))
+    klass.__html__ = lambda self: str(self)
+    return klass
diff --git a/fix_tests.py b/fix_tests.py
new file mode 100644
index 0000000000..5ecf4fe416
--- /dev/null
+++ b/fix_tests.py
@@ -0,0 +1,16 @@
+#!/usr/bin/env python3
+
+# Read the test file
+with open('/testbed/tests/utils_tests/test_html.py', 'r', encoding='utf-8') as f:
+    content = f.read()
+
+# Replace &#39; with &#x27;
+content = content.replace("(\"'\", '&#39;'),", "(\"'\", '&#x27;'),")
+content = content.replace("'<p>See: &#39;&eacute; is an apostrophe followed by e acute</p>',", "'<p>See: &#x27;&eacute; is an apostrophe followed by e acute</p>',")
+content = content.replace("'See: &#39;&eacute; is an apostrophe followed by e acute'", "'See: &#x27;&eacute; is an apostrophe followed by e acute'")
+
+# Write the file back
+with open('/testbed/tests/utils_tests/test_html.py', 'w', encoding='utf-8') as f:
+    f.write(content)
+
+print("Tests fixed successfully")
diff --git a/patch_escape.py b/patch_escape.py
new file mode 100644
index 0000000000..6c68e8423f
--- /dev/null
+++ b/patch_escape.py
@@ -0,0 +1,26 @@
+#!/usr/bin/env python3
+import re
+
+# Read the file
+with open('/testbed/django/utils/html.py', 'r', encoding='utf-8') as f:
+    content = f.read()
+
+# Find and replace the escape function
+# We need to preserve the decorator and docstring but change the implementation
+pattern = r'''(@keep_lazy\(str, SafeString\)\ndef escape\(text\):\n    """\n    Return the given text with ampersands, quotes and angle brackets encoded\n    for use in HTML\.\n\n    Always escape input, even if it's already escaped and marked as such\.\n    This may result in double-escaping\. If this is a concern, use\n    conditional_escape\(\) instead\.\n    """\n)    return mark_safe\(str\(text\)\.translate\(_html_escapes\)\)'''
+
+replacement = r'''\1    return mark_safe(html.escape(str(text)))'''
+
+# Apply the replacement
+new_content = re.sub(pattern, replacement, content, flags=re.MULTILINE | re.DOTALL)
+
+# Also remove the _html_escapes dictionary since we won't need it anymore
+# Find the pattern for _html_escapes
+escapes_pattern = r'''_html_escapes = \{[^}]+\}\n\n'''
+new_content = re.sub(escapes_pattern, '', new_content, flags=re.MULTILINE | re.DOTALL)
+
+# Write the file back
+with open('/testbed/django/utils/html.py', 'w', encoding='utf-8') as f:
+    f.write(new_content)
+
+print("File patched successfully")
diff --git a/test_escape_comparison.py b/test_escape_comparison.py
new file mode 100644
index 0000000000..4354b4f576
--- /dev/null
+++ b/test_escape_comparison.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+import html
+from django.utils.html import escape as django_escape
+
+# Test characters
+test_chars = [
+    ('&', 'Ampersand'),
+    ('<', 'Less than'),
+    ('>', 'Greater than'), 
+    ('"', 'Double quote'),
+    ("'", 'Single quote/apostrophe'),
+]
+
+print("Comparison of escape functions:")
+print("-" * 60)
+
+for char, name in test_chars:
+    django_result = django_escape(char)
+    html_result = html.escape(char)
+    
+    print(f"{name} ({char}):")
+    print(f"  Django: {django_result}")
+    print(f"  html.escape: {html_result}")
+    if django_result != html_result:
+        print(f"  >>> DIFFERENT! <<<")
+    print()
+
+# Test a more complex string
+test_string = "This & that < something > with \"quotes\" and 'apostrophes'"
+print("Complex string test:")
+print(f"Original: {test_string}")
+print(f"Django: {django_escape(test_string)}")
+print(f"html.escape: {html.escape(test_string)}")
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/admin_docs/test_views.py b/tests/admin_docs/test_views.py
index bcadff7d8a..cffa435747 100644
--- a/tests/admin_docs/test_views.py
+++ b/tests/admin_docs/test_views.py
@@ -199,7 +199,7 @@ class TestModelDetailView(TestDataMixin, AdminDocsTestCase):
         """
         Methods with keyword arguments should have their arguments displayed.
         """
-        self.assertContains(self.response, "<td>suffix=&#39;ltd&#39;</td>")
+        self.assertContains(self.response, "<td>suffix=&#x27;ltd&#x27;</td>")
 
     def test_methods_with_multiple_arguments_display_arguments(self):
         """
diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py
index e12cf0161f..e36931501e 100644
--- a/tests/auth_tests/test_forms.py
+++ b/tests/auth_tests/test_forms.py
@@ -236,7 +236,7 @@ class UserCreationFormTest(TestDataMixin, TestCase):
         form = UserCreationForm()
         self.assertEqual(
             form.fields['password1'].help_text,
-            '<ul><li>Your password can&#39;t be too similar to your other personal information.</li></ul>'
+            '<ul><li>Your password can&#x27;t be too similar to your other personal information.</li></ul>'
         )
 
     @override_settings(AUTH_PASSWORD_VALIDATORS=[
diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py
index edce5e801f..18fb4a94de 100644
--- a/tests/forms_tests/tests/test_forms.py
+++ b/tests/forms_tests/tests/test_forms.py
@@ -995,7 +995,7 @@ Java</label></li>
         self.assertHTMLEqual(
             f.as_table(),
             """<tr><th>&lt;em&gt;Special&lt;/em&gt; Field:</th><td>
-<ul class="errorlist"><li>Something&#39;s wrong with &#39;Nothing to escape&#39;</li></ul>
+<ul class="errorlist"><li>Something&#x27;s wrong with &#x27;Nothing to escape&#x27;</li></ul>
 <input type="text" name="special_name" value="Nothing to escape" required></td></tr>
 <tr><th><em>Special</em> Field:</th><td>
 <ul class="errorlist"><li>'<b>Nothing to escape</b>' is a safe string</li></ul>
@@ -1008,10 +1008,10 @@ Java</label></li>
         self.assertHTMLEqual(
             f.as_table(),
             """<tr><th>&lt;em&gt;Special&lt;/em&gt; Field:</th><td>
-<ul class="errorlist"><li>Something&#39;s wrong with &#39;Should escape &lt; &amp; &gt; and
-&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&#39;</li></ul>
+<ul class="errorlist"><li>Something&#x27;s wrong with &#x27;Should escape &lt; &amp; &gt; and
+&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&#x27;</li></ul>
 <input type="text" name="special_name"
-value="Should escape &lt; &amp; &gt; and &lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;" required></td></tr>
+value="Should escape &lt; &amp; &gt; and &lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;" required></td></tr>
 <tr><th><em>Special</em> Field:</th><td>
 <ul class="errorlist"><li>'<b><i>Do not escape</i></b>' is a safe string</li></ul>
 <input type="text" name="special_safe_name" value="&lt;i&gt;Do not escape&lt;/i&gt;" required></td></tr>"""
@@ -2632,7 +2632,7 @@ Password: <input type="password" name="password" required>
             t.render(Context({'form': UserRegistration(auto_id=False)})),
             """<form>
 <p>Username: <input type="text" name="username" maxlength="10" required><br>
-Good luck picking a username that doesn&#39;t already exist.</p>
+Good luck picking a username that doesn&#x27;t already exist.</p>
 <p>Password1: <input type="password" name="password1" required></p>
 <p>Password2: <input type="password" name="password2" required></p>
 <input type="submit" required>
diff --git a/tests/forms_tests/widget_tests/test_clearablefileinput.py b/tests/forms_tests/widget_tests/test_clearablefileinput.py
index 2ba376db8a..ff6a1c74e7 100644
--- a/tests/forms_tests/widget_tests/test_clearablefileinput.py
+++ b/tests/forms_tests/widget_tests/test_clearablefileinput.py
@@ -46,7 +46,7 @@ class ClearableFileInputTest(WidgetTest):
         self.check_html(ClearableFileInput(), 'my<div>file', StrangeFieldFile(), html=(
             """
             Currently: <a href="something?chapter=1&amp;sect=2&amp;copy=3&amp;lang=en">
-            something&lt;div onclick=&quot;alert(&#39;oops&#39;)&quot;&gt;.jpg</a>
+            something&lt;div onclick=&quot;alert(&#x27;oops&#x27;)&quot;&gt;.jpg</a>
             <input type="checkbox" name="my&lt;div&gt;file-clear" id="my&lt;div&gt;file-clear_id">
             <label for="my&lt;div&gt;file-clear_id">Clear</label><br>
             Change: <input type="file" name="my&lt;div&gt;file">
diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py
index e4f24c31ee..cef6c24958 100644
--- a/tests/model_forms/tests.py
+++ b/tests/model_forms/tests.py
@@ -1197,7 +1197,7 @@ class ModelFormBasicTests(TestCase):
 <li>Article: <textarea rows="10" cols="40" name="article" required></textarea></li>
 <li>Categories: <select multiple name="categories">
 <option value="%s" selected>Entertainment</option>
-<option value="%s" selected>It&#39;s a test</option>
+<option value="%s" selected>It&#x27;s a test</option>
 <option value="%s">Third test</option>
 </select></li>
 <li>Status: <select name="status">
@@ -1239,7 +1239,7 @@ class ModelFormBasicTests(TestCase):
 <li>Article: <textarea rows="10" cols="40" name="article" required>Hello.</textarea></li>
 <li>Categories: <select multiple name="categories">
 <option value="%s">Entertainment</option>
-<option value="%s">It&#39;s a test</option>
+<option value="%s">It&#x27;s a test</option>
 <option value="%s">Third test</option>
 </select></li>
 <li>Status: <select name="status">
@@ -1361,7 +1361,7 @@ class ModelFormBasicTests(TestCase):
 <tr><th>Article:</th><td><textarea rows="10" cols="40" name="article" required></textarea></td></tr>
 <tr><th>Categories:</th><td><select multiple name="categories">
 <option value="%s">Entertainment</option>
-<option value="%s">It&#39;s a test</option>
+<option value="%s">It&#x27;s a test</option>
 <option value="%s">Third test</option>
 </select></td></tr>
 <tr><th>Status:</th><td><select name="status">
@@ -1391,7 +1391,7 @@ class ModelFormBasicTests(TestCase):
 <li>Article: <textarea rows="10" cols="40" name="article" required>Hello.</textarea></li>
 <li>Categories: <select multiple name="categories">
 <option value="%s" selected>Entertainment</option>
-<option value="%s">It&#39;s a test</option>
+<option value="%s">It&#x27;s a test</option>
 <option value="%s">Third test</option>
 </select></li>
 <li>Status: <select name="status">
@@ -1535,7 +1535,7 @@ class ModelFormBasicTests(TestCase):
 <li>Article: <textarea rows="10" cols="40" name="article" required></textarea></li>
 <li>Categories: <select multiple name="categories">
 <option value="%s">Entertainment</option>
-<option value="%s">It&#39;s a test</option>
+<option value="%s">It&#x27;s a test</option>
 <option value="%s">Third test</option>
 </select> </li>
 <li>Status: <select name="status">
@@ -1561,7 +1561,7 @@ class ModelFormBasicTests(TestCase):
 <li>Article: <textarea rows="10" cols="40" name="article" required></textarea></li>
 <li>Categories: <select multiple name="categories">
 <option value="%s">Entertainment</option>
-<option value="%s">It&#39;s a test</option>
+<option value="%s">It&#x27;s a test</option>
 <option value="%s">Third test</option>
 <option value="%s">Fourth</option>
 </select></li>
diff --git a/tests/template_tests/filter_tests/test_addslashes.py b/tests/template_tests/filter_tests/test_addslashes.py
index 9c6abd8684..ede25cfb14 100644
--- a/tests/template_tests/filter_tests/test_addslashes.py
+++ b/tests/template_tests/filter_tests/test_addslashes.py
@@ -15,7 +15,7 @@ class AddslashesTests(SimpleTestCase):
     @setup({'addslashes02': '{{ a|addslashes }} {{ b|addslashes }}'})
     def test_addslashes02(self):
         output = self.engine.render_to_string('addslashes02', {"a": "<a>'", "b": mark_safe("<a>'")})
-        self.assertEqual(output, r"&lt;a&gt;\&#39; <a>\'")
+        self.assertEqual(output, r"&lt;a&gt;\&#x27; <a>\'")
 
 
 class FunctionTests(SimpleTestCase):
diff --git a/tests/template_tests/filter_tests/test_make_list.py b/tests/template_tests/filter_tests/test_make_list.py
index 17c4cac480..6b2c03b7de 100644
--- a/tests/template_tests/filter_tests/test_make_list.py
+++ b/tests/template_tests/filter_tests/test_make_list.py
@@ -19,7 +19,7 @@ class MakeListTests(SimpleTestCase):
     @setup({'make_list02': '{{ a|make_list }}'})
     def test_make_list02(self):
         output = self.engine.render_to_string('make_list02', {"a": mark_safe("&")})
-        self.assertEqual(output, "[&#39;&amp;&#39;]")
+        self.assertEqual(output, "[&#x27;&amp;&#x27;]")
 
     @setup({'make_list03': '{% autoescape off %}{{ a|make_list|stringformat:"s"|safe }}{% endautoescape %}'})
     def test_make_list03(self):
diff --git a/tests/template_tests/filter_tests/test_title.py b/tests/template_tests/filter_tests/test_title.py
index 08a5fb0de4..2eaf4a0219 100644
--- a/tests/template_tests/filter_tests/test_title.py
+++ b/tests/template_tests/filter_tests/test_title.py
@@ -9,7 +9,7 @@ class TitleTests(SimpleTestCase):
     @setup({'title1': '{{ a|title }}'})
     def test_title1(self):
         output = self.engine.render_to_string('title1', {'a': 'JOE\'S CRAB SHACK'})
-        self.assertEqual(output, 'Joe&#39;s Crab Shack')
+        self.assertEqual(output, 'Joe&#x27;s Crab Shack')
 
     @setup({'title2': '{{ a|title }}'})
     def test_title2(self):
diff --git a/tests/template_tests/filter_tests/test_urlize.py b/tests/template_tests/filter_tests/test_urlize.py
index 649a965203..3843cc3e0a 100644
--- a/tests/template_tests/filter_tests/test_urlize.py
+++ b/tests/template_tests/filter_tests/test_urlize.py
@@ -52,7 +52,7 @@ class UrlizeTests(SimpleTestCase):
     @setup({'urlize06': '{{ a|urlize }}'})
     def test_urlize06(self):
         output = self.engine.render_to_string('urlize06', {'a': "<script>alert('foo')</script>"})
-        self.assertEqual(output, '&lt;script&gt;alert(&#39;foo&#39;)&lt;/script&gt;')
+        self.assertEqual(output, '&lt;script&gt;alert(&#x27;foo&#x27;)&lt;/script&gt;')
 
     # mailto: testing for urlize
     @setup({'urlize07': '{{ a|urlize }}'})
@@ -113,7 +113,7 @@ class FunctionTests(SimpleTestCase):
         )
         self.assertEqual(
             urlize('www.server.com\'abc'),
-            '<a href="http://www.server.com" rel="nofollow">www.server.com</a>&#39;abc',
+            '<a href="http://www.server.com" rel="nofollow">www.server.com</a>&#x27;abc',
         )
         self.assertEqual(
             urlize('www.server.com<abc'),
@@ -284,7 +284,7 @@ class FunctionTests(SimpleTestCase):
             ('<>', ('&lt;', '&gt;')),
             ('[]', ('[', ']')),
             ('""', ('&quot;', '&quot;')),
-            ("''", ('&#39;', '&#39;')),
+            ("''", ('&#x27;', '&#x27;')),
         )
         for wrapping_in, (start_out, end_out) in wrapping_chars:
             with self.subTest(wrapping_in=wrapping_in):
diff --git a/tests/template_tests/syntax_tests/test_url.py b/tests/template_tests/syntax_tests/test_url.py
index a6cc2d50a0..bdbc61454d 100644
--- a/tests/template_tests/syntax_tests/test_url.py
+++ b/tests/template_tests/syntax_tests/test_url.py
@@ -78,7 +78,7 @@ class UrlTagTests(SimpleTestCase):
     @setup({'url12': '{% url "client_action" id=client.id action="!$&\'()*+,;=~:@," %}'})
     def test_url12(self):
         output = self.engine.render_to_string('url12', {'client': {'id': 1}})
-        self.assertEqual(output, '/client/1/!$&amp;&#39;()*+,;=~:@,/')
+        self.assertEqual(output, '/client/1/!$&amp;&#x27;()*+,;=~:@,/')
 
     @setup({'url13': '{% url "client_action" id=client.id action=arg|join:"-" %}'})
     def test_url13(self):
diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py
index d87927cdfe..94e86c99ab 100644
--- a/tests/utils_tests/test_html.py
+++ b/tests/utils_tests/test_html.py
@@ -27,7 +27,7 @@ class TestUtilsHtml(SimpleTestCase):
             ('<', '&lt;'),
             ('>', '&gt;'),
             ('"', '&quot;'),
-            ("'", '&#39;'),
+            ("'", '&#x27;'),
         )
         # Substitution patterns for testing the above items.
         patterns = ("%s", "asdf%sfdsa", "%s1", "1%sb")
@@ -68,8 +68,8 @@ class TestUtilsHtml(SimpleTestCase):
 
     def test_strip_tags(self):
         items = (
-            ('<p>See: &#39;&eacute; is an apostrophe followed by e acute</p>',
-             'See: &#39;&eacute; is an apostrophe followed by e acute'),
+            ('<p>See: &#x27;&eacute; is an apostrophe followed by e acute</p>',
+             'See: &#x27;&eacute; is an apostrophe followed by e acute'),
             ('<adf>a', 'a'),
             ('</adf>a', 'a'),
             ('<asdf><asdf>e', 'e'),
diff --git a/tests/utils_tests/test_html.py.backup b/tests/utils_tests/test_html.py.backup
new file mode 100644
index 0000000000..9c519978f5
--- /dev/null
+++ b/tests/utils_tests/test_html.py.backup
@@ -0,0 +1,390 @@
+"""HTML utilities suitable for global use."""
+
+import json
+import re
+from html.parser import HTMLParser
+from urllib.parse import (
+    parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit,
+)
+
+from django.utils.functional import Promise, keep_lazy, keep_lazy_text
+from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS
+from django.utils.safestring import SafeData, SafeString, mark_safe
+from django.utils.text import normalize_newlines
+
+# Configuration for urlize() function.
+TRAILING_PUNCTUATION_CHARS = '.,:;!'
+WRAPPING_PUNCTUATION = [('(', ')'), ('[', ']')]
+
+# List of possible strings used for bullets in bulleted lists.
+DOTS = ['&middot;', '*', '\u2022', '&#149;', '&bull;', '&#8226;']
+
+unencoded_ampersands_re = re.compile(r'&(?!(\w+|#\d+);)')
+word_split_re = re.compile(r'''([\s<>"']+)''')
+simple_url_re = re.compile(r'^https?://\[?\w', re.IGNORECASE)
+simple_url_2_re = re.compile(r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$', re.IGNORECASE)
+
+_html_escapes = {
+    ord('&'): '&amp;',
+    ord('<'): '&lt;',
+    ord('>'): '&gt;',
+    ord('"'): '&quot;',
+    ord("'"): '&#39;',
+}
+
+
+@keep_lazy(str, SafeString)
+def escape(text):
+    """
+    Return the given text with ampersands, quotes and angle brackets encoded
+    for use in HTML.
+
+    Always escape input, even if it's already escaped and marked as such.
+    This may result in double-escaping. If this is a concern, use
+    conditional_escape() instead.
+    """
+    return mark_safe(str(text).translate(_html_escapes))
+
+
+_js_escapes = {
+    ord('\\'): '\\u005C',
+    ord('\''): '\\u0027',
+    ord('"'): '\\u0022',
+    ord('>'): '\\u003E',
+    ord('<'): '\\u003C',
+    ord('&'): '\\u0026',
+    ord('='): '\\u003D',
+    ord('-'): '\\u002D',
+    ord(';'): '\\u003B',
+    ord('`'): '\\u0060',
+    ord('\u2028'): '\\u2028',
+    ord('\u2029'): '\\u2029'
+}
+
+# Escape every ASCII character with a value less than 32.
+_js_escapes.update((ord('%c' % z), '\\u%04X' % z) for z in range(32))
+
+
+@keep_lazy(str, SafeString)
+def escapejs(value):
+    """Hex encode characters for use in JavaScript strings."""
+    return mark_safe(str(value).translate(_js_escapes))
+
+
+_json_script_escapes = {
+    ord('>'): '\\u003E',
+    ord('<'): '\\u003C',
+    ord('&'): '\\u0026',
+}
+
+
+def json_script(value, element_id):
+    """
+    Escape all the HTML/XML special characters with their unicode escapes, so
+    value is safe to be output anywhere except for inside a tag attribute. Wrap
+    the escaped JSON in a script tag.
+    """
+    from django.core.serializers.json import DjangoJSONEncoder
+    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)
+    return format_html(
+        '<script id="{}" type="application/json">{}</script>',
+        element_id, mark_safe(json_str)
+    )
+
+
+def conditional_escape(text):
+    """
+    Similar to escape(), except that it doesn't operate on pre-escaped strings.
+
+    This function relies on the __html__ convention used both by Django's
+    SafeData class and by third-party libraries like markupsafe.
+    """
+    if isinstance(text, Promise):
+        text = str(text)
+    if hasattr(text, '__html__'):
+        return text.__html__()
+    else:
+        return escape(text)
+
+
+def format_html(format_string, *args, **kwargs):
+    """
+    Similar to str.format, but pass all arguments through conditional_escape(),
+    and call mark_safe() on the result. This function should be used instead
+    of str.format or % interpolation to build up small HTML fragments.
+    """
+    args_safe = map(conditional_escape, args)
+    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}
+    return mark_safe(format_string.format(*args_safe, **kwargs_safe))
+
+
+def format_html_join(sep, format_string, args_generator):
+    """
+    A wrapper of format_html, for the common case of a group of arguments that
+    need to be formatted using the same format string, and then joined using
+    'sep'. 'sep' is also passed through conditional_escape.
+
+    'args_generator' should be an iterator that returns the sequence of 'args'
+    that will be passed to format_html.
+
+    Example:
+
+      format_html_join('\n', "<li>{} {}</li>", ((u.first_name, u.last_name)
+                                                  for u in users))
+    """
+    return mark_safe(conditional_escape(sep).join(
+        format_html(format_string, *args)
+        for args in args_generator
+    ))
+
+
+@keep_lazy_text
+def linebreaks(value, autoescape=False):
+    """Convert newlines into <p> and <br>s."""
+    value = normalize_newlines(value)
+    paras = re.split('\n{2,}', str(value))
+    if autoescape:
+        paras = ['<p>%s</p>' % escape(p).replace('\n', '<br>') for p in paras]
+    else:
+        paras = ['<p>%s</p>' % p.replace('\n', '<br>') for p in paras]
+    return '\n\n'.join(paras)
+
+
+class MLStripper(HTMLParser):
+    def __init__(self):
+        super().__init__(convert_charrefs=False)
+        self.reset()
+        self.fed = []
+
+    def handle_data(self, d):
+        self.fed.append(d)
+
+    def handle_entityref(self, name):
+        self.fed.append('&%s;' % name)
+
+    def handle_charref(self, name):
+        self.fed.append('&#%s;' % name)
+
+    def get_data(self):
+        return ''.join(self.fed)
+
+
+def _strip_once(value):
+    """
+    Internal tag stripping utility used by strip_tags.
+    """
+    s = MLStripper()
+    s.feed(value)
+    s.close()
+    return s.get_data()
+
+
+@keep_lazy_text
+def strip_tags(value):
+    """Return the given HTML with all tags stripped."""
+    # Note: in typical case this loop executes _strip_once once. Loop condition
+    # is redundant, but helps to reduce number of executions of _strip_once.
+    value = str(value)
+    while '<' in value and '>' in value:
+        new_value = _strip_once(value)
+        if len(new_value) >= len(value):
+            # _strip_once was not able to detect more tags
+            break
+        value = new_value
+    return value
+
+
+@keep_lazy_text
+def strip_spaces_between_tags(value):
+    """Return the given HTML with spaces between tags removed."""
+    return re.sub(r'>\s+<', '><', str(value))
+
+
+def smart_urlquote(url):
+    """Quote a URL if it isn't already quoted."""
+    def unquote_quote(segment):
+        segment = unquote(segment)
+        # Tilde is part of RFC3986 Unreserved Characters
+        # https://tools.ietf.org/html/rfc3986#section-2.3
+        # See also https://bugs.python.org/issue16285
+        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + '~')
+
+    # Handle IDN before quoting.
+    try:
+        scheme, netloc, path, query, fragment = urlsplit(url)
+    except ValueError:
+        # invalid IPv6 URL (normally square brackets in hostname part).
+        return unquote_quote(url)
+
+    try:
+        netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE
+    except UnicodeError:  # invalid domain part
+        return unquote_quote(url)
+
+    if query:
+        # Separately unquoting key/value, so as to not mix querystring separators
+        # included in query values. See #22267.
+        query_parts = [(unquote(q[0]), unquote(q[1]))
+                       for q in parse_qsl(query, keep_blank_values=True)]
+        # urlencode will take care of quoting
+        query = urlencode(query_parts)
+
+    path = unquote_quote(path)
+    fragment = unquote_quote(fragment)
+
+    return urlunsplit((scheme, netloc, path, query, fragment))
+
+
+@keep_lazy_text
+def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):
+    """
+    Convert any URLs in text into clickable links.
+
+    Works on http://, https://, www. links, and also on links ending in one of
+    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).
+    Links can have trailing punctuation (periods, commas, close-parens) and
+    leading punctuation (opening parens) and it'll still do the right thing.
+
+    If trim_url_limit is not None, truncate the URLs in the link text longer
+    than this limit to trim_url_limit - 1 characters and append an ellipsis.
+
+    If nofollow is True, give the links a rel="nofollow" attribute.
+
+    If autoescape is True, autoescape the link text and URLs.
+    """
+    safe_input = isinstance(text, SafeData)
+
+    def trim_url(x, limit=trim_url_limit):
+        if limit is None or len(x) <= limit:
+            return x
+        return '%sâ€¦' % x[:max(0, limit - 1)]
+
+    def unescape(text):
+        """
+        If input URL is HTML-escaped, unescape it so that it can be safely fed
+        to smart_urlquote. For example:
+        http://example.com?x=1&amp;y=&lt;2&gt; => http://example.com?x=1&y=<2>
+        """
+        return text.replace('&amp;', '&').replace('&lt;', '<').replace(
+            '&gt;', '>').replace('&quot;', '"').replace('&#39;', "'")
+
+    def trim_punctuation(lead, middle, trail):
+        """
+        Trim trailing and wrapping punctuation from `middle`. Return the items
+        of the new state.
+        """
+        # Continue trimming until middle remains unchanged.
+        trimmed_something = True
+        while trimmed_something:
+            trimmed_something = False
+            # Trim wrapping punctuation.
+            for opening, closing in WRAPPING_PUNCTUATION:
+                if middle.startswith(opening):
+                    middle = middle[len(opening):]
+                    lead += opening
+                    trimmed_something = True
+                # Keep parentheses at the end only if they're balanced.
+                if (middle.endswith(closing) and
+                        middle.count(closing) == middle.count(opening) + 1):
+                    middle = middle[:-len(closing)]
+                    trail = closing + trail
+                    trimmed_something = True
+            # Trim trailing punctuation (after trimming wrapping punctuation,
+            # as encoded entities contain ';'). Unescape entites to avoid
+            # breaking them by removing ';'.
+            middle_unescaped = unescape(middle)
+            stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)
+            if middle_unescaped != stripped:
+                trail = middle[len(stripped):] + trail
+                middle = middle[:len(stripped) - len(middle_unescaped)]
+                trimmed_something = True
+        return lead, middle, trail
+
+    def is_email_simple(value):
+        """Return True if value looks like an email address."""
+        # An @ must be in the middle of the value.
+        if '@' not in value or value.startswith('@') or value.endswith('@'):
+            return False
+        try:
+            p1, p2 = value.split('@')
+        except ValueError:
+            # value contains more than one @.
+            return False
+        # Dot must be in p2 (e.g. example.com)
+        if '.' not in p2 or p2.startswith('.'):
+            return False
+        return True
+
+    words = word_split_re.split(str(text))
+    for i, word in enumerate(words):
+        if '.' in word or '@' in word or ':' in word:
+            # lead: Current punctuation trimmed from the beginning of the word.
+            # middle: Current state of the word.
+            # trail: Current punctuation trimmed from the end of the word.
+            lead, middle, trail = '', word, ''
+            # Deal with punctuation.
+            lead, middle, trail = trim_punctuation(lead, middle, trail)
+
+            # Make URL we want to point to.
+            url = None
+            nofollow_attr = ' rel="nofollow"' if nofollow else ''
+            if simple_url_re.match(middle):
+                url = smart_urlquote(unescape(middle))
+            elif simple_url_2_re.match(middle):
+                url = smart_urlquote('http://%s' % unescape(middle))
+            elif ':' not in middle and is_email_simple(middle):
+                local, domain = middle.rsplit('@', 1)
+                try:
+                    domain = domain.encode('idna').decode('ascii')
+                except UnicodeError:
+                    continue
+                url = 'mailto:%s@%s' % (local, domain)
+                nofollow_attr = ''
+
+            # Make link.
+            if url:
+                trimmed = trim_url(middle)
+                if autoescape and not safe_input:
+                    lead, trail = escape(lead), escape(trail)
+                    trimmed = escape(trimmed)
+                middle = '<a href="%s"%s>%s</a>' % (escape(url), nofollow_attr, trimmed)
+                words[i] = mark_safe('%s%s%s' % (lead, middle, trail))
+            else:
+                if safe_input:
+                    words[i] = mark_safe(word)
+                elif autoescape:
+                    words[i] = escape(word)
+        elif safe_input:
+            words[i] = mark_safe(word)
+        elif autoescape:
+            words[i] = escape(word)
+    return ''.join(words)
+
+
+def avoid_wrapping(value):
+    """
+    Avoid text wrapping in the middle of a phrase by adding non-breaking
+    spaces where there previously were normal spaces.
+    """
+    return value.replace(" ", "\xa0")
+
+
+def html_safe(klass):
+    """
+    A decorator that defines the __html__ method. This helps non-Django
+    templates to detect classes whose __str__ methods return SafeString.
+    """
+    if '__html__' in klass.__dict__:
+        raise ValueError(
+            "can't apply @html_safe to %s because it defines "
+            "__html__()." % klass.__name__
+        )
+    if '__str__' not in klass.__dict__:
+        raise ValueError(
+            "can't apply @html_safe to %s because it doesn't "
+            "define __str__()." % klass.__name__
+        )
+    klass_str = klass.__str__
+    klass.__str__ = lambda self: mark_safe(klass_str(self))
+    klass.__html__ = lambda self: str(self)
+    return klass
diff --git a/tests/view_tests/tests/test_csrf.py b/tests/view_tests/tests/test_csrf.py
index 4c20cb897d..77f2373347 100644
--- a/tests/view_tests/tests/test_csrf.py
+++ b/tests/view_tests/tests/test_csrf.py
@@ -44,22 +44,22 @@ class CsrfViewTests(SimpleTestCase):
         self.assertContains(
             response,
             'You are seeing this message because this HTTPS site requires a '
-            '&#39;Referer header&#39; to be sent by your Web browser, but '
+            '&#x27;Referer header&#x27; to be sent by your Web browser, but '
             'none was sent.',
             status_code=403,
         )
         self.assertContains(
             response,
-            'If you have configured your browser to disable &#39;Referer&#39; '
+            'If you have configured your browser to disable &#x27;Referer&#x27; '
             'headers, please re-enable them, at least for this site, or for '
-            'HTTPS connections, or for &#39;same-origin&#39; requests.',
+            'HTTPS connections, or for &#x27;same-origin&#x27; requests.',
             status_code=403,
         )
         self.assertContains(
             response,
             'If you are using the &lt;meta name=&quot;referrer&quot; '
             'content=&quot;no-referrer&quot;&gt; tag or including the '
-            '&#39;Referrer-Policy: no-referrer&#39; header, please remove them.',
+            '&#x27;Referrer-Policy: no-referrer&#x27; header, please remove them.',
             status_code=403,
         )
 
diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py
index a61e4b24ff..abe41dc375 100644
--- a/tests/view_tests/tests/test_debug.py
+++ b/tests/view_tests/tests/test_debug.py
@@ -304,7 +304,7 @@ class ExceptionReporterTests(SimpleTestCase):
         reporter = ExceptionReporter(request, exc_type, exc_value, tb)
         html = reporter.get_traceback_html()
         self.assertInHTML('<h1>ValueError at /test_view/</h1>', html)
-        self.assertIn('<pre class="exception_value">Can&#39;t find my keys</pre>', html)
+        self.assertIn('<pre class="exception_value">Can&#x27;t find my keys</pre>', html)
         self.assertIn('<th>Request Method:</th>', html)
         self.assertIn('<th>Request URL:</th>', html)
         self.assertIn('<h3 id="user-info">USER</h3>', html)
@@ -325,7 +325,7 @@ class ExceptionReporterTests(SimpleTestCase):
         reporter = ExceptionReporter(None, exc_type, exc_value, tb)
         html = reporter.get_traceback_html()
         self.assertInHTML('<h1>ValueError</h1>', html)
-        self.assertIn('<pre class="exception_value">Can&#39;t find my keys</pre>', html)
+        self.assertIn('<pre class="exception_value">Can&#x27;t find my keys</pre>', html)
         self.assertNotIn('<th>Request Method:</th>', html)
         self.assertNotIn('<th>Request URL:</th>', html)
         self.assertNotIn('<h3 id="user-info">USER</h3>', html)
@@ -463,7 +463,7 @@ class ExceptionReporterTests(SimpleTestCase):
         reporter = ExceptionReporter(request, None, "I'm a little teapot", None)
         html = reporter.get_traceback_html()
         self.assertInHTML('<h1>Report at /test_view/</h1>', html)
-        self.assertIn('<pre class="exception_value">I&#39;m a little teapot</pre>', html)
+        self.assertIn('<pre class="exception_value">I&#x27;m a little teapot</pre>', html)
         self.assertIn('<th>Request Method:</th>', html)
         self.assertIn('<th>Request URL:</th>', html)
         self.assertNotIn('<th>Exception Type:</th>', html)
@@ -476,7 +476,7 @@ class ExceptionReporterTests(SimpleTestCase):
         reporter = ExceptionReporter(None, None, "I'm a little teapot", None)
         html = reporter.get_traceback_html()
         self.assertInHTML('<h1>Report</h1>', html)
-        self.assertIn('<pre class="exception_value">I&#39;m a little teapot</pre>', html)
+        self.assertIn('<pre class="exception_value">I&#x27;m a little teapot</pre>', html)
         self.assertNotIn('<th>Request Method:</th>', html)
         self.assertNotIn('<th>Request URL:</th>', html)
         self.assertNotIn('<th>Exception Type:</th>', html)
@@ -508,7 +508,7 @@ class ExceptionReporterTests(SimpleTestCase):
         except Exception:
             exc_type, exc_value, tb = sys.exc_info()
         html = ExceptionReporter(None, exc_type, exc_value, tb).get_traceback_html()
-        self.assertIn('<td class="code"><pre>&#39;&lt;p&gt;Local variable&lt;/p&gt;&#39;</pre></td>', html)
+        self.assertIn('<td class="code"><pre>&#x27;&lt;p&gt;Local variable&lt;/p&gt;&#x27;</pre></td>', html)
 
     def test_unprintable_values_handling(self):
         "Unprintable values should not make the output generation choke."
@@ -607,7 +607,7 @@ class ExceptionReporterTests(SimpleTestCase):
         An exception report can be generated for requests with 'items' in
         request GET, POST, FILES, or COOKIES QueryDicts.
         """
-        value = '<td>items</td><td class="code"><pre>&#39;Oops&#39;</pre></td>'
+        value = '<td>items</td><td class="code"><pre>&#x27;Oops&#x27;</pre></td>'
         # GET
         request = self.rf.get('/test_view/?items=Oops')
         reporter = ExceptionReporter(request, None, None, None)
@@ -634,7 +634,7 @@ class ExceptionReporterTests(SimpleTestCase):
         request = rf.get('/test_view/')
         reporter = ExceptionReporter(request, None, None, None)
         html = reporter.get_traceback_html()
-        self.assertInHTML('<td>items</td><td class="code"><pre>&#39;Oops&#39;</pre></td>', html)
+        self.assertInHTML('<td>items</td><td class="code"><pre>&#x27;Oops&#x27;</pre></td>', html)
 
     def test_exception_fetching_user(self):
         """
diff --git a/update_all_tests.py b/update_all_tests.py
new file mode 100644
index 0000000000..48e3ed93f3
--- /dev/null
+++ b/update_all_tests.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python3
+import os
+import re
+
+# Find all Python test files
+test_files = []
+for root, dirs, files in os.walk('/testbed/tests/'):
+    for file in files:
+        if file.endswith('.py') and '__pycache__' not in root:
+            test_files.append(os.path.join(root, file))
+
+# Process each file
+updated_files = []
+for filepath in test_files:
+    try:
+        with open(filepath, 'r', encoding='utf-8') as f:
+            content = f.read()
+        
+        # Replace &#39; with &#x27; in test assertions
+        original_content = content
+        content = content.replace("&#39;", "&#x27;")
+        
+        if content != original_content:
+            with open(filepath, 'w', encoding='utf-8') as f:
+                f.write(content)
+            updated_files.append(filepath)
+    except Exception as e:
+        print(f"Error processing {filepath}: {e}")
+
+print(f"Updated {len(updated_files)} files:")
+for f in updated_files:
+    print(f"  - {f}")
