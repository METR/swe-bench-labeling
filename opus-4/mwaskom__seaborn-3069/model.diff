diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py
index 4f0290a4..e88213b8 100644
--- a/seaborn/_core/plot.py
+++ b/seaborn/_core/plot.py
@@ -1475,7 +1475,7 @@ class Plotter:
 
                 axes_df = self._filter_subplot_data(df, view)
 
-                with pd.option_context("mode.use_inf_as_null", True):
+                with pd.option_context("mode.use_inf_as_na", True):
                     if keep_na:
                         # The simpler thing to do would be x.dropna().reindex(x.index).
                         # But that doesn't work with the way that the subset iteration
diff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py
index 192af381..9f521a47 100644
--- a/seaborn/_oldcore.py
+++ b/seaborn/_oldcore.py
@@ -1116,7 +1116,7 @@ class VectorPlotter:
                 parts = []
                 grouped = self.plot_data[var].groupby(self.converters[var], sort=False)
                 for converter, orig in grouped:
-                    with pd.option_context('mode.use_inf_as_null', True):
+                    with pd.option_context('mode.use_inf_as_na', True):
                         orig = orig.dropna()
                         if var in self.var_levels:
                             # TODO this should happen in some centralized location
diff --git a/seaborn/categorical.py b/seaborn/categorical.py
index 3394c9c7..cbdc6fb1 100644
--- a/seaborn/categorical.py
+++ b/seaborn/categorical.py
@@ -1790,7 +1790,7 @@ class _LVPlotter(_CategoricalPlotter):
         vals = np.asarray(vals)
         # Remove infinite values while handling a 'object' dtype
         # that can come from pd.Float64Dtype() input
-        with pd.option_context('mode.use_inf_as_null', True):
+        with pd.option_context('mode.use_inf_as_na', True):
             vals = vals[~pd.isnull(vals)]
         n = len(vals)
         p = self.outlier_prop
diff --git a/test_nominal_direct.py b/test_nominal_direct.py
new file mode 100644
index 00000000..668e9058
--- /dev/null
+++ b/test_nominal_direct.py
@@ -0,0 +1,34 @@
+import matplotlib.pyplot as plt
+import seaborn as sns
+import pandas as pd
+
+# Create test data
+data = pd.DataFrame({
+    'x': ['A', 'B', 'C', 'A', 'B', 'C'],
+    'y': [1, 2, 3, 2, 3, 4],
+    'cat': ['cat1', 'cat1', 'cat1', 'cat2', 'cat2', 'cat2']
+})
+
+# Test categorical plot behavior
+fig, ax = plt.subplots()
+sns.stripplot(data=data, x='x', y='y', ax=ax)
+print("Categorical plot x-axis limits:", ax.get_xlim())
+print("Categorical plot x grid visible:", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else "No grid")
+
+# Test with y categorical
+fig, ax = plt.subplots()
+sns.stripplot(data=data, x='y', y='x', ax=ax)
+ylim = ax.get_ylim()
+print("\nCategorical plot y-axis limits:", ylim)
+print("Categorical plot y-axis inverted:", ylim[0] > ylim[1])
+print("Categorical plot y grid visible:", ax.yaxis.get_gridlines()[0].get_visible() if ax.yaxis.get_gridlines() else "No grid")
+
+# Let's look at the grid for both axes
+xgrid = ax.xaxis.get_gridlines()
+ygrid = ax.yaxis.get_gridlines()
+print(f"\nX-axis grid lines: {len(xgrid)}")
+print(f"Y-axis grid lines: {len(ygrid)}")
+if xgrid:
+    print(f"X-axis grid visible: {xgrid[0].get_visible()}")
+if ygrid:
+    print(f"Y-axis grid visible: {ygrid[0].get_visible()}")
diff --git a/test_nominal_scale.py b/test_nominal_scale.py
new file mode 100644
index 00000000..27093b86
--- /dev/null
+++ b/test_nominal_scale.py
@@ -0,0 +1,70 @@
+import matplotlib.pyplot as plt
+import matplotlib as mpl
+import seaborn as sns
+from seaborn import objects as so
+import numpy as np
+import pandas as pd
+
+# Avoid pandas option context issue
+import warnings
+warnings.filterwarnings("ignore")
+
+# Create test data
+data = pd.DataFrame({
+    'x': ['A', 'B', 'C', 'A', 'B', 'C'],
+    'y': [1, 2, 3, 2, 3, 4],
+    'cat': ['cat1', 'cat1', 'cat1', 'cat2', 'cat2', 'cat2']
+})
+
+# Test 1: Check if grid is shown with Nominal scale on x-axis
+fig, ax = plt.subplots()
+p = (
+    so.Plot(data, x='x', y='y')
+    .add(so.Dot())
+    .on(ax)
+    .plot()
+)
+print("Grid visible (x nominal):", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else "No grid")
+plt.close()
+
+# Test 2: Check if y-axis is inverted with Nominal scale
+fig, ax = plt.subplots()
+p = (
+    so.Plot(data, x='y', y='x')  # Swap to make y categorical
+    .add(so.Dot())
+    .on(ax)
+    .plot()
+)
+ylim = ax.get_ylim()
+print("Y-axis limits (y nominal):", ylim)
+print("Y-axis inverted:", ylim[0] > ylim[1])
+plt.close()
+
+# Test 3: Check axis limits with nominal scale
+fig, ax = plt.subplots()
+p = (
+    so.Plot(data, x='x', y='y')
+    .add(so.Dot())
+    .on(ax)
+    .plot()
+)
+xlim = ax.get_xlim()
+print("X-axis limits (x nominal):", xlim)
+print("Expected limits: (-0.5, 2.5)")
+plt.close()
+
+# Test 4: Compare with categorical plot
+fig, ax = plt.subplots()
+sns.stripplot(data=data, x='x', y='y', ax=ax)
+print("\nCategorical plot x-axis limits:", ax.get_xlim())
+print("Categorical plot x grid visible:", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else "No grid")
+plt.close()
+
+# Test 5: Y-axis categorical
+fig, ax = plt.subplots()
+sns.stripplot(data=data, x='y', y='x', ax=ax)
+ylim = ax.get_ylim()
+print("Categorical plot y-axis limits:", ylim)
+print("Categorical plot y-axis inverted:", ylim[0] > ylim[1])
+print("Categorical plot y grid visible:", ax.yaxis.get_gridlines()[0].get_visible() if ax.yaxis.get_gridlines() else "No grid")
+plt.close()
