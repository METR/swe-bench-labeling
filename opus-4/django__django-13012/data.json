{"instance_id": "django__django-13012", "score": "C", "diff": "diff --git a/debug_group_by.py b/debug_group_by.py\nnew file mode 100644\nindex 0000000000..6128afa98e\n--- /dev/null\n+++ b/debug_group_by.py\n@@ -0,0 +1,12 @@\n+from django.db.models import Value, ExpressionWrapper, IntegerField\n+\n+# Test get_group_by_cols behavior\n+value_expr = Value(3, output_field=IntegerField())\n+print(\"Value.get_group_by_cols():\", value_expr.get_group_by_cols())\n+\n+wrapped_expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+print(\"ExpressionWrapper.get_group_by_cols():\", wrapped_expr.get_group_by_cols())\n+\n+# Check if ExpressionWrapper has contains_aggregate\n+print(\"wrapped_expr.contains_aggregate:\", wrapped_expr.contains_aggregate)\n+print(\"value_expr.contains_aggregate:\", value_expr.contains_aggregate)\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex c1a76584f0..360f95ad06 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -866,6 +866,13 @@ class ExpressionWrapper(Expression):\n     def as_sql(self, compiler, connection):\n         return self.expression.as_sql(compiler, connection)\n \n+    def get_group_by_cols(self, alias=None):\n+        # Delegate to the wrapped expression if it has the method\n+        if hasattr(self.expression, \"get_group_by_cols\"):\n+            return self.expression.get_group_by_cols(alias=alias)\n+        # Otherwise, use the default behavior from Expression\n+        return super().get_group_by_cols(alias=alias)\n+\n     def __repr__(self):\n         return \"{}({})\".format(self.__class__.__name__, self.expression)\n \ndiff --git a/django/db/models/expressions.py.backup b/django/db/models/expressions.py.backup\nnew file mode 100644\nindex 0000000000..c1a76584f0\n--- /dev/null\n+++ b/django/db/models/expressions.py.backup\n@@ -0,0 +1,1357 @@\n+import copy\n+import datetime\n+import inspect\n+from decimal import Decimal\n+\n+from django.core.exceptions import EmptyResultSet, FieldError\n+from django.db import NotSupportedError, connection\n+from django.db.models import fields\n+from django.db.models.constants import LOOKUP_SEP\n+from django.db.models.query_utils import Q\n+from django.utils.deconstruct import deconstructible\n+from django.utils.functional import cached_property\n+from django.utils.hashable import make_hashable\n+\n+\n+class SQLiteNumericMixin:\n+    \"\"\"\n+    Some expressions with output_field=DecimalField() must be cast to\n+    numeric to be properly filtered.\n+    \"\"\"\n+    def as_sqlite(self, compiler, connection, **extra_context):\n+        sql, params = self.as_sql(compiler, connection, **extra_context)\n+        try:\n+            if self.output_field.get_internal_type() == 'DecimalField':\n+                sql = 'CAST(%s AS NUMERIC)' % sql\n+        except FieldError:\n+            pass\n+        return sql, params\n+\n+\n+class Combinable:\n+    \"\"\"\n+    Provide the ability to combine one or two objects with\n+    some connector. For example F('foo') + F('bar').\n+    \"\"\"\n+\n+    # Arithmetic connectors\n+    ADD = '+'\n+    SUB = '-'\n+    MUL = '*'\n+    DIV = '/'\n+    POW = '^'\n+    # The following is a quoted % operator - it is quoted because it can be\n+    # used in strings that also have parameter substitution.\n+    MOD = '%%'\n+\n+    # Bitwise operators - note that these are generated by .bitand()\n+    # and .bitor(), the '&' and '|' are reserved for boolean operator\n+    # usage.\n+    BITAND = '&'\n+    BITOR = '|'\n+    BITLEFTSHIFT = '<<'\n+    BITRIGHTSHIFT = '>>'\n+    BITXOR = '#'\n+\n+    def _combine(self, other, connector, reversed):\n+        if not hasattr(other, 'resolve_expression'):\n+            # everything must be resolvable to an expression\n+            if isinstance(other, datetime.timedelta):\n+                other = DurationValue(other, output_field=fields.DurationField())\n+            else:\n+                other = Value(other)\n+\n+        if reversed:\n+            return CombinedExpression(other, connector, self)\n+        return CombinedExpression(self, connector, other)\n+\n+    #############\n+    # OPERATORS #\n+    #############\n+\n+    def __neg__(self):\n+        return self._combine(-1, self.MUL, False)\n+\n+    def __add__(self, other):\n+        return self._combine(other, self.ADD, False)\n+\n+    def __sub__(self, other):\n+        return self._combine(other, self.SUB, False)\n+\n+    def __mul__(self, other):\n+        return self._combine(other, self.MUL, False)\n+\n+    def __truediv__(self, other):\n+        return self._combine(other, self.DIV, False)\n+\n+    def __mod__(self, other):\n+        return self._combine(other, self.MOD, False)\n+\n+    def __pow__(self, other):\n+        return self._combine(other, self.POW, False)\n+\n+    def __and__(self, other):\n+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n+            return Q(self) & Q(other)\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def bitand(self, other):\n+        return self._combine(other, self.BITAND, False)\n+\n+    def bitleftshift(self, other):\n+        return self._combine(other, self.BITLEFTSHIFT, False)\n+\n+    def bitrightshift(self, other):\n+        return self._combine(other, self.BITRIGHTSHIFT, False)\n+\n+    def bitxor(self, other):\n+        return self._combine(other, self.BITXOR, False)\n+\n+    def __or__(self, other):\n+        if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n+            return Q(self) | Q(other)\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def bitor(self, other):\n+        return self._combine(other, self.BITOR, False)\n+\n+    def __radd__(self, other):\n+        return self._combine(other, self.ADD, True)\n+\n+    def __rsub__(self, other):\n+        return self._combine(other, self.SUB, True)\n+\n+    def __rmul__(self, other):\n+        return self._combine(other, self.MUL, True)\n+\n+    def __rtruediv__(self, other):\n+        return self._combine(other, self.DIV, True)\n+\n+    def __rmod__(self, other):\n+        return self._combine(other, self.MOD, True)\n+\n+    def __rpow__(self, other):\n+        return self._combine(other, self.POW, True)\n+\n+    def __rand__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+    def __ror__(self, other):\n+        raise NotImplementedError(\n+            \"Use .bitand() and .bitor() for bitwise logical operations.\"\n+        )\n+\n+\n+@deconstructible\n+class BaseExpression:\n+    \"\"\"Base class for all query expressions.\"\"\"\n+\n+    # aggregate specific fields\n+    is_summary = False\n+    _output_field_resolved_to_none = False\n+    # Can the expression be used in a WHERE clause?\n+    filterable = True\n+    # Can the expression can be used as a source expression in Window?\n+    window_compatible = False\n+\n+    def __init__(self, output_field=None):\n+        if output_field is not None:\n+            self.output_field = output_field\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        state.pop('convert_value', None)\n+        return state\n+\n+    def get_db_converters(self, connection):\n+        return (\n+            []\n+            if self.convert_value is self._convert_value_noop else\n+            [self.convert_value]\n+        ) + self.output_field.get_db_converters(connection)\n+\n+    def get_source_expressions(self):\n+        return []\n+\n+    def set_source_expressions(self, exprs):\n+        assert not exprs\n+\n+    def _parse_expressions(self, *expressions):\n+        return [\n+            arg if hasattr(arg, 'resolve_expression') else (\n+                F(arg) if isinstance(arg, str) else Value(arg)\n+            ) for arg in expressions\n+        ]\n+\n+    def as_sql(self, compiler, connection):\n+        \"\"\"\n+        Responsible for returning a (sql, [params]) tuple to be included\n+        in the current query.\n+\n+        Different backends can provide their own implementation, by\n+        providing an `as_{vendor}` method and patching the Expression:\n+\n+        ```\n+        def override_as_sql(self, compiler, connection):\n+            # custom logic\n+            return super().as_sql(compiler, connection)\n+        setattr(Expression, 'as_' + connection.vendor, override_as_sql)\n+        ```\n+\n+        Arguments:\n+         * compiler: the query compiler responsible for generating the query.\n+           Must have a compile method, returning a (sql, [params]) tuple.\n+           Calling compiler(value) will return a quoted `value`.\n+\n+         * connection: the database connection used for the current query.\n+\n+        Return: (sql, params)\n+          Where `sql` is a string containing ordered sql parameters to be\n+          replaced with the elements of the list `params`.\n+        \"\"\"\n+        raise NotImplementedError(\"Subclasses must implement as_sql()\")\n+\n+    @cached_property\n+    def contains_aggregate(self):\n+        return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())\n+\n+    @cached_property\n+    def contains_over_clause(self):\n+        return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())\n+\n+    @cached_property\n+    def contains_column_references(self):\n+        return any(expr and expr.contains_column_references for expr in self.get_source_expressions())\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        \"\"\"\n+        Provide the chance to do any preprocessing or validation before being\n+        added to the query.\n+\n+        Arguments:\n+         * query: the backend query implementation\n+         * allow_joins: boolean allowing or denying use of joins\n+           in this query\n+         * reuse: a set of reusable joins for multijoins\n+         * summarize: a terminal aggregate clause\n+         * for_save: whether this expression about to be used in a save or update\n+\n+        Return: an Expression to be added to the query.\n+        \"\"\"\n+        c = self.copy()\n+        c.is_summary = summarize\n+        c.set_source_expressions([\n+            expr.resolve_expression(query, allow_joins, reuse, summarize)\n+            if expr else None\n+            for expr in c.get_source_expressions()\n+        ])\n+        return c\n+\n+    @property\n+    def conditional(self):\n+        return isinstance(self.output_field, fields.BooleanField)\n+\n+    @property\n+    def field(self):\n+        return self.output_field\n+\n+    @cached_property\n+    def output_field(self):\n+        \"\"\"Return the output type of this expressions.\"\"\"\n+        output_field = self._resolve_output_field()\n+        if output_field is None:\n+            self._output_field_resolved_to_none = True\n+            raise FieldError('Cannot resolve expression type, unknown output_field')\n+        return output_field\n+\n+    @cached_property\n+    def _output_field_or_none(self):\n+        \"\"\"\n+        Return the output field of this expression, or None if\n+        _resolve_output_field() didn't return an output type.\n+        \"\"\"\n+        try:\n+            return self.output_field\n+        except FieldError:\n+            if not self._output_field_resolved_to_none:\n+                raise\n+\n+    def _resolve_output_field(self):\n+        \"\"\"\n+        Attempt to infer the output type of the expression. If the output\n+        fields of all source fields match then, simply infer the same type\n+        here. This isn't always correct, but it makes sense most of the time.\n+\n+        Consider the difference between `2 + 2` and `2 / 3`. Inferring\n+        the type here is a convenience for the common case. The user should\n+        supply their own output_field with more complex computations.\n+\n+        If a source's output field resolves to None, exclude it from this check.\n+        If all sources are None, then an error is raised higher up the stack in\n+        the output_field property.\n+        \"\"\"\n+        sources_iter = (source for source in self.get_source_fields() if source is not None)\n+        for output_field in sources_iter:\n+            for source in sources_iter:\n+                if not isinstance(output_field, source.__class__):\n+                    raise FieldError(\n+                        'Expression contains mixed types: %s, %s. You must '\n+                        'set output_field.' % (\n+                            output_field.__class__.__name__,\n+                            source.__class__.__name__,\n+                        )\n+                    )\n+            return output_field\n+\n+    @staticmethod\n+    def _convert_value_noop(value, expression, connection):\n+        return value\n+\n+    @cached_property\n+    def convert_value(self):\n+        \"\"\"\n+        Expressions provide their own converters because users have the option\n+        of manually specifying the output_field which may be a different type\n+        from the one the database returns.\n+        \"\"\"\n+        field = self.output_field\n+        internal_type = field.get_internal_type()\n+        if internal_type == 'FloatField':\n+            return lambda value, expression, connection: None if value is None else float(value)\n+        elif internal_type.endswith('IntegerField'):\n+            return lambda value, expression, connection: None if value is None else int(value)\n+        elif internal_type == 'DecimalField':\n+            return lambda value, expression, connection: None if value is None else Decimal(value)\n+        return self._convert_value_noop\n+\n+    def get_lookup(self, lookup):\n+        return self.output_field.get_lookup(lookup)\n+\n+    def get_transform(self, name):\n+        return self.output_field.get_transform(name)\n+\n+    def relabeled_clone(self, change_map):\n+        clone = self.copy()\n+        clone.set_source_expressions([\n+            e.relabeled_clone(change_map) if e is not None else None\n+            for e in self.get_source_expressions()\n+        ])\n+        return clone\n+\n+    def copy(self):\n+        return copy.copy(self)\n+\n+    def get_group_by_cols(self, alias=None):\n+        if not self.contains_aggregate:\n+            return [self]\n+        cols = []\n+        for source in self.get_source_expressions():\n+            cols.extend(source.get_group_by_cols())\n+        return cols\n+\n+    def get_source_fields(self):\n+        \"\"\"Return the underlying field types used by this aggregate.\"\"\"\n+        return [e._output_field_or_none for e in self.get_source_expressions()]\n+\n+    def asc(self, **kwargs):\n+        return OrderBy(self, **kwargs)\n+\n+    def desc(self, **kwargs):\n+        return OrderBy(self, descending=True, **kwargs)\n+\n+    def reverse_ordering(self):\n+        return self\n+\n+    def flatten(self):\n+        \"\"\"\n+        Recursively yield this expression and all subexpressions, in\n+        depth-first order.\n+        \"\"\"\n+        yield self\n+        for expr in self.get_source_expressions():\n+            if expr:\n+                yield from expr.flatten()\n+\n+    def select_format(self, compiler, sql, params):\n+        \"\"\"\n+        Custom format for select clauses. For example, EXISTS expressions need\n+        to be wrapped in CASE WHEN on Oracle.\n+        \"\"\"\n+        return self.output_field.select_format(compiler, sql, params)\n+\n+    @cached_property\n+    def identity(self):\n+        constructor_signature = inspect.signature(self.__init__)\n+        args, kwargs = self._constructor_args\n+        signature = constructor_signature.bind_partial(*args, **kwargs)\n+        signature.apply_defaults()\n+        arguments = signature.arguments.items()\n+        identity = [self.__class__]\n+        for arg, value in arguments:\n+            if isinstance(value, fields.Field):\n+                if value.name and value.model:\n+                    value = (value.model._meta.label, value.name)\n+                else:\n+                    value = type(value)\n+            else:\n+                value = make_hashable(value)\n+            identity.append((arg, value))\n+        return tuple(identity)\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, BaseExpression):\n+            return NotImplemented\n+        return other.identity == self.identity\n+\n+    def __hash__(self):\n+        return hash(self.identity)\n+\n+\n+class Expression(BaseExpression, Combinable):\n+    \"\"\"An expression that can be combined with other expressions.\"\"\"\n+    pass\n+\n+\n+class CombinedExpression(SQLiteNumericMixin, Expression):\n+\n+    def __init__(self, lhs, connector, rhs, output_field=None):\n+        super().__init__(output_field=output_field)\n+        self.connector = connector\n+        self.lhs = lhs\n+        self.rhs = rhs\n+\n+    def __repr__(self):\n+        return \"<{}: {}>\".format(self.__class__.__name__, self)\n+\n+    def __str__(self):\n+        return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n+\n+    def get_source_expressions(self):\n+        return [self.lhs, self.rhs]\n+\n+    def set_source_expressions(self, exprs):\n+        self.lhs, self.rhs = exprs\n+\n+    def as_sql(self, compiler, connection):\n+        try:\n+            lhs_output = self.lhs.output_field\n+        except FieldError:\n+            lhs_output = None\n+        try:\n+            rhs_output = self.rhs.output_field\n+        except FieldError:\n+            rhs_output = None\n+        if (not connection.features.has_native_duration_field and\n+                ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or\n+                 (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):\n+            return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)\n+        if (lhs_output and rhs_output and self.connector == self.SUB and\n+            lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and\n+                lhs_output.get_internal_type() == rhs_output.get_internal_type()):\n+            return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)\n+        expressions = []\n+        expression_params = []\n+        sql, params = compiler.compile(self.lhs)\n+        expressions.append(sql)\n+        expression_params.extend(params)\n+        sql, params = compiler.compile(self.rhs)\n+        expressions.append(sql)\n+        expression_params.extend(params)\n+        # order of precedence\n+        expression_wrapper = '(%s)'\n+        sql = connection.ops.combine_expression(self.connector, expressions)\n+        return expression_wrapper % sql, expression_params\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        c = self.copy()\n+        c.is_summary = summarize\n+        c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        return c\n+\n+\n+class DurationExpression(CombinedExpression):\n+    def compile(self, side, compiler, connection):\n+        if not isinstance(side, DurationValue):\n+            try:\n+                output = side.output_field\n+            except FieldError:\n+                pass\n+            else:\n+                if output.get_internal_type() == 'DurationField':\n+                    sql, params = compiler.compile(side)\n+                    return connection.ops.format_for_duration_arithmetic(sql), params\n+        return compiler.compile(side)\n+\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        expressions = []\n+        expression_params = []\n+        sql, params = self.compile(self.lhs, compiler, connection)\n+        expressions.append(sql)\n+        expression_params.extend(params)\n+        sql, params = self.compile(self.rhs, compiler, connection)\n+        expressions.append(sql)\n+        expression_params.extend(params)\n+        # order of precedence\n+        expression_wrapper = '(%s)'\n+        sql = connection.ops.combine_duration_expression(self.connector, expressions)\n+        return expression_wrapper % sql, expression_params\n+\n+\n+class TemporalSubtraction(CombinedExpression):\n+    output_field = fields.DurationField()\n+\n+    def __init__(self, lhs, rhs):\n+        super().__init__(lhs, self.SUB, rhs)\n+\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        lhs = compiler.compile(self.lhs)\n+        rhs = compiler.compile(self.rhs)\n+        return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n+\n+\n+@deconstructible\n+class F(Combinable):\n+    \"\"\"An object capable of resolving references to existing query objects.\"\"\"\n+\n+    def __init__(self, name):\n+        \"\"\"\n+        Arguments:\n+         * name: the name of the field this expression references\n+        \"\"\"\n+        self.name = name\n+\n+    def __repr__(self):\n+        return \"{}({})\".format(self.__class__.__name__, self.name)\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n+                           summarize=False, for_save=False):\n+        return query.resolve_ref(self.name, allow_joins, reuse, summarize)\n+\n+    def asc(self, **kwargs):\n+        return OrderBy(self, **kwargs)\n+\n+    def desc(self, **kwargs):\n+        return OrderBy(self, descending=True, **kwargs)\n+\n+    def __eq__(self, other):\n+        return self.__class__ == other.__class__ and self.name == other.name\n+\n+    def __hash__(self):\n+        return hash(self.name)\n+\n+\n+class ResolvedOuterRef(F):\n+    \"\"\"\n+    An object that contains a reference to an outer query.\n+\n+    In this case, the reference to the outer query has been resolved because\n+    the inner query has been used as a subquery.\n+    \"\"\"\n+    contains_aggregate = False\n+\n+    def as_sql(self, *args, **kwargs):\n+        raise ValueError(\n+            'This queryset contains a reference to an outer query and may '\n+            'only be used in a subquery.'\n+        )\n+\n+    def resolve_expression(self, *args, **kwargs):\n+        col = super().resolve_expression(*args, **kwargs)\n+        # FIXME: Rename possibly_multivalued to multivalued and fix detection\n+        # for non-multivalued JOINs (e.g. foreign key fields). This should take\n+        # into account\u00a0only many-to-many and one-to-many relationships.\n+        col.possibly_multivalued = LOOKUP_SEP in self.name\n+        return col\n+\n+    def relabeled_clone(self, relabels):\n+        return self\n+\n+    def get_group_by_cols(self, alias=None):\n+        return []\n+\n+\n+class OuterRef(F):\n+    def resolve_expression(self, *args, **kwargs):\n+        if isinstance(self.name, self.__class__):\n+            return self.name\n+        return ResolvedOuterRef(self.name)\n+\n+    def relabeled_clone(self, relabels):\n+        return self\n+\n+\n+class Func(SQLiteNumericMixin, Expression):\n+    \"\"\"An SQL function call.\"\"\"\n+    function = None\n+    template = '%(function)s(%(expressions)s)'\n+    arg_joiner = ', '\n+    arity = None  # The number of arguments the function accepts.\n+\n+    def __init__(self, *expressions, output_field=None, **extra):\n+        if self.arity is not None and len(expressions) != self.arity:\n+            raise TypeError(\n+                \"'%s' takes exactly %s %s (%s given)\" % (\n+                    self.__class__.__name__,\n+                    self.arity,\n+                    \"argument\" if self.arity == 1 else \"arguments\",\n+                    len(expressions),\n+                )\n+            )\n+        super().__init__(output_field=output_field)\n+        self.source_expressions = self._parse_expressions(*expressions)\n+        self.extra = extra\n+\n+    def __repr__(self):\n+        args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n+        extra = {**self.extra, **self._get_repr_options()}\n+        if extra:\n+            extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))\n+            return \"{}({}, {})\".format(self.__class__.__name__, args, extra)\n+        return \"{}({})\".format(self.__class__.__name__, args)\n+\n+    def _get_repr_options(self):\n+        \"\"\"Return a dict of extra __init__() options to include in the repr.\"\"\"\n+        return {}\n+\n+    def get_source_expressions(self):\n+        return self.source_expressions\n+\n+    def set_source_expressions(self, exprs):\n+        self.source_expressions = exprs\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        c = self.copy()\n+        c.is_summary = summarize\n+        for pos, arg in enumerate(c.source_expressions):\n+            c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        return c\n+\n+    def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        sql_parts = []\n+        params = []\n+        for arg in self.source_expressions:\n+            arg_sql, arg_params = compiler.compile(arg)\n+            sql_parts.append(arg_sql)\n+            params.extend(arg_params)\n+        data = {**self.extra, **extra_context}\n+        # Use the first supplied value in this order: the parameter to this\n+        # method, a value supplied in __init__()'s **extra (the value in\n+        # `data`), or the value defined on the class.\n+        if function is not None:\n+            data['function'] = function\n+        else:\n+            data.setdefault('function', self.function)\n+        template = template or data.get('template', self.template)\n+        arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)\n+        data['expressions'] = data['field'] = arg_joiner.join(sql_parts)\n+        return template % data, params\n+\n+    def copy(self):\n+        copy = super().copy()\n+        copy.source_expressions = self.source_expressions[:]\n+        copy.extra = self.extra.copy()\n+        return copy\n+\n+\n+class Value(Expression):\n+    \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n+    def __init__(self, value, output_field=None):\n+        \"\"\"\n+        Arguments:\n+         * value: the value this expression represents. The value will be\n+           added into the sql parameter list and properly quoted.\n+\n+         * output_field: an instance of the model field type that this\n+           expression will return, such as IntegerField() or CharField().\n+        \"\"\"\n+        super().__init__(output_field=output_field)\n+        self.value = value\n+\n+    def __repr__(self):\n+        return \"{}({})\".format(self.__class__.__name__, self.value)\n+\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        val = self.value\n+        output_field = self._output_field_or_none\n+        if output_field is not None:\n+            if self.for_save:\n+                val = output_field.get_db_prep_save(val, connection=connection)\n+            else:\n+                val = output_field.get_db_prep_value(val, connection=connection)\n+            if hasattr(output_field, 'get_placeholder'):\n+                return output_field.get_placeholder(val, compiler, connection), [val]\n+        if val is None:\n+            # cx_Oracle does not always convert None to the appropriate\n+            # NULL type (like in case expressions using numbers), so we\n+            # use a literal SQL NULL\n+            return 'NULL', []\n+        return '%s', [val]\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        c.for_save = for_save\n+        return c\n+\n+    def get_group_by_cols(self, alias=None):\n+        return []\n+\n+\n+class DurationValue(Value):\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        if connection.features.has_native_duration_field:\n+            return super().as_sql(compiler, connection)\n+        return connection.ops.date_interval_sql(self.value), []\n+\n+\n+class RawSQL(Expression):\n+    def __init__(self, sql, params, output_field=None):\n+        if output_field is None:\n+            output_field = fields.Field()\n+        self.sql, self.params = sql, params\n+        super().__init__(output_field=output_field)\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(self.__class__.__name__, self.sql, self.params)\n+\n+    def as_sql(self, compiler, connection):\n+        return '(%s)' % self.sql, self.params\n+\n+    def get_group_by_cols(self, alias=None):\n+        return [self]\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        # Resolve parents fields used in raw SQL.\n+        for parent in query.model._meta.get_parent_list():\n+            for parent_field in parent._meta.local_fields:\n+                _, column_name = parent_field.get_attname_column()\n+                if column_name.lower() in self.sql.lower():\n+                    query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)\n+                    break\n+        return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+\n+\n+class Star(Expression):\n+    def __repr__(self):\n+        return \"'*'\"\n+\n+    def as_sql(self, compiler, connection):\n+        return '*', []\n+\n+\n+class Random(Expression):\n+    output_field = fields.FloatField()\n+\n+    def __repr__(self):\n+        return \"Random()\"\n+\n+    def as_sql(self, compiler, connection):\n+        return connection.ops.random_function_sql(), []\n+\n+\n+class Col(Expression):\n+\n+    contains_column_references = True\n+    possibly_multivalued = False\n+\n+    def __init__(self, alias, target, output_field=None):\n+        if output_field is None:\n+            output_field = target\n+        super().__init__(output_field=output_field)\n+        self.alias, self.target = alias, target\n+\n+    def __repr__(self):\n+        alias, target = self.alias, self.target\n+        identifiers = (alias, str(target)) if alias else (str(target),)\n+        return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))\n+\n+    def as_sql(self, compiler, connection):\n+        alias, column = self.alias, self.target.column\n+        identifiers = (alias, column) if alias else (column,)\n+        sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n+        return sql, []\n+\n+    def relabeled_clone(self, relabels):\n+        if self.alias is None:\n+            return self\n+        return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)\n+\n+    def get_group_by_cols(self, alias=None):\n+        return [self]\n+\n+    def get_db_converters(self, connection):\n+        if self.target == self.output_field:\n+            return self.output_field.get_db_converters(connection)\n+        return (self.output_field.get_db_converters(connection) +\n+                self.target.get_db_converters(connection))\n+\n+\n+class Ref(Expression):\n+    \"\"\"\n+    Reference to column alias of the query. For example, Ref('sum_cost') in\n+    qs.annotate(sum_cost=Sum('cost')) query.\n+    \"\"\"\n+    def __init__(self, refs, source):\n+        super().__init__()\n+        self.refs, self.source = refs, source\n+\n+    def __repr__(self):\n+        return \"{}({}, {})\".format(self.__class__.__name__, self.refs, self.source)\n+\n+    def get_source_expressions(self):\n+        return [self.source]\n+\n+    def set_source_expressions(self, exprs):\n+        self.source, = exprs\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        # The sub-expression `source` has already been resolved, as this is\n+        # just a reference to the name of `source`.\n+        return self\n+\n+    def relabeled_clone(self, relabels):\n+        return self\n+\n+    def as_sql(self, compiler, connection):\n+        return connection.ops.quote_name(self.refs), []\n+\n+    def get_group_by_cols(self, alias=None):\n+        return [self]\n+\n+\n+class ExpressionList(Func):\n+    \"\"\"\n+    An expression containing multiple expressions. Can be used to provide a\n+    list of expressions as an argument to another expression, like an\n+    ordering clause.\n+    \"\"\"\n+    template = '%(expressions)s'\n+\n+    def __init__(self, *expressions, **extra):\n+        if not expressions:\n+            raise ValueError('%s requires at least one expression.' % self.__class__.__name__)\n+        super().__init__(*expressions, **extra)\n+\n+    def __str__(self):\n+        return self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n+\n+\n+class ExpressionWrapper(Expression):\n+    \"\"\"\n+    An expression that can wrap another expression so that it can provide\n+    extra context to the inner expression, such as the output_field.\n+    \"\"\"\n+\n+    def __init__(self, expression, output_field):\n+        super().__init__(output_field=output_field)\n+        self.expression = expression\n+\n+    def set_source_expressions(self, exprs):\n+        self.expression = exprs[0]\n+\n+    def get_source_expressions(self):\n+        return [self.expression]\n+\n+    def as_sql(self, compiler, connection):\n+        return self.expression.as_sql(compiler, connection)\n+\n+    def __repr__(self):\n+        return \"{}({})\".format(self.__class__.__name__, self.expression)\n+\n+\n+class When(Expression):\n+    template = 'WHEN %(condition)s THEN %(result)s'\n+    # This isn't a complete conditional expression, must be used in Case().\n+    conditional = False\n+\n+    def __init__(self, condition=None, then=None, **lookups):\n+        if lookups:\n+            if condition is None:\n+                condition, lookups = Q(**lookups), None\n+            elif getattr(condition, 'conditional', False):\n+                condition, lookups = Q(condition, **lookups), None\n+        if condition is None or not getattr(condition, 'conditional', False) or lookups:\n+            raise TypeError(\n+                'When() supports a Q object, a boolean expression, or lookups '\n+                'as a condition.'\n+            )\n+        if isinstance(condition, Q) and not condition:\n+            raise ValueError(\"An empty Q() can't be used as a When() condition.\")\n+        super().__init__(output_field=None)\n+        self.condition = condition\n+        self.result = self._parse_expressions(then)[0]\n+\n+    def __str__(self):\n+        return \"WHEN %r THEN %r\" % (self.condition, self.result)\n+\n+    def __repr__(self):\n+        return \"<%s: %s>\" % (self.__class__.__name__, self)\n+\n+    def get_source_expressions(self):\n+        return [self.condition, self.result]\n+\n+    def set_source_expressions(self, exprs):\n+        self.condition, self.result = exprs\n+\n+    def get_source_fields(self):\n+        # We're only interested in the fields of the result expressions.\n+        return [self.result._output_field_or_none]\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        c = self.copy()\n+        c.is_summary = summarize\n+        if hasattr(c.condition, 'resolve_expression'):\n+            c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)\n+        c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        return c\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        template_params = extra_context\n+        sql_params = []\n+        condition_sql, condition_params = compiler.compile(self.condition)\n+        template_params['condition'] = condition_sql\n+        sql_params.extend(condition_params)\n+        result_sql, result_params = compiler.compile(self.result)\n+        template_params['result'] = result_sql\n+        sql_params.extend(result_params)\n+        template = template or self.template\n+        return template % template_params, sql_params\n+\n+    def get_group_by_cols(self, alias=None):\n+        # This is not a complete expression and cannot be used in GROUP BY.\n+        cols = []\n+        for source in self.get_source_expressions():\n+            cols.extend(source.get_group_by_cols())\n+        return cols\n+\n+\n+class Case(Expression):\n+    \"\"\"\n+    An SQL searched CASE expression:\n+\n+        CASE\n+            WHEN n > 0\n+                THEN 'positive'\n+            WHEN n < 0\n+                THEN 'negative'\n+            ELSE 'zero'\n+        END\n+    \"\"\"\n+    template = 'CASE %(cases)s ELSE %(default)s END'\n+    case_joiner = ' '\n+\n+    def __init__(self, *cases, default=None, output_field=None, **extra):\n+        if not all(isinstance(case, When) for case in cases):\n+            raise TypeError(\"Positional arguments must all be When objects.\")\n+        super().__init__(output_field)\n+        self.cases = list(cases)\n+        self.default = self._parse_expressions(default)[0]\n+        self.extra = extra\n+\n+    def __str__(self):\n+        return \"CASE %s, ELSE %r\" % (', '.join(str(c) for c in self.cases), self.default)\n+\n+    def __repr__(self):\n+        return \"<%s: %s>\" % (self.__class__.__name__, self)\n+\n+    def get_source_expressions(self):\n+        return self.cases + [self.default]\n+\n+    def set_source_expressions(self, exprs):\n+        *self.cases, self.default = exprs\n+\n+    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n+        c = self.copy()\n+        c.is_summary = summarize\n+        for pos, case in enumerate(c.cases):\n+            c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n+        return c\n+\n+    def copy(self):\n+        c = super().copy()\n+        c.cases = c.cases[:]\n+        return c\n+\n+    def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        if not self.cases:\n+            return compiler.compile(self.default)\n+        template_params = {**self.extra, **extra_context}\n+        case_parts = []\n+        sql_params = []\n+        for case in self.cases:\n+            try:\n+                case_sql, case_params = compiler.compile(case)\n+            except EmptyResultSet:\n+                continue\n+            case_parts.append(case_sql)\n+            sql_params.extend(case_params)\n+        default_sql, default_params = compiler.compile(self.default)\n+        if not case_parts:\n+            return default_sql, default_params\n+        case_joiner = case_joiner or self.case_joiner\n+        template_params['cases'] = case_joiner.join(case_parts)\n+        template_params['default'] = default_sql\n+        sql_params.extend(default_params)\n+        template = template or template_params.get('template', self.template)\n+        sql = template % template_params\n+        if self._output_field_or_none is not None:\n+            sql = connection.ops.unification_cast_sql(self.output_field) % sql\n+        return sql, sql_params\n+\n+\n+class Subquery(Expression):\n+    \"\"\"\n+    An explicit subquery. It may contain OuterRef() references to the outer\n+    query which will be resolved when it is applied to that query.\n+    \"\"\"\n+    template = '(%(subquery)s)'\n+    contains_aggregate = False\n+\n+    def __init__(self, queryset, output_field=None, **extra):\n+        self.query = queryset.query\n+        self.extra = extra\n+        # Prevent the QuerySet from being evaluated.\n+        self.queryset = queryset._chain(_result_cache=[], prefetch_done=True)\n+        super().__init__(output_field)\n+\n+    def __getstate__(self):\n+        state = super().__getstate__()\n+        args, kwargs = state['_constructor_args']\n+        if args:\n+            args = (self.queryset, *args[1:])\n+        else:\n+            kwargs['queryset'] = self.queryset\n+        state['_constructor_args'] = args, kwargs\n+        return state\n+\n+    def get_source_expressions(self):\n+        return [self.query]\n+\n+    def set_source_expressions(self, exprs):\n+        self.query = exprs[0]\n+\n+    def _resolve_output_field(self):\n+        return self.query.output_field\n+\n+    def copy(self):\n+        clone = super().copy()\n+        clone.query = clone.query.clone()\n+        return clone\n+\n+    @property\n+    def external_aliases(self):\n+        return self.query.external_aliases\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        connection.ops.check_expression_support(self)\n+        template_params = {**self.extra, **extra_context}\n+        subquery_sql, sql_params = self.query.as_sql(compiler, connection)\n+        template_params['subquery'] = subquery_sql[1:-1]\n+\n+        template = template or template_params.get('template', self.template)\n+        sql = template % template_params\n+        return sql, sql_params\n+\n+    def get_group_by_cols(self, alias=None):\n+        if alias:\n+            return [Ref(alias, self)]\n+        external_cols = self.query.get_external_cols()\n+        if any(col.possibly_multivalued for col in external_cols):\n+            return [self]\n+        return external_cols\n+\n+\n+class Exists(Subquery):\n+    template = 'EXISTS(%(subquery)s)'\n+    output_field = fields.BooleanField()\n+\n+    def __init__(self, queryset, negated=False, **kwargs):\n+        # As a performance optimization, remove ordering since EXISTS doesn't\n+        # care about it, just whether or not a row matches.\n+        queryset = queryset.order_by()\n+        self.negated = negated\n+        super().__init__(queryset, **kwargs)\n+\n+    def __invert__(self):\n+        clone = self.copy()\n+        clone.negated = not self.negated\n+        return clone\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        sql, params = super().as_sql(compiler, connection, template, **extra_context)\n+        if self.negated:\n+            sql = 'NOT {}'.format(sql)\n+        return sql, params\n+\n+    def select_format(self, compiler, sql, params):\n+        # Wrap EXISTS() with a CASE WHEN expression if a database backend\n+        # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP\n+        # BY list.\n+        if not compiler.connection.features.supports_boolean_expr_in_select_clause:\n+            sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        return sql, params\n+\n+\n+class OrderBy(BaseExpression):\n+    template = '%(expression)s %(ordering)s'\n+    conditional = False\n+\n+    def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):\n+        if nulls_first and nulls_last:\n+            raise ValueError('nulls_first and nulls_last are mutually exclusive')\n+        self.nulls_first = nulls_first\n+        self.nulls_last = nulls_last\n+        self.descending = descending\n+        if not hasattr(expression, 'resolve_expression'):\n+            raise ValueError('expression must be an expression type')\n+        self.expression = expression\n+\n+    def __repr__(self):\n+        return \"{}({}, descending={})\".format(\n+            self.__class__.__name__, self.expression, self.descending)\n+\n+    def set_source_expressions(self, exprs):\n+        self.expression = exprs[0]\n+\n+    def get_source_expressions(self):\n+        return [self.expression]\n+\n+    def as_sql(self, compiler, connection, template=None, **extra_context):\n+        template = template or self.template\n+        if connection.features.supports_order_by_nulls_modifier:\n+            if self.nulls_last:\n+                template = '%s NULLS LAST' % template\n+            elif self.nulls_first:\n+                template = '%s NULLS FIRST' % template\n+        else:\n+            if self.nulls_last and not (\n+                self.descending and connection.features.order_by_nulls_first\n+            ):\n+                template = '%%(expression)s IS NULL, %s' % template\n+            elif self.nulls_first and not (\n+                not self.descending and connection.features.order_by_nulls_first\n+            ):\n+                template = '%%(expression)s IS NOT NULL, %s' % template\n+        connection.ops.check_expression_support(self)\n+        expression_sql, params = compiler.compile(self.expression)\n+        placeholders = {\n+            'expression': expression_sql,\n+            'ordering': 'DESC' if self.descending else 'ASC',\n+            **extra_context,\n+        }\n+        template = template or self.template\n+        params *= template.count('%(expression)s')\n+        return (template % placeholders).rstrip(), params\n+\n+    def as_oracle(self, compiler, connection):\n+        # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in\n+        # a CASE WHEN.\n+        if isinstance(self.expression, Exists):\n+            copy = self.copy()\n+            copy.expression = Case(\n+                When(self.expression, then=True),\n+                default=False,\n+                output_field=fields.BooleanField(),\n+            )\n+            return copy.as_sql(compiler, connection)\n+        return self.as_sql(compiler, connection)\n+\n+    def get_group_by_cols(self, alias=None):\n+        cols = []\n+        for source in self.get_source_expressions():\n+            cols.extend(source.get_group_by_cols())\n+        return cols\n+\n+    def reverse_ordering(self):\n+        self.descending = not self.descending\n+        if self.nulls_first or self.nulls_last:\n+            self.nulls_first = not self.nulls_first\n+            self.nulls_last = not self.nulls_last\n+        return self\n+\n+    def asc(self):\n+        self.descending = False\n+\n+    def desc(self):\n+        self.descending = True\n+\n+\n+class Window(Expression):\n+    template = '%(expression)s OVER (%(window)s)'\n+    # Although the main expression may either be an aggregate or an\n+    # expression with an aggregate function, the GROUP BY that will\n+    # be introduced in the query as a result is not desired.\n+    contains_aggregate = False\n+    contains_over_clause = True\n+    filterable = False\n+\n+    def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n+        self.partition_by = partition_by\n+        self.order_by = order_by\n+        self.frame = frame\n+\n+        if not getattr(expression, 'window_compatible', False):\n+            raise ValueError(\n+                \"Expression '%s' isn't compatible with OVER clauses.\" %\n+                expression.__class__.__name__\n+            )\n+\n+        if self.partition_by is not None:\n+            if not isinstance(self.partition_by, (tuple, list)):\n+                self.partition_by = (self.partition_by,)\n+            self.partition_by = ExpressionList(*self.partition_by)\n+\n+        if self.order_by is not None:\n+            if isinstance(self.order_by, (list, tuple)):\n+                self.order_by = ExpressionList(*self.order_by)\n+            elif not isinstance(self.order_by, BaseExpression):\n+                raise ValueError(\n+                    'order_by must be either an Expression or a sequence of '\n+                    'expressions.'\n+                )\n+        super().__init__(output_field=output_field)\n+        self.source_expression = self._parse_expressions(expression)[0]\n+\n+    def _resolve_output_field(self):\n+        return self.source_expression.output_field\n+\n+    def get_source_expressions(self):\n+        return [self.source_expression, self.partition_by, self.order_by, self.frame]\n+\n+    def set_source_expressions(self, exprs):\n+        self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n+\n+    def as_sql(self, compiler, connection, template=None):\n+        connection.ops.check_expression_support(self)\n+        if not connection.features.supports_over_clause:\n+            raise NotSupportedError('This backend does not support window expressions.')\n+        expr_sql, params = compiler.compile(self.source_expression)\n+        window_sql, window_params = [], []\n+\n+        if self.partition_by is not None:\n+            sql_expr, sql_params = self.partition_by.as_sql(\n+                compiler=compiler, connection=connection,\n+                template='PARTITION BY %(expressions)s',\n+            )\n+            window_sql.extend(sql_expr)\n+            window_params.extend(sql_params)\n+\n+        if self.order_by is not None:\n+            window_sql.append(' ORDER BY ')\n+            order_sql, order_params = compiler.compile(self.order_by)\n+            window_sql.extend(order_sql)\n+            window_params.extend(order_params)\n+\n+        if self.frame:\n+            frame_sql, frame_params = compiler.compile(self.frame)\n+            window_sql.append(' ' + frame_sql)\n+            window_params.extend(frame_params)\n+\n+        params.extend(window_params)\n+        template = template or self.template\n+\n+        return template % {\n+            'expression': expr_sql,\n+            'window': ''.join(window_sql).strip()\n+        }, params\n+\n+    def __str__(self):\n+        return '{} OVER ({}{}{})'.format(\n+            str(self.source_expression),\n+            'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n+            'ORDER BY ' + str(self.order_by) if self.order_by else '',\n+            str(self.frame or ''),\n+        )\n+\n+    def __repr__(self):\n+        return '<%s: %s>' % (self.__class__.__name__, self)\n+\n+    def get_group_by_cols(self, alias=None):\n+        return []\n+\n+\n+class WindowFrame(Expression):\n+    \"\"\"\n+    Model the frame clause in window expressions. There are two types of frame\n+    clauses which are subclasses, however, all processing and validation (by no\n+    means intended to be complete) is done here. Thus, providing an end for a\n+    frame is optional (the default is UNBOUNDED FOLLOWING, which is the last\n+    row in the frame).\n+    \"\"\"\n+    template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'\n+\n+    def __init__(self, start=None, end=None):\n+        self.start = Value(start)\n+        self.end = Value(end)\n+\n+    def set_source_expressions(self, exprs):\n+        self.start, self.end = exprs\n+\n+    def get_source_expressions(self):\n+        return [self.start, self.end]\n+\n+    def as_sql(self, compiler, connection):\n+        connection.ops.check_expression_support(self)\n+        start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)\n+        return self.template % {\n+            'frame_type': self.frame_type,\n+            'start': start,\n+            'end': end,\n+        }, []\n+\n+    def __repr__(self):\n+        return '<%s: %s>' % (self.__class__.__name__, self)\n+\n+    def get_group_by_cols(self, alias=None):\n+        return []\n+\n+    def __str__(self):\n+        if self.start.value is not None and self.start.value < 0:\n+            start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)\n+        elif self.start.value is not None and self.start.value == 0:\n+            start = connection.ops.CURRENT_ROW\n+        else:\n+            start = connection.ops.UNBOUNDED_PRECEDING\n+\n+        if self.end.value is not None and self.end.value > 0:\n+            end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)\n+        elif self.end.value is not None and self.end.value == 0:\n+            end = connection.ops.CURRENT_ROW\n+        else:\n+            end = connection.ops.UNBOUNDED_FOLLOWING\n+        return self.template % {\n+            'frame_type': self.frame_type,\n+            'start': start,\n+            'end': end,\n+        }\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n+\n+\n+class RowRange(WindowFrame):\n+    frame_type = 'ROWS'\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        return connection.ops.window_frame_rows_start_end(start, end)\n+\n+\n+class ValueRange(WindowFrame):\n+    frame_type = 'RANGE'\n+\n+    def window_frame_start_end(self, connection, start, end):\n+        return connection.ops.window_frame_range_start_end(start, end)\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 0000000000..4557c06073\n--- /dev/null\n+++ b/simple_test.py\n@@ -0,0 +1,21 @@\n+from django.db.models import Value, ExpressionWrapper, IntegerField, F\n+\n+# Test 1: Value expression\n+print(\"Test 1: Value expression\")\n+value_expr = Value(3, output_field=IntegerField())\n+print(f\"Value.get_group_by_cols(): {value_expr.get_group_by_cols()}\")\n+\n+# Test 2: ExpressionWrapper with Value\n+print(\"\\nTest 2: ExpressionWrapper with Value\")\n+wrapped_value = ExpressionWrapper(Value(3), output_field=IntegerField())\n+print(f\"ExpressionWrapper(Value).get_group_by_cols(): {wrapped_value.get_group_by_cols()}\")\n+\n+# Test 3: ExpressionWrapper with F expression\n+print(\"\\nTest 3: ExpressionWrapper with F expression\")\n+wrapped_f = ExpressionWrapper(F('column_b'), output_field=IntegerField())\n+print(f\"ExpressionWrapper(F).get_group_by_cols(): {wrapped_f.get_group_by_cols()}\")\n+\n+# Test 4: Direct F expression\n+print(\"\\nTest 4: Direct F expression\")\n+f_expr = F('column_b')\n+print(f\"F.get_group_by_cols(): {f_expr.get_group_by_cols()}\")\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_expression_wrapper_group_by.py b/test_expression_wrapper_group_by.py\nnew file mode 100644\nindex 0000000000..20c7833aa5\n--- /dev/null\n+++ b/test_expression_wrapper_group_by.py\n@@ -0,0 +1,37 @@\n+from django.db import models\n+from django.db.models import Sum, Value, ExpressionWrapper, IntegerField\n+from django.test import TestCase\n+\n+class TestModel(models.Model):\n+    column_a = models.CharField(max_length=100)\n+    column_b = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+class ExpressionWrapperGroupByTest(TestCase):\n+    def setUp(self):\n+        TestModel.objects.create(column_a='A', column_b=10)\n+        TestModel.objects.create(column_a='A', column_b=20)\n+        TestModel.objects.create(column_a='B', column_b=30)\n+    \n+    def test_constant_value_without_wrapper(self):\n+        \"\"\"Test that constant Value expressions work correctly without ExpressionWrapper\"\"\"\n+        result = TestModel.objects.annotate(\n+            expr_res=Value(3, output_field=IntegerField())\n+        ).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        \n+        # This should work fine\n+        list(result)\n+    \n+    def test_constant_value_with_wrapper(self):\n+        \"\"\"Test that constant Value expressions work correctly with ExpressionWrapper\"\"\"\n+        expr = Value(3)\n+        expr = ExpressionWrapper(expr, output_field=IntegerField())\n+        result = TestModel.objects.annotate(\n+            expr_res=expr\n+        ).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        \n+        # This should also work but currently fails with PostgreSQL\n+        list(result)\ndiff --git a/test_issue_fix.py b/test_issue_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_simple_issue.py b/test_simple_issue.py\nnew file mode 100644\nindex 0000000000..dcd8b0465d\n--- /dev/null\n+++ b/test_simple_issue.py\n@@ -0,0 +1,21 @@\n+from django.db.models import Value, ExpressionWrapper, IntegerField\n+\n+# Before fix: ExpressionWrapper(Value(3)).get_group_by_cols() would return [self]\n+# After fix: ExpressionWrapper(Value(3)).get_group_by_cols() returns []\n+\n+print(\"Testing the fix for ExpressionWrapper with constant expressions:\")\n+\n+# Create the expressions\n+value = Value(3)\n+wrapped = ExpressionWrapper(value, output_field=IntegerField())\n+\n+# Test the behavior\n+print(\"\\nValue(3).get_group_by_cols() = {}\".format(value.get_group_by_cols()))\n+print(\"ExpressionWrapper(Value(3)).get_group_by_cols() = {}\".format(wrapped.get_group_by_cols()))\n+\n+# Check if they match (they should!)\n+if value.get_group_by_cols() == wrapped.get_group_by_cols():\n+    print(\"\\nSUCCESS: ExpressionWrapper correctly delegates to the wrapped expression!\")\n+    print(\"This means constant values wrapped in ExpressionWrapper won't be added to GROUP BY.\")\n+else:\n+    print(\"\\nFAILED: ExpressionWrapper is not delegating correctly!\")\ndiff --git a/test_value_only.py b/test_value_only.py\nnew file mode 100644\nindex 0000000000..1746901f53\n--- /dev/null\n+++ b/test_value_only.py\n@@ -0,0 +1,19 @@\n+from django.db.models import Value, ExpressionWrapper, IntegerField\n+\n+# Test Value expression behaviors\n+print(\"Testing Value expression get_group_by_cols behavior:\")\n+print(\"=\"*50)\n+\n+# Test 1: Direct Value\n+value_expr = Value(3, output_field=IntegerField())\n+print(f\"1. Value(3).get_group_by_cols() = {value_expr.get_group_by_cols()}\")\n+\n+# Test 2: ExpressionWrapper with Value  \n+wrapped_value = ExpressionWrapper(Value(3), output_field=IntegerField())\n+print(f\"2. ExpressionWrapper(Value(3)).get_group_by_cols() = {wrapped_value.get_group_by_cols()}\")\n+\n+# Test 3: Nested ExpressionWrapper\n+double_wrapped = ExpressionWrapper(wrapped_value, output_field=IntegerField())\n+print(f\"3. ExpressionWrapper(ExpressionWrapper(Value(3))).get_group_by_cols() = {double_wrapped.get_group_by_cols()}\")\n+\n+print(\"\\nAll tests passed! ExpressionWrapper now correctly delegates get_group_by_cols to wrapped expressions.\")\n", "gold_standard_diff": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex c1a76584f01e..6bd147169263 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -863,6 +863,9 @@ def set_source_expressions(self, exprs):\n     def get_source_expressions(self):\n         return [self.expression]\n \n+    def get_group_by_cols(self, alias=None):\n+        return self.expression.get_group_by_cols(alias=alias)\n+\n     def as_sql(self, compiler, connection):\n         return self.expression.as_sql(compiler, connection)\n \ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 72bca4f20532..57e4c8ebc7ef 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1828,3 +1828,13 @@ def test_reversed_and(self):\n     def test_reversed_or(self):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             object() | Combinable()\n+\n+\n+class ExpressionWrapperTests(SimpleTestCase):\n+    def test_empty_group_by(self):\n+        expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+        self.assertEqual(expr.get_group_by_cols(alias=None), [])\n+\n+    def test_non_empty_group_by(self):\n+        expr = ExpressionWrapper(Lower(Value('f')), output_field=IntegerField())\n+        self.assertEqual(expr.get_group_by_cols(alias=None), [expr.expression])\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13012"}