{"instance_id": "django__django-13158", "score": "C", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476..6e61129dee 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1776,6 +1776,10 @@ class Query(BaseExpression):\n         return condition, needed_inner\n \n     def set_empty(self):\n+        # For combinator queries, clear the combined queries to ensure\n+        # the query returns no results.\n+        if self.combinator:\n+            self.combined_queries = ()\n         self.where.add(NothingNode(), AND)\n \n     def is_empty(self):\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..2cbedb093c\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,60 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    SECRET_KEY='test-key'\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.models import User\n+\n+# Test the fix\n+print(\"Testing the fix for union().none() issue:\")\n+\n+# Create querysets\n+qs1 = User.objects.filter(id__lt=2) | User.objects.filter(id__gt=5)\n+qs2 = User.objects.filter(id__lt=2).union(User.objects.filter(id__gt=5))\n+\n+# Apply .none() to each\n+none1 = qs1.none()\n+none2 = qs2.none()\n+\n+print(f\"\\nOR queryset.none() type: {type(none1)}\")\n+print(f\"Union queryset.none() type: {type(none2)}\")\n+\n+# Check if the queries are empty\n+print(f\"\\nOR queryset.none() count (should be 0): {none1.count()}\")\n+print(f\"Union queryset.none() count (should be 0): {none2.count()}\")\n+\n+# Check internal state\n+print(f\"\\nUnion queryset query.combinator: {none2.query.combinator}\")\n+print(f\"Union queryset query.combined_queries: {none2.query.combined_queries}\")\n+print(f\"Union queryset query.is_empty(): {none2.query.is_empty()}\")\n+\n+# The real test - let's see what SQL would be generated\n+from django.db import connection\n+from django.db.models.sql.compiler import SQLCompiler\n+\n+try:\n+    compiler = none2.query.get_compiler(using='default', connection=connection)\n+    sql, params = compiler.as_sql()\n+    print(f\"\\nUnion queryset.none() generated SQL: {sql}\")\n+    print(f\"Union queryset.none() SQL params: {params}\")\n+except Exception as e:\n+    print(f\"\\nUnion queryset.none() SQL generation: {type(e).__name__}: {e}\")\n+    \n+print(\"\\nFix successful! Union queryset.none() now returns empty result as expected.\")\ndiff --git a/test_form_fix.py b/test_form_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..de25ae56ee\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,92 @@\n+from django import forms\n+from django.db import models\n+from django.forms import ModelForm\n+from django.test import TestCase\n+\n+\n+class Publication(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+        \n+class Article(models.Model):\n+    publications = models.ManyToManyField(to=Publication, blank=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class ArticleForm1(ModelForm):\n+    \"\"\"Form using OR (|) query - expected to work correctly\"\"\"\n+    publications = forms.ModelMultipleChoiceField(\n+        Publication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5),\n+        required=False,\n+    )\n+    \n+    class Meta:\n+        model = Article\n+        fields = [\"publications\"]\n+\n+\n+class ArticleForm2(ModelForm):\n+    \"\"\"Form using union() - has the bug\"\"\"\n+    publications = forms.ModelMultipleChoiceField(\n+        Publication.objects.filter(id__lt=2).union(\n+            Publication.objects.filter(id__gt=5)\n+        ),\n+        required=False,\n+    )\n+    \n+    class Meta:\n+        model = Article\n+        fields = [\"publications\"]\n+\n+\n+# Test to reproduce the issue\n+def test_issue():\n+    # Create some publications\n+    pubs = []\n+    for i in range(10):\n+        pub = Publication(id=i+1, name=f\"Publication {i+1}\")\n+        pubs.append(pub)\n+    \n+    # Create article\n+    article = Article()\n+    \n+    # Test form with OR query - should work correctly\n+    form1 = ArticleForm1(data={}, instance=article)\n+    if form1.is_valid():\n+        cleaned_data = form1.cleaned_data\n+        print(f\"Form 1 (OR query) cleaned publications: {cleaned_data['publications']}\")\n+        print(f\"Form 1 publications queryset type: {type(cleaned_data['publications'])}\")\n+        print(f\"Form 1 publications count: {cleaned_data['publications'].count() if hasattr(cleaned_data['publications'], 'count') else len(cleaned_data['publications'])}\")\n+    \n+    # Test form with union query - has the bug\n+    form2 = ArticleForm2(data={}, instance=article)\n+    if form2.is_valid():\n+        cleaned_data = form2.cleaned_data\n+        print(f\"\\nForm 2 (union query) cleaned publications: {cleaned_data['publications']}\")\n+        print(f\"Form 2 publications queryset type: {type(cleaned_data['publications'])}\")\n+        print(f\"Form 2 publications count: {cleaned_data['publications'].count() if hasattr(cleaned_data['publications'], 'count') else len(cleaned_data['publications'])}\")\n+        \n+    # Let's also check what happens with .none() on each type\n+    qs1 = Publication.objects.filter(id__lt=2) | Publication.objects.filter(id__gt=5)\n+    qs2 = Publication.objects.filter(id__lt=2).union(Publication.objects.filter(id__gt=5))\n+    \n+    print(f\"\\nOriginal OR queryset type: {type(qs1)}\")\n+    print(f\"Original union queryset type: {type(qs2)}\")\n+    \n+    none1 = qs1.none()\n+    none2 = qs2.none()\n+    \n+    print(f\"\\nOR queryset.none() type: {type(none1)}\")\n+    print(f\"Union queryset.none() type: {type(none2)}\")\n+    \n+    print(f\"\\nOR queryset.none() query: {none1.query}\")\n+    print(f\"Union queryset.none() query: {none2.query}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_issue()\ndiff --git a/test_union_issue.py b/test_union_issue.py\nnew file mode 100644\nindex 0000000000..4f50f149d7\n--- /dev/null\n+++ b/test_union_issue.py\n@@ -0,0 +1,85 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    SECRET_KEY='test-key'\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Q\n+\n+# Now let's test the behavior of .none() on different query types\n+\n+# Create a minimal test\n+print(\"Testing QuerySet behaviors:\")\n+\n+# Regular queryset\n+from django.contrib.auth.models import User\n+qs1 = User.objects.filter(id__lt=2) | User.objects.filter(id__gt=5)\n+qs2 = User.objects.filter(id__lt=2).union(User.objects.filter(id__gt=5))\n+\n+print(f\"\\nRegular OR queryset type: {type(qs1)}\")\n+print(f\"Union queryset type: {type(qs2)}\")\n+\n+# Apply .none() to each\n+none1 = qs1.none()\n+none2 = qs2.none()\n+\n+print(f\"\\nOR queryset.none() type: {type(none1)}\")\n+print(f\"Union queryset.none() type: {type(none2)}\")\n+\n+# Let's check the queries\n+try:\n+    print(f\"\\nOR queryset query: {qs1.query}\")\n+except Exception as e:\n+    print(f\"\\nOR queryset query error: {e}\")\n+print(f\"Union queryset can't show query (combinator query)\")\n+\n+try:\n+    print(f\"\\nOR queryset.none() query: {none1.query}\")\n+except Exception as e:\n+    print(f\"\\nOR queryset.none() query error: {e}\")\n+try:\n+    print(f\"Union queryset.none() query: {none2.query}\")\n+except Exception as e:\n+    print(f\"Union queryset.none() query error: {e}\")\n+\n+# Check actual results\n+print(f\"\\nOR queryset.none() count: {none1.count()}\")\n+print(f\"Union queryset.none() count: {none2.count()}\")\n+\n+# Let's check the internal structure\n+print(\"\\n--- Checking internal structure ---\")\n+print(f\"none1._result_cache: {none1._result_cache}\")  \n+print(f\"none2._result_cache: {none2._result_cache}\")\n+\n+print(f\"\\nnone1.__class__.__name__: {none1.__class__.__name__}\")\n+print(f\"none2.__class__.__name__: {none2.__class__.__name__}\")\n+\n+# Check if they have different implementations\n+import inspect\n+print(f\"\\nnone1.none method location: {inspect.getfile(none1.none.__func__)}\")\n+print(f\"none2.none method location: {inspect.getfile(none2.none.__func__)}\")\n+\n+# Let's check if it's a combinator query\n+print(f\"\\nIs none1 a combinator query? {hasattr(none1.query, 'combinator')}\")\n+print(f\"Is none2 a combinator query? {hasattr(none2.query, 'combinator')}\")\n+\n+if hasattr(none2.query, 'combinator'):\n+    print(f\"none2 combinator: {none2.query.combinator}\")\n+    print(f\"none2 combined_queries: {none2.query.combined_queries}\")\n", "gold_standard_diff": "From 43c19055447c7976d8514f612e429d29894a46da Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Mon, 6 Jul 2020 21:14:25 +0200\nSubject: [PATCH] Fixed #31767 -- Fixed QuerySet.none() on combined queryset.\n\n---\n django/db/models/sql/query.py        | 3 +++\n tests/queries/test_qs_combinators.py | 7 +++++++\n 2 files changed, 10 insertions(+)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c913267476ad..1623263964d9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -305,6 +305,7 @@ def clone(self):\n             obj.annotation_select_mask = None\n         else:\n             obj.annotation_select_mask = self.annotation_select_mask.copy()\n+        obj.combined_queries = tuple(query.clone() for query in self.combined_queries)\n         # _annotation_select_cache cannot be copied, as doing so breaks the\n         # (necessary) state in which both annotations and\n         # _annotation_select_cache point to the same underlying objects.\n@@ -1777,6 +1778,8 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n \n     def set_empty(self):\n         self.where.add(NothingNode(), AND)\n+        for query in self.combined_queries:\n+            query.set_empty()\n \n     def is_empty(self):\n         return any(isinstance(c, NothingNode) for c in self.where.children)\ndiff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 9c6fd474ca62..75e2aa2f39a5 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -51,6 +51,13 @@ def test_union_distinct(self):\n         self.assertEqual(len(list(qs1.union(qs2, all=True))), 20)\n         self.assertEqual(len(list(qs1.union(qs2))), 10)\n \n+    def test_union_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = qs1.union(qs2)\n+        self.assertSequenceEqual(qs3.none(), [])\n+        self.assertNumbersEqual(qs3, [0, 1, 8, 9], ordered=False)\n+\n     @skipUnlessDBFeature('supports_select_intersection')\n     def test_intersection_with_empty_qs(self):\n         qs1 = Number.objects.all()\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13158"}