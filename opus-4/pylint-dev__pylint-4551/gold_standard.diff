From 4b35586e1e5a94cd8dd5876597559d13ec5e25c6 Mon Sep 17 00:00:00 2001
From: Mark Byrne <mbyrnepr2@gmail.com>
Date: Sat, 15 May 2021 19:15:06 +0200
Subject: [PATCH 1/3] Add type annotations to pyreverse dot files

Closes #1548
---
 ChangeLog                     |  4 ++++
 doc/whatsnew/2.9.rst          |  2 ++
 pylint/pyreverse/diagrams.py  |  2 +-
 pylint/pyreverse/inspector.py | 14 ++++++++++++--
 pylint/pyreverse/writer.py    | 11 ++++++++++-
 5 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 9f4bd8462d..0b3046c640 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -9,6 +9,10 @@ Release date: TBA
 ..
   Put new features and bugfixes here and also in 'doc/whatsnew/2.9.rst'
 
+* Add type annotations to pyreverse dot files
+
+  Closes #1548
+
 * Added ``deprecated-decorator``: Emitted when deprecated decorator is used.
 
   Closes #4429
diff --git a/doc/whatsnew/2.9.rst b/doc/whatsnew/2.9.rst
index 59ad255c07..bbdd90769b 100644
--- a/doc/whatsnew/2.9.rst
+++ b/doc/whatsnew/2.9.rst
@@ -40,6 +40,8 @@ New checkers
 Other Changes
 =============
 
+* Add type annotations to pyreverse dot files
+
 * Pylint's tags are now the standard form ``vX.Y.Z`` and not ``pylint-X.Y.Z`` anymore.
 
 * Fix false-positive ``too-many-ancestors`` when inheriting from builtin classes,
diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py
index bf9f67af66..f111bfe0ed 100644
--- a/pylint/pyreverse/diagrams.py
+++ b/pylint/pyreverse/diagrams.py
@@ -122,7 +122,7 @@ def class_names(self, nodes):
             if isinstance(node, astroid.Instance):
                 node = node._proxied
             if (
-                isinstance(node, astroid.ClassDef)
+                isinstance(node, (astroid.ClassDef, astroid.Name))
                 and hasattr(node, "name")
                 and not self.has_node(node)
             ):
diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py
index 8fa1220224..a301b4defc 100644
--- a/pylint/pyreverse/inspector.py
+++ b/pylint/pyreverse/inspector.py
@@ -218,7 +218,8 @@ def visit_assignname(self, node):
                     self.visit_module(frame)
 
             current = frame.locals_type[node.name]
-            values = set(node.infer())
+            ann = getattr(node.parent, "annotation", None)
+            values = {ann} if ann else set(node.infer())
             frame.locals_type[node.name] = list(set(current) | values)
         except astroid.InferenceError:
             pass
@@ -229,8 +230,17 @@ def handle_assignattr_type(node, parent):
 
         handle instance_attrs_type
         """
+        ann = None
+        if isinstance(node.parent.value, astroid.Name):
+            try:
+                idx = list(node.parent.parent.locals).index(node.parent.value.name)
+                ann = node.parent.parent.args.annotations[idx]
+            except (IndexError, ValueError):
+                pass
+        elif hasattr(node.parent, "annotation"):
+            ann = node.parent.annotation
         try:
-            values = set(node.infer())
+            values = {ann} if ann else set(node.infer())
             current = set(parent.instance_attrs_type[node.attrname])
             parent.instance_attrs_type[node.attrname] = list(current | values)
         except astroid.InferenceError:
diff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py
index 0d80bb9ca6..d68fcd56e0 100644
--- a/pylint/pyreverse/writer.py
+++ b/pylint/pyreverse/writer.py
@@ -134,11 +134,20 @@ def get_values(self, obj):
         if not self.config.only_classnames:
             label = r"{}|{}\l|".format(label, r"\l".join(obj.attrs))
             for func in obj.methods:
+                return_type = f": {func.returns.name}" if func.returns else ""
+
                 if func.args.args:
                     args = [arg.name for arg in func.args.args if arg.name != "self"]
                 else:
                     args = []
-                label = r"{}{}({})\l".format(label, func.name, ", ".join(args))
+
+                annotations = [a.name if a else None for a in func.args.annotations[1:]]
+                args = ", ".join(
+                    f"{arg}: {ann}" if ann else f"{arg}"
+                    for arg, ann in zip(args, annotations)
+                )
+
+                label = fr"{label}{func.name}({args}){return_type}\l"
             label = "{%s}" % label
         if is_exception(obj.node):
             return dict(fontcolor="red", label=label, shape="record")

From 4534b72c1325fafb990828044b57729ca93f1757 Mon Sep 17 00:00:00 2001
From: Mark Byrne <mbyrnepr2@gmail.com>
Date: Mon, 14 Jun 2021 07:56:45 +0200
Subject: [PATCH 2/3] Add type annotations to pyreverse dot files

- Indicate the attribute is optional in the dot files by
  inspecting the default value.
- Handle the Subscript type annotations
- Refactor & move the logic to obtain annotations to utils.py as
  re-usable functions
- Add unittests for the added functions
---
 pylint/pyreverse/diagrams.py       |  2 +-
 pylint/pyreverse/inspector.py      | 12 ++------
 pylint/pyreverse/utils.py          | 43 ++++++++++++++++++++++++++++
 pylint/pyreverse/writer.py         | 21 ++++++++++----
 tests/unittest_pyreverse_writer.py | 46 +++++++++++++++++++++++++++++-
 5 files changed, 106 insertions(+), 18 deletions(-)

diff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py
index f111bfe0ed..4c391c7fa8 100644
--- a/pylint/pyreverse/diagrams.py
+++ b/pylint/pyreverse/diagrams.py
@@ -122,7 +122,7 @@ def class_names(self, nodes):
             if isinstance(node, astroid.Instance):
                 node = node._proxied
             if (
-                isinstance(node, (astroid.ClassDef, astroid.Name))
+                isinstance(node, (astroid.ClassDef, astroid.Name, astroid.Subscript))
                 and hasattr(node, "name")
                 and not self.has_node(node)
             ):
diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py
index a301b4defc..1923f0252a 100644
--- a/pylint/pyreverse/inspector.py
+++ b/pylint/pyreverse/inspector.py
@@ -218,7 +218,7 @@ def visit_assignname(self, node):
                     self.visit_module(frame)
 
             current = frame.locals_type[node.name]
-            ann = getattr(node.parent, "annotation", None)
+            ann = utils.get_annotation(node)
             values = {ann} if ann else set(node.infer())
             frame.locals_type[node.name] = list(set(current) | values)
         except astroid.InferenceError:
@@ -230,15 +230,7 @@ def handle_assignattr_type(node, parent):
 
         handle instance_attrs_type
         """
-        ann = None
-        if isinstance(node.parent.value, astroid.Name):
-            try:
-                idx = list(node.parent.parent.locals).index(node.parent.value.name)
-                ann = node.parent.parent.args.annotations[idx]
-            except (IndexError, ValueError):
-                pass
-        elif hasattr(node.parent, "annotation"):
-            ann = node.parent.annotation
+        ann = utils.get_annotation(node)
         try:
             values = {ann} if ann else set(node.infer())
             current = set(parent.instance_attrs_type[node.attrname])
diff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py
index 34558aac1b..2d7231ee13 100644
--- a/pylint/pyreverse/utils.py
+++ b/pylint/pyreverse/utils.py
@@ -18,6 +18,9 @@
 import os
 import re
 import sys
+from typing import Optional, Union
+
+import astroid
 
 RCFILE = ".pyreverserc"
 
@@ -212,3 +215,43 @@ def visit(self, node):
         if methods[1] is not None:
             return methods[1](node)
         return None
+
+
+def get_annotation_label(ann: Union[astroid.Name, astroid.Subscript]) -> str:
+    label = ""
+    if isinstance(ann, astroid.Subscript):
+        label = ann.as_string()
+    elif isinstance(ann, astroid.Name):
+        label = ann.name
+    return label
+
+
+def get_annotation(
+    node: Union[astroid.AnnAssign, astroid.AssignAttr]
+) -> Optional[Union[astroid.Name, astroid.Subscript]]:
+    """return the annotation for `node`"""
+    ann = None
+    if isinstance(node.parent, astroid.AnnAssign):
+        ann = node.parent.annotation
+    elif isinstance(node, astroid.AssignAttr):
+        init_method = node.parent.parent
+        try:
+            annotations = dict(zip(init_method.locals, init_method.args.annotations))
+            ann = annotations.get(node.parent.value.name)
+        except AttributeError:
+            pass
+    else:
+        return ann
+
+    default, *_ = node.infer()
+    label = get_annotation_label(ann)
+    if ann:
+        label = (
+            rf"Optional[{label}]"
+            if getattr(default, "value", "value") is None
+            and not label.startswith("Optional")
+            else label
+        )
+    if label:
+        ann.name = label
+    return ann
diff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py
index d68fcd56e0..baafc6904f 100644
--- a/pylint/pyreverse/writer.py
+++ b/pylint/pyreverse/writer.py
@@ -19,7 +19,7 @@
 import os
 
 from pylint.graph import DotBackend
-from pylint.pyreverse.utils import is_exception
+from pylint.pyreverse.utils import get_annotation_label, is_exception
 from pylint.pyreverse.vcgutils import VCGPrinter
 
 
@@ -134,17 +134,26 @@ def get_values(self, obj):
         if not self.config.only_classnames:
             label = r"{}|{}\l|".format(label, r"\l".join(obj.attrs))
             for func in obj.methods:
-                return_type = f": {func.returns.name}" if func.returns else ""
+                return_type = (
+                    f": {get_annotation_label(func.returns)}" if func.returns else ""
+                )
 
                 if func.args.args:
-                    args = [arg.name for arg in func.args.args if arg.name != "self"]
+                    args = [arg for arg in func.args.args if arg.name != "self"]
                 else:
                     args = []
 
-                annotations = [a.name if a else None for a in func.args.annotations[1:]]
+                annotations = dict(zip(args, func.args.annotations[1:]))
+                for arg in args:
+                    annotation_label = ""
+                    ann = annotations.get(arg)
+                    if ann:
+                        annotation_label = get_annotation_label(ann)
+                    annotations[arg] = annotation_label
+
                 args = ", ".join(
-                    f"{arg}: {ann}" if ann else f"{arg}"
-                    for arg, ann in zip(args, annotations)
+                    f"{arg.name}: {ann}" if ann else f"{arg.name}"
+                    for arg, ann in annotations.items()
                 )
 
                 label = fr"{label}{func.name}({args}){return_type}\l"
diff --git a/tests/unittest_pyreverse_writer.py b/tests/unittest_pyreverse_writer.py
index 98bb014881..8ffdbafda9 100644
--- a/tests/unittest_pyreverse_writer.py
+++ b/tests/unittest_pyreverse_writer.py
@@ -23,11 +23,12 @@
 import os
 from difflib import unified_diff
 
+import astroid
 import pytest
 
 from pylint.pyreverse.diadefslib import DefaultDiadefGenerator, DiadefsHandler
 from pylint.pyreverse.inspector import Linker, project_from_files
-from pylint.pyreverse.utils import get_visibility
+from pylint.pyreverse.utils import get_annotation, get_visibility
 from pylint.pyreverse.writer import DotWriter
 
 _DEFAULTS = {
@@ -132,3 +133,46 @@ def test_get_visibility(names, expected):
     for name in names:
         got = get_visibility(name)
         assert got == expected, f"got {got} instead of {expected} for value {name}"
+
+
+@pytest.mark.parametrize(
+    "assign, label",
+    [
+        ("a: str = None", "Optional[str]"),
+        ("a: str = 'mystr'", "str"),
+        ("a: Optional[str] = 'str'", "Optional[str]"),
+        ("a: Optional[str] = None", "Optional[str]"),
+    ],
+)
+def test_get_annotation_annassign(assign, label):
+    """AnnAssign"""
+    node = astroid.extract_node(assign)
+    got = get_annotation(node.value).name
+    assert isinstance(node, astroid.AnnAssign)
+    assert got == label, f"got {got} instead of {label} for value {node}"
+
+
+@pytest.mark.parametrize(
+    "init_method, label",
+    [
+        ("def __init__(self, x: str):                   self.x = x", "str"),
+        ("def __init__(self, x: str = 'str'):           self.x = x", "str"),
+        ("def __init__(self, x: str = None):            self.x = x", "Optional[str]"),
+        ("def __init__(self, x: Optional[str]):         self.x = x", "Optional[str]"),
+        ("def __init__(self, x: Optional[str] = None):  self.x = x", "Optional[str]"),
+        ("def __init__(self, x: Optional[str] = 'str'): self.x = x", "Optional[str]"),
+    ],
+)
+def test_get_annotation_assignattr(init_method, label):
+    """AssignAttr"""
+    assign = rf"""
+        class A:
+            {init_method}
+    """
+    node = astroid.extract_node(assign)
+    instance_attrs = node.instance_attrs
+    for _, assign_attrs in instance_attrs.items():
+        for assign_attr in assign_attrs:
+            got = get_annotation(assign_attr).name
+            assert isinstance(assign_attr, astroid.AssignAttr)
+            assert got == label, f"got {got} instead of {label} for value {node}"

From 194e6d35d40f15828bae97dccd4871d49537bdbc Mon Sep 17 00:00:00 2001
From: Mark Byrne <mbyrnepr2@gmail.com>
Date: Sat, 26 Jun 2021 17:55:02 +0200
Subject: [PATCH 3/3] Add type annotations to pyreverse dot files

- Add a try/except to deal with a possible InferenceError when using
NodeNG.infer method
- Create a function in utils and so remove repeated logic in inspector.py
- Add unittests to check the InferenceError logic
- Adjust the types in function input
---
 pylint/pyreverse/inspector.py      | 42 ++++++++++++------------------
 pylint/pyreverse/utils.py          | 21 +++++++++++++--
 tests/unittest_pyreverse_writer.py | 29 ++++++++++++++++++++-
 3 files changed, 64 insertions(+), 28 deletions(-)

diff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py
index 1923f0252a..d6c0bb9c6a 100644
--- a/pylint/pyreverse/inspector.py
+++ b/pylint/pyreverse/inspector.py
@@ -205,24 +205,19 @@ def visit_assignname(self, node):
             # the name has been defined as 'global' in the frame and belongs
             # there.
             frame = node.root()
-        try:
-            if not hasattr(frame, "locals_type"):
-                # If the frame doesn't have a locals_type yet,
-                # it means it wasn't yet visited. Visit it now
-                # to add what's missing from it.
-                if isinstance(frame, astroid.ClassDef):
-                    self.visit_classdef(frame)
-                elif isinstance(frame, astroid.FunctionDef):
-                    self.visit_functiondef(frame)
-                else:
-                    self.visit_module(frame)
-
-            current = frame.locals_type[node.name]
-            ann = utils.get_annotation(node)
-            values = {ann} if ann else set(node.infer())
-            frame.locals_type[node.name] = list(set(current) | values)
-        except astroid.InferenceError:
-            pass
+        if not hasattr(frame, "locals_type"):
+            # If the frame doesn't have a locals_type yet,
+            # it means it wasn't yet visited. Visit it now
+            # to add what's missing from it.
+            if isinstance(frame, astroid.ClassDef):
+                self.visit_classdef(frame)
+            elif isinstance(frame, astroid.FunctionDef):
+                self.visit_functiondef(frame)
+            else:
+                self.visit_module(frame)
+
+        current = frame.locals_type[node.name]
+        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))
 
     @staticmethod
     def handle_assignattr_type(node, parent):
@@ -230,13 +225,10 @@ def handle_assignattr_type(node, parent):
 
         handle instance_attrs_type
         """
-        ann = utils.get_annotation(node)
-        try:
-            values = {ann} if ann else set(node.infer())
-            current = set(parent.instance_attrs_type[node.attrname])
-            parent.instance_attrs_type[node.attrname] = list(current | values)
-        except astroid.InferenceError:
-            pass
+        current = set(parent.instance_attrs_type[node.attrname])
+        parent.instance_attrs_type[node.attrname] = list(
+            current | utils.infer_node(node)
+        )
 
     def visit_import(self, node):
         """visit an astroid.Import node
diff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py
index 18d2e96a6d..1f4a65e5be 100644
--- a/pylint/pyreverse/utils.py
+++ b/pylint/pyreverse/utils.py
@@ -228,7 +228,7 @@ def get_annotation_label(ann: Union[astroid.Name, astroid.Subscript]) -> str:
 
 
 def get_annotation(
-    node: Union[astroid.AnnAssign, astroid.AssignAttr]
+    node: Union[astroid.AssignAttr, astroid.AssignName]
 ) -> Optional[Union[astroid.Name, astroid.Subscript]]:
     """return the annotation for `node`"""
     ann = None
@@ -244,7 +244,11 @@ def get_annotation(
     else:
         return ann
 
-    default, *_ = node.infer()
+    try:
+        default, *_ = node.infer()
+    except astroid.InferenceError:
+        default = ""
+
     label = get_annotation_label(ann)
     if ann:
         label = (
@@ -256,3 +260,16 @@ def get_annotation(
     if label:
         ann.name = label
     return ann
+
+
+def infer_node(node: Union[astroid.AssignAttr, astroid.AssignName]) -> set:
+    """Return a set containing the node annotation if it exists
+    otherwise return a set of the inferred types using the NodeNG.infer method"""
+
+    ann = get_annotation(node)
+    if ann:
+        return {ann}
+    try:
+        return set(node.infer())
+    except astroid.InferenceError:
+        return set()
diff --git a/tests/unittest_pyreverse_writer.py b/tests/unittest_pyreverse_writer.py
index 8ffdbafda9..95b1b20e05 100644
--- a/tests/unittest_pyreverse_writer.py
+++ b/tests/unittest_pyreverse_writer.py
@@ -22,13 +22,14 @@
 import codecs
 import os
 from difflib import unified_diff
+from unittest.mock import patch
 
 import astroid
 import pytest
 
 from pylint.pyreverse.diadefslib import DefaultDiadefGenerator, DiadefsHandler
 from pylint.pyreverse.inspector import Linker, project_from_files
-from pylint.pyreverse.utils import get_annotation, get_visibility
+from pylint.pyreverse.utils import get_annotation, get_visibility, infer_node
 from pylint.pyreverse.writer import DotWriter
 
 _DEFAULTS = {
@@ -176,3 +177,29 @@ class A:
             got = get_annotation(assign_attr).name
             assert isinstance(assign_attr, astroid.AssignAttr)
             assert got == label, f"got {got} instead of {label} for value {node}"
+
+
+@patch("pylint.pyreverse.utils.get_annotation")
+@patch("astroid.node_classes.NodeNG.infer", side_effect=astroid.InferenceError)
+def test_infer_node_1(mock_infer, mock_get_annotation):
+    """Return set() when astroid.InferenceError is raised and an annotation has
+    not been returned
+    """
+    mock_get_annotation.return_value = None
+    node = astroid.extract_node("a: str = 'mystr'")
+    mock_infer.return_value = "x"
+    assert infer_node(node) == set()
+    assert mock_infer.called
+
+
+@patch("pylint.pyreverse.utils.get_annotation")
+@patch("astroid.node_classes.NodeNG.infer")
+def test_infer_node_2(mock_infer, mock_get_annotation):
+    """Return set(node.infer()) when InferenceError is not raised and an
+    annotation has not been returned
+    """
+    mock_get_annotation.return_value = None
+    node = astroid.extract_node("a: str = 'mystr'")
+    mock_infer.return_value = "x"
+    assert infer_node(node) == set("x")
+    assert mock_infer.called
