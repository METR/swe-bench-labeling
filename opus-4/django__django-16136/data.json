{"instance_id": "django__django-16136", "score": "C", "diff": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex db1842e3e5..9e0362f166 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -148,7 +148,15 @@ class View:\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        response = HttpResponseNotAllowed(self._allowed_methods())\n+        \n+        if self.view_is_async:\n+            async def func():\n+                return response\n+            \n+            return func()\n+        else:\n+            return response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\ndiff --git a/test_async_view.py b/test_async_view.py\nnew file mode 100644\nindex 0000000000..eb2a626224\n--- /dev/null\n+++ b/test_async_view.py\n@@ -0,0 +1,55 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    DEFAULT_CHARSET='utf-8',\n+    ALLOWED_HOSTS=['*'],\n+    MIDDLEWARE=[],\n+    ROOT_URLCONF=[],\n+)\n+django.setup()\n+\n+from django.views import View\n+from django.http import HttpResponse\n+\n+class Demo(View):\n+    \"\"\"This basic view supports only POST requests\"\"\"\n+    async def post(self, request):\n+        return HttpResponse(\"ok\")\n+\n+# Test the issue\n+from django.test import RequestFactory\n+\n+# Create a request factory\n+rf = RequestFactory()\n+\n+# Create a GET request to the view\n+request = rf.get('/demo')\n+\n+# Get the view callable\n+view = Demo.as_view()\n+\n+# Call the view - this should work now\n+try:\n+    import asyncio\n+    response = asyncio.run(view(request))\n+    print(f\"Response status code: {response.status_code}\")\n+    print(f\"Response type: {type(response)}\")\n+    print(f\"Allowed methods: {response['Allow']}\")\n+    print(\"Success! The async view correctly returned a 405 response for GET request\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+\n+# Test POST request (should work)\n+print(\"\\nTesting POST request...\")\n+post_request = rf.post('/demo')\n+try:\n+    response = asyncio.run(view(post_request))\n+    print(f\"POST Response status code: {response.status_code}\")\n+    print(f\"POST Response content: {response.content.decode()}\")\n+except Exception as e:\n+    print(f\"POST Error: {e}\")\ndiff --git a/test_mixed_view.py b/test_mixed_view.py\nnew file mode 100644\nindex 0000000000..4b3f51c4d7\n--- /dev/null\n+++ b/test_mixed_view.py\n@@ -0,0 +1,39 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    DEFAULT_CHARSET='utf-8',\n+    ALLOWED_HOSTS=['*'],\n+    MIDDLEWARE=[],\n+    ROOT_URLCONF=[],\n+)\n+django.setup()\n+\n+from django.views import View\n+from django.http import HttpResponse\n+\n+class MixedDemo(View):\n+    \"\"\"This view has mixed sync/async handlers - should raise error\"\"\"\n+    async def post(self, request):\n+        return HttpResponse(\"ok from async\")\n+    \n+    def get(self, request):\n+        return HttpResponse(\"ok from sync\")\n+\n+# Test the issue\n+from django.test import RequestFactory\n+\n+# Create a request factory\n+rf = RequestFactory()\n+\n+# Get the view callable - this should raise an error\n+try:\n+    view = MixedDemo.as_view()\n+    print(\"ERROR: Mixed view should have raised ImproperlyConfigured!\")\n+except Exception as e:\n+    print(f\"Expected error: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+    print(\"Success! Mixed sync/async handlers are properly detected\")\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000000..411725704a\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,74 @@\n+\"\"\"\n+Test to reproduce the exact issue described in the bug report.\n+\"\"\"\n+\n+import django\n+from django.conf import settings\n+from django.urls import path\n+\n+# Configure Django settings as in the report\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    DEFAULT_CHARSET='utf-8',\n+    ALLOWED_HOSTS=['*'],\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'django.contrib.sessions',\n+    ],\n+    MIDDLEWARE=[\n+        'django.middleware.security.SecurityMiddleware',\n+        'django.contrib.sessions.middleware.SessionMiddleware',\n+        'django.middleware.common.CommonMiddleware',\n+        'django.middleware.csrf.CsrfViewMiddleware',\n+        'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        'django.contrib.messages.middleware.MessageMiddleware',\n+    ],\n+    ROOT_URLCONF=__name__,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+)\n+\n+django.setup()\n+\n+from django.views import View\n+from django.http import HttpResponse\n+from django.test import Client\n+\n+class Demo(View):\n+    \"\"\"This basic view supports only POST requests\"\"\"\n+    async def post(self, request):\n+        return HttpResponse(\"ok\")\n+\n+# URL patterns\n+urlpatterns = [\n+    path(\"demo\", Demo.as_view()),\n+]\n+\n+# Test with Django test client\n+client = Client()\n+\n+# This should cause the issue before our fix\n+print(\"Testing GET request to async view with only POST handler...\")\n+try:\n+    response = client.get('/demo')\n+    print(f\"Response status: {response.status_code}\")\n+    print(f\"Response Allow header: {response.get('Allow')}\")\n+    print(\"SUCCESS: The issue is fixed!\")\n+except Exception as e:\n+    print(f\"ERROR: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+\n+# Test POST request (should work)\n+print(\"\\nTesting POST request...\")\n+try:\n+    response = client.post('/demo')\n+    print(f\"Response status: {response.status_code}\")\n+    print(f\"Response content: {response.content.decode()}\")\n+except Exception as e:\n+    print(f\"POST Error: {e}\")\ndiff --git a/test_sync_view.py b/test_sync_view.py\nnew file mode 100644\nindex 0000000000..61f3190716\n--- /dev/null\n+++ b/test_sync_view.py\n@@ -0,0 +1,54 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    DEFAULT_CHARSET='utf-8',\n+    ALLOWED_HOSTS=['*'],\n+    MIDDLEWARE=[],\n+    ROOT_URLCONF=[],\n+)\n+django.setup()\n+\n+from django.views import View\n+from django.http import HttpResponse\n+\n+class SyncDemo(View):\n+    \"\"\"This basic view supports only POST requests\"\"\"\n+    def post(self, request):\n+        return HttpResponse(\"ok from sync\")\n+\n+# Test the issue\n+from django.test import RequestFactory\n+\n+# Create a request factory\n+rf = RequestFactory()\n+\n+# Create a GET request to the view\n+request = rf.get('/demo')\n+\n+# Get the view callable\n+view = SyncDemo.as_view()\n+\n+# Call the view - this should work for sync views\n+try:\n+    response = view(request)\n+    print(f\"Response status code: {response.status_code}\")\n+    print(f\"Response type: {type(response)}\")\n+    print(f\"Allowed methods: {response['Allow']}\")\n+    print(\"Success! The sync view correctly returned a 405 response for GET request\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+\n+# Test POST request (should work)\n+print(\"\\nTesting POST request...\")\n+post_request = rf.post('/demo')\n+try:\n+    response = view(post_request)\n+    print(f\"POST Response status code: {response.status_code}\")\n+    print(f\"POST Response content: {response.content.decode()}\")\n+except Exception as e:\n+    print(f\"POST Error: {e}\")\ndiff --git a/tests/async/tests.py b/tests/async/tests.py\nindex 66eece4b97..98d181503c 100644\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -125,3 +125,44 @@ class ViewTests(SimpleTestCase):\n         sync.\n         \"\"\"\n         self.assertIs(View.view_is_async, False)\n+\n+    def test_http_method_not_allowed_responds_correctly(self):\n+        \"\"\"\n+        Test that http_method_not_allowed returns a coroutine for async views\n+        and a regular response for sync views.\n+        \"\"\"\n+        from django.test import RequestFactory\n+        \n+        rf = RequestFactory()\n+        \n+        # Test async view with method not allowed\n+        class AsyncOnlyPostView(View):\n+            async def post(self, request, *args, **kwargs):\n+                return HttpResponse(\"POST response\")\n+        \n+        # Test sync view with method not allowed  \n+        class SyncOnlyPostView(View):\n+            def post(self, request, *args, **kwargs):\n+                return HttpResponse(\"POST response\")\n+        \n+        tests = [\n+            (AsyncOnlyPostView, True),\n+            (SyncOnlyPostView, False),\n+        ]\n+        \n+        for view_cls, is_async in tests:\n+            with self.subTest(view_cls=view_cls, is_async=is_async):\n+                view = view_cls.as_view()\n+                # GET request to a view that only implements POST\n+                request = rf.get('/')\n+                \n+                if is_async:\n+                    # For async views, the view should return a coroutine\n+                    response = asyncio.run(view(request))\n+                else:\n+                    # For sync views, it should return directly\n+                    response = view(request)\n+                    \n+                self.assertEqual(response.status_code, 405)\n+                self.assertEqual(response['Allow'], 'POST, OPTIONS')\n+        self.assertIs(View.view_is_async, False)\n", "gold_standard_diff": "diff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex db1842e3e5e7..3a3afb0c7347 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -148,7 +148,16 @@ def http_method_not_allowed(self, request, *args, **kwargs):\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        response = HttpResponseNotAllowed(self._allowed_methods())\n+\n+        if self.view_is_async:\n+\n+            async def func():\n+                return response\n+\n+            return func()\n+        else:\n+            return response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\ndiff --git a/docs/releases/4.1.2.txt b/docs/releases/4.1.2.txt\nindex 57b0b6c6e808..d607c34c920f 100644\n--- a/docs/releases/4.1.2.txt\n+++ b/docs/releases/4.1.2.txt\n@@ -39,3 +39,7 @@ Bugfixes\n * Fixed a regression in Django 4.1 that didn't alter a sequence type when\n   altering type of pre-Django 4.1 serial columns on PostgreSQL\n   (:ticket:`34058`).\n+\n+* Fixed a regression in Django 4.1 that caused a crash for :class:`View`\n+  subclasses with asynchronous handlers when handling non-allowed HTTP methods\n+  (:ticket:`34062`).\ndiff --git a/tests/async/tests.py b/tests/async/tests.py\nindex 66eece4b975f..559f21b8b10b 100644\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -6,8 +6,8 @@\n \n from django.core.cache import DEFAULT_CACHE_ALIAS, caches\n from django.core.exceptions import ImproperlyConfigured, SynchronousOnlyOperation\n-from django.http import HttpResponse\n-from django.test import SimpleTestCase\n+from django.http import HttpResponse, HttpResponseNotAllowed\n+from django.test import RequestFactory, SimpleTestCase\n from django.utils.asyncio import async_unsafe\n from django.views.generic.base import View\n \n@@ -119,6 +119,25 @@ def test_options_handler_responds_correctly(self):\n \n                 self.assertIsInstance(response, HttpResponse)\n \n+    def test_http_method_not_allowed_responds_correctly(self):\n+        request_factory = RequestFactory()\n+        tests = [\n+            (SyncView, False),\n+            (AsyncView, True),\n+        ]\n+        for view_cls, is_coroutine in tests:\n+            with self.subTest(view_cls=view_cls, is_coroutine=is_coroutine):\n+                instance = view_cls()\n+                response = instance.http_method_not_allowed(request_factory.post(\"/\"))\n+                self.assertIs(\n+                    asyncio.iscoroutine(response),\n+                    is_coroutine,\n+                )\n+                if is_coroutine:\n+                    response = asyncio.run(response)\n+\n+                self.assertIsInstance(response, HttpResponseNotAllowed)\n+\n     def test_base_view_class_is_sync(self):\n         \"\"\"\n         View and by extension any subclasses that don't define handlers are\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16136"}