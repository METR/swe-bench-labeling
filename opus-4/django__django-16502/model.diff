diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py
index fef5532e58..a27fc352a1 100644
--- a/django/core/servers/basehttp.py
+++ b/django/core/servers/basehttp.py
@@ -136,17 +136,47 @@ class ServerHandler(simple_server.ServerHandler):
         if "Content-Length" not in self.headers:
             self.headers["Connection"] = "close"
         # Persistent connections require threading server.
-        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):
+        elif hasattr(self, 'request_handler') and not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):
             self.headers["Connection"] = "close"
         # Mark the connection for closing if it's set as such above or if the
         # application sent the header.
-        if self.headers.get("Connection") == "close":
+        if self.headers.get("Connection") == "close" and hasattr(self, 'request_handler'):
             self.request_handler.close_connection = True
 
     def close(self):
         self.get_stdin().read()
         super().close()
 
+    def finish_response(self):
+        """
+        Send any iterable data, then close self and the iterable.
+        
+        For HEAD requests, skip sending the response body as per
+        RFC 2616 section 4.3.
+        """
+        try:
+            if self.environ.get('REQUEST_METHOD') == 'HEAD':
+                # For HEAD requests, we need to send headers but not the body
+                if not self.headers_sent:
+                    self.finish_content()
+                # Skip iterating through the result to avoid sending the body
+            else:
+                # For non-HEAD requests, use the parent implementation
+                if not self.result_is_file() or not self.sendfile():
+                    for data in self.result:
+                        self.write(data)
+                    self.finish_content()
+        except:
+            # Call close() on the iterable returned by the WSGI application
+            # in case of an exception.
+            if hasattr(self.result, 'close'):
+                self.result.close()
+            raise
+        else:
+            # We only call close() when no exception is raised, because it
+            # will set status, result, headers, and environ fields to None.
+            self.close()
+
 
 class WSGIRequestHandler(simple_server.WSGIRequestHandler):
     protocol_version = "HTTP/1.1"
diff --git a/test_curl.py b/test_curl.py
new file mode 100644
index 0000000000..20b217bbae
--- /dev/null
+++ b/test_curl.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python
+"""Test using curl to replicate the issue exactly as described."""
+import subprocess
+import time
+import os
+import sys
+
+# Setup test project
+os.system('django-admin startproject testproject')
+os.chdir('testproject')
+
+# Start runserver in background
+server = subprocess.Popen([sys.executable, 'manage.py', 'runserver'], 
+                         stdout=subprocess.PIPE, 
+                         stderr=subprocess.PIPE)
+
+# Wait for server to start
+time.sleep(3)
+
+try:
+    # Test with curl as in the issue
+    print("Testing HEAD request with curl...")
+    result = subprocess.run(['curl', '-iX', 'HEAD', 'http://127.0.0.1:8000/'], 
+                          capture_output=True, text=True)
+    print("CURL OUTPUT:")
+    print(result.stdout)
+    
+    # Check if body is present
+    if '<html>' in result.stdout or 'DOCTYPE' in result.stdout:
+        print("\n✗ FAILURE: Response body detected in HEAD request")
+    else:
+        print("\n✓ SUCCESS: No response body in HEAD request")
+        
+finally:
+    server.terminate()
+    server.wait()
+    os.chdir('..')
diff --git a/test_head_fix.py b/test_head_fix.py
new file mode 100644
index 0000000000..7027065de5
--- /dev/null
+++ b/test_head_fix.py
@@ -0,0 +1,127 @@
+#!/usr/bin/env python
+"""Direct test of ServerHandler to verify HEAD request handling."""
+import sys
+import io
+from django.core.servers.basehttp import ServerHandler
+
+def test_head_request():
+    """Test that ServerHandler doesn't send body for HEAD requests."""
+    # Create mock streams
+    stdin = io.BytesIO(b'')
+    stdout = io.BytesIO()
+    stderr = io.BytesIO()
+    
+    # Create environ for HEAD request
+    environ = {
+        'REQUEST_METHOD': 'HEAD',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '8000',
+        'PATH_INFO': '/',
+        'wsgi.input': stdin,
+        'wsgi.errors': stderr,
+        'wsgi.version': (1, 0),
+        'wsgi.multithread': False,
+        'wsgi.multiprocess': True,
+        'wsgi.run_once': False,
+        'wsgi.url_scheme': 'http',
+    }
+    
+    # Create a simple WSGI app that returns a response with body
+    def app(environ, start_response):
+        status = '200 OK'
+        headers = [('Content-Type', 'text/html')]
+        start_response(status, headers)
+        return [b'<html><body>This should not be sent for HEAD</body></html>']
+    
+    # Create handler
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+    handler.run(app)
+    
+    # Get the output
+    output = stdout.getvalue()
+    
+    # Parse the output to separate headers and body
+    parts = output.split(b'\r\n\r\n', 1)
+    headers = parts[0].decode('latin-1')
+    body = parts[1] if len(parts) > 1 else b''
+    
+    print("Response headers:")
+    print(headers)
+    print("\nResponse body length:", len(body))
+    print("Response body:", body)
+    
+    if len(body) == 0:
+        print("\n✓ SUCCESS: HEAD request returns no body")
+        return True
+    else:
+        print("\n✗ FAILURE: HEAD request returns body")
+        return False
+
+def test_get_request():
+    """Test that ServerHandler sends body for GET requests."""
+    # Create mock streams
+    stdin = io.BytesIO(b'')
+    stdout = io.BytesIO()
+    stderr = io.BytesIO()
+    
+    # Create environ for GET request
+    environ = {
+        'REQUEST_METHOD': 'GET',
+        'SERVER_NAME': 'localhost',
+        'SERVER_PORT': '8000',
+        'PATH_INFO': '/',
+        'wsgi.input': stdin,
+        'wsgi.errors': stderr,
+        'wsgi.version': (1, 0),
+        'wsgi.multithread': False,
+        'wsgi.multiprocess': True,
+        'wsgi.run_once': False,
+        'wsgi.url_scheme': 'http',
+    }
+    
+    # Create a simple WSGI app that returns a response with body
+    def app(environ, start_response):
+        status = '200 OK'
+        headers = [('Content-Type', 'text/html')]
+        start_response(status, headers)
+        return [b'<html><body>This should be sent for GET</body></html>']
+    
+    # Create handler
+    handler = ServerHandler(stdin, stdout, stderr, environ)
+    handler.run(app)
+    
+    # Get the output
+    output = stdout.getvalue()
+    
+    # Parse the output to separate headers and body
+    parts = output.split(b'\r\n\r\n', 1)
+    headers = parts[0].decode('latin-1')
+    body = parts[1] if len(parts) > 1 else b''
+    
+    print("Response headers:")
+    print(headers)
+    print("\nResponse body length:", len(body))
+    print("Response body:", body)
+    
+    if len(body) > 0:
+        print("\n✓ SUCCESS: GET request returns body")
+        return True
+    else:
+        print("\n✗ FAILURE: GET request does not return body")
+        return False
+
+if __name__ == '__main__':
+    print("Testing HEAD request...")
+    print("=" * 50)
+    head_ok = test_head_request()
+    
+    print("\n\nTesting GET request...")
+    print("=" * 50)
+    get_ok = test_get_request()
+    
+    if head_ok and get_ok:
+        print("\n\nAll tests passed!")
+        sys.exit(0)
+    else:
+        print("\n\nSome tests failed!")
+        sys.exit(1)
diff --git a/test_head_request.py b/test_head_request.py
new file mode 100644
index 0000000000..9f61f2fa65
--- /dev/null
+++ b/test_head_request.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python
+"""Test script to verify HEAD request behavior."""
+import subprocess
+import time
+import os
+import sys
+import requests
+
+# Create a simple Django project for testing
+def setup_test_project():
+    """Create a minimal Django project for testing."""
+    # Create project structure
+    os.makedirs('testproject', exist_ok=True)
+    
+    # Create settings.py
+    settings_content = '''
+DEBUG = True
+SECRET_KEY = 'test-key'
+ROOT_URLCONF = 'urls'
+ALLOWED_HOSTS = ['*']
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'django.contrib.auth',
+]
+MIDDLEWARE = []
+TEMPLATES = [{
+    'BACKEND': 'django.template.backends.django.DjangoTemplates',
+    'DIRS': [],
+    'APP_DIRS': True,
+    'OPTIONS': {
+        'context_processors': [
+            'django.template.context_processors.debug',
+            'django.template.context_processors.request',
+        ],
+    },
+}]
+'''
+    with open('testproject/settings.py', 'w') as f:
+        f.write(settings_content)
+    
+    # Create urls.py
+    urls_content = '''
+from django.urls import path
+from django.http import HttpResponse
+
+def test_view(request):
+    return HttpResponse('<html><body>Test response body</body></html>')
+
+urlpatterns = [
+    path('', test_view),
+]
+'''
+    with open('testproject/urls.py', 'w') as f:
+        f.write(urls_content)
+    
+    # Create manage.py
+    manage_content = '''#!/usr/bin/env python
+import os
+import sys
+
+if __name__ == '__main__':
+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(sys.argv)
+'''
+    with open('testproject/manage.py', 'w') as f:
+        f.write(manage_content)
+    os.chmod('testproject/manage.py', 0o755)
+
+def test_head_request():
+    """Test HEAD request behavior."""
+    # Start the development server
+    os.chdir('testproject')
+    server_proc = subprocess.Popen(
+        [sys.executable, 'manage.py', 'runserver', '8888', '--noreload'],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE
+    )
+    
+    # Wait for server to start
+    time.sleep(2)
+    
+    try:
+        # Test HEAD request
+        print("Testing HEAD request...")
+        response = requests.head('http://127.0.0.1:8888/')
+        
+        print(f"Status Code: {response.status_code}")
+        print(f"Headers: {dict(response.headers)}")
+        print(f"Content Length from header: {response.headers.get('Content-Length', 'Not set')}")
+        print(f"Actual content length: {len(response.content)}")
+        print(f"Response body: {response.content}")
+        
+        # The body should be empty for HEAD requests
+        if len(response.content) == 0:
+            print("\n✓ SUCCESS: HEAD request returns no body (compliant with RFC 2616)")
+        else:
+            print("\n✗ FAILURE: HEAD request returns body (non-compliant)")
+            
+        print("\n" + "="*50 + "\n")
+        
+        # Test GET request for comparison
+        print("Testing GET request for comparison...")
+        response = requests.get('http://127.0.0.1:8888/')
+        print(f"Status Code: {response.status_code}")
+        print(f"Content Length from header: {response.headers.get('Content-Length', 'Not set')}")
+        print(f"Actual content length: {len(response.content)}")
+        print(f"Response body preview: {response.content[:100]}...")
+        
+    finally:
+        # Clean up
+        server_proc.terminate()
+        server_proc.wait()
+        os.chdir('..')
+
+if __name__ == '__main__':
+    setup_test_project()
+    test_head_request()
diff --git a/test_head_request_fix.py b/test_head_request_fix.py
new file mode 100644
index 0000000000..d4f5c5a2e2
--- /dev/null
+++ b/test_head_request_fix.py
@@ -0,0 +1,90 @@
+#!/usr/bin/env python
+"""Test to verify HEAD request handling in Django's runserver."""
+import os
+import sys
+import django
+from django.conf import settings
+from django.test import TestCase, Client
+from django.http import HttpResponse
+from django.urls import path
+import threading
+import time
+import requests
+from wsgiref.simple_server import make_server
+from django.core.handlers.wsgi import WSGIHandler
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    ROOT_URLCONF=__name__,
+    ALLOWED_HOSTS=['*'],
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+    MIDDLEWARE=[],
+)
+
+# Set up Django
+django.setup()
+
+# Define a simple view that returns a response with body
+def test_view(request):
+    return HttpResponse('<html><body>Test response body</body></html>')
+
+# URL patterns
+urlpatterns = [
+    path('', test_view),
+]
+
+def test_head_with_runserver():
+    """Test HEAD requests using Django's built-in server."""
+    from django.core.servers.basehttp import WSGIServer, WSGIRequestHandler
+    
+    # Create WSGI handler
+    handler = WSGIHandler()
+    
+    # Create server
+    server = make_server('127.0.0.1', 0, handler, 
+                        server_class=WSGIServer,
+                        handler_class=WSGIRequestHandler)
+    port = server.server_port
+    
+    # Start server in a thread
+    server_thread = threading.Thread(target=server.serve_forever)
+    server_thread.daemon = True
+    server_thread.start()
+    
+    time.sleep(0.5)  # Give server time to start
+    
+    try:
+        # Test HEAD request
+        print("Testing HEAD request...")
+        response = requests.head(f'http://127.0.0.1:{port}/')
+        
+        print(f"Status Code: {response.status_code}")
+        print(f"Content-Length header: {response.headers.get('Content-Length', 'Not set')}")
+        print(f"Actual content length: {len(response.content)}")
+        print(f"Response body: {response.content}")
+        
+        if len(response.content) == 0:
+            print("\n✓ SUCCESS: HEAD request returns no body (RFC 2616 compliant)")
+        else:
+            print("\n✗ FAILURE: HEAD request returns body (non-compliant)")
+            print(f"Body content: {response.content.decode()}")
+            
+        print("\n" + "="*50 + "\n")
+        
+        # Test GET request for comparison
+        print("Testing GET request for comparison...")
+        response = requests.get(f'http://127.0.0.1:{port}/')
+        print(f"Status Code: {response.status_code}")
+        print(f"Content length: {len(response.content)}")
+        print(f"Response body: {response.content.decode()}")
+        
+    finally:
+        server.shutdown()
+        server_thread.join()
+
+if __name__ == '__main__':
+    test_head_with_runserver()
diff --git a/testproject/db.sqlite3 b/testproject/db.sqlite3
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/testproject/manage.py b/testproject/manage.py
new file mode 100755
index 0000000000..8bd034f0d2
--- /dev/null
+++ b/testproject/manage.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+"""Django's command-line utility for administrative tasks."""
+import os
+import sys
+
+
+def main():
+    """Run administrative tasks."""
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testproject.settings")
+    try:
+        from django.core.management import execute_from_command_line
+    except ImportError as exc:
+        raise ImportError(
+            "Couldn't import Django. Are you sure it's installed and "
+            "available on your PYTHONPATH environment variable? Did you "
+            "forget to activate a virtual environment?"
+        ) from exc
+    execute_from_command_line(sys.argv)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/testproject/testproject/__init__.py b/testproject/testproject/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/testproject/testproject/asgi.py b/testproject/testproject/asgi.py
new file mode 100644
index 0000000000..7f8fbc1461
--- /dev/null
+++ b/testproject/testproject/asgi.py
@@ -0,0 +1,16 @@
+"""
+ASGI config for testproject project.
+
+It exposes the ASGI callable as a module-level variable named ``application``.
+
+For more information on this file, see
+https://docs.djangoproject.com/en/dev/howto/deployment/asgi/
+"""
+
+import os
+
+from django.core.asgi import get_asgi_application
+
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testproject.settings")
+
+application = get_asgi_application()
diff --git a/testproject/testproject/settings.py b/testproject/testproject/settings.py
new file mode 100644
index 0000000000..9386d02621
--- /dev/null
+++ b/testproject/testproject/settings.py
@@ -0,0 +1,123 @@
+"""
+Django settings for testproject project.
+
+Generated by 'django-admin startproject' using Django 5.0.dev20230126185448.
+
+For more information on this file, see
+https://docs.djangoproject.com/en/dev/topics/settings/
+
+For the full list of settings and their values, see
+https://docs.djangoproject.com/en/dev/ref/settings/
+"""
+
+from pathlib import Path
+
+# Build paths inside the project like this: BASE_DIR / 'subdir'.
+BASE_DIR = Path(__file__).resolve().parent.parent
+
+
+# Quick-start development settings - unsuitable for production
+# See https://docs.djangoproject.com/en/dev/howto/deployment/checklist/
+
+# SECURITY WARNING: keep the secret key used in production secret!
+SECRET_KEY = "django-insecure-7(m0*bqa-_)dc8u)$vyht3iq=_n$ly_3flzl5e#1zzg)*1e-m6"
+
+# SECURITY WARNING: don't run with debug turned on in production!
+DEBUG = True
+
+ALLOWED_HOSTS = []
+
+
+# Application definition
+
+INSTALLED_APPS = [
+    "django.contrib.admin",
+    "django.contrib.auth",
+    "django.contrib.contenttypes",
+    "django.contrib.sessions",
+    "django.contrib.messages",
+    "django.contrib.staticfiles",
+]
+
+MIDDLEWARE = [
+    "django.middleware.security.SecurityMiddleware",
+    "django.contrib.sessions.middleware.SessionMiddleware",
+    "django.middleware.common.CommonMiddleware",
+    "django.middleware.csrf.CsrfViewMiddleware",
+    "django.contrib.auth.middleware.AuthenticationMiddleware",
+    "django.contrib.messages.middleware.MessageMiddleware",
+    "django.middleware.clickjacking.XFrameOptionsMiddleware",
+]
+
+ROOT_URLCONF = "testproject.urls"
+
+TEMPLATES = [
+    {
+        "BACKEND": "django.template.backends.django.DjangoTemplates",
+        "DIRS": [],
+        "APP_DIRS": True,
+        "OPTIONS": {
+            "context_processors": [
+                "django.template.context_processors.debug",
+                "django.template.context_processors.request",
+                "django.contrib.auth.context_processors.auth",
+                "django.contrib.messages.context_processors.messages",
+            ],
+        },
+    },
+]
+
+WSGI_APPLICATION = "testproject.wsgi.application"
+
+
+# Database
+# https://docs.djangoproject.com/en/dev/ref/settings/#databases
+
+DATABASES = {
+    "default": {
+        "ENGINE": "django.db.backends.sqlite3",
+        "NAME": BASE_DIR / "db.sqlite3",
+    }
+}
+
+
+# Password validation
+# https://docs.djangoproject.com/en/dev/ref/settings/#auth-password-validators
+
+AUTH_PASSWORD_VALIDATORS = [
+    {
+        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
+    },
+    {
+        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
+    },
+    {
+        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
+    },
+    {
+        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
+    },
+]
+
+
+# Internationalization
+# https://docs.djangoproject.com/en/dev/topics/i18n/
+
+LANGUAGE_CODE = "en-us"
+
+TIME_ZONE = "UTC"
+
+USE_I18N = True
+
+USE_TZ = True
+
+
+# Static files (CSS, JavaScript, Images)
+# https://docs.djangoproject.com/en/dev/howto/static-files/
+
+STATIC_URL = "static/"
+
+# Default primary key field type
+# https://docs.djangoproject.com/en/dev/ref/settings/#default-auto-field
+
+DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
diff --git a/testproject/testproject/urls.py b/testproject/testproject/urls.py
new file mode 100644
index 0000000000..0127e6d889
--- /dev/null
+++ b/testproject/testproject/urls.py
@@ -0,0 +1,23 @@
+"""
+URL configuration for testproject project.
+
+The `urlpatterns` list routes URLs to views. For more information please see:
+    https://docs.djangoproject.com/en/dev/topics/http/urls/
+Examples:
+Function views
+    1. Add an import:  from my_app import views
+    2. Add a URL to urlpatterns:  path('', views.home, name='home')
+Class-based views
+    1. Add an import:  from other_app.views import Home
+    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
+Including another URLconf
+    1. Import the include() function: from django.urls import include, path
+    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
+"""
+
+from django.contrib import admin
+from django.urls import path
+
+urlpatterns = [
+    path("admin/", admin.site.urls),
+]
diff --git a/testproject/testproject/wsgi.py b/testproject/testproject/wsgi.py
new file mode 100644
index 0000000000..c24d0012dc
--- /dev/null
+++ b/testproject/testproject/wsgi.py
@@ -0,0 +1,16 @@
+"""
+WSGI config for testproject project.
+
+It exposes the WSGI callable as a module-level variable named ``application``.
+
+For more information on this file, see
+https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/
+"""
+
+import os
+
+from django.core.wsgi import get_wsgi_application
+
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "testproject.settings")
+
+application = get_wsgi_application()
diff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py
index a837505feb..503446c011 100644
--- a/tests/servers/test_basehttp.py
+++ b/tests/servers/test_basehttp.py
@@ -106,6 +106,53 @@ class WSGIRequestHandlerTestCase(SimpleTestCase):
 
         self.assertEqual(body, b"HTTP_SOME_HEADER:good")
 
+    def test_head_request_no_body(self):
+        """HEAD requests should not return a response body."""
+        def test_app(environ, start_response):
+            """A WSGI app that returns a response with body."""
+            start_response("200 OK", [("Content-Type", "text/html")])
+            return [b"<html><body>This should not be sent for HEAD</body></html>"]
+
+        # Test HEAD request
+        rfile = BytesIO()
+        rfile.write(b"HEAD / HTTP/1.0\r\n")
+        rfile.write(b"\r\n")
+        rfile.seek(0)
+
+        class UnclosableBytesIO(BytesIO):
+            def close(self):
+                pass
+
+        wfile = UnclosableBytesIO()
+
+        def makefile(mode, *a, **kw):
+            if mode == "rb":
+                return rfile
+            elif mode == "wb":
+                return wfile
+
+        request = Stub(makefile=makefile)
+        server = Stub(base_environ={}, get_app=lambda: test_app)
+
+        # Prevent logging from appearing in test output.
+        with self.assertLogs("django.server", "INFO"):
+            WSGIRequestHandler(request, "192.168.0.2", server)
+
+        wfile.seek(0)
+        response = wfile.getvalue()
+        
+        # Split response into headers and body
+        parts = response.split(b"\r\n\r\n", 1)
+        headers = parts[0]
+        body = parts[1] if len(parts) > 1 else b""
+        
+        # Headers should be present
+        self.assertIn(b"HTTP/1.1 200", headers)
+        self.assertIn(b"Content-Type: text/html", headers)
+        
+        # Body should be empty for HEAD request
+        self.assertEqual(body, b"")
+
 
 class WSGIServerTestCase(SimpleTestCase):
     request_factory = RequestFactory()
