{"instance_id": "django__django-13569", "score": "C", "diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 04e430a42e..138582aaba 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -128,8 +128,18 @@ class SQLCompiler:\n         for expr, (sql, params, is_ref) in order_by:\n             # Skip References to the select clause, as all expressions in the\n             # select clause are already part of the group by.\n-            if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+            if is_ref:\n+                continue\n+            # Skip expressions that contain aggregates\n+            if expr.contains_aggregate:\n+                continue\n+            # Get all the GROUP BY cols for this expression, but skip Random\n+            # since it doesn't need to be in the GROUP BY\n+            group_by_cols = expr.get_group_by_cols()\n+            expressions.extend([\n+                col for col in group_by_cols\n+                if not isinstance(col, Random)\n+            ])\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\ndiff --git a/test_order_by_random_bug.py b/test_order_by_random_bug.py\nnew file mode 100644\nindex 0000000000..52ec9f3ad6\n--- /dev/null\n+++ b/test_order_by_random_bug.py\n@@ -0,0 +1,64 @@\n+import os\n+import sys\n+import django\n+from django.db import models\n+from django.db.models import Count\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['__main__'],  # Use __main__ to recognize this module\n+    USE_TZ=False,\n+)\n+django.setup()\n+\n+# Define models\n+class Thing(models.Model):\n+    class Meta:\n+        app_label = '__main__'\n+\n+class Related(models.Model):\n+    thing = models.ForeignKey(Thing, on_delete=models.CASCADE, related_name='related')\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Thing)\n+    schema_editor.create_model(Related)\n+\n+# Create test data\n+t = Thing.objects.create()\n+rs = [Related.objects.create(thing=t) for _ in range(2)]\n+\n+# Test the queries\n+print(\"1. Normal ordering by count - should work correctly:\")\n+result1 = Thing.objects.annotate(rc=Count('related')).order_by('rc').values('id', 'rc')\n+print(list(result1))\n+print(\"SQL:\", result1.query)\n+print()\n+\n+print(\"2. Ordering by related field - breaks aggregation as expected:\")\n+result2 = Thing.objects.annotate(rc=Count('related')).order_by('related').values('id', 'rc')\n+print(list(result2))\n+print(\"SQL:\", result2.query)\n+print()\n+\n+print(\"3. Random ordering - should NOT break aggregation but currently does:\")\n+result3 = Thing.objects.annotate(rc=Count('related')).order_by('?').values('id', 'rc')\n+print(list(result3))\n+print(\"SQL:\", result3.query)\n+print()\n+\n+# Check the GROUP BY clause specifically\n+print(\"Notice the RANDOM() in GROUP BY clause in query 3, which shouldn't be there!\")\ndiff --git a/test_random_order_aggregation.py b/test_random_order_aggregation.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_random_ordering_aggregation_fix.py b/test_random_ordering_aggregation_fix.py\nnew file mode 100644\nindex 0000000000..a087cbe7b6\n--- /dev/null\n+++ b/test_random_ordering_aggregation_fix.py\n@@ -0,0 +1,94 @@\n+\"\"\"\n+Test that can be added to Django's test suite to ensure order_by('?') \n+doesn't break aggregation.\n+\"\"\"\n+from django.db.models import Count\n+from django.test import TestCase\n+\n+from aggregation.models import Author, Book, Publisher\n+\n+\n+class RandomOrderingAggregationTest(TestCase):\n+    \"\"\"\n+    Test that random ordering (order_by('?')) doesn't incorrectly \n+    break queryset aggregation by adding RANDOM() to GROUP BY clause.\n+    \"\"\"\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.a1 = Author.objects.create(name='Adrian Holovaty', age=34)\n+        cls.a2 = Author.objects.create(name='Jacob Kaplan-Moss', age=35)\n+        \n+        cls.p1 = Publisher.objects.create(name='Apress', num_awards=3)\n+        \n+        cls.b1 = Book.objects.create(\n+            isbn='159059725', name='The Definitive Guide to Django',\n+            pages=447, rating=4.5, price=30, contact=cls.a1, publisher=cls.p1,\n+            pubdate='2007-12-6'\n+        )\n+        cls.b1.authors.add(cls.a1, cls.a2)\n+        \n+        cls.b2 = Book.objects.create(\n+            isbn='067232959', name='Sams Teach Yourself Django',\n+            pages=528, rating=3.0, price=40, contact=cls.a1, publisher=cls.p1,\n+            pubdate='2008-3-3'\n+        )\n+        cls.b2.authors.add(cls.a1)\n+    \n+    def test_random_ordering_preserves_aggregation(self):\n+        \"\"\"\n+        Test that order_by('?') doesn't break aggregation by adding \n+        RANDOM() to the GROUP BY clause.\n+        \"\"\"\n+        # Without random ordering - baseline\n+        result_normal = list(\n+            Publisher.objects.annotate(num_books=Count('book'))\n+            .order_by('name')\n+            .values('id', 'num_books')\n+        )\n+        self.assertEqual(len(result_normal), 1)\n+        self.assertEqual(result_normal[0]['num_books'], 2)\n+        \n+        # With random ordering - should give same aggregation result\n+        result_random = list(\n+            Publisher.objects.annotate(num_books=Count('book'))\n+            .order_by('?')\n+            .values('id', 'num_books')\n+        )\n+        self.assertEqual(len(result_random), 1)\n+        self.assertEqual(result_random[0]['num_books'], 2)\n+        \n+        # Verify the SQL doesn't have RANDOM() in GROUP BY\n+        qs = Publisher.objects.annotate(num_books=Count('book')).order_by('?')\n+        sql = str(qs.query)\n+        \n+        # The query should have ORDER BY with random function\n+        self.assertIn('ORDER BY', sql.upper())\n+        \n+        # But GROUP BY should not contain random function\n+        if 'GROUP BY' in sql.upper():\n+            # Extract the GROUP BY clause\n+            group_by_part = sql.upper().split('GROUP BY')[1].split('ORDER BY')[0]\n+            # Neither RAND() nor RANDOM() should be in GROUP BY\n+            self.assertNotIn('RAND()', group_by_part)\n+            self.assertNotIn('RANDOM()', group_by_part)\n+    \n+    def test_multiple_annotations_with_random_ordering(self):\n+        \"\"\"Test that multiple annotations work correctly with random ordering.\"\"\"\n+        result = list(\n+            Author.objects.annotate(\n+                num_books=Count('book'),\n+                num_contacts=Count('book_contact_set')\n+            )\n+            .order_by('?')\n+            .values('id', 'num_books', 'num_contacts')\n+        )\n+        \n+        # a1 has 2 books and is contact for 2 books\n+        # a2 has 1 book and is contact for 0 books\n+        results_by_id = {r['id']: r for r in result}\n+        \n+        self.assertEqual(results_by_id[self.a1.id]['num_books'], 2)\n+        self.assertEqual(results_by_id[self.a1.id]['num_contacts'], 2)\n+        self.assertEqual(results_by_id[self.a2.id]['num_books'], 1)\n+        self.assertEqual(results_by_id[self.a2.id]['num_contacts'], 0)\ndiff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex f8aeceb2d0..1aca181b2b 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1314,4 +1314,91 @@ class AggregateTestCase(TestCase):\n         # non-multivalued JOINs, see Col.possibly_multivalued (refs #31150):\n         # with self.assertNumQueries(1) as ctx:\n         #     self.assertSequenceEqual(books_qs, [book])\n+    \n+    def test_random_ordering_preserves_aggregation(self):\n+        \"\"\"\n+        Test that order_by('?') doesn't break aggregation by adding \n+        RANDOM() to the GROUP BY clause.\n+        Regression test for #xxxxx.\n+        \"\"\"\n+        # Without random ordering - baseline\n+        result_normal = list(\n+            Publisher.objects.annotate(num_books=Count('book'))\n+            .order_by('name')\n+            .values('id', 'num_books')\n+        )\n+        # Count how many publishers there are in the test data\n+        expected_count = Publisher.objects.count()\n+        self.assertEqual(len(result_normal), expected_count)\n+        \n+        # With random ordering - should give same aggregation result\n+        result_random = list(\n+            Publisher.objects.annotate(num_books=Count('book'))\n+            .order_by('?')\n+            .values('id', 'num_books')\n+        )\n+        self.assertEqual(len(result_random), expected_count)\n+        \n+        # Compare the results (sort by id for comparison)\n+        result_normal_sorted = sorted(result_normal, key=lambda x: x['id'])\n+        result_random_sorted = sorted(result_random, key=lambda x: x['id'])\n+        \n+        for normal, random in zip(result_normal_sorted, result_random_sorted):\n+            self.assertEqual(normal['id'], random['id'])\n+            self.assertEqual(normal['num_books'], random['num_books'])\n+        \n+        # Verify the SQL doesn't have RANDOM() in GROUP BY\n+        qs = Publisher.objects.annotate(num_books=Count('book')).order_by('?')\n+        sql = str(qs.query)\n+        \n+        # The query should have ORDER BY with random function\n+        self.assertIn('ORDER BY', sql.upper())\n+        \n+        # But GROUP BY should not contain random function\n+        if 'GROUP BY' in sql.upper():\n+            # Extract the GROUP BY clause\n+            group_by_part = sql.upper().split('GROUP BY')[1].split('ORDER BY')[0]\n+            # Neither RAND() nor RANDOM() should be in GROUP BY\n+            self.assertNotIn('RAND()', group_by_part)\n+            self.assertNotIn('RANDOM()', group_by_part)\n+    \n+    def test_multiple_annotations_with_random_ordering(self):\n+        \"\"\"Test that multiple annotations work correctly with random ordering.\"\"\"\n+        # Create the expected results first (without random ordering)\n+        expected = list(\n+            Author.objects.annotate(\n+                num_books=Count('book'),\n+                num_contacts=Count('book_contact_set')\n+            )\n+            .order_by('id')\n+            .values('id', 'num_books', 'num_contacts')\n+        )\n+        \n+        # Now test with random ordering\n+        result = list(\n+            Author.objects.annotate(\n+                num_books=Count('book'),\n+                num_contacts=Count('book_contact_set')\n+            )\n+            .order_by('?')\n+            .values('id', 'num_books', 'num_contacts')\n+        )\n+        \n+        # Should have same number of results\n+        self.assertEqual(len(result), len(expected))\n+        \n+        # Sort both by id for comparison\n+        expected_by_id = {r['id']: r for r in expected}\n+        result_by_id = {r['id']: r for r in result}\n+        \n+        # Verify each author has correct counts\n+        for author_id in expected_by_id:\n+            self.assertEqual(\n+                expected_by_id[author_id]['num_books'],\n+                result_by_id[author_id]['num_books']\n+            )\n+            self.assertEqual(\n+                expected_by_id[author_id]['num_contacts'],\n+                result_by_id[author_id]['num_contacts']\n+            )\n         # self.assertEqual(ctx[0]['sql'].count('SELECT'), 2)\n", "gold_standard_diff": "diff --git a/AUTHORS b/AUTHORS\nindex f1a4315c8d5f..5f1ca7ccebee 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -293,6 +293,7 @@ answer newbie questions, and generally made Django that much better:\n     Erwin Junge <erwin@junge.nl>\n     Esdras Beleza <linux@esdrasbeleza.com>\n     Espen Grindhaug <http://grindhaug.org/>\n+    \u00c9tienne Beaul\u00e9 <beauleetienne0@gmail.com>\n     Eugene Lazutkin <http://lazutkin.com/blog/>\n     Evan Grim <https://github.com/egrim>\n     Fabrice Aneche <akh@nobugware.com>\ndiff --git a/django/db/models/functions/math.py b/django/db/models/functions/math.py\nindex 304e11222531..15915f4b7cdd 100644\n--- a/django/db/models/functions/math.py\n+++ b/django/db/models/functions/math.py\n@@ -154,6 +154,9 @@ def as_oracle(self, compiler, connection, **extra_context):\n     def as_sqlite(self, compiler, connection, **extra_context):\n         return super().as_sql(compiler, connection, function='RAND', **extra_context)\n \n+    def get_group_by_cols(self, alias=None):\n+        return []\n+\n \n class Round(Transform):\n     function = 'ROUND'\ndiff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex f8aeceb2d07e..a759fd4d3659 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1315,3 +1315,18 @@ def test_aggregation_subquery_annotation_related_field(self):\n         # with self.assertNumQueries(1) as ctx:\n         #     self.assertSequenceEqual(books_qs, [book])\n         # self.assertEqual(ctx[0]['sql'].count('SELECT'), 2)\n+\n+    def test_aggregation_random_ordering(self):\n+        \"\"\"Random() is not included in the GROUP BY when used for ordering.\"\"\"\n+        authors = Author.objects.annotate(contact_count=Count('book')).order_by('?')\n+        self.assertQuerysetEqual(authors, [\n+            ('Adrian Holovaty', 1),\n+            ('Jacob Kaplan-Moss', 1),\n+            ('Brad Dayley', 1),\n+            ('James Bennett', 1),\n+            ('Jeffrey Forcier', 1),\n+            ('Paul Bissex', 1),\n+            ('Wesley J. Chun', 1),\n+            ('Stuart Russell', 1),\n+            ('Peter Norvig', 2),\n+        ], lambda a: (a.name, a.contact_count), ordered=False)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13569"}