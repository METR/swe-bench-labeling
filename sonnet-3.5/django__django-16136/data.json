{"instance_id": "django__django-16136", "score": "I", "diff": "diff --git a/django/http/response.py b/django/http/response.py\nindex 7c0db55a5d..b122cef565 100644\n--- a/django/http/response.py\n+++ b/django/http/response.py\n@@ -396,6 +396,9 @@ class HttpResponse(HttpResponseBase):\n             \"content_type\": self._content_type_for_repr,\n         }\n \n+    def __await__(self):\n+        yield self\n+\n     def serialize(self):\n         \"\"\"Full HTTP message, including headers, as a bytestring.\"\"\"\n         return self.serialize_headers() + b\"\\r\\n\\r\\n\" + self.content\n@@ -662,6 +665,9 @@ class HttpResponseNotAllowed(HttpResponse):\n             \"methods\": self[\"Allow\"],\n         }\n \n+    def __await__(self):\n+        yield self\n+\n \n class HttpResponseGone(HttpResponse):\n     status_code = 410\n", "gold_standard_diff": "From 422e07e174d171307d292d7632af641dec0bdd18 Mon Sep 17 00:00:00 2001\nFrom: Antoine Lorence <contact@alorence.me>\nDate: Thu, 29 Sep 2022 12:10:02 +0200\nSubject: [PATCH] Fixed #34062 -- Updated View.http_method_not_allowed() to\n support async.\n\nAs with the options() methods, wrap the response in a coroutine if\nthe view is async.\n\nCo-authored-by: Carlton Gibson <carlton.gibson@noumenal.es>\n---\n django/views/generic/base.py | 11 ++++++++++-\n docs/releases/4.1.2.txt      |  4 ++++\n tests/async/tests.py         | 23 +++++++++++++++++++++--\n 3 files changed, 35 insertions(+), 3 deletions(-)\n\ndiff --git a/django/views/generic/base.py b/django/views/generic/base.py\nindex db1842e3e5e7..3a3afb0c7347 100644\n--- a/django/views/generic/base.py\n+++ b/django/views/generic/base.py\n@@ -148,7 +148,16 @@ def http_method_not_allowed(self, request, *args, **kwargs):\n             request.path,\n             extra={\"status_code\": 405, \"request\": request},\n         )\n-        return HttpResponseNotAllowed(self._allowed_methods())\n+        response = HttpResponseNotAllowed(self._allowed_methods())\n+\n+        if self.view_is_async:\n+\n+            async def func():\n+                return response\n+\n+            return func()\n+        else:\n+            return response\n \n     def options(self, request, *args, **kwargs):\n         \"\"\"Handle responding to requests for the OPTIONS HTTP verb.\"\"\"\ndiff --git a/docs/releases/4.1.2.txt b/docs/releases/4.1.2.txt\nindex 57b0b6c6e808..d607c34c920f 100644\n--- a/docs/releases/4.1.2.txt\n+++ b/docs/releases/4.1.2.txt\n@@ -39,3 +39,7 @@ Bugfixes\n * Fixed a regression in Django 4.1 that didn't alter a sequence type when\n   altering type of pre-Django 4.1 serial columns on PostgreSQL\n   (:ticket:`34058`).\n+\n+* Fixed a regression in Django 4.1 that caused a crash for :class:`View`\n+  subclasses with asynchronous handlers when handling non-allowed HTTP methods\n+  (:ticket:`34062`).\ndiff --git a/tests/async/tests.py b/tests/async/tests.py\nindex 66eece4b975f..559f21b8b10b 100644\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -6,8 +6,8 @@\n \n from django.core.cache import DEFAULT_CACHE_ALIAS, caches\n from django.core.exceptions import ImproperlyConfigured, SynchronousOnlyOperation\n-from django.http import HttpResponse\n-from django.test import SimpleTestCase\n+from django.http import HttpResponse, HttpResponseNotAllowed\n+from django.test import RequestFactory, SimpleTestCase\n from django.utils.asyncio import async_unsafe\n from django.views.generic.base import View\n \n@@ -119,6 +119,25 @@ def test_options_handler_responds_correctly(self):\n \n                 self.assertIsInstance(response, HttpResponse)\n \n+    def test_http_method_not_allowed_responds_correctly(self):\n+        request_factory = RequestFactory()\n+        tests = [\n+            (SyncView, False),\n+            (AsyncView, True),\n+        ]\n+        for view_cls, is_coroutine in tests:\n+            with self.subTest(view_cls=view_cls, is_coroutine=is_coroutine):\n+                instance = view_cls()\n+                response = instance.http_method_not_allowed(request_factory.post(\"/\"))\n+                self.assertIs(\n+                    asyncio.iscoroutine(response),\n+                    is_coroutine,\n+                )\n+                if is_coroutine:\n+                    response = asyncio.run(response)\n+\n+                self.assertIsInstance(response, HttpResponseNotAllowed)\n+\n     def test_base_view_class_is_sync(self):\n         \"\"\"\n         View and by extension any subclasses that don't define handlers are\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16136"}