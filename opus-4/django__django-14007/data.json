{"instance_id": "django__django-14007", "score": "I", "diff": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 55b1691166..242a4969f3 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -872,6 +872,10 @@ class Model(metaclass=ModelBase):\n             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)\n             if results:\n                 for value, field in zip(results[0], returning_fields):\n+                    # Apply database converters for returning fields\n+                    converters = field.get_db_converters(connections[using]) + connections[using].ops.get_db_converters(field)\n+                    for converter in converters:\n+                        value = converter(value, field, connections[using])\n                     setattr(self, field.attname, value)\n         return updated\n \ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 387deca527..da4aea38e9 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -505,6 +505,10 @@ class QuerySet:\n                 for obj_with_pk, results in zip(objs_with_pk, returned_columns):\n                     for result, field in zip(results, opts.db_returning_fields):\n                         if field != opts.pk:\n+                            # Apply database converters for returning fields\n+                            converters = field.get_db_converters(connection) + connection.ops.get_db_converters(field)\n+                            for converter in converters:\n+                                result = converter(result, field, connection)\n                             setattr(obj_with_pk, field.attname, result)\n                 for obj_with_pk in objs_with_pk:\n                     obj_with_pk._state.adding = False\n@@ -518,6 +522,10 @@ class QuerySet:\n                     assert len(returned_columns) == len(objs_without_pk)\n                 for obj_without_pk, results in zip(objs_without_pk, returned_columns):\n                     for result, field in zip(results, opts.db_returning_fields):\n+                        # Apply database converters for returning fields\n+                        converters = field.get_db_converters(connection) + connection.ops.get_db_converters(field)\n+                        for converter in converters:\n+                            result = converter(result, field, connection)\n                         setattr(obj_without_pk, field.attname, result)\n                     obj_without_pk._state.adding = False\n                     obj_without_pk._state.db = self.db\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..9ac4accdcc\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,75 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='test',\n+)\n+django.setup()\n+\n+from django.db import models, connection\n+\n+\n+class MyIntWrapper(int):\n+    \"\"\"A simple wrapper to distinguish from plain int\"\"\"\n+    def __repr__(self):\n+        return f\"<MyIntWrapper: {super().__repr__()}>\"\n+\n+\n+class MyAutoField(models.BigAutoField):\n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return None\n+        return MyIntWrapper(value)\n+    \n+    def get_prep_value(self, value):\n+        if value is None:\n+            return None\n+        return int(value)\n+\n+\n+class AutoModel(models.Model):\n+    id = MyAutoField(primary_key=True)\n+    \n+    class Meta:\n+        app_label = 'test_issue'\n+\n+\n+# Create the table\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(AutoModel)\n+\n+# Test 1: Create object\n+print(\"Test 1: Create object\")\n+am = AutoModel.objects.create()\n+print(f\"Created object id: {am.id}, type: {type(am.id)}\")\n+print(f\"Expected: MyIntWrapper, Got: {type(am.id).__name__}\")\n+print(f\"PASS\" if isinstance(am.id, MyIntWrapper) else \"FAIL\")\n+\n+# Test 2: Query object\n+print(\"\\nTest 2: Query object\")\n+am2 = AutoModel.objects.first()\n+print(f\"Queried object id: {am2.id}, type: {type(am2.id)}\")\n+print(f\"Expected: MyIntWrapper, Got: {type(am2.id).__name__}\")\n+print(f\"PASS\" if isinstance(am2.id, MyIntWrapper) else \"FAIL\")\n+\n+# Test 3: Bulk create\n+print(\"\\nTest 3: Bulk create\")\n+if connection.features.can_return_rows_from_bulk_insert:\n+    ams = [AutoModel()]\n+    AutoModel.objects.bulk_create(ams)\n+    print(f\"Bulk created object id: {ams[0].id}, type: {type(ams[0].id)}\")\n+    print(f\"Expected: MyIntWrapper, Got: {type(ams[0].id).__name__}\")\n+    print(f\"PASS\" if isinstance(ams[0].id, MyIntWrapper) else \"FAIL\")\n+else:\n+    print(\"SKIPPED - Database doesn't support returning rows from bulk insert\")\ndiff --git a/test_returning_fields.py b/test_returning_fields.py\nnew file mode 100644\nindex 0000000000..c92e60aa84\n--- /dev/null\n+++ b/test_returning_fields.py\n@@ -0,0 +1,106 @@\n+import django\n+from django.conf import settings\n+\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='test',\n+    )\n+    django.setup()\n+\n+from django.db import models\n+from django.test import TestCase, skipUnlessDBFeature\n+\n+\n+class MyIntWrapper(int):\n+    \"\"\"A simple wrapper to distinguish from plain int\"\"\"\n+    def __repr__(self):\n+        return f\"<MyIntWrapper: {super().__repr__()}>\"\n+\n+\n+class MyAutoField(models.BigAutoField):\n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return None\n+        return MyIntWrapper(value)\n+    \n+    def get_prep_value(self, value):\n+        if value is None:\n+            return None\n+        return int(value)\n+\n+\n+class AutoModel(models.Model):\n+    id = MyAutoField(primary_key=True)\n+    \n+    class Meta:\n+        app_label = 'test_returning_fields'\n+\n+\n+class TestReturningFields(TestCase):\n+    def test_create_applies_converters(self):\n+        \"\"\"Test that from_db_value is called for returning fields on create\"\"\"\n+        am = AutoModel.objects.create()\n+        # The id should be wrapped in MyIntWrapper\n+        self.assertIsInstance(am.id, MyIntWrapper)\n+    \n+    def test_query_applies_converters(self):\n+        \"\"\"Test that from_db_value is called on normal queries\"\"\"\n+        AutoModel.objects.create()\n+        am = AutoModel.objects.first()\n+        self.assertIsInstance(am.id, MyIntWrapper)\n+    \n+    @skipUnlessDBFeature('can_return_rows_from_bulk_insert')\n+    def test_bulk_create_applies_converters(self):\n+        \"\"\"Test that from_db_value is called for returning fields on bulk_create\"\"\"\n+        ams = [AutoModel()]\n+        AutoModel.objects.bulk_create(ams)\n+        # The id should be wrapped in MyIntWrapper\n+        self.assertIsInstance(ams[0].id, MyIntWrapper)\n+\n+\n+if __name__ == '__main__':\n+    # Run a simple test\n+    import django\n+    from django.conf import settings\n+    \n+    if not settings.configured:\n+        settings.configure(\n+            DATABASES={\n+                'default': {\n+                    'ENGINE': 'django.db.backends.sqlite3',\n+                    'NAME': ':memory:',\n+                }\n+            },\n+            INSTALLED_APPS=[\n+                'django.contrib.contenttypes',\n+                'django.contrib.auth',\n+            ],\n+            USE_TZ=True,\n+            SECRET_KEY='test',\n+        )\n+        django.setup()\n+    \n+    # Create the table\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(AutoModel)\n+    \n+    # Run tests\n+    am = AutoModel.objects.create()\n+    print(f\"Created object id: {am.id}, type: {type(am.id)}\")\n+    print(f\"Expected: MyIntWrapper, Got: {type(am.id).__name__}\")\n+    \n+    am2 = AutoModel.objects.first()\n+    print(f\"\\nQueried object id: {am2.id}, type: {type(am2.id)}\")\n+    print(f\"Expected: MyIntWrapper, Got: {type(am2.id).__name__}\")\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex f02199d97ca1..11ad4fde90df 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1405,6 +1405,7 @@ def execute_sql(self, returning_fields=None):\n             returning_fields and len(self.query.objs) != 1 and\n             not self.connection.features.can_return_rows_from_bulk_insert\n         )\n+        opts = self.query.get_meta()\n         self.returning_fields = returning_fields\n         with self.connection.cursor() as cursor:\n             for sql, params in self.as_sql():\n@@ -1412,13 +1413,21 @@ def execute_sql(self, returning_fields=None):\n             if not self.returning_fields:\n                 return []\n             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:\n-                return self.connection.ops.fetch_returned_insert_rows(cursor)\n-            if self.connection.features.can_return_columns_from_insert:\n+                rows = self.connection.ops.fetch_returned_insert_rows(cursor)\n+            elif self.connection.features.can_return_columns_from_insert:\n                 assert len(self.query.objs) == 1\n-                return [self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)]\n-            return [(self.connection.ops.last_insert_id(\n-                cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column\n-            ),)]\n+                rows = [self.connection.ops.fetch_returned_insert_columns(\n+                    cursor, self.returning_params,\n+                )]\n+            else:\n+                rows = [(self.connection.ops.last_insert_id(\n+                    cursor, opts.db_table, opts.pk.column,\n+                ),)]\n+        cols = [field.get_col(opts.db_table) for field in self.returning_fields]\n+        converters = self.get_converters(cols)\n+        if converters:\n+            rows = list(self.apply_converters(rows, converters))\n+        return rows\n \n \n class SQLDeleteCompiler(SQLCompiler):\ndiff --git a/tests/custom_pk/fields.py b/tests/custom_pk/fields.py\nindex 5bd249df3c1b..bc7259300b75 100644\n--- a/tests/custom_pk/fields.py\n+++ b/tests/custom_pk/fields.py\n@@ -20,7 +20,7 @@ def __eq__(self, other):\n         return self.value == other\n \n \n-class MyAutoField(models.CharField):\n+class MyWrapperField(models.CharField):\n \n     def __init__(self, *args, **kwargs):\n         kwargs['max_length'] = 10\n@@ -58,3 +58,15 @@ def get_db_prep_value(self, value, connection, prepared=False):\n         if isinstance(value, MyWrapper):\n             return str(value)\n         return value\n+\n+\n+class MyAutoField(models.BigAutoField):\n+    def from_db_value(self, value, expression, connection):\n+        if value is None:\n+            return None\n+        return MyWrapper(value)\n+\n+    def get_prep_value(self, value):\n+        if value is None:\n+            return None\n+        return int(value)\ndiff --git a/tests/custom_pk/models.py b/tests/custom_pk/models.py\nindex edfc6712f352..d9a73885f2ee 100644\n--- a/tests/custom_pk/models.py\n+++ b/tests/custom_pk/models.py\n@@ -7,7 +7,7 @@\n \n from django.db import models\n \n-from .fields import MyAutoField\n+from .fields import MyAutoField, MyWrapperField\n \n \n class Employee(models.Model):\n@@ -31,8 +31,12 @@ class Meta:\n \n \n class Bar(models.Model):\n-    id = MyAutoField(primary_key=True, db_index=True)\n+    id = MyWrapperField(primary_key=True, db_index=True)\n \n \n class Foo(models.Model):\n     bar = models.ForeignKey(Bar, models.CASCADE)\n+\n+\n+class CustomAutoFieldModel(models.Model):\n+    id = MyAutoField(primary_key=True)\ndiff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\nindex abb4ccd90b5b..cbf1fd2cb60c 100644\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -1,7 +1,8 @@\n from django.db import IntegrityError, transaction\n-from django.test import TestCase, skipIfDBFeature\n+from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n-from .models import Bar, Business, Employee, Foo\n+from .fields import MyWrapper\n+from .models import Bar, Business, CustomAutoFieldModel, Employee, Foo\n \n \n class BasicCustomPKTests(TestCase):\n@@ -230,3 +231,13 @@ def test_required_pk(self):\n         with self.assertRaises(IntegrityError):\n             with transaction.atomic():\n                 Employee.objects.create(first_name=\"Tom\", last_name=\"Smith\")\n+\n+    def test_auto_field_subclass_create(self):\n+        obj = CustomAutoFieldModel.objects.create()\n+        self.assertIsInstance(obj.id, MyWrapper)\n+\n+    @skipUnlessDBFeature('can_return_rows_from_bulk_insert')\n+    def test_auto_field_subclass_bulk_create(self):\n+        obj = CustomAutoFieldModel()\n+        CustomAutoFieldModel.objects.bulk_create([obj])\n+        self.assertIsInstance(obj.id, MyWrapper)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14007"}