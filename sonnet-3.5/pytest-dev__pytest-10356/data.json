{"instance_id": "pytest-dev__pytest-10356", "score": "I", "diff": "diff --git a/AUTHORS b/AUTHORS\nindex ca2872f32..723f7f9ce 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -98,6 +98,7 @@ David Mohr\n David Paul R\u00f6thlisberger\n David Szotten\n David Vierra\n+AI Assistant\n Daw-Ran Liou\n Debi Mishra\n Denis Kirisov\ndiff --git a/changelog/10626.bugfix.rst b/changelog/10626.bugfix.rst\nnew file mode 100644\nindex 000000000..76a74c72a\n--- /dev/null\n+++ b/changelog/10626.bugfix.rst\n@@ -0,0 +1 @@\n+Fixed an issue where pytest markers were not properly collected from all base classes in the Method Resolution Order (MRO) when inheriting from multiple classes.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 3db877506..d2950ec6b 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -1714,7 +1714,7 @@ class Function(PyobjMixin, nodes.Item):\n         # Note: when FunctionDefinition is introduced, we should change ``originalname``\n         # to a readonly property that returns FunctionDefinition.name.\n \n-        self.own_markers.extend(get_unpacked_marks(self.obj))\n+        self.own_markers.extend(self.collect_markers_from_mro())\n         if callspec:\n             self.callspec = callspec\n             self.own_markers.extend(callspec.marks)\n@@ -1737,6 +1737,18 @@ class Function(PyobjMixin, nodes.Item):\n         self.fixturenames = fixtureinfo.names_closure\n         self._initrequest()\n \n+    def collect_markers_from_mro(self):\n+        markers = []\n+        if hasattr(self.obj, '__self__'):  # Check if it's a bound method\n+            cls = self.obj.__self__.__class__\n+        elif hasattr(self.obj, '__class__'):  # Check if it's a class\n+            cls = self.obj.__class__\n+        else:\n+            return markers  # Return empty list if it's not a method or class\n+        for base_cls in cls.__mro__:\n+            markers.extend(get_unpacked_marks(base_cls))\n+        return markers\n+\n     @classmethod\n     def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n         \"\"\"The public constructor.\"\"\"\n", "gold_standard_diff": "From d8c783268c6876379f5a3a0251b72d0d6d22d0cf Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:18:26 +0200\nSubject: [PATCH 1/6] fix #7792: consider marks from the mro\n\ncloses #9105 as superseeded\n---\n changelog/7792.bugfix.rst      |  1 +\n src/_pytest/mark/structures.py | 29 +++++++++++++++++++++++------\n testing/test_mark.py           | 23 +++++++++++++++++++++++\n 3 files changed, 47 insertions(+), 6 deletions(-)\n create mode 100644 changelog/7792.bugfix.rst\n\ndiff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nnew file mode 100644\nindex 00000000000..00e09ebe849\n--- /dev/null\n+++ b/changelog/7792.bugfix.rst\n@@ -0,0 +1 @@\n+Consider the full mro when getting marks from classes.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c9243..e9e00612529 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,12 +355,29 @@ def __call__(self, *args: object, **kwargs: object):\n         return self.with_args(*args, **kwargs)\n \n \n-def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n+def get_unpacked_marks(\n+    obj: object | type,\n+    consider_mro: bool = True,\n+) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n-    return normalize_mark_list(mark_list)\n+    if isinstance(obj, type):\n+        if not consider_mro:\n+            mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\n+        else:\n+            mark_lists = [x.__dict__.get(\"pytestmark\", []) for x in obj.__mro__]\n+        mark_list = []\n+        for item in mark_lists:\n+            if isinstance(item, list):\n+                mark_list.extend(item)\n+            else:\n+                mark_list.append(item)\n+    else:\n+        mark_attribute = getattr(obj, \"pytestmark\", [])\n+        if isinstance(mark_attribute, list):\n+            mark_list = mark_attribute\n+        else:\n+            mark_list = [mark_attribute]\n+    return list(normalize_mark_list(mark_list))\n \n \n def normalize_mark_list(\n@@ -388,7 +405,7 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    obj.pytestmark = [*get_unpacked_marks(obj, consider_mro=False), mark]\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 65f2581bd63..8c20fe8b17d 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1109,3 +1109,26 @@ def test_foo():\n     result = pytester.runpytest(foo, \"-m\", expr)\n     result.stderr.fnmatch_lines([expected])\n     assert result.ret == ExitCode.USAGE_ERROR\n+\n+\n+def test_mark_mro():\n+    @pytest.mark.xfail(\"a\")\n+    class A:\n+        pass\n+\n+    @pytest.mark.xfail(\"b\")\n+    class B:\n+        pass\n+\n+    @pytest.mark.xfail(\"c\")\n+    class C(A, B):\n+        pass\n+\n+    from _pytest.mark.structures import get_unpacked_marks\n+\n+    all_marks = list(get_unpacked_marks(C))\n+\n+    nk = [(x.name, x.args[0]) for x in all_marks]\n+    assert nk == [(\"xfail\", \"c\"), (\"xfail\", \"a\"), (\"xfail\", \"b\")]\n+\n+    assert list(get_unpacked_marks(C, consider_mro=False)) == []\n\nFrom 4e7486d3fb95f97422283fc7f21b24e8aa6ef2c8 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:28:03 +0200\nSubject: [PATCH 2/6] fixup: annotations\n\n---\n src/_pytest/mark/structures.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex e9e00612529..0b1daefd639 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -356,7 +356,7 @@ def __call__(self, *args: object, **kwargs: object):\n \n \n def get_unpacked_marks(\n-    obj: object | type,\n+    obj: Union[object, type],\n     consider_mro: bool = True,\n ) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n\nFrom 13e594a31474136fb185eff7084760f724897d6b Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:35:26 +0200\nSubject: [PATCH 3/6] fixup: mark mro test reformatt\n\n---\n testing/test_mark.py | 15 ++++++++-------\n 1 file changed, 8 insertions(+), 7 deletions(-)\n\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 8c20fe8b17d..6199dc0b374 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1112,23 +1112,24 @@ def test_foo():\n \n \n def test_mark_mro():\n-    @pytest.mark.xfail(\"a\")\n+    xfail = pytest.mark.xfail\n+\n+    @xfail(\"a\")\n     class A:\n         pass\n \n-    @pytest.mark.xfail(\"b\")\n+    @xfail(\"b\")\n     class B:\n         pass\n \n-    @pytest.mark.xfail(\"c\")\n+    @xfail(\"c\")\n     class C(A, B):\n         pass\n \n     from _pytest.mark.structures import get_unpacked_marks\n \n-    all_marks = list(get_unpacked_marks(C))\n+    all_marks = get_unpacked_marks(C)\n \n-    nk = [(x.name, x.args[0]) for x in all_marks]\n-    assert nk == [(\"xfail\", \"c\"), (\"xfail\", \"a\"), (\"xfail\", \"b\")]\n+    assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n \n-    assert list(get_unpacked_marks(C, consider_mro=False)) == []\n+    assert get_unpacked_marks(C, consider_mro=False) == [pytest.mark.xfail(\"c\").mark]\n\nFrom c42bb36009445e0cf1915dd5d1b762639a710675 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:35:53 +0200\nSubject: [PATCH 4/6] fixup: mark mro test reformatt\n\n---\n testing/test_mark.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 6199dc0b374..ebb70e2470b 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1132,4 +1132,4 @@ class C(A, B):\n \n     assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n \n-    assert get_unpacked_marks(C, consider_mro=False) == [pytest.mark.xfail(\"c\").mark]\n+    assert get_unpacked_marks(C, consider_mro=False) == [xfail(\"c\").mark]\n\nFrom f13f4360d3ff379144f32b4bbb4b4fa4a7a8cf23 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Wed, 12 Oct 2022 10:20:16 +0200\nSubject: [PATCH 5/6] Apply suggestions from code review\n\nCo-authored-by: Ran Benita <ran@unusedvar.com>\n---\n changelog/7792.bugfix.rst      | 6 +++++-\n src/_pytest/mark/structures.py | 8 +++++++-\n testing/test_mark.py           | 2 +-\n 3 files changed, 13 insertions(+), 3 deletions(-)\n\ndiff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nindex 00e09ebe849..8f65637896d 100644\n--- a/changelog/7792.bugfix.rst\n+++ b/changelog/7792.bugfix.rst\n@@ -1 +1,5 @@\n-Consider the full mro when getting marks from classes.\n+Marks are now inherited according to the full MRO in test classes. Previously, if a test class inherited from two or more classes, only marks from the first super-class would apply.\n+\n+When inheriting marks from super-classes, marks from the sub-classes are now ordered before marks from the super-classes, in MRO order. Previously it was the reverse.\n+\n+When inheriting marks from super-classes, the `pytestmark` attribute of the sub-class now only contains the marks directly applied to it. Previously, it also contained marks from its super-classes. Please note that this attribute should not normally be accessed directly; use :func:`pytest.Node.iter_markers` instead.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 0b1daefd639..b93bf6ed9fc 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -357,9 +357,15 @@ def __call__(self, *args: object, **kwargs: object):\n \n def get_unpacked_marks(\n     obj: Union[object, type],\n+    *,\n     consider_mro: bool = True,\n ) -> List[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    If obj is a class and consider_mro is true, return marks applied to\n+    this class and all of its super-classes in MRO order. If consider_mro\n+    is false, only return marks applied directly to this class.\n+    \"\"\"\n     if isinstance(obj, type):\n         if not consider_mro:\n             mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex ebb70e2470b..e2d1a40c38a 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1111,7 +1111,7 @@ def test_foo():\n     assert result.ret == ExitCode.USAGE_ERROR\n \n \n-def test_mark_mro():\n+def test_mark_mro() -> None:\n     xfail = pytest.mark.xfail\n \n     @xfail(\"a\")\n\nFrom c543e0c4e83f63943efb0cb06b6c94990c4eb0a9 Mon Sep 17 00:00:00 2001\nFrom: \"pre-commit-ci[bot]\"\n <66853113+pre-commit-ci[bot]@users.noreply.github.com>\nDate: Wed, 12 Oct 2022 08:21:16 +0000\nSubject: [PATCH 6/6] [pre-commit.ci] auto fixes from pre-commit.com hooks\n\nfor more information, see https://pre-commit.ci\n---\n src/_pytest/mark/structures.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex b93bf6ed9fc..5186c9ea3b6 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -361,7 +361,7 @@ def get_unpacked_marks(\n     consider_mro: bool = True,\n ) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\n-    \n+\n     If obj is a class and consider_mro is true, return marks applied to\n     this class and all of its super-classes in MRO order. If consider_mro\n     is false, only return marks applied directly to this class.\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10356"}