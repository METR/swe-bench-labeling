{"instance_id": "mwaskom__seaborn-3069", "score": "I", "diff": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 4f0290a4..e88213b8 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1475,7 +1475,7 @@ class Plotter:\n \n                 axes_df = self._filter_subplot_data(df, view)\n \n-                with pd.option_context(\"mode.use_inf_as_null\", True):\n+                with pd.option_context(\"mode.use_inf_as_na\", True):\n                     if keep_na:\n                         # The simpler thing to do would be x.dropna().reindex(x.index).\n                         # But that doesn't work with the way that the subset iteration\ndiff --git a/seaborn/_oldcore.py b/seaborn/_oldcore.py\nindex 192af381..9f521a47 100644\n--- a/seaborn/_oldcore.py\n+++ b/seaborn/_oldcore.py\n@@ -1116,7 +1116,7 @@ class VectorPlotter:\n                 parts = []\n                 grouped = self.plot_data[var].groupby(self.converters[var], sort=False)\n                 for converter, orig in grouped:\n-                    with pd.option_context('mode.use_inf_as_null', True):\n+                    with pd.option_context('mode.use_inf_as_na', True):\n                         orig = orig.dropna()\n                         if var in self.var_levels:\n                             # TODO this should happen in some centralized location\ndiff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex 3394c9c7..cbdc6fb1 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -1790,7 +1790,7 @@ class _LVPlotter(_CategoricalPlotter):\n         vals = np.asarray(vals)\n         # Remove infinite values while handling a 'object' dtype\n         # that can come from pd.Float64Dtype() input\n-        with pd.option_context('mode.use_inf_as_null', True):\n+        with pd.option_context('mode.use_inf_as_na', True):\n             vals = vals[~pd.isnull(vals)]\n         n = len(vals)\n         p = self.outlier_prop\ndiff --git a/test_nominal_direct.py b/test_nominal_direct.py\nnew file mode 100644\nindex 00000000..668e9058\n--- /dev/null\n+++ b/test_nominal_direct.py\n@@ -0,0 +1,34 @@\n+import matplotlib.pyplot as plt\n+import seaborn as sns\n+import pandas as pd\n+\n+# Create test data\n+data = pd.DataFrame({\n+    'x': ['A', 'B', 'C', 'A', 'B', 'C'],\n+    'y': [1, 2, 3, 2, 3, 4],\n+    'cat': ['cat1', 'cat1', 'cat1', 'cat2', 'cat2', 'cat2']\n+})\n+\n+# Test categorical plot behavior\n+fig, ax = plt.subplots()\n+sns.stripplot(data=data, x='x', y='y', ax=ax)\n+print(\"Categorical plot x-axis limits:\", ax.get_xlim())\n+print(\"Categorical plot x grid visible:\", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else \"No grid\")\n+\n+# Test with y categorical\n+fig, ax = plt.subplots()\n+sns.stripplot(data=data, x='y', y='x', ax=ax)\n+ylim = ax.get_ylim()\n+print(\"\\nCategorical plot y-axis limits:\", ylim)\n+print(\"Categorical plot y-axis inverted:\", ylim[0] > ylim[1])\n+print(\"Categorical plot y grid visible:\", ax.yaxis.get_gridlines()[0].get_visible() if ax.yaxis.get_gridlines() else \"No grid\")\n+\n+# Let's look at the grid for both axes\n+xgrid = ax.xaxis.get_gridlines()\n+ygrid = ax.yaxis.get_gridlines()\n+print(f\"\\nX-axis grid lines: {len(xgrid)}\")\n+print(f\"Y-axis grid lines: {len(ygrid)}\")\n+if xgrid:\n+    print(f\"X-axis grid visible: {xgrid[0].get_visible()}\")\n+if ygrid:\n+    print(f\"Y-axis grid visible: {ygrid[0].get_visible()}\")\ndiff --git a/test_nominal_scale.py b/test_nominal_scale.py\nnew file mode 100644\nindex 00000000..27093b86\n--- /dev/null\n+++ b/test_nominal_scale.py\n@@ -0,0 +1,70 @@\n+import matplotlib.pyplot as plt\n+import matplotlib as mpl\n+import seaborn as sns\n+from seaborn import objects as so\n+import numpy as np\n+import pandas as pd\n+\n+# Avoid pandas option context issue\n+import warnings\n+warnings.filterwarnings(\"ignore\")\n+\n+# Create test data\n+data = pd.DataFrame({\n+    'x': ['A', 'B', 'C', 'A', 'B', 'C'],\n+    'y': [1, 2, 3, 2, 3, 4],\n+    'cat': ['cat1', 'cat1', 'cat1', 'cat2', 'cat2', 'cat2']\n+})\n+\n+# Test 1: Check if grid is shown with Nominal scale on x-axis\n+fig, ax = plt.subplots()\n+p = (\n+    so.Plot(data, x='x', y='y')\n+    .add(so.Dot())\n+    .on(ax)\n+    .plot()\n+)\n+print(\"Grid visible (x nominal):\", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else \"No grid\")\n+plt.close()\n+\n+# Test 2: Check if y-axis is inverted with Nominal scale\n+fig, ax = plt.subplots()\n+p = (\n+    so.Plot(data, x='y', y='x')  # Swap to make y categorical\n+    .add(so.Dot())\n+    .on(ax)\n+    .plot()\n+)\n+ylim = ax.get_ylim()\n+print(\"Y-axis limits (y nominal):\", ylim)\n+print(\"Y-axis inverted:\", ylim[0] > ylim[1])\n+plt.close()\n+\n+# Test 3: Check axis limits with nominal scale\n+fig, ax = plt.subplots()\n+p = (\n+    so.Plot(data, x='x', y='y')\n+    .add(so.Dot())\n+    .on(ax)\n+    .plot()\n+)\n+xlim = ax.get_xlim()\n+print(\"X-axis limits (x nominal):\", xlim)\n+print(\"Expected limits: (-0.5, 2.5)\")\n+plt.close()\n+\n+# Test 4: Compare with categorical plot\n+fig, ax = plt.subplots()\n+sns.stripplot(data=data, x='x', y='y', ax=ax)\n+print(\"\\nCategorical plot x-axis limits:\", ax.get_xlim())\n+print(\"Categorical plot x grid visible:\", ax.xaxis.get_gridlines()[0].get_visible() if ax.xaxis.get_gridlines() else \"No grid\")\n+plt.close()\n+\n+# Test 5: Y-axis categorical\n+fig, ax = plt.subplots()\n+sns.stripplot(data=data, x='y', y='x', ax=ax)\n+ylim = ax.get_ylim()\n+print(\"Categorical plot y-axis limits:\", ylim)\n+print(\"Categorical plot y-axis inverted:\", ylim[0] > ylim[1])\n+print(\"Categorical plot y grid visible:\", ax.yaxis.get_gridlines()[0].get_visible() if ax.yaxis.get_gridlines() else \"No grid\")\n+plt.close()\n", "gold_standard_diff": "diff --git a/doc/whatsnew/v0.12.1.rst b/doc/whatsnew/v0.12.1.rst\nindex 6ba57d5b49..8c14a2f3bc 100644\n--- a/doc/whatsnew/v0.12.1.rst\n+++ b/doc/whatsnew/v0.12.1.rst\n@@ -6,11 +6,13 @@ v0.12.1 (Unreleased)\n \n - |Feature| Added the :class:`objects.Perc` stat (:pr:`3063`).\n \n-- |Feature| The :class:`Band` and :class:`Range` marks will now cover the full extent of the data if `min` / `max` variables are not explicitly assigned or added in a transform (:pr:`3056`).\n+- |Feature| The :class:`objects.Band` and :class:`objects.Range` marks will now cover the full extent of the data if `min` / `max` variables are not explicitly assigned or added in a transform (:pr:`3056`).\n \n-- |Enhancement| The :class:`Jitter` move now applies a small amount of jitter by default (:pr:`3066`).\n+- |Enhancement| |Defaults| The :class:`objects.Jitter` move now applies a small amount of jitter by default (:pr:`3066`).\n \n-- |Enhancement| Marks that sort along the orient axis (e.g. :class:`Line`) now use a stable algorithm (:pr:`3064`).\n+- |Enhancement| |Defaults| Axes with a :class:`objects.Nominal` scale now appear like categorical axes in class seaborn, with fixed margins, no grid, and an inverted y axis (:pr:`3069`).\n+\n+- |Enhancement| Marks that sort along the orient axis (e.g. :class:`objects.Line`) now use a stable algorithm (:pr:`3064`).\n \n - |Fix| Make :class:`objects.PolyFit` robust to missing data (:pr:`3010`).\n \ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 4f0290a494..bfe612a1f5 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -25,7 +25,7 @@\n from seaborn._stats.base import Stat\n from seaborn._core.data import PlotData\n from seaborn._core.moves import Move\n-from seaborn._core.scales import Scale\n+from seaborn._core.scales import Scale, Nominal\n from seaborn._core.subplots import Subplots\n from seaborn._core.groupby import GroupBy\n from seaborn._core.properties import PROPERTIES, Property\n@@ -1238,7 +1238,6 @@ def _setup_scales(\n             # This only affects us when sharing *paired* axes. This is a novel/niche\n             # behavior, so we will raise rather than hack together a workaround.\n             if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):\n-                from seaborn._core.scales import Nominal\n                 paired_axis = axis in p._pair_spec.get(\"structure\", {})\n                 cat_scale = isinstance(scale, Nominal)\n                 ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]\n@@ -1631,6 +1630,7 @@ def _finalize_figure(self, p: Plot) -> None:\n             ax = sub[\"ax\"]\n             for axis in \"xy\":\n                 axis_key = sub[axis]\n+                axis_obj = getattr(ax, f\"{axis}axis\")\n \n                 # Axis limits\n                 if axis_key in p._limits:\n@@ -1644,6 +1644,17 @@ def _finalize_figure(self, p: Plot) -> None:\n                         hi = cast(float, hi) + 0.5\n                     ax.set(**{f\"{axis}lim\": (lo, hi)})\n \n+                # Nominal scale special-casing\n+                if isinstance(self._scales.get(axis_key), Nominal):\n+                    axis_obj.grid(False, which=\"both\")\n+                    if axis_key not in p._limits:\n+                        nticks = len(axis_obj.get_major_ticks())\n+                        lo, hi = -.5, nticks - .5\n+                        if axis == \"y\":\n+                            lo, hi = hi, lo\n+                        set_lim = getattr(ax, f\"set_{axis}lim\")\n+                        set_lim(lo, hi, auto=None)\n+\n         engine_default = None if p._target is not None else \"tight\"\n         layout_engine = p._layout_spec.get(\"engine\", engine_default)\n         set_layout_engine(self._figure, layout_engine)\ndiff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex 03a64917f3..e855aef9e6 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -645,6 +645,28 @@ def test_undefined_variable_raises(self):\n         with pytest.raises(RuntimeError, match=err):\n             p.plot()\n \n+    def test_nominal_x_axis_tweaks(self):\n+\n+        p = Plot(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3])\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_xlim() == (-.5, 2.5)\n+        assert not any(x.get_visible() for x in ax1.xaxis.get_gridlines())\n+\n+        lim = (-1, 2.1)\n+        ax2 = p.limit(x=lim).plot()._figure.axes[0]\n+        assert ax2.get_xlim() == lim\n+\n+    def test_nominal_y_axis_tweaks(self):\n+\n+        p = Plot(x=[1, 2, 3], y=[\"a\", \"b\", \"c\"])\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_ylim() == (2.5, -.5)\n+        assert not any(y.get_visible() for y in ax1.yaxis.get_gridlines())\n+\n+        lim = (-1, 2.1)\n+        ax2 = p.limit(y=lim).plot()._figure.axes[0]\n+        assert ax2.get_ylim() == lim\n+\n \n class TestPlotting:\n \n", "gold_standard_pr_link": "https://github.com/mwaskom/seaborn/pull/3069"}