{"instance_id": "django__django-14999", "score": "C", "diff": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 982816be3a..9e2c4e3da9 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -320,6 +320,9 @@ class RenameModel(ModelOperation):\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n+            # If the db_table names are the same, the rename is a no-op at the database level\n+            if old_model._meta.db_table == new_model._meta.db_table:\n+                return\n             # Move the main table\n             schema_editor.alter_db_table(\n                 new_model,\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..7fbb57e985\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,125 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': 'test_db.sqlite3',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+from django.db import connection, models\n+from django.db.migrations.operations import RenameModel\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+print(\"=== Testing Edge Cases for RenameModel with db_table ===\\n\")\n+\n+# Clean up any existing test database\n+if os.path.exists('test_db.sqlite3'):\n+    os.remove('test_db.sqlite3')\n+\n+# Test 1: Model without custom db_table (should still rename table)\n+print(\"Test 1: Model WITHOUT custom db_table\")\n+state1 = ProjectState()\n+state1.add_model(ModelState(\n+    'test_app',\n+    'RegularModel',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('name', models.CharField(max_length=100)),\n+    ],\n+    {}  # No db_table specified\n+))\n+\n+RegularModel = state1.apps.get_model('test_app', 'RegularModel')\n+print(f\"Original db_table: {RegularModel._meta.db_table}\")\n+\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(RegularModel)\n+\n+# Rename the model\n+rename_op = RenameModel('RegularModel', 'RenamedModel')\n+state2 = state1.clone()\n+rename_op.state_forwards('test_app', state2)\n+\n+RenamedModel = state2.apps.get_model('test_app', 'RenamedModel')\n+print(f\"After rename db_table: {RenamedModel._meta.db_table}\")\n+\n+# Apply database operation\n+from django.db import connection as conn\n+conn.queries_log.clear()\n+\n+with connection.schema_editor() as schema_editor:\n+    rename_op.database_forwards('test_app', schema_editor, state1, state2)\n+\n+print(f\"Number of queries: {len(conn.queries_log)}\")\n+print(\"Should rename table:\", any('ALTER TABLE' in q['sql'] and 'RENAME TO' in q['sql'] for q in conn.queries_log))\n+\n+# Test 2: Model with custom db_table and M2M relationship\n+print(\"\\n\\nTest 2: Model with custom db_table and M2M relationship\")\n+state3 = ProjectState()\n+\n+# Author with custom db_table\n+state3.add_model(ModelState(\n+    'test_app',\n+    'Author',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('name', models.CharField(max_length=100)),\n+        ('books', models.ManyToManyField('test_app.Book')),\n+    ],\n+    {'db_table': 'custom_author_table'}\n+))\n+\n+# Book model\n+state3.add_model(ModelState(\n+    'test_app',\n+    'Book',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('title', models.CharField(max_length=100)),\n+    ],\n+    {}\n+))\n+\n+Author = state3.apps.get_model('test_app', 'Author')\n+Book = state3.apps.get_model('test_app', 'Book')\n+\n+# Get the through model\n+through_model = Author._meta.get_field('books').remote_field.through\n+print(f\"M2M through table: {through_model._meta.db_table}\")\n+\n+# Rename Author to Writer\n+rename_op2 = RenameModel('Author', 'Writer')\n+state4 = state3.clone()\n+rename_op2.state_forwards('test_app', state4)\n+\n+Writer = state4.apps.get_model('test_app', 'Writer')\n+new_through_model = Writer._meta.get_field('books').remote_field.through\n+print(f\"After rename - Writer db_table: {Writer._meta.db_table}\")\n+print(f\"After rename - M2M through table: {new_through_model._meta.db_table}\")\n+\n+# Clean up\n+if os.path.exists('test_db.sqlite3'):\n+    os.remove('test_db.sqlite3')\n+\n+print(\"\\n=== Summary ===\")\n+print(\"1. Models WITHOUT custom db_table should still rename the table\")\n+print(\"2. Models WITH custom db_table should be a no-op\")\n+print(\"3. M2M through tables might change if they're auto-generated\")\ndiff --git a/test_full_scenario.py b/test_full_scenario.py\nnew file mode 100644\nindex 0000000000..d26f1ed7ea\n--- /dev/null\n+++ b/test_full_scenario.py\n@@ -0,0 +1,129 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': 'test_db.sqlite3',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+from django.db import connection, models\n+from django.db.migrations.operations import RenameModel, CreateModel\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+# Helper to log SQL queries\n+class QueryLogger:\n+    def __init__(self):\n+        self.queries = []\n+        \n+    def __enter__(self):\n+        from django.db import connection\n+        connection.queries_log.clear()\n+        return self\n+        \n+    def __exit__(self, *args):\n+        from django.db import connection\n+        self.queries = list(connection.queries_log)\n+        \n+    def print_queries(self):\n+        for i, query in enumerate(self.queries):\n+            print(f\"{i+1}. {query['sql']}\")\n+\n+print(\"=== Testing RenameModel with db_table ===\\n\")\n+\n+# Clean up any existing test database\n+if os.path.exists('test_db.sqlite3'):\n+    os.remove('test_db.sqlite3')\n+\n+# Create initial state with models\n+initial_state = ProjectState()\n+\n+# Model with custom db_table\n+initial_state.add_model(ModelState(\n+    'test_app',\n+    'Author',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('name', models.CharField(max_length=100)),\n+    ],\n+    {'db_table': 'custom_author_table'}\n+))\n+\n+# Model with FK to Author\n+initial_state.add_model(ModelState(\n+    'test_app',\n+    'Book',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('title', models.CharField(max_length=100)),\n+        ('author', models.ForeignKey('test_app.Author', on_delete=models.CASCADE)),\n+    ],\n+    {}\n+))\n+\n+# Get the models\n+Author = initial_state.apps.get_model('test_app', 'Author')\n+Book = initial_state.apps.get_model('test_app', 'Book')\n+\n+print(f\"Author model db_table: {Author._meta.db_table}\")\n+print(f\"Book model db_table: {Book._meta.db_table}\")\n+\n+# Create the tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+    \n+print(\"\\nTables created successfully\")\n+\n+# Now create the rename operation\n+rename_op = RenameModel('Author', 'Writer')\n+\n+# Apply state change\n+new_state = initial_state.clone()\n+rename_op.state_forwards('test_app', new_state)\n+\n+# Get new models\n+Writer = new_state.apps.get_model('test_app', 'Writer')\n+print(f\"\\nAfter rename - Writer model db_table: {Writer._meta.db_table}\")\n+\n+# Apply database changes and log queries\n+print(\"\\nApplying RenameModel operation...\")\n+print(\"SQL queries executed:\")\n+\n+from django.db import connection as conn\n+conn.queries_log.clear()\n+\n+with connection.schema_editor() as schema_editor:\n+    rename_op.database_forwards('test_app', schema_editor, initial_state, new_state)\n+\n+# Print the queries that were executed\n+print(f\"\\nNumber of queries executed: {len(conn.queries_log)}\")\n+for i, query in enumerate(conn.queries_log):\n+    print(f\"{i+1}. {query['sql']}\")\n+\n+# Clean up\n+if os.path.exists('test_db.sqlite3'):\n+    os.remove('test_db.sqlite3')\n+\n+print(\"\\n=== Analysis ===\")\n+print(\"When a model has a custom db_table defined, renaming the model should NOT:\")\n+print(\"1. Rename the actual database table (since db_table is explicitly set)\")\n+print(\"2. Drop and recreate foreign key constraints unnecessarily\")\n+print(\"\\nThe operation should be mostly a no-op at the database level.\")\ndiff --git a/test_rename_db_table.py b/test_rename_db_table.py\nnew file mode 100644\nindex 0000000000..8371f1d254\n--- /dev/null\n+++ b/test_rename_db_table.py\n@@ -0,0 +1,67 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test import TestCase, TransactionTestCase\n+from django.db import connection, models\n+from django.db.migrations.operations import RenameModel, CreateModel\n+from django.db.migrations.state import ProjectState, ModelState\n+\n+# Add the parent directory to sys.path\n+sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n+\n+# Configure Django\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+\n+# Set up Django\n+django.setup()\n+\n+# Simple test to verify the issue\n+print(\"Testing RenameModel with db_table...\")\n+\n+# Create initial state with a model that has db_table\n+initial_state = ProjectState()\n+initial_state.add_model(ModelState(\n+    'test_app',\n+    'OldModel',\n+    [\n+        ('id', models.AutoField(primary_key=True)),\n+        ('name', models.CharField(max_length=100)),\n+    ],\n+    {'db_table': 'custom_table'}\n+))\n+\n+# Create the renamed state\n+new_state = initial_state.clone()\n+operation = RenameModel('OldModel', 'NewModel')\n+operation.state_forwards('test_app', new_state)\n+\n+# Get the models from states\n+old_model = initial_state.apps.get_model('test_app', 'OldModel')\n+new_model = new_state.apps.get_model('test_app', 'NewModel')\n+\n+print(f\"Old model name: {old_model._meta.model_name}\")\n+print(f\"Old model db_table: {old_model._meta.db_table}\")\n+print(f\"New model name: {new_model._meta.model_name}\")  \n+print(f\"New model db_table: {new_model._meta.db_table}\")\n+print(f\"db_table unchanged: {old_model._meta.db_table == new_model._meta.db_table}\")\n+\n+# Test the database operation\n+with connection.schema_editor() as schema_editor:\n+    # First create the table\n+    schema_editor.create_model(old_model)\n+    print(\"\\nTable created successfully\")\n+    \n+    # Apply the rename operation\n+    print(\"\\nApplying RenameModel operation...\")\n+    operation.database_forwards('test_app', schema_editor, initial_state, new_state)\n+    print(\"RenameModel operation completed\")\n+    \n+    # Check if the table still exists with same name\n+    with connection.cursor() as cursor:\n+        tables = connection.introspection.table_names(cursor)\n+        print(f\"\\nTable 'custom_table' exists: {'custom_table' in tables}\")\n+    \n+    # Clean up\n+    schema_editor.delete_model(new_model)\ndiff --git a/test_rename_issue.py b/test_rename_issue.py\nnew file mode 100644\nindex 0000000000..c873dfaf7b\n--- /dev/null\n+++ b/test_rename_issue.py\n@@ -0,0 +1,138 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.operations import RenameModel, CreateModel\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.db.migrations.migration import Migration\n+from django.db.migrations.executor import MigrationExecutor\n+from django.apps import apps\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'test_app',\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='test-secret-key',\n+        MIGRATION_MODULES={\n+            'test_app': None,\n+        }\n+    )\n+    django.setup()\n+\n+# Create test app config\n+from django.apps import AppConfig\n+\n+class TestAppConfig(AppConfig):\n+    name = 'test_app'\n+    label = 'test_app'\n+\n+# Create a migration to test\n+class Migration1(Migration):\n+    initial = True\n+    \n+    operations = [\n+        CreateModel(\n+            name='OldModel',\n+            fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('name', models.CharField(max_length=100)),\n+            ],\n+            options={\n+                'db_table': 'my_custom_table',\n+            },\n+        ),\n+    ]\n+\n+class Migration2(Migration):\n+    dependencies = [\n+        ('test_app', '0001_initial'),\n+    ]\n+    \n+    operations = [\n+        RenameModel(\n+            old_name='OldModel',\n+            new_name='NewModel',\n+        ),\n+    ]\n+\n+# Mock some SQL tracking\n+class SQLTracker:\n+    def __init__(self):\n+        self.queries = []\n+        \n+    def __enter__(self):\n+        from django.db import connection\n+        self.old_execute = connection.cursor().execute\n+        \n+        def track_execute(sql, params=None):\n+            self.queries.append(sql)\n+            return self.old_execute(sql, params)\n+            \n+        connection.cursor().execute = track_execute\n+        return self\n+        \n+    def __exit__(self, *args):\n+        from django.db import connection\n+        connection.cursor().execute = self.old_execute\n+\n+# Run the test\n+print(\"Testing RenameModel operation with db_table...\")\n+\n+# Apply migrations\n+from django.db import connection\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Track SQL queries\n+with connection.schema_editor() as schema_editor:\n+    print(\"\\nCapturing SQL for table rename...\")\n+    \n+    # Create from_state and to_state\n+    from_state = ProjectState()\n+    from_state.add_model(ModelState(\n+        'test_app',\n+        'OldModel',\n+        [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],\n+        {'db_table': 'my_custom_table'}\n+    ))\n+    \n+    to_state = ProjectState()\n+    to_state.add_model(ModelState(\n+        'test_app',\n+        'NewModel',\n+        [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],\n+        {'db_table': 'my_custom_table'}\n+    ))\n+    \n+    # Get models\n+    old_model = from_state.apps.get_model('test_app', 'OldModel')\n+    new_model = to_state.apps.get_model('test_app', 'NewModel')\n+    \n+    print(f\"Old model db_table: {old_model._meta.db_table}\")\n+    print(f\"New model db_table: {new_model._meta.db_table}\")\n+    print(f\"Tables are the same: {old_model._meta.db_table == new_model._meta.db_table}\")\n+    \n+    # Test what alter_db_table does when tables are the same\n+    print(\"\\nTesting alter_db_table with same table names...\")\n+    try:\n+        schema_editor.alter_db_table(\n+            new_model,\n+            old_model._meta.db_table,\n+            new_model._meta.db_table,\n+        )\n+        print(\"alter_db_table executed\")\n+    except Exception as e:\n+        print(f\"Error: {e}\")\ndiff --git a/test_rename_model_noop.py b/test_rename_model_noop.py\nnew file mode 100644\nindex 0000000000..53f1a1bfdd\n--- /dev/null\n+++ b/test_rename_model_noop.py\n@@ -0,0 +1,69 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.migrations.operations import RenameModel\n+from django.db.migrations.state import ProjectState, ModelState\n+from django.apps import apps\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+# Create a test model with db_table\n+class OldModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'my_custom_table'\n+\n+# Create states\n+from_state = ProjectState()\n+from_state.add_model(ModelState(\n+    'test_app',\n+    'OldModel',\n+    [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],\n+    {'db_table': 'my_custom_table'}\n+))\n+\n+to_state = ProjectState()\n+to_state.add_model(ModelState(\n+    'test_app',\n+    'NewModel',\n+    [('id', models.AutoField(primary_key=True)), ('name', models.CharField(max_length=100))],\n+    {'db_table': 'my_custom_table'}\n+))\n+\n+# Create RenameModel operation\n+rename_op = RenameModel('OldModel', 'NewModel')\n+\n+# Test the operation\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+\n+print(\"Testing RenameModel with db_table...\")\n+print(f\"Old model db_table: {from_state.apps.get_model('test_app', 'OldModel')._meta.db_table}\")\n+print(f\"New model db_table: {to_state.apps.get_model('test_app', 'NewModel')._meta.db_table}\")\n+\n+# Check if they're the same\n+old_db_table = from_state.apps.get_model('test_app', 'OldModel')._meta.db_table\n+new_db_table = to_state.apps.get_model('test_app', 'NewModel')._meta.db_table\n+print(f\"Are db_tables the same? {old_db_table == new_db_table}\")\ndiff --git a/test_specific_issue.py b/test_specific_issue.py\nnew file mode 100644\nindex 0000000000..4005217e3e\n--- /dev/null\n+++ b/test_specific_issue.py\n@@ -0,0 +1,42 @@\n+\"\"\"\n+Test to verify that RenameModel is not a no-op when db_table is specified.\n+According to the issue, it should be a no-op but currently it drops and \n+recreates foreign key constraints in Postgres and recreates the table in SQLite.\n+\"\"\"\n+\n+print(\"\\n=== Testing Issue: RenameModel with db_table should be a no-op ===\\n\")\n+\n+# Let's check what happens in the alter_db_table method\n+print(\"1. Checking base alter_db_table implementation:\")\n+print(\"   - File: django/db/backends/base/schema.py\")\n+print(\"   - Lines 470-473 check if old_db_table == new_db_table\")\n+print(\"   - If they're equal, it returns early (no-op)\")\n+\n+print(\"\\n2. RenameModel.database_forwards calls alter_db_table with:\")\n+print(\"   - old_model._meta.db_table\")\n+print(\"   - new_model._meta.db_table\")\n+\n+print(\"\\n3. When a model has db_table specified:\")\n+print(\"   - Both old and new models will have the same db_table\")\n+print(\"   - So alter_db_table should be a no-op\")\n+\n+print(\"\\n4. The issue mentions:\")\n+print(\"   - In Postgres: drops and recreates foreign key constraints\")\n+print(\"   - In SQLite: recreates the table\")\n+\n+print(\"\\nLet's trace through the code to see what else happens in database_forwards...\")\n+\n+# Looking at the RenameModel.database_forwards method\n+print(\"\\nIn RenameModel.database_forwards (lines 319-368):\")\n+print(\"1. Line 324-328: Calls alter_db_table\")\n+print(\"2. Line 329-347: Alters fields pointing to this model\")\n+print(\"3. Line 348-368: Renames M2M fields\")\n+\n+print(\"\\nThe issue might be in steps 2 and 3, where foreign keys are updated.\")\n+print(\"Even if the table name doesn't change, the model name does change,\")\n+print(\"so foreign key constraints might be dropped and recreated.\")\n+\n+print(\"\\n=== Proposed Fix ===\")\n+print(\"The fix should check if old and new db_table are the same.\")\n+print(\"If they are, we should skip the alter_db_table call entirely.\")\n+print(\"However, we still need to update foreign key references to use the new model name.\")\n", "gold_standard_diff": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 982816be3a6b..c120f5d32dff 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -320,12 +320,13 @@ def database_forwards(self, app_label, schema_editor, from_state, to_state):\n         new_model = to_state.apps.get_model(app_label, self.new_name)\n         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n             old_model = from_state.apps.get_model(app_label, self.old_name)\n+            old_db_table = old_model._meta.db_table\n+            new_db_table = new_model._meta.db_table\n+            # Don't alter when a table name is not changed.\n+            if old_db_table == new_db_table:\n+                return\n             # Move the main table\n-            schema_editor.alter_db_table(\n-                new_model,\n-                old_model._meta.db_table,\n-                new_model._meta.db_table,\n-            )\n+            schema_editor.alter_db_table(new_model, old_db_table, new_db_table)\n             # Alter the fields pointing to us\n             for related_object in old_model._meta.related_objects:\n                 if related_object.related_model == old_model:\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 11961a1f40b3..ae6d0f1a9235 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -793,6 +793,28 @@ def test_rename_model_with_m2m(self):\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n \n+    def test_rename_model_with_db_table_noop(self):\n+        app_label = 'test_rmwdbtn'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_backwards(app_label, editor, new_state, project_state)\n+\n     def test_rename_m2m_target_model(self):\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14999"}