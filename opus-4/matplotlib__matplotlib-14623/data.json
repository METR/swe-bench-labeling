{"instance_id": "matplotlib__matplotlib-14623", "score": "I", "diff": "diff --git a/fix_scale.py b/fix_scale.py\nnew file mode 100644\nindex 0000000000..2eb659a573\n--- /dev/null\n+++ b/fix_scale.py\n@@ -0,0 +1,47 @@\n+import re\n+\n+# Read the file\n+with open('./lib/matplotlib/scale.py', 'r') as f:\n+    content = f.read()\n+\n+# Find and replace the limit_range_for_scale method in LogScale\n+old_method = '''    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"\n+        Limit the domain to positive values.\n+        \"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300  # This value should rarely if ever\n+                             # end up with a visible effect.\n+\n+        return (minpos if vmin <= 0 else vmin,\n+                minpos if vmax <= 0 else vmax)'''\n+\n+new_method = '''    def limit_range_for_scale(self, vmin, vmax, minpos):\n+        \"\"\"\n+        Limit the domain to positive values.\n+        \"\"\"\n+        if not np.isfinite(minpos):\n+            minpos = 1e-300  # This value should rarely if ever\n+                             # end up with a visible effect.\n+\n+        # Preserve the order of vmin and vmax to handle inverted axes\n+        inverted = vmin > vmax\n+        if inverted:\n+            vmin, vmax = vmax, vmin\n+            \n+        vmin = minpos if vmin <= 0 else vmin\n+        vmax = minpos if vmax <= 0 else vmax\n+        \n+        if inverted:\n+            vmin, vmax = vmax, vmin\n+            \n+        return vmin, vmax'''\n+\n+# Replace the method\n+content = content.replace(old_method, new_method)\n+\n+# Write back\n+with open('./lib/matplotlib/scale.py', 'w') as f:\n+    f.write(content)\n+\n+print(\"File updated successfully!\")\ndiff --git a/fix_set_ylim.py b/fix_set_ylim.py\nnew file mode 100644\nindex 0000000000..88b47250b9\n--- /dev/null\n+++ b/fix_set_ylim.py\n@@ -0,0 +1,62 @@\n+import re\n+\n+# Read the file\n+with open('./lib/matplotlib/axes/_base.py', 'r') as f:\n+    content = f.read()\n+\n+# Find the set_ylim method section that needs modification\n+old_code = '''        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n+        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+\n+        self.viewLim.intervaly = (bottom, top)'''\n+\n+new_code = '''        # Preserve the inverted state of the axis\n+        inverted = bottom > top\n+        bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n+        bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        \n+        # Restore inverted state if needed\n+        if inverted and bottom < top:\n+            bottom, top = top, bottom\n+\n+        self.viewLim.intervaly = (bottom, top)'''\n+\n+# Replace the code\n+content = content.replace(old_code, new_code)\n+\n+# Write back\n+with open('./lib/matplotlib/axes/_base.py', 'w') as f:\n+    f.write(content)\n+\n+print(\"Fixed set_ylim method!\")\n+\n+# Now do the same for set_xlim\n+# Read the file again\n+with open('./lib/matplotlib/axes/_base.py', 'r') as f:\n+    content = f.read()\n+\n+# Find the set_xlim method section that needs modification  \n+old_code = '''        left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n+        left, right = self.xaxis.limit_range_for_scale(left, right)\n+\n+        self.viewLim.intervalx = (left, right)'''\n+\n+new_code = '''        # Preserve the inverted state of the axis\n+        inverted = left > right\n+        left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n+        left, right = self.xaxis.limit_range_for_scale(left, right)\n+        \n+        # Restore inverted state if needed\n+        if inverted and left < right:\n+            left, right = right, left\n+\n+        self.viewLim.intervalx = (left, right)'''\n+\n+# Replace the code\n+content = content.replace(old_code, new_code)\n+\n+# Write back\n+with open('./lib/matplotlib/axes/_base.py', 'w') as f:\n+    f.write(content)\n+\n+print(\"Fixed set_xlim method!\")\ndiff --git a/lib/matplotlib/scale.py b/lib/matplotlib/scale.py\nindex b482a664b7..84aa143bf7 100644\n--- a/lib/matplotlib/scale.py\n+++ b/lib/matplotlib/scale.py\n@@ -425,8 +425,18 @@ class LogScale(ScaleBase):\n             minpos = 1e-300  # This value should rarely if ever\n                              # end up with a visible effect.\n \n-        return (minpos if vmin <= 0 else vmin,\n-                minpos if vmax <= 0 else vmax)\n+        # Preserve the order of vmin and vmax to handle inverted axes\n+        inverted = vmin > vmax\n+        if inverted:\n+            vmin, vmax = vmax, vmin\n+            \n+        vmin = minpos if vmin <= 0 else vmin\n+        vmax = minpos if vmax <= 0 else vmax\n+        \n+        if inverted:\n+            vmin, vmax = vmax, vmin\n+            \n+        return vmin, vmax\n \n \n class FuncScaleLog(LogScale):\ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..041d983cd1\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,28 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+fig, ax = plt.subplots()\n+y = np.linspace(1000e2, 1, 100)\n+x = np.exp(-np.linspace(0, 1, y.size))\n+ax.plot(x, y)\n+\n+print(\"Before set_yscale('log'):\")\n+print(f\"  viewLim.intervaly: {ax.viewLim.intervaly}\")\n+\n+ax.set_yscale('log')\n+print(\"\\nAfter set_yscale('log'):\")\n+print(f\"  viewLim.intervaly: {ax.viewLim.intervaly}\")\n+\n+print(\"\\nCalling set_ylim(100000.0, 1.0)...\")\n+ax.set_ylim(100000.0, 1.0)\n+print(f\"  viewLim.intervaly: {ax.viewLim.intervaly}\")\n+\n+# Let's try using set_view_interval directly\n+print(\"\\nCalling yaxis.set_view_interval(100000.0, 1.0)...\")\n+ax.yaxis.set_view_interval(100000.0, 1.0)\n+print(f\"  viewLim.intervaly: {ax.viewLim.intervaly}\")\n+\n+# Let's try with ignore=True\n+print(\"\\nCalling yaxis.set_view_interval(100000.0, 1.0, ignore=True)...\")\n+ax.yaxis.set_view_interval(100000.0, 1.0, ignore=True)\n+print(f\"  viewLim.intervaly: {ax.viewLim.intervaly}\")\ndiff --git a/test_debug2.py b/test_debug2.py\nnew file mode 100644\nindex 0000000000..5e5ba362eb\n--- /dev/null\n+++ b/test_debug2.py\n@@ -0,0 +1,26 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+# Patch the limit_range_for_scale method to add debug output\n+from matplotlib.scale import LogScale\n+original_limit_range = LogScale.limit_range_for_scale\n+\n+def debug_limit_range(self, vmin, vmax, minpos):\n+    print(f\"LogScale.limit_range_for_scale called with vmin={vmin}, vmax={vmax}, minpos={minpos}\")\n+    result = original_limit_range(self, vmin, vmax, minpos)\n+    print(f\"  returning: {result}\")\n+    return result\n+\n+LogScale.limit_range_for_scale = debug_limit_range\n+\n+# Now test\n+fig, ax = plt.subplots()\n+y = np.linspace(1000e2, 1, 100)\n+x = np.exp(-np.linspace(0, 1, y.size))\n+ax.plot(x, y)\n+\n+ax.set_yscale('log')\n+print(\"\\nCalling set_ylim(100000.0, 1.0)...\")\n+ax.set_ylim(100000.0, 1.0)\n+print(f\"Final viewLim.intervaly: {ax.viewLim.intervaly}\")\n+print(f\"Final get_ylim(): {ax.get_ylim()}\")\ndiff --git a/test_debug3.py b/test_debug3.py\nnew file mode 100644\nindex 0000000000..a605ddfdb5\n--- /dev/null\n+++ b/test_debug3.py\n@@ -0,0 +1,14 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+fig, ax = plt.subplots()\n+y = np.linspace(1000e2, 1, 100)\n+x = np.exp(-np.linspace(0, 1, y.size))\n+ax.plot(x, y)\n+ax.set_yscale('log')\n+\n+# Test nonsingular\n+locator = ax.yaxis.get_major_locator()\n+print(f\"Locator type: {type(locator)}\")\n+print(f\"nonsingular(100000.0, 1.0): {locator.nonsingular(100000.0, 1.0)}\")\n+print(f\"nonsingular(1.0, 100000.0): {locator.nonsingular(1.0, 100000.0)}\")\ndiff --git a/test_linear.png b/test_linear.png\nnew file mode 100644\nindex 0000000000..76f2deee55\nBinary files /dev/null and b/test_linear.png differ\ndiff --git a/test_log.png b/test_log.png\nnew file mode 100644\nindex 0000000000..3bbe803282\nBinary files /dev/null and b/test_log.png differ\ndiff --git a/test_log_invert.py b/test_log_invert.py\nnew file mode 100644\nindex 0000000000..0b3ff61a4b\n--- /dev/null\n+++ b/test_log_invert.py\n@@ -0,0 +1,16 @@\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n+y = np.linspace(1000e2, 1, 100)\n+x = np.exp(-np.linspace(0, 1, y.size))\n+\n+for yscale in ('linear', 'log'):\n+    fig, ax = plt.subplots()\n+    ax.plot(x, y)\n+    ax.set_yscale(yscale)\n+    ax.set_ylim(y.max(), y.min())\n+    print(f\"Scale: {yscale}\")\n+    print(f\"  ylim: {ax.get_ylim()}\")\n+    print(f\"  inverted: {ax.yaxis_inverted()}\")\n+    plt.savefig(f'test_{yscale}.png')\n+    plt.close()\n", "gold_standard_diff": "diff --git a/doc/api/next_api_changes/2019-06-25-AL.rst b/doc/api/next_api_changes/2019-06-25-AL.rst\nnew file mode 100644\nindex 000000000000..d4ab0107eba7\n--- /dev/null\n+++ b/doc/api/next_api_changes/2019-06-25-AL.rst\n@@ -0,0 +1,6 @@\n+API changes\n+```````````\n+\n+`Locator.nonsingular` (introduced in mpl 3.1) now returns a range ``v0, v1``\n+with ``v0 <= v1``.  This behavior is consistent with the implementation of\n+``nonsingular`` by the `LogLocator` and `LogitLocator` subclasses.\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex ae464e33c0a5..cb50a6ab1e95 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -3262,8 +3262,11 @@ def set_xlim(self, left=None, right=None, emit=True, auto=False,\n             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\n+        swapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\n+        if swapped:\n+            left, right = right, left\n \n         self.viewLim.intervalx = (left, right)\n         if auto is not None:\n@@ -3642,8 +3645,11 @@ def set_ylim(self, bottom=None, top=None, emit=True, auto=False,\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+        swapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        if swapped:\n+            bottom, top = top, bottom\n \n         self.viewLim.intervaly = (bottom, top)\n         if auto is not None:\ndiff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 3ad2f259bcb2..4686af9bb5a8 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -936,7 +936,12 @@ def test_inverted_limits():\n \n     assert ax.get_xlim() == (-5, 4)\n     assert ax.get_ylim() == (5, -3)\n-    plt.close()\n+\n+    # Test inverting nonlinear axes.\n+    fig, ax = plt.subplots()\n+    ax.set_yscale(\"log\")\n+    ax.set_ylim(10, 1)\n+    assert ax.get_ylim() == (10, 1)\n \n \n @image_comparison(baseline_images=['nonfinite_limits'])\ndiff --git a/lib/matplotlib/ticker.py b/lib/matplotlib/ticker.py\nindex 209a3f92ce6b..3f6130164814 100644\n--- a/lib/matplotlib/ticker.py\n+++ b/lib/matplotlib/ticker.py\n@@ -1521,8 +1521,8 @@ def raise_if_exceeds(self, locs):\n         return locs\n \n     def nonsingular(self, v0, v1):\n-        \"\"\"Modify the endpoints of a range as needed to avoid singularities.\"\"\"\n-        return mtransforms.nonsingular(v0, v1, increasing=False, expander=.05)\n+        \"\"\"Expand a range as needed to avoid singularities.\"\"\"\n+        return mtransforms.nonsingular(v0, v1, expander=.05)\n \n     def view_limits(self, vmin, vmax):\n         \"\"\"\ndiff --git a/lib/mpl_toolkits/mplot3d/axes3d.py b/lib/mpl_toolkits/mplot3d/axes3d.py\nindex e4a13f3e200e..97579c685564 100644\n--- a/lib/mpl_toolkits/mplot3d/axes3d.py\n+++ b/lib/mpl_toolkits/mplot3d/axes3d.py\n@@ -623,8 +623,11 @@ def set_xlim3d(self, left=None, right=None, emit=True, auto=False,\n             cbook._warn_external(\n                 f\"Attempting to set identical left == right == {left} results \"\n                 f\"in singular transformations; automatically expanding.\")\n+        swapped = left > right\n         left, right = self.xaxis.get_major_locator().nonsingular(left, right)\n         left, right = self.xaxis.limit_range_for_scale(left, right)\n+        if swapped:\n+            left, right = right, left\n         self.xy_viewLim.intervalx = (left, right)\n \n         if auto is not None:\n@@ -681,8 +684,11 @@ def set_ylim3d(self, bottom=None, top=None, emit=True, auto=False,\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+        swapped = bottom > top\n         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)\n+        if swapped:\n+            bottom, top = top, bottom\n         self.xy_viewLim.intervaly = (bottom, top)\n \n         if auto is not None:\n@@ -739,8 +745,11 @@ def set_zlim3d(self, bottom=None, top=None, emit=True, auto=False,\n                 f\"Attempting to set identical bottom == top == {bottom} \"\n                 f\"results in singular transformations; automatically \"\n                 f\"expanding.\")\n+        swapped = bottom > top\n         bottom, top = self.zaxis.get_major_locator().nonsingular(bottom, top)\n         bottom, top = self.zaxis.limit_range_for_scale(bottom, top)\n+        if swapped:\n+            bottom, top = top, bottom\n         self.zz_viewLim.intervalx = (bottom, top)\n \n         if auto is not None:\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/14623"}