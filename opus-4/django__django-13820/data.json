{"instance_id": "django__django-13820", "score": "C", "diff": "diff --git a/demo_frozen_support.py b/demo_frozen_support.py\nnew file mode 100644\nindex 0000000000..53597db421\n--- /dev/null\n+++ b/demo_frozen_support.py\n@@ -0,0 +1,32 @@\n+\"\"\"\n+Demo showing how the improved namespace detection helps frozen Python environments.\n+\"\"\"\n+\n+print(\"Django Migration Loader - Improved Namespace Package Detection\")\n+print(\"=\" * 60)\n+print()\n+print(\"PROBLEM:\")\n+print(\"In frozen Python environments (e.g., py2exe, PyInstaller, cx_Freeze),\")\n+print(\"regular packages often don't have __file__ attributes set.\")\n+print(\"Django's migration loader previously rejected ALL modules without __file__,\")\n+print(\"incorrectly treating frozen regular packages as namespace packages.\")\n+print()\n+print(\"SOLUTION:\")\n+print(\"The improved check now properly distinguishes between:\")\n+print(\"1. Regular packages without __file__ (has list __path__) - ACCEPTED\")\n+print(\"2. Namespace packages (has non-list __path__) - REJECTED\")\n+print()\n+print(\"IMPACT:\")\n+print(\"This change enables Django to find and load migrations in frozen\")\n+print(\"Python environments, while still correctly rejecting namespace packages.\")\n+print()\n+print(\"The check changed from:\")\n+print(\"  if getattr(module, '__file__', None) is None:\")\n+print(\"      # Reject as namespace package\")\n+print()\n+print(\"To:\")\n+print(\"  if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):\")\n+print(\"      # Reject only if it's actually a namespace package\")\n+print()\n+print(\"This narrow change maintains backward compatibility while enabling\")\n+print(\"Django to work better in frozen environments!\")\ndiff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\nindex 95a5062ec9..c84a17f14b 100644\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -88,15 +88,17 @@ class MigrationLoader:\n                     continue\n                 raise\n             else:\n-                # Empty directories are namespaces.\n-                # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n-                    self.unmigrated_apps.add(app_config.label)\n-                    continue\n                 # Module is not a package (e.g. migrations.py).\n                 if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n                     continue\n+                # Namespace packages have no __file__ and don't use a regular list for __path__.\n+                # Check for namespace packages more accurately - avoid rejecting regular packages\n+                # in frozen environments that don't set __file__.\n+                # getattr() needed on PY36 and older (replace w/attribute access).\n+                if getattr(module, '__file__', None) is None and not isinstance(module.__path__, list):\n+                    self.unmigrated_apps.add(app_config.label)\n+                    continue\n                 # Force a reload if it's already loaded (tests need this)\n                 if was_loaded:\n                     reload(module)\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..83ef266a9a\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,75 @@\n+\"\"\"Test edge cases for the namespace package detection.\"\"\"\n+from types import ModuleType\n+\n+\n+def test_edge_cases():\n+    \"\"\"Test various edge cases for module identification.\"\"\"\n+    \n+    # Case 1: Module with __file__ set (normal case)\n+    normal_module = ModuleType('normal')\n+    normal_module.__file__ = '/some/path/normal.py'\n+    normal_module.__path__ = ['/some/path']\n+    \n+    # Case 2: Module without __path__ (not a package, e.g., migrations.py file)\n+    non_package = ModuleType('non_package')\n+    non_package.__file__ = '/some/path/migrations.py'\n+    # No __path__ attribute\n+    \n+    # Case 3: Frozen regular package (no __file__, list __path__)\n+    frozen_regular = ModuleType('frozen_regular')\n+    # No __file__\n+    frozen_regular.__path__ = ['/frozen/path']\n+    \n+    # Case 4: Namespace package (no __file__, non-list __path__)\n+    class FakePath:\n+        def __init__(self, paths):\n+            self.paths = paths\n+        def __iter__(self):\n+            return iter(self.paths)\n+    \n+    namespace_pkg = ModuleType('namespace')\n+    # No __file__\n+    namespace_pkg.__path__ = FakePath(['/namespace/path'])\n+    \n+    # Test each case\n+    print(\"Testing edge cases:\")\n+    \n+    for name, module in [\n+        ('normal_module', normal_module),\n+        ('non_package', non_package),\n+        ('frozen_regular', frozen_regular),\n+        ('namespace_pkg', namespace_pkg)\n+    ]:\n+        has_file = getattr(module, '__file__', None) is not None\n+        has_path = hasattr(module, '__path__')\n+        has_list_path = has_path and isinstance(module.__path__, list)\n+        \n+        # Old check (would reject if no __file__)\n+        old_would_reject = getattr(module, '__file__', None) is None\n+        \n+        # New check (reject if no __file__ AND __path__ is not a list)\n+        new_would_reject = (getattr(module, '__file__', None) is None and \n+                           has_path and not isinstance(module.__path__, list))\n+        \n+        print(f\"\\n{name}:\")\n+        print(f\"  has __file__: {has_file}\")\n+        print(f\"  has __path__: {has_path}\")\n+        print(f\"  __path__ is list: {has_list_path}\")\n+        print(f\"  OLD check would reject: {old_would_reject}\")\n+        print(f\"  NEW check would reject: {new_would_reject}\")\n+        \n+        # Verify the logic makes sense\n+        if name == 'normal_module':\n+            assert not old_would_reject and not new_would_reject\n+        elif name == 'non_package':\n+            assert not old_would_reject and not new_would_reject\n+        elif name == 'frozen_regular':\n+            assert old_would_reject and not new_would_reject  # This is the key improvement!\n+        elif name == 'namespace_pkg':\n+            assert old_would_reject and new_would_reject\n+    \n+    print(\"\\nAll edge case tests passed!\")\n+\n+\n+if __name__ == '__main__':\n+    test_edge_cases()\ndiff --git a/test_frozen_environment.py b/test_frozen_environment.py\nnew file mode 100644\nindex 0000000000..114a9571f9\n--- /dev/null\n+++ b/test_frozen_environment.py\n@@ -0,0 +1,148 @@\n+\"\"\"\n+Test for the improved namespace package detection in frozen environments.\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+from types import ModuleType\n+from importlib.machinery import ModuleSpec\n+from django.db.migrations.loader import MigrationLoader\n+from django.db import connection\n+from django.test import TestCase, override_settings\n+from django.apps import apps\n+\n+\n+class MockFrozenModule(ModuleType):\n+    \"\"\"A mock module that simulates a regular package in a frozen environment.\n+    \n+    This has no __file__ attribute but has a list __path__ attribute.\n+    \"\"\"\n+    def __init__(self, name, path):\n+        super().__init__(name)\n+        self.__path__ = [path]  # Regular list path, not _NamespacePath\n+\n+\n+class NamespacePathMock:\n+    \"\"\"Mock of the _NamespacePath type used by namespace packages.\"\"\"\n+    def __init__(self, paths):\n+        self._paths = paths\n+    \n+    def __iter__(self):\n+        return iter(self._paths)\n+\n+\n+class MockNamespaceModule(ModuleType):\n+    \"\"\"A mock module that simulates a namespace package.\n+    \n+    This has no __file__ attribute and has a non-list __path__ attribute.\n+    \"\"\"\n+    def __init__(self, name, path):\n+        super().__init__(name)\n+        self.__path__ = NamespacePathMock([path])\n+\n+\n+def test_namespace_detection():\n+    \"\"\"Test the improved namespace package detection logic directly.\"\"\"\n+    print(\"Testing namespace package detection logic...\")\n+    \n+    # Create test modules\n+    frozen_regular = MockFrozenModule('frozen_regular', '/some/path')\n+    namespace_pkg = MockNamespaceModule('namespace_pkg', '/some/namespace')\n+    \n+    # Test the new logic\n+    for name, module in [('frozen_regular', frozen_regular), ('namespace_pkg', namespace_pkg)]:\n+        has_file = getattr(module, '__file__', None) is not None\n+        has_list_path = hasattr(module, '__path__') and isinstance(module.__path__, list)\n+        is_namespace = not has_file and not has_list_path\n+        \n+        print(f\"\\n{name}:\")\n+        print(f\"  has __file__: {has_file}\")\n+        print(f\"  has list __path__: {has_list_path}\")\n+        print(f\"  is namespace package: {is_namespace}\")\n+    \n+    # The frozen regular package should NOT be detected as namespace\n+    assert not (getattr(frozen_regular, '__file__', None) is None and \n+                not isinstance(frozen_regular.__path__, list))\n+    \n+    # The namespace package SHOULD be detected as namespace\n+    assert (getattr(namespace_pkg, '__file__', None) is None and \n+            not isinstance(namespace_pkg.__path__, list))\n+    \n+    print(\"\\nAll assertions passed!\")\n+\n+\n+def test_migration_loader_with_frozen_module():\n+    \"\"\"Test that MigrationLoader accepts regular packages without __file__.\"\"\"\n+    print(\"\\nTesting MigrationLoader with frozen-style module...\")\n+    \n+    # Create a temporary directory for our test app\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create app structure\n+        app_dir = os.path.join(tmpdir, 'test_app')\n+        migrations_dir = os.path.join(app_dir, 'migrations')\n+        os.makedirs(migrations_dir)\n+        \n+        # Create __init__.py files (regular package, not namespace)\n+        with open(os.path.join(app_dir, '__init__.py'), 'w') as f:\n+            f.write('')\n+        with open(os.path.join(migrations_dir, '__init__.py'), 'w') as f:\n+            f.write('')\n+        \n+        # Create a migration\n+        with open(os.path.join(migrations_dir, '0001_initial.py'), 'w') as f:\n+            f.write('''\n+from django.db import migrations\n+\n+class Migration(migrations.Migration):\n+    initial = True\n+    dependencies = []\n+    operations = []\n+''')\n+        \n+        # Add to sys.path\n+        sys.path.insert(0, tmpdir)\n+        \n+        try:\n+            # Import the modules\n+            import test_app\n+            import test_app.migrations\n+            \n+            # Simulate frozen environment by removing __file__\n+            original_file = getattr(test_app.migrations, '__file__', None)\n+            if hasattr(test_app.migrations, '__file__'):\n+                delattr(test_app.migrations, '__file__')\n+            \n+            # Verify it's a regular package (has list __path__)\n+            assert isinstance(test_app.migrations.__path__, list), \\\n+                f\"Expected list path, got {type(test_app.migrations.__path__)}\"\n+            \n+            # Mock the app config\n+            class MockAppConfig:\n+                label = 'test_app'\n+                name = 'test_app'\n+            \n+            # Test that our module would NOT be rejected by the new check\n+            module = test_app.migrations\n+            would_be_rejected = (getattr(module, '__file__', None) is None and \n+                               not isinstance(module.__path__, list))\n+            \n+            print(f\"Module has __file__: {hasattr(module, '__file__')}\")\n+            print(f\"Module __path__ is list: {isinstance(module.__path__, list)}\")\n+            print(f\"Would be rejected as namespace: {would_be_rejected}\")\n+            \n+            assert not would_be_rejected, \"Regular package without __file__ should not be rejected!\"\n+            \n+            print(\"Test passed: Regular packages without __file__ are accepted!\")\n+            \n+        finally:\n+            # Cleanup\n+            sys.path.remove(tmpdir)\n+            # Remove imported modules\n+            for mod in list(sys.modules.keys()):\n+                if mod.startswith('test_app'):\n+                    del sys.modules[mod]\n+\n+\n+if __name__ == '__main__':\n+    test_namespace_detection()\n+    test_migration_loader_with_frozen_module()\ndiff --git a/test_frozen_package_support.py b/test_frozen_package_support.py\nnew file mode 100644\nindex 0000000000..0b06bc033f\n--- /dev/null\n+++ b/test_frozen_package_support.py\n@@ -0,0 +1,85 @@\n+\"\"\"\n+Test to add to Django's test suite for frozen environment support.\n+This test could be added to tests/migrations/test_loader.py\n+\"\"\"\n+\n+from django.test import TestCase, override_settings\n+from django.db.migrations.loader import MigrationLoader\n+from django.db import connection\n+import sys\n+from types import ModuleType\n+from unittest import mock\n+\n+\n+class FrozenEnvironmentTests(TestCase):\n+    \"\"\"Tests for migration loader behavior in frozen Python environments.\"\"\"\n+    \n+    def test_frozen_regular_package_accepted(self):\n+        \"\"\"\n+        Regular packages without __file__ (as in frozen environments) should be\n+        accepted by the migration loader, not rejected as namespace packages.\n+        \"\"\"\n+        # Create a mock module that simulates a regular package in frozen env\n+        mock_module = ModuleType('test_frozen_migrations')\n+        mock_module.__path__ = ['/some/frozen/path']  # List path = regular package\n+        # No __file__ attribute (frozen environment characteristic)\n+        \n+        # The module should NOT be identified as a namespace package\n+        is_namespace = (getattr(mock_module, '__file__', None) is None and \n+                       not isinstance(mock_module.__path__, list))\n+        self.assertFalse(is_namespace, \n+                        \"Regular package without __file__ incorrectly identified as namespace\")\n+    \n+    def test_namespace_package_still_rejected(self):\n+        \"\"\"\n+        True namespace packages (with non-list __path__) should still be rejected.\n+        \"\"\"\n+        # Create a mock namespace package\n+        class _NamespacePath:\n+            def __init__(self, paths):\n+                self._paths = paths\n+            def __iter__(self):\n+                return iter(self._paths)\n+        \n+        mock_module = ModuleType('test_namespace_migrations')\n+        mock_module.__path__ = _NamespacePath(['/some/namespace/path'])\n+        # No __file__ attribute\n+        \n+        # The module SHOULD be identified as a namespace package\n+        is_namespace = (getattr(mock_module, '__file__', None) is None and \n+                       not isinstance(mock_module.__path__, list))\n+        self.assertTrue(is_namespace, \n+                       \"Namespace package not correctly identified\")\n+    \n+    @mock.patch('django.db.migrations.loader.import_module')\n+    def test_loader_accepts_frozen_package(self, mock_import):\n+        \"\"\"\n+        MigrationLoader should process regular packages without __file__.\n+        \"\"\"\n+        # Create a mock frozen module\n+        mock_module = ModuleType('test_app.migrations')\n+        mock_module.__path__ = ['/frozen/test_app/migrations']\n+        # No __file__ attribute\n+        \n+        # Configure the mock\n+        mock_import.return_value = mock_module\n+        \n+        # Override settings to test our app\n+        with override_settings(\n+            INSTALLED_APPS=['test_app'],\n+            MIGRATION_MODULES={'test_app': 'test_app.migrations'}\n+        ):\n+            # Mock apps.get_app_configs to return our test app\n+            from django.apps import apps\n+            \n+            class MockAppConfig:\n+                label = 'test_app'\n+                name = 'test_app'\n+            \n+            with mock.patch.object(apps, 'get_app_configs', return_value=[MockAppConfig()]):\n+                loader = MigrationLoader(connection, load=False)\n+                loader.load_disk()\n+                \n+                # The app should be in migrated_apps, not unmigrated_apps\n+                self.assertIn('test_app', loader.migrated_apps)\n+                self.assertNotIn('test_app', loader.unmigrated_apps)\ndiff --git a/test_namespace_check.py b/test_namespace_check.py\nnew file mode 100644\nindex 0000000000..8e516d6d82\n--- /dev/null\n+++ b/test_namespace_check.py\n@@ -0,0 +1,56 @@\n+\"\"\"Test script to verify namespace package detection behavior.\"\"\"\n+import sys\n+from types import ModuleType\n+from importlib.machinery import ModuleSpec\n+\n+# Create a mock module that has no __file__ but has a list __path__ (regular package)\n+regular_package_no_file = ModuleType('regular_package_no_file')\n+regular_package_no_file.__path__ = ['/some/path']  # List path (regular package)\n+# No __file__ attribute set\n+\n+# Create a mock namespace package (has no __file__ and non-list __path__)\n+class _NamespacePath:\n+    \"\"\"Mock of the _NamespacePath type used by namespace packages.\"\"\"\n+    def __init__(self, paths):\n+        self._paths = paths\n+    \n+    def __iter__(self):\n+        return iter(self._paths)\n+\n+namespace_package = ModuleType('namespace_package')\n+namespace_package.__path__ = _NamespacePath(['/some/namespace/path'])\n+# No __file__ attribute set\n+\n+# Test current behavior\n+def test_current_check():\n+    \"\"\"Test the current implementation's behavior.\"\"\"\n+    print(\"Testing current implementation:\")\n+    \n+    # Current check: getattr(module, '__file__', None) is None\n+    print(f\"regular_package_no_file has __file__: {hasattr(regular_package_no_file, '__file__')}\")\n+    print(f\"regular_package_no_file.__file__ is None: {getattr(regular_package_no_file, '__file__', None) is None}\")\n+    print(f\"namespace_package has __file__: {hasattr(namespace_package, '__file__')}\")\n+    print(f\"namespace_package.__file__ is None: {getattr(namespace_package, '__file__', None) is None}\")\n+    \n+    print(\"\\nCurrent check would reject both packages!\")\n+\n+def test_proposed_check():\n+    \"\"\"Test the proposed implementation's behavior.\"\"\"\n+    print(\"\\nTesting proposed implementation:\")\n+    \n+    for name, module in [('regular_package_no_file', regular_package_no_file), \n+                         ('namespace_package', namespace_package)]:\n+        has_file = getattr(module, '__file__', None) is not None\n+        has_list_path = hasattr(module, '__path__') and isinstance(module.__path__, list)\n+        \n+        # Proposed check: reject if no __file__ AND __path__ is not a list\n+        is_namespace = not has_file and not has_list_path\n+        \n+        print(f\"\\n{name}:\")\n+        print(f\"  has __file__: {has_file}\")\n+        print(f\"  has list __path__: {has_list_path}\")\n+        print(f\"  Would be rejected as namespace: {is_namespace}\")\n+\n+if __name__ == \"__main__\":\n+    test_current_check()\n+    test_proposed_check()\n", "gold_standard_diff": "From e64c1d8055a3e476122633da141f16b50f0c4a2d Mon Sep 17 00:00:00 2001\nFrom: William Schwartz <wkschwartz@gmail.com>\nDate: Mon, 28 Dec 2020 16:05:18 -0600\nSubject: [PATCH] Fixed #32302 -- Allowed migrations to be loaded from regular\n packages with no __file__ attribute.\n\nThe migrations loader prevents the use of PEP-420 namespace packages\nfor holding apps' migrations modules. Previously the loader tested for\nthis only by checking that app.migrations.__file__ is present. This\nprevented migrations' being found in frozen Python environments that\ndon't set __file__ on any modules. Now the loader *additionally* checks\nwhether app.migrations.__path__ is a list because namespace packages\nuse a different type for __path__. Namespace packages continue to be\nforbidden, and, in fact, users of normal Python environments should\nexperience no change whatsoever.\n---\n django/db/migrations/loader.py  | 14 +++++++++-----\n tests/migrations/test_loader.py | 30 ++++++++++++++++++++++++++++++\n 2 files changed, 39 insertions(+), 5 deletions(-)\n\ndiff --git a/django/db/migrations/loader.py b/django/db/migrations/loader.py\nindex 95a5062ec957..eb370164f37b 100644\n--- a/django/db/migrations/loader.py\n+++ b/django/db/migrations/loader.py\n@@ -88,15 +88,19 @@ def load_disk(self):\n                     continue\n                 raise\n             else:\n-                # Empty directories are namespaces.\n-                # getattr() needed on PY36 and older (replace w/attribute access).\n-                if getattr(module, '__file__', None) is None:\n-                    self.unmigrated_apps.add(app_config.label)\n-                    continue\n                 # Module is not a package (e.g. migrations.py).\n                 if not hasattr(module, '__path__'):\n                     self.unmigrated_apps.add(app_config.label)\n                     continue\n+                # Empty directories are namespaces. Namespace packages have no\n+                # __file__ and don't use a list for __path__. See\n+                # https://docs.python.org/3/reference/import.html#namespace-packages\n+                if (\n+                    getattr(module, '__file__', None) is None and\n+                    not isinstance(module.__path__, list)\n+                ):\n+                    self.unmigrated_apps.add(app_config.label)\n+                    continue\n                 # Force a reload if it's already loaded (tests need this)\n                 if was_loaded:\n                     reload(module)\ndiff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\nindex 27a052ddac65..d8f07851d2cd 100644\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -1,5 +1,6 @@\n import compileall\n import os\n+from importlib import import_module\n \n from django.db import connection, connections\n from django.db.migrations.exceptions import (\n@@ -512,6 +513,35 @@ def test_loading_namespace_package(self):\n         migrations = [name for app, name in loader.disk_migrations if app == 'migrations']\n         self.assertEqual(migrations, [])\n \n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})\n+    def test_loading_package_without__file__(self):\n+        \"\"\"\n+        To support frozen environments, MigrationLoader loads migrations from\n+        regular packages with no __file__ attribute.\n+        \"\"\"\n+        test_module = import_module('migrations.test_migrations')\n+        loader = MigrationLoader(connection)\n+        # __file__ == __spec__.origin or the latter is None and former is\n+        # undefined.\n+        module_file = test_module.__file__\n+        module_origin = test_module.__spec__.origin\n+        module_has_location = test_module.__spec__.has_location\n+        try:\n+            del test_module.__file__\n+            test_module.__spec__.origin = None\n+            test_module.__spec__.has_location = False\n+            loader.load_disk()\n+            migrations = [\n+                name\n+                for app, name in loader.disk_migrations\n+                if app == 'migrations'\n+            ]\n+            self.assertCountEqual(migrations, ['0001_initial', '0002_second'])\n+        finally:\n+            test_module.__file__ = module_file\n+            test_module.__spec__.origin = module_origin\n+            test_module.__spec__.has_location = module_has_location\n+\n \n class PycLoaderTests(MigrationTestBase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/13820"}