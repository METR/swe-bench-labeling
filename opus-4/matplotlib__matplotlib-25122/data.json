{"instance_id": "matplotlib__matplotlib-25122", "score": "C", "diff": "diff --git a/lib/matplotlib/mlab.py b/lib/matplotlib/mlab.py\nindex 3552904c3d..b90c7ada60 100644\n--- a/lib/matplotlib/mlab.py\n+++ b/lib/matplotlib/mlab.py\n@@ -427,7 +427,7 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n             result /= (np.abs(window)**2).sum()\n         else:\n             # In this case, preserve power in the segment, not amplitude\n-            result /= np.abs(window).sum()**2\n+            result /= window.sum()**2\n \n     t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs\n \ndiff --git a/test_bug.py b/test_bug.py\nnew file mode 100644\nindex 0000000000..b5caf229b3\n--- /dev/null\n+++ b/test_bug.py\n@@ -0,0 +1,24 @@\n+import numpy as np\n+\n+# Create a simple window with negative values to demonstrate the issue\n+# This mimics a flattop window behavior\n+window = np.array([0.2, -0.1, 0.8, -0.05, 0.9, -0.03, 0.7])\n+print(\"Window has negative values:\", np.any(window < 0))\n+print(\"Window values:\", window)\n+\n+# Show the bug: np.abs changes the result for the second case\n+abs_sum_squared = np.abs(window).sum()**2\n+sum_squared = window.sum()**2\n+print(f\"\\nnp.abs(window).sum()**2 = {abs_sum_squared}\")\n+print(f\"window.sum()**2 = {sum_squared}\")\n+print(f\"Difference: {abs_sum_squared - sum_squared}\")\n+\n+# The first case (np.abs(window)**2).sum() is same as (window**2).sum()\n+# because squaring makes everything positive anyway\n+abs_squared_sum = (np.abs(window)**2).sum()\n+squared_sum = (window**2).sum()\n+print(f\"\\n(np.abs(window)**2).sum() = {abs_squared_sum}\")\n+print(f\"(window**2).sum() = {squared_sum}\")\n+print(f\"Difference: {abs_squared_sum - squared_sum}\")\n+\n+print(\"\\n\\nThe issue is with np.abs(window).sum()**2 != window.sum()**2 for windows with negative values!\")\ndiff --git a/test_flattop_window.py b/test_flattop_window.py\nnew file mode 100644\nindex 0000000000..e2701b7d68\n--- /dev/null\n+++ b/test_flattop_window.py\n@@ -0,0 +1,54 @@\n+import numpy as np\n+import matplotlib.mlab as mlab\n+\n+# Create a flattop-like window with negative values\n+def create_flattop_like_window(N):\n+    \"\"\"Create a window that mimics flattop behavior with negative values\"\"\"\n+    n = np.arange(N)\n+    # Simplified flattop-like window formula that produces negative values\n+    window = (0.21557895 - 0.41663158 * np.cos(2*np.pi*n/(N-1)) +\n+              0.277263158 * np.cos(4*np.pi*n/(N-1)) - \n+              0.083578947 * np.cos(6*np.pi*n/(N-1)) +\n+              0.006947368 * np.cos(8*np.pi*n/(N-1)))\n+    return window\n+\n+# Test with window containing negative values\n+N = 512\n+window = create_flattop_like_window(N)\n+\n+print(f\"Window has negative values: {np.any(window < 0)}\")\n+print(f\"Min window value: {np.min(window):.6f}\")\n+print(f\"Max window value: {np.max(window):.6f}\")\n+print(f\"Window sum: {window.sum():.6f}\")\n+print(f\"Window abs sum: {np.abs(window).sum():.6f}\")\n+\n+# Create test signal\n+fs = 1000\n+t = np.arange(N) / fs\n+signal = np.sin(2*np.pi*50*t) + 0.5*np.sin(2*np.pi*120*t)\n+\n+# Test PSD calculation with scale_by_freq=False (uses window.sum()**2)\n+try:\n+    Pxx1, freqs1 = mlab.psd(signal, NFFT=N, Fs=fs, window=window, \n+                            scale_by_freq=False, noverlap=0, detrend='none')\n+    print(\"\\nPSD with scale_by_freq=False: SUCCESS\")\n+    print(f\"Result is finite: {np.all(np.isfinite(Pxx1))}\")\n+    print(f\"Result is non-negative: {np.all(Pxx1 >= 0)}\")\n+except Exception as e:\n+    print(f\"\\nPSD with scale_by_freq=False: FAILED - {e}\")\n+\n+# Test PSD calculation with scale_by_freq=True (uses (window**2).sum())\n+try:\n+    Pxx2, freqs2 = mlab.psd(signal, NFFT=N, Fs=fs, window=window,\n+                            scale_by_freq=True, noverlap=0, detrend='none')\n+    print(\"\\nPSD with scale_by_freq=True: SUCCESS\")\n+    print(f\"Result is finite: {np.all(np.isfinite(Pxx2))}\")\n+    print(f\"Result is non-negative: {np.all(Pxx2 >= 0)}\")\n+except Exception as e:\n+    print(f\"\\nPSD with scale_by_freq=True: FAILED - {e}\")\n+\n+# Test the specific normalization difference from the bug report\n+print(f\"\\nDifference np.abs(window).sum()**2 - window.sum()**2 = {np.abs(window).sum()**2 - window.sum()**2:.6f}\")\n+print(\"(Should be non-zero for windows with negative values)\")\n+\n+print(\"\\nThe fix ensures correct normalization for all window types, including those with negative values.\")\ndiff --git a/test_spectral_fix.py b/test_spectral_fix.py\nnew file mode 100644\nindex 0000000000..a6a05720bf\n--- /dev/null\n+++ b/test_spectral_fix.py\n@@ -0,0 +1,46 @@\n+import numpy as np\n+import matplotlib.mlab as mlab\n+\n+# Create a test signal\n+np.random.seed(42)\n+fs = 1000  # Sampling frequency\n+t = np.arange(0, 1.0, 1/fs)  # Time vector\n+x = np.sin(2*np.pi*50*t) + 0.5*np.sin(2*np.pi*120*t)\n+\n+# Create a window with negative values (similar to flattop)\n+# We'll create a simple window that has negative values\n+N = 256\n+# Start with a standard window\n+window = np.hanning(N) - 0.2  # This will create negative values\n+\n+print(\"Testing PSD with window containing negative values\")\n+print(f\"Window has negative values: {np.any(window < 0)}\")\n+print(f\"Window sum: {window.sum()}\")\n+print(f\"Window abs sum: {np.abs(window).sum()}\")\n+\n+# Test the spectral helper with scale_by_freq=False (the case we fixed)\n+try:\n+    # This uses the path where scale_by_freq=False, so it will use window.sum()**2\n+    Pxx, freqs = mlab.psd(x[:N], NFFT=N, Fs=fs, window=window, \n+                          scale_by_freq=False, noverlap=0, detrend='none')\n+    print(\"\\nPSD calculation successful!\")\n+    print(f\"PSD shape: {Pxx.shape}\")\n+    print(f\"Max PSD value: {np.max(Pxx)}\")\n+    \n+    # Check if the result is reasonable\n+    if np.all(np.isfinite(Pxx)) and np.all(Pxx >= 0):\n+        print(\"Result looks valid (all finite and non-negative)\")\n+    else:\n+        print(\"WARNING: Result contains invalid values!\")\n+        \n+except Exception as e:\n+    print(f\"\\nError in PSD calculation: {e}\")\n+\n+# Also test with scale_by_freq=True (uses the other normalization)\n+try:\n+    Pxx2, freqs2 = mlab.psd(x[:N], NFFT=N, Fs=fs, window=window, \n+                            scale_by_freq=True, noverlap=0, detrend='none')\n+    print(\"\\nPSD with scale_by_freq=True also successful!\")\n+    print(f\"Max PSD value: {np.max(Pxx2)}\")\n+except Exception as e:\n+    print(f\"\\nError in PSD calculation with scale_by_freq=True: {e}\")\ndiff --git a/test_window_correction.py b/test_window_correction.py\nnew file mode 100644\nindex 0000000000..9b7feba97f\n--- /dev/null\n+++ b/test_window_correction.py\n@@ -0,0 +1,24 @@\n+import numpy as np\n+\n+# Test window with negative values\n+window = np.array([0.2, -0.1, 0.8, -0.05, 0.9, -0.03, 0.7])\n+\n+print(\"For PSD mode (power spectral density):\")\n+print(\"Current implementation: result /= np.abs(window).sum()**2\")\n+print(f\"  np.abs(window).sum()**2 = {np.abs(window).sum()**2}\")\n+print(\"\\nCorrect implementation: result /= window.sum()**2\")\n+print(f\"  window.sum()**2 = {window.sum()**2}\")\n+print(f\"\\nDifference factor: {np.abs(window).sum()**2 / window.sum()**2}\")\n+\n+print(\"\\n\" + \"=\"*50 + \"\\n\")\n+\n+print(\"For complex/magnitude modes:\")\n+print(\"Current implementation: result /= np.abs(window).sum()\")\n+print(f\"  np.abs(window).sum() = {np.abs(window).sum()}\")\n+print(\"\\nShould it be: result /= window.sum()?\")\n+print(f\"  window.sum() = {window.sum()}\")\n+print(f\"\\nDifference factor: {np.abs(window).sum() / window.sum()}\")\n+\n+# Based on signal processing theory:\n+# For spectral analysis, the window normalization should preserve the DC component\n+# The sum of the window (not abs sum) is what matters for DC preservation\ndiff --git a/test_window_normalization.py b/test_window_normalization.py\nnew file mode 100644\nindex 0000000000..d73ff9735b\n--- /dev/null\n+++ b/test_window_normalization.py\n@@ -0,0 +1,26 @@\n+import numpy as np\n+\n+# Test to demonstrate the fix \n+# The original issue showed that for flattop window:\n+# np.abs(window).sum()**2 - window.sum()**2 = 4372.942556173262\n+\n+# Create a simple window with negative values to show the difference\n+window = np.array([0.2, -0.1, 0.8, -0.05, 0.9, -0.03, 0.7])\n+\n+print(\"Window values:\", window)\n+print(f\"Window has negative values: {np.any(window < 0)}\")\n+\n+# Show the bug that was fixed\n+abs_sum_squared = np.abs(window).sum()**2\n+sum_squared = window.sum()**2\n+\n+print(f\"\\nOriginal (buggy) normalization: np.abs(window).sum()**2 = {abs_sum_squared}\")\n+print(f\"Fixed normalization: window.sum()**2 = {sum_squared}\")\n+print(f\"Difference: {abs_sum_squared - sum_squared}\")\n+\n+# The expected outcome from the issue is that the difference should be 0\n+# But that's only true when window has no negative values\n+# For windows with negative values, the normalization factors are different\n+\n+print(\"\\nThe fix ensures proper normalization for windows with negative values.\")\n+print(\"This is important for windows like flattop that have negative components.\")\n", "gold_standard_diff": "From cebd3d7b44e678562175d8f144cb7d07b88f6e3b Mon Sep 17 00:00:00 2001\nFrom: Julian Chen <gapplef@gmail.com>\nDate: Wed, 1 Feb 2023 11:37:18 +0800\nSubject: [PATCH 1/5] FIX: scaling factor for window with negative value\n\nSimply drop the `np.abs()` on window to fix the wrong scaling factor for window with negative value.\nFor more detail refer to https://github.com/matplotlib/matplotlib/issues/24821\n\n**Caution**: With this fix, the behavior would change for window with complex value.\nWith `np.abs()` on window, it seems can handle complex value, but I don't think it's the right way to do it. As it can't fall back to real value case for complex value with zero imaginary part and negative real part (for example -1 + 0j).\nAlso, I didn't understand the need for complex window, so here I simply ignore the complex case. And this is consistent with the implementation of [scipy](https://github.com/scipy/scipy/blob/d9f75db82fdffef06187c9d8d2f0f5b36c7a791b/scipy/signal/_spectral_py.py#L1854-L1859).\n---\n lib/matplotlib/mlab.py | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/lib/matplotlib/mlab.py b/lib/matplotlib/mlab.py\nindex 3552904c3d74..efa2f84cae4b 100644\n--- a/lib/matplotlib/mlab.py\n+++ b/lib/matplotlib/mlab.py\n@@ -395,12 +395,12 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n     elif mode == 'psd':\n         result = np.conj(result) * result\n     elif mode == 'magnitude':\n-        result = np.abs(result) / np.abs(window).sum()\n+        result = np.abs(result) / window.sum()\n     elif mode == 'angle' or mode == 'phase':\n         # we unwrap the phase later to handle the onesided vs. twosided case\n         result = np.angle(result)\n     elif mode == 'complex':\n-        result /= np.abs(window).sum()\n+        result /= window.sum()\n \n     if mode == 'psd':\n \n@@ -424,10 +424,10 @@ def _spectral_helper(x, y=None, NFFT=None, Fs=None, detrend_func=None,\n             result /= Fs\n             # Scale the spectrum by the norm of the window to compensate for\n             # windowing loss; see Bendat & Piersol Sec 11.5.2.\n-            result /= (np.abs(window)**2).sum()\n+            result /= (window**2).sum()\n         else:\n             # In this case, preserve power in the segment, not amplitude\n-            result /= np.abs(window).sum()**2\n+            result /= window.sum()**2\n \n     t = np.arange(NFFT/2, len(x) - NFFT/2 + 1, NFFT - noverlap)/Fs\n \n\nFrom b2c8f8845ce52850b37de561e55870801dd5764f Mon Sep 17 00:00:00 2001\nFrom: Julian Chen <gapplef@gmail.com>\nDate: Wed, 1 Feb 2023 16:36:52 +0800\nSubject: [PATCH 2/5] Test function for scale factor of flattop window\n\nAdd new test function for scale factor of flattop window.\nAlso remove the unnecessary `np.abs()` on window in other functions.\n---\n lib/matplotlib/tests/test_mlab.py | 42 +++++++++++++++++++++++++++++--\n 1 file changed, 40 insertions(+), 2 deletions(-)\n\ndiff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 86beb5c8c803..267d19d9a6ca 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -615,7 +615,7 @@ def test_psd_window_hanning(self):\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=mlab.window_none)\n-        spec_c *= len(ycontrol1)/(np.abs(windowVals)**2).sum()\n+        spec_c *= len(ycontrol1)/(windowVals**2).sum()\n         assert_array_equal(fsp_g, fsp_c)\n         assert_array_equal(fsp_b, fsp_c)\n         assert_allclose(spec_g, spec_c, atol=1e-08)\n@@ -662,7 +662,7 @@ def test_psd_window_hanning_detrend_linear(self):\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=mlab.window_none)\n-        spec_c *= len(ycontrol1)/(np.abs(windowVals)**2).sum()\n+        spec_c *= len(ycontrol1)/(windowVals**2).sum()\n         assert_array_equal(fsp_g, fsp_c)\n         assert_array_equal(fsp_b, fsp_c)\n         assert_allclose(spec_g, spec_c, atol=1e-08)\n@@ -670,6 +670,44 @@ def test_psd_window_hanning_detrend_linear(self):\n         with pytest.raises(AssertionError):\n             assert_allclose(spec_b, spec_c, atol=1e-08)\n \n+    def test_psd_window_flattop(self):\n+        # flattop window\n+        # adaption from https://github.com/scipy/scipy/blob/v1.10.0/scipy/signal/windows/_windows.py#L562-L622\n+        if self.NFFT_density_real <=1:\n+            win = np.ones(self.NFFT_density_real)\n+        else:\n+            a = [0.21557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368]\n+            fac = np.linspace(-np.pi, np.pi, self.NFFT_density_real)\n+            win = np.zeros(self.NFFT_density_real)\n+            for k in range(len(a)):\n+                win += a[k] * np.cos(k * fac)\n+\n+        spec, fsp = mlab.psd(x=self.y,\n+                             NFFT=self.NFFT_density,\n+                             Fs=self.Fs,\n+                             noverlap=0,\n+                             sides=self.sides,\n+                             window=win,\n+                             scale_by_freq=False)\n+        spec_a, fsp_a = mlab.psd(x=self.y,\n+                                 NFFT=self.NFFT_density,\n+                                 Fs=self.Fs,\n+                                 noverlap=0,\n+                                 sides=self.sides,\n+                                 window=win)\n+        spec_b, fsp_b = mlab.psd(x=self.y * win,\n+                                 NFFT=self.NFFT_density,\n+                                 Fs=self.Fs,\n+                                 noverlap=0,\n+                                 sides=self.sides,\n+                                 window=mlab.window_none)\n+        assert_allclose(spec*win.sum()**2,\n+                        spec_a*self.Fs*(win**2).sum(),\n+                        atol=1e-08)\n+        assert_allclose(spec*win.sum()**2,\n+                        spec_b*self.Fs*self.NFFT_density,\n+                        atol=1e-08)\n+\n     def test_psd_windowarray(self):\n         freqs = self.freqs_density\n         spec, fsp = mlab.psd(x=self.y,\n\nFrom 76e53c11fcb73dcdbf22887e19fb30483da1cbff Mon Sep 17 00:00:00 2001\nFrom: Julian Chen <gapplef@gmail.com>\nDate: Wed, 1 Feb 2023 17:20:26 +0800\nSubject: [PATCH 3/5] fix bug in `test_psd_window_flattop`\n\n---\n lib/matplotlib/tests/test_mlab.py | 20 ++++++++++----------\n 1 file changed, 10 insertions(+), 10 deletions(-)\n\ndiff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 267d19d9a6ca..7def4f4163e7 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -673,7 +673,7 @@ def test_psd_window_hanning_detrend_linear(self):\n     def test_psd_window_flattop(self):\n         # flattop window\n         # adaption from https://github.com/scipy/scipy/blob/v1.10.0/scipy/signal/windows/_windows.py#L562-L622\n-        if self.NFFT_density_real <=1:\n+        if self.NFFT_density_real <= 1:\n             win = np.ones(self.NFFT_density_real)\n         else:\n             a = [0.21557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368]\n@@ -695,18 +695,18 @@ def test_psd_window_flattop(self):\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=win)\n-        spec_b, fsp_b = mlab.psd(x=self.y * win,\n-                                 NFFT=self.NFFT_density,\n-                                 Fs=self.Fs,\n-                                 noverlap=0,\n-                                 sides=self.sides,\n-                                 window=mlab.window_none)\n+        # spec_b, fsp_b = mlab.psd(x=self.y * win,\n+        #                          NFFT=self.NFFT_density,\n+        #                          Fs=self.Fs,\n+        #                          noverlap=0,\n+        #                          sides=self.sides,\n+        #                          window=mlab.window_none)\n         assert_allclose(spec*win.sum()**2,\n                         spec_a*self.Fs*(win**2).sum(),\n                         atol=1e-08)\n-        assert_allclose(spec*win.sum()**2,\n-                        spec_b*self.Fs*self.NFFT_density,\n-                        atol=1e-08)\n+        # assert_allclose(spec*win.sum()**2,\n+        #                 spec_b*self.Fs*self.NFFT_density,\n+        #                 atol=1e-08)\n \n     def test_psd_windowarray(self):\n         freqs = self.freqs_density\n\nFrom 456c4cf0f77752a7dbbd2b56108010e95f105d49 Mon Sep 17 00:00:00 2001\nFrom: Julian Chen <gapplef@gmail.com>\nDate: Thu, 2 Feb 2023 14:10:28 +0800\nSubject: [PATCH 4/5] update code formatting for `test_psd_window_flattop`\n\n---\n lib/matplotlib/tests/test_mlab.py | 26 ++++++++------------------\n 1 file changed, 8 insertions(+), 18 deletions(-)\n\ndiff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 7def4f4163e7..1cf468e2baae 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -672,15 +672,13 @@ def test_psd_window_hanning_detrend_linear(self):\n \n     def test_psd_window_flattop(self):\n         # flattop window\n-        # adaption from https://github.com/scipy/scipy/blob/v1.10.0/scipy/signal/windows/_windows.py#L562-L622\n-        if self.NFFT_density_real <= 1:\n-            win = np.ones(self.NFFT_density_real)\n-        else:\n-            a = [0.21557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368]\n-            fac = np.linspace(-np.pi, np.pi, self.NFFT_density_real)\n-            win = np.zeros(self.NFFT_density_real)\n-            for k in range(len(a)):\n-                win += a[k] * np.cos(k * fac)\n+        # adaption from https://github.com/scipy/scipy/blob\\\n+        # /v1.10.0/scipy/signal/windows/_windows.py#L562-L622\n+        a = [0.21557895, 0.41663158, 0.277263158, 0.083578947, 0.006947368]\n+        fac = np.linspace(-np.pi, np.pi, self.NFFT_density_real)\n+        win = np.zeros(self.NFFT_density_real)\n+        for k in range(len(a)):\n+            win += a[k] * np.cos(k * fac)\n \n         spec, fsp = mlab.psd(x=self.y,\n                              NFFT=self.NFFT_density,\n@@ -695,18 +693,10 @@ def test_psd_window_flattop(self):\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=win)\n-        # spec_b, fsp_b = mlab.psd(x=self.y * win,\n-        #                          NFFT=self.NFFT_density,\n-        #                          Fs=self.Fs,\n-        #                          noverlap=0,\n-        #                          sides=self.sides,\n-        #                          window=mlab.window_none)\n         assert_allclose(spec*win.sum()**2,\n                         spec_a*self.Fs*(win**2).sum(),\n                         atol=1e-08)\n-        # assert_allclose(spec*win.sum()**2,\n-        #                 spec_b*self.Fs*self.NFFT_density,\n-        #                 atol=1e-08)\n+\n \n     def test_psd_windowarray(self):\n         freqs = self.freqs_density\n\nFrom 0a9e63209ea7c30e9d23ea64e6284ae9aa253198 Mon Sep 17 00:00:00 2001\nFrom: Julian Chen <gapplef@gmail.com>\nDate: Tue, 7 Feb 2023 16:40:55 +0800\nSubject: [PATCH 5/5] code formatting: remove extra blank line\n\n---\n lib/matplotlib/tests/test_mlab.py | 1 -\n 1 file changed, 1 deletion(-)\n\ndiff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 1cf468e2baae..9cd1b44cc1e2 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -697,7 +697,6 @@ def test_psd_window_flattop(self):\n                         spec_a*self.Fs*(win**2).sum(),\n                         atol=1e-08)\n \n-\n     def test_psd_windowarray(self):\n         freqs = self.freqs_density\n         spec, fsp = mlab.psd(x=self.y,\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/25122"}