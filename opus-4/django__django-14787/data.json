{"instance_id": "django__django-14787", "score": "C", "diff": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c7..d661e5f6b1 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -37,10 +37,16 @@ def _multi_decorate(decorators, method):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        bound_method = method.__get__(self, type(self))\n+        # Create a wrapper function instead of using partial directly to preserve attributes\n+        @wraps(method)\n+        def _method_wrapper(*args, **kwargs):\n+            return bound_method(*args, **kwargs)\n+        \n+        # Apply decorators to the wrapper function\n         for dec in decorators:\n-            bound_method = dec(bound_method)\n-        return bound_method(*args, **kwargs)\n+            _method_wrapper = dec(_method_wrapper)\n+        return _method_wrapper(*args, **kwargs)\n \n     # Copy any attributes that a decorator adds to the function it decorates.\n     for dec in decorators:\ndiff --git a/test_attributes.py b/test_attributes.py\nnew file mode 100644\nindex 0000000000..efd86ae7d4\n--- /dev/null\n+++ b/test_attributes.py\n@@ -0,0 +1,32 @@\n+from functools import partial\n+\n+class Test:\n+    def hello_world(self):\n+        return \"hello\"\n+\n+# Check what attributes are available on the method\n+method = Test.hello_world\n+print(\"Original method attributes:\")\n+for attr in ['__name__', '__module__', '__doc__', '__dict__', '__qualname__']:\n+    if hasattr(method, attr):\n+        print(f\"  {attr}: {getattr(method, attr)}\")\n+\n+# Check what attributes are available on a bound method\n+instance = Test()\n+bound_method = method.__get__(instance, type(instance))\n+print(\"\\nBound method attributes:\")\n+for attr in ['__name__', '__module__', '__doc__', '__dict__', '__qualname__']:\n+    if hasattr(bound_method, attr):\n+        print(f\"  {attr}: {getattr(bound_method, attr)}\")\n+\n+# Check what attributes are available on a partial\n+partial_method = partial(bound_method)\n+print(\"\\nPartial object attributes:\")\n+for attr in ['__name__', '__module__', '__doc__', '__dict__', '__qualname__']:\n+    if hasattr(partial_method, attr):\n+        print(f\"  {attr}: {getattr(partial_method, attr)}\")\n+\n+print(\"\\nPartial object special attributes:\")\n+for attr in ['func', 'args', 'keywords']:\n+    if hasattr(partial_method, attr):\n+        print(f\"  {attr}: {getattr(partial_method, attr)}\")\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..05ec403950\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,77 @@\n+from functools import wraps\n+from django.utils.decorators import method_decorator\n+\n+def logger(func):\n+    @wraps(func)\n+    def inner(*args, **kwargs):\n+        try:\n+            result = func(*args, **kwargs)\n+        except Exception as e:\n+            result = str(e)\n+        finally:\n+            print(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n+        return result\n+    return inner\n+\n+def check_attributes(func):\n+    \"\"\"Decorator that checks if func has expected attributes\"\"\"\n+    @wraps(func)\n+    def inner(*args, **kwargs):\n+        print(f\"Checking attributes for {func}:\")\n+        for attr in ['__name__', '__module__', '__doc__', '__qualname__']:\n+            if hasattr(func, attr):\n+                print(f\"  {attr}: {getattr(func, attr)}\")\n+            else:\n+                print(f\"  {attr}: NOT FOUND\")\n+        return func(*args, **kwargs)\n+    return inner\n+\n+class TestClass:\n+    \"\"\"Test class for method_decorator\"\"\"\n+    \n+    @method_decorator(logger)\n+    def method1(self, x, y=10):\n+        \"\"\"Method with arguments\"\"\"\n+        return f\"method1: x={x}, y={y}\"\n+    \n+    @method_decorator(check_attributes)\n+    @method_decorator(logger)\n+    def method2(self):\n+        \"\"\"Method with multiple decorators\"\"\"\n+        return \"method2\"\n+    \n+    @method_decorator([check_attributes, logger])\n+    def method3(self):\n+        \"\"\"Method with list of decorators\"\"\"\n+        return \"method3\"\n+\n+# Test all methods\n+test = TestClass()\n+\n+print(\"Test 1: Single decorator with arguments\")\n+print(test.method1(5, y=20))\n+print()\n+\n+print(\"Test 2: Multiple decorators\")\n+print(test.method2())\n+print()\n+\n+print(\"Test 3: List of decorators\")\n+print(test.method3())\n+print()\n+\n+# Test decorator on class\n+@method_decorator(logger, name='class_method')\n+class DecoratedClass:\n+    def class_method(self):\n+        return \"decorated via class\"\n+\n+print(\"Test 4: Decorator on class\")\n+DecoratedClass().class_method()\n+\n+# Test that original method attributes are preserved\n+print(\"\\nTest 5: Check preserved attributes\")\n+print(f\"method1.__name__: {TestClass.method1.__name__}\")\n+print(f\"method1.__doc__: {TestClass.method1.__doc__}\")\n+print(f\"method2.__name__: {TestClass.method2.__name__}\")\n+print(f\"method2.__doc__: {TestClass.method2.__doc__}\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..377c578441\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,23 @@\n+from functools import wraps\n+from django.utils.decorators import method_decorator\n+\n+def logger(func):\n+    @wraps(func)\n+    def inner(*args, **kwargs):\n+        try:\n+            result = func(*args, **kwargs)\n+        except Exception as e:\n+            result = str(e)\n+        finally:\n+            print(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n+        return result\n+    return inner\n+\n+class Test:\n+    @method_decorator(logger)\n+    def hello_world(self):\n+        return \"hello\"\n+\n+# Test the issue\n+test_instance = Test()\n+test_instance.hello_world()\ndiff --git a/test_name_attribute.py b/test_name_attribute.py\nnew file mode 100644\nindex 0000000000..aba41a7c49\n--- /dev/null\n+++ b/test_name_attribute.py\n@@ -0,0 +1,30 @@\n+from functools import wraps\n+from django.utils.decorators import method_decorator\n+\n+def name_accessing_decorator(func):\n+    \"\"\"A decorator that accesses __name__ during decoration\"\"\"\n+    print(f\"Decorating function: {func.__name__}\")\n+    \n+    @wraps(func)\n+    def wrapper(*args, **kwargs):\n+        print(f\"Calling {func.__name__}\")\n+        result = func(*args, **kwargs)\n+        print(f\"Finished {func.__name__}\")\n+        return result\n+    return wrapper\n+\n+class TestClass:\n+    @method_decorator(name_accessing_decorator)\n+    def test_method(self):\n+        \"\"\"Test method with name-accessing decorator\"\"\"\n+        return \"success\"\n+\n+# This should not raise AttributeError anymore\n+print(\"Creating instance and calling method...\")\n+instance = TestClass()\n+result = instance.test_method()\n+print(f\"Result: {result}\")\n+\n+# Verify attributes are preserved\n+print(f\"\\nMethod name: {TestClass.test_method.__name__}\")\n+print(f\"Method doc: {TestClass.test_method.__doc__}\")\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000000..95605cc8f0\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,22 @@\n+from functools import wraps\n+from django.utils.decorators import method_decorator\n+\n+def logger(func):\n+    @wraps(func)\n+    def inner(*args, **kwargs):\n+        try:\n+            result = func(*args, **kwargs)\n+        except Exception as e:\n+            result = str(e)\n+        finally:\n+            print(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n+        return result\n+    return inner\n+\n+class Test:\n+    @method_decorator(logger)\n+    def hello_world(self):\n+        return \"hello\"\n+\n+# This was raising AttributeError before the fix\n+Test().hello_world()\n", "gold_standard_diff": "diff --git a/django/utils/decorators.py b/django/utils/decorators.py\nindex 5c9a5d01c76e..69aca10a4d56 100644\n--- a/django/utils/decorators.py\n+++ b/django/utils/decorators.py\n@@ -37,7 +37,7 @@ def _wrapper(self, *args, **kwargs):\n         # 'self' argument, but it's a closure over self so it can call\n         # 'func'. Also, wrap method.__get__() in a function because new\n         # attributes can't be set on bound method objects, only on functions.\n-        bound_method = partial(method.__get__(self, type(self)))\n+        bound_method = wraps(method)(partial(method.__get__(self, type(self))))\n         for dec in decorators:\n             bound_method = dec(bound_method)\n         return bound_method(*args, **kwargs)\ndiff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 46b01c18521f..e496e2c79015 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -425,6 +425,29 @@ class Test:\n                 def __module__(cls):\n                     return \"tests\"\n \n+    def test_wrapper_assignments(self):\n+        \"\"\"@method_decorator preserves wrapper assignments.\"\"\"\n+        func_name = None\n+        func_module = None\n+\n+        def decorator(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                nonlocal func_name, func_module\n+                func_name = getattr(func, '__name__', None)\n+                func_module = getattr(func, '__module__', None)\n+                return func(*args, **kwargs)\n+            return inner\n+\n+        class Test:\n+            @method_decorator(decorator)\n+            def method(self):\n+                return 'tests'\n+\n+        Test().method()\n+        self.assertEqual(func_name, 'method')\n+        self.assertIsNotNone(func_module)\n+\n \n class XFrameOptionsDecoratorsTests(TestCase):\n     \"\"\"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14787"}