{"instance_id": "django__django-13406", "score": "I", "diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex b48d0df9c0..4e642f8557 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -238,7 +238,11 @@ class QuerySet:\n     def __getstate__(self):\n         # Force the cache to be fully populated.\n         self._fetch_all()\n-        return {**self.__dict__, DJANGO_VERSION_PICKLE_KEY: django.__version__}\n+        state = {**self.__dict__, DJANGO_VERSION_PICKLE_KEY: django.__version__}\n+        # Add information about values() and annotate() calls\n+        state['_values'] = getattr(self, '_values', None)\n+        state['_annotations'] = getattr(self.query, 'annotations', {})\n+        return state\n \n     def __setstate__(self, state):\n         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)\n@@ -258,6 +262,21 @@ class QuerySet:\n                 stacklevel=2,\n             )\n         self.__dict__.update(state)\n+        \n+        # Restore values() and annotate() information\n+        if '_values' in state:\n+            self._values = state['_values']\n+        if '_annotations' in state:\n+            self.query.annotations = state['_annotations']\n+        \n+        # Update the iterable class based on the restored state\n+        if self._values is not None:\n+            if isinstance(self._values, tuple):\n+                self._iterable_class = ValuesListIterable\n+            else:\n+                self._iterable_class = ValuesIterable\n+        elif self.query.annotations:\n+            self._iterable_class = ModelIterable\n \n     def __repr__(self):\n         data = list(self[:REPR_OUTPUT_SIZE + 1])\n@@ -829,6 +848,7 @@ class QuerySet:\n         fields += tuple(expressions)\n         clone = self._values(*fields, **expressions)\n         clone._iterable_class = ValuesIterable\n+        clone._values = fields\n         return clone\n \n     def values_list(self, *fields, flat=False, named=False):\n@@ -860,6 +880,7 @@ class QuerySet:\n             else FlatValuesListIterable if flat\n             else ValuesListIterable\n         )\n+        clone._values = tuple(_fields)\n         return clone\n \n     def dates(self, field_name, kind, order='ASC'):\n@@ -1074,7 +1095,9 @@ class QuerySet:\n         with extra data or aggregations.\n         \"\"\"\n         self._not_support_combined_queries('annotate')\n-        return self._annotate(args, kwargs, select=True)\n+        clone = self._annotate(args, kwargs, select=True)\n+        clone.query.annotations = dict(self.query.annotations, **kwargs)\n+        return clone\n \n     def alias(self, *args, **kwargs):\n         \"\"\"\n@@ -1298,6 +1321,9 @@ class QuerySet:\n         c._known_related_objects = self._known_related_objects\n         c._iterable_class = self._iterable_class\n         c._fields = self._fields\n+        c._values = getattr(self, '_values', None)\n+        if hasattr(self.query, 'annotations'):\n+            c.query.annotations = self.query.annotations.copy()\n         return c\n \n     def _fetch_all(self):\n", "gold_standard_diff": "From 5362e08624c6745181944a10979da876934ea136 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Thu, 10 Sep 2020 14:34:04 +0200\nSubject: [PATCH] Fixed #31943 -- Fixed recreating\n QuerySet.values()/values_list() when using a pickled Query.\n\n---\n django/db/models/query.py      |  2 ++\n docs/ref/models/querysets.txt  | 14 ++++++++++++++\n tests/queryset_pickle/tests.py | 24 +++++++++++++++++++++++-\n 3 files changed, 39 insertions(+), 1 deletion(-)\n\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\nindex b48d0df9c000..85cd8311a7d2 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -210,6 +210,8 @@ def query(self):\n \n     @query.setter\n     def query(self, value):\n+        if value.values_select:\n+            self._iterable_class = ValuesIterable\n         self._query = value\n \n     def as_manager(cls):\ndiff --git a/docs/ref/models/querysets.txt b/docs/ref/models/querysets.txt\nindex 228e2cf73627..7f55684e0827 100644\n--- a/docs/ref/models/querysets.txt\n+++ b/docs/ref/models/querysets.txt\n@@ -106,6 +106,20 @@ the query construction and is not part of the public API. However, it is safe\n (and fully supported) to pickle and unpickle the attribute's contents as\n described here.\n \n+.. admonition:: Restrictions on ``QuerySet.values_list()``\n+\n+    If you recreate :meth:`QuerySet.values_list` using the pickled ``query``\n+    attribute, it will be converted to :meth:`QuerySet.values`::\n+\n+        >>> import pickle\n+        >>> qs = Blog.objects.values_list('id', 'name')\n+        >>> qs\n+        <QuerySet [(1, 'Beatles Blog')]>\n+        >>> reloaded_qs = Blog.objects.all()\n+        >>> reloaded_qs.query = pickle.loads(pickle.dumps(qs.query))\n+        >>> reloaded_qs\n+        <QuerySet [{'id': 1, 'name': 'Beatles Blog'}]>\n+\n .. admonition:: You can't share pickles between versions\n \n     Pickles of ``QuerySets`` are only valid for the version of Django that\ndiff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex a58e45caed40..8575c6fe8114 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -11,7 +11,7 @@\n class PickleabilityTestCase(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n-        Happening.objects.create()  # make sure the defaults are working (#20158)\n+        cls.happening = Happening.objects.create()  # make sure the defaults are working (#20158)\n \n     def assert_pickles(self, qs):\n         self.assertEqual(list(pickle.loads(pickle.dumps(qs))), list(qs))\n@@ -224,6 +224,28 @@ def test_annotation_with_callable_default(self):\n         qs = Happening.objects.annotate(latest_time=models.Max('when'))\n         self.assert_pickles(qs)\n \n+    def test_annotation_values(self):\n+        qs = Happening.objects.values('name').annotate(latest_time=models.Max('when'))\n+        reloaded = Happening.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+        self.assertEqual(\n+            reloaded.get(),\n+            {'name': 'test', 'latest_time': self.happening.when},\n+        )\n+\n+    def test_annotation_values_list(self):\n+        # values_list() is reloaded to values() when using a pickled query.\n+        tests = [\n+            Happening.objects.values_list('name'),\n+            Happening.objects.values_list('name', flat=True),\n+            Happening.objects.values_list('name', named=True),\n+        ]\n+        for qs in tests:\n+            with self.subTest(qs._iterable_class.__name__):\n+                reloaded = Happening.objects.all()\n+                reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+                self.assertEqual(reloaded.get(), {'name': 'test'})\n+\n     def test_filter_deferred(self):\n         qs = Happening.objects.all()\n         qs._defer_next_filter = True\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13406"}