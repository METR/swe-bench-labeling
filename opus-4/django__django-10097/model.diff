diff --git a/django/core/validators.py b/django/core/validators.py
index 92394a7eae..6a2788b9b0 100644
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -92,9 +92,21 @@ class URLValidator(RegexValidator):
     )
     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
 
+    # Characters allowed in userinfo (username and password) according to RFC 1738
+    # user = *[ uchar | ";" | "?" | "&" | "=" ]
+    # password = *[ uchar | ";" | "?" | "&" | "=" ]
+    # uchar = unreserved | escape
+    # unreserved = alpha | digit | safe | extra
+    # safe = "$" | "-" | "_" | "." | "+"
+    # extra = "!" | "*" | "'" | "(" | ")" | ","
+    # escape = "%" hex hex
+    # Within the user and password field, any ":", "@", or "/" must be encoded.
+    userinfo_chars = r"[a-zA-Z0-9$\-_.+!*'(),;?&=]|%[0-9a-fA-F]{2}"
+    userinfo_re = r'(?:(?:' + userinfo_chars + r')+(?::(?:' + userinfo_chars + r')*)?@)?'
+
     regex = _lazy_re_compile(
         r'^(?:[a-z0-9\.\-\+]*)://'  # scheme is validated separately
-        r'(?:\S+(?::\S*)?@)?'  # user:pass authentication
+        userinfo_re +  # user:pass authentication
         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
         r'(?::\d{2,5})?'  # port
         r'(?:[/?#][^\s]*)?'  # resource path
diff --git a/django/core/validators.py.backup b/django/core/validators.py.backup
new file mode 100644
index 0000000000..92394a7eae
--- /dev/null
+++ b/django/core/validators.py.backup
@@ -0,0 +1,538 @@
+import ipaddress
+import re
+from pathlib import Path
+from urllib.parse import urlsplit, urlunsplit
+
+from django.core.exceptions import ValidationError
+from django.utils.deconstruct import deconstructible
+from django.utils.functional import SimpleLazyObject
+from django.utils.ipv6 import is_valid_ipv6_address
+from django.utils.translation import gettext_lazy as _, ngettext_lazy
+
+# These values, if given to validate(), will trigger the self.required check.
+EMPTY_VALUES = (None, '', [], (), {})
+
+
+def _lazy_re_compile(regex, flags=0):
+    """Lazily compile a regex with flags."""
+    def _compile():
+        # Compile the regex if it was not passed pre-compiled.
+        if isinstance(regex, str):
+            return re.compile(regex, flags)
+        else:
+            assert not flags, "flags must be empty if regex is passed pre-compiled"
+            return regex
+    return SimpleLazyObject(_compile)
+
+
+@deconstructible
+class RegexValidator:
+    regex = ''
+    message = _('Enter a valid value.')
+    code = 'invalid'
+    inverse_match = False
+    flags = 0
+
+    def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):
+        if regex is not None:
+            self.regex = regex
+        if message is not None:
+            self.message = message
+        if code is not None:
+            self.code = code
+        if inverse_match is not None:
+            self.inverse_match = inverse_match
+        if flags is not None:
+            self.flags = flags
+        if self.flags and not isinstance(self.regex, str):
+            raise TypeError("If the flags are set, regex must be a regular expression string.")
+
+        self.regex = _lazy_re_compile(self.regex, self.flags)
+
+    def __call__(self, value):
+        """
+        Validate that the input contains (or does *not* contain, if
+        inverse_match is True) a match for the regular expression.
+        """
+        regex_matches = self.regex.search(str(value))
+        invalid_input = regex_matches if self.inverse_match else not regex_matches
+        if invalid_input:
+            raise ValidationError(self.message, code=self.code)
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, RegexValidator) and
+            self.regex.pattern == other.regex.pattern and
+            self.regex.flags == other.regex.flags and
+            (self.message == other.message) and
+            (self.code == other.code) and
+            (self.inverse_match == other.inverse_match)
+        )
+
+
+@deconstructible
+class URLValidator(RegexValidator):
+    ul = '\u00a1-\uffff'  # unicode letters range (must not be a raw string)
+
+    # IP patterns
+    ipv4_re = r'(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}'
+    ipv6_re = r'\[[0-9a-f:\.]+\]'  # (simple regex, validated later)
+
+    # Host patterns
+    hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'
+    # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1
+    domain_re = r'(?:\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'
+    tld_re = (
+        r'\.'                                # dot
+        r'(?!-)'                             # can't start with a dash
+        r'(?:[a-z' + ul + '-]{2,63}'         # domain label
+        r'|xn--[a-z0-9]{1,59})'              # or punycode label
+        r'(?<!-)'                            # can't end with a dash
+        r'\.?'                               # may have a trailing dot
+    )
+    host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
+
+    regex = _lazy_re_compile(
+        r'^(?:[a-z0-9\.\-\+]*)://'  # scheme is validated separately
+        r'(?:\S+(?::\S*)?@)?'  # user:pass authentication
+        r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
+        r'(?::\d{2,5})?'  # port
+        r'(?:[/?#][^\s]*)?'  # resource path
+        r'\Z', re.IGNORECASE)
+    message = _('Enter a valid URL.')
+    schemes = ['http', 'https', 'ftp', 'ftps']
+
+    def __init__(self, schemes=None, **kwargs):
+        super().__init__(**kwargs)
+        if schemes is not None:
+            self.schemes = schemes
+
+    def __call__(self, value):
+        # Check first if the scheme is valid
+        scheme = value.split('://')[0].lower()
+        if scheme not in self.schemes:
+            raise ValidationError(self.message, code=self.code)
+
+        # Then check full URL
+        try:
+            super().__call__(value)
+        except ValidationError as e:
+            # Trivial case failed. Try for possible IDN domain
+            if value:
+                try:
+                    scheme, netloc, path, query, fragment = urlsplit(value)
+                except ValueError:  # for example, "Invalid IPv6 URL"
+                    raise ValidationError(self.message, code=self.code)
+                try:
+                    netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE
+                except UnicodeError:  # invalid domain part
+                    raise e
+                url = urlunsplit((scheme, netloc, path, query, fragment))
+                super().__call__(url)
+            else:
+                raise
+        else:
+            # Now verify IPv6 in the netloc part
+            host_match = re.search(r'^\[(.+)\](?::\d{2,5})?$', urlsplit(value).netloc)
+            if host_match:
+                potential_ip = host_match.groups()[0]
+                try:
+                    validate_ipv6_address(potential_ip)
+                except ValidationError:
+                    raise ValidationError(self.message, code=self.code)
+
+        # The maximum length of a full host name is 253 characters per RFC 1034
+        # section 3.1. It's defined to be 255 bytes or less, but this includes
+        # one byte for the length of the name and one byte for the trailing dot
+        # that's used to indicate absolute names in DNS.
+        if len(urlsplit(value).netloc) > 253:
+            raise ValidationError(self.message, code=self.code)
+
+
+integer_validator = RegexValidator(
+    _lazy_re_compile(r'^-?\d+\Z'),
+    message=_('Enter a valid integer.'),
+    code='invalid',
+)
+
+
+def validate_integer(value):
+    return integer_validator(value)
+
+
+@deconstructible
+class EmailValidator:
+    message = _('Enter a valid email address.')
+    code = 'invalid'
+    user_regex = _lazy_re_compile(
+        r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
+        r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
+        re.IGNORECASE)
+    domain_regex = _lazy_re_compile(
+        # max length for domain name labels is 63 characters per RFC 1034
+        r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\Z',
+        re.IGNORECASE)
+    literal_regex = _lazy_re_compile(
+        # literal form, ipv4 or ipv6 address (SMTP 4.1.3)
+        r'\[([A-f0-9:\.]+)\]\Z',
+        re.IGNORECASE)
+    domain_whitelist = ['localhost']
+
+    def __init__(self, message=None, code=None, whitelist=None):
+        if message is not None:
+            self.message = message
+        if code is not None:
+            self.code = code
+        if whitelist is not None:
+            self.domain_whitelist = whitelist
+
+    def __call__(self, value):
+        if not value or '@' not in value:
+            raise ValidationError(self.message, code=self.code)
+
+        user_part, domain_part = value.rsplit('@', 1)
+
+        if not self.user_regex.match(user_part):
+            raise ValidationError(self.message, code=self.code)
+
+        if (domain_part not in self.domain_whitelist and
+                not self.validate_domain_part(domain_part)):
+            # Try for possible IDN domain-part
+            try:
+                domain_part = domain_part.encode('idna').decode('ascii')
+            except UnicodeError:
+                pass
+            else:
+                if self.validate_domain_part(domain_part):
+                    return
+            raise ValidationError(self.message, code=self.code)
+
+    def validate_domain_part(self, domain_part):
+        if self.domain_regex.match(domain_part):
+            return True
+
+        literal_match = self.literal_regex.match(domain_part)
+        if literal_match:
+            ip_address = literal_match.group(1)
+            try:
+                validate_ipv46_address(ip_address)
+                return True
+            except ValidationError:
+                pass
+        return False
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, EmailValidator) and
+            (self.domain_whitelist == other.domain_whitelist) and
+            (self.message == other.message) and
+            (self.code == other.code)
+        )
+
+
+validate_email = EmailValidator()
+
+slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\Z')
+validate_slug = RegexValidator(
+    slug_re,
+    # Translators: "letters" means latin letters: a-z and A-Z.
+    _("Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens."),
+    'invalid'
+)
+
+slug_unicode_re = _lazy_re_compile(r'^[-\w]+\Z')
+validate_unicode_slug = RegexValidator(
+    slug_unicode_re,
+    _("Enter a valid 'slug' consisting of Unicode letters, numbers, underscores, or hyphens."),
+    'invalid'
+)
+
+
+def validate_ipv4_address(value):
+    try:
+        ipaddress.IPv4Address(value)
+    except ValueError:
+        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')
+
+
+def validate_ipv6_address(value):
+    if not is_valid_ipv6_address(value):
+        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')
+
+
+def validate_ipv46_address(value):
+    try:
+        validate_ipv4_address(value)
+    except ValidationError:
+        try:
+            validate_ipv6_address(value)
+        except ValidationError:
+            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')
+
+
+ip_address_validator_map = {
+    'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),
+    'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),
+    'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),
+}
+
+
+def ip_address_validators(protocol, unpack_ipv4):
+    """
+    Depending on the given parameters, return the appropriate validators for
+    the GenericIPAddressField.
+    """
+    if protocol != 'both' and unpack_ipv4:
+        raise ValueError(
+            "You can only use `unpack_ipv4` if `protocol` is set to 'both'")
+    try:
+        return ip_address_validator_map[protocol.lower()]
+    except KeyError:
+        raise ValueError("The protocol '%s' is unknown. Supported: %s"
+                         % (protocol, list(ip_address_validator_map)))
+
+
+def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):
+    regexp = _lazy_re_compile(r'^%(neg)s\d+(?:%(sep)s%(neg)s\d+)*\Z' % {
+        'neg': '(-)?' if allow_negative else '',
+        'sep': re.escape(sep),
+    })
+    return RegexValidator(regexp, message=message, code=code)
+
+
+validate_comma_separated_integer_list = int_list_validator(
+    message=_('Enter only digits separated by commas.'),
+)
+
+
+@deconstructible
+class BaseValidator:
+    message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')
+    code = 'limit_value'
+
+    def __init__(self, limit_value, message=None):
+        self.limit_value = limit_value
+        if message:
+            self.message = message
+
+    def __call__(self, value):
+        cleaned = self.clean(value)
+        params = {'limit_value': self.limit_value, 'show_value': cleaned, 'value': value}
+        if self.compare(cleaned, self.limit_value):
+            raise ValidationError(self.message, code=self.code, params=params)
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, self.__class__) and
+            self.limit_value == other.limit_value and
+            self.message == other.message and
+            self.code == other.code
+        )
+
+    def compare(self, a, b):
+        return a is not b
+
+    def clean(self, x):
+        return x
+
+
+@deconstructible
+class MaxValueValidator(BaseValidator):
+    message = _('Ensure this value is less than or equal to %(limit_value)s.')
+    code = 'max_value'
+
+    def compare(self, a, b):
+        return a > b
+
+
+@deconstructible
+class MinValueValidator(BaseValidator):
+    message = _('Ensure this value is greater than or equal to %(limit_value)s.')
+    code = 'min_value'
+
+    def compare(self, a, b):
+        return a < b
+
+
+@deconstructible
+class MinLengthValidator(BaseValidator):
+    message = ngettext_lazy(
+        'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',
+        'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',
+        'limit_value')
+    code = 'min_length'
+
+    def compare(self, a, b):
+        return a < b
+
+    def clean(self, x):
+        return len(x)
+
+
+@deconstructible
+class MaxLengthValidator(BaseValidator):
+    message = ngettext_lazy(
+        'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',
+        'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',
+        'limit_value')
+    code = 'max_length'
+
+    def compare(self, a, b):
+        return a > b
+
+    def clean(self, x):
+        return len(x)
+
+
+@deconstructible
+class DecimalValidator:
+    """
+    Validate that the input does not exceed the maximum number of digits
+    expected, otherwise raise ValidationError.
+    """
+    messages = {
+        'invalid': _('Enter a number.'),
+        'max_digits': ngettext_lazy(
+            'Ensure that there are no more than %(max)s digit in total.',
+            'Ensure that there are no more than %(max)s digits in total.',
+            'max'
+        ),
+        'max_decimal_places': ngettext_lazy(
+            'Ensure that there are no more than %(max)s decimal place.',
+            'Ensure that there are no more than %(max)s decimal places.',
+            'max'
+        ),
+        'max_whole_digits': ngettext_lazy(
+            'Ensure that there are no more than %(max)s digit before the decimal point.',
+            'Ensure that there are no more than %(max)s digits before the decimal point.',
+            'max'
+        ),
+    }
+
+    def __init__(self, max_digits, decimal_places):
+        self.max_digits = max_digits
+        self.decimal_places = decimal_places
+
+    def __call__(self, value):
+        digit_tuple, exponent = value.as_tuple()[1:]
+        if exponent in {'F', 'n', 'N'}:
+            raise ValidationError(self.messages['invalid'])
+        if exponent >= 0:
+            # A positive exponent adds that many trailing zeros.
+            digits = len(digit_tuple) + exponent
+            decimals = 0
+        else:
+            # If the absolute value of the negative exponent is larger than the
+            # number of digits, then it's the same as the number of digits,
+            # because it'll consume all of the digits in digit_tuple and then
+            # add abs(exponent) - len(digit_tuple) leading zeros after the
+            # decimal point.
+            if abs(exponent) > len(digit_tuple):
+                digits = decimals = abs(exponent)
+            else:
+                digits = len(digit_tuple)
+                decimals = abs(exponent)
+        whole_digits = digits - decimals
+
+        if self.max_digits is not None and digits > self.max_digits:
+            raise ValidationError(
+                self.messages['max_digits'],
+                code='max_digits',
+                params={'max': self.max_digits},
+            )
+        if self.decimal_places is not None and decimals > self.decimal_places:
+            raise ValidationError(
+                self.messages['max_decimal_places'],
+                code='max_decimal_places',
+                params={'max': self.decimal_places},
+            )
+        if (self.max_digits is not None and self.decimal_places is not None and
+                whole_digits > (self.max_digits - self.decimal_places)):
+            raise ValidationError(
+                self.messages['max_whole_digits'],
+                code='max_whole_digits',
+                params={'max': (self.max_digits - self.decimal_places)},
+            )
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, self.__class__) and
+            self.max_digits == other.max_digits and
+            self.decimal_places == other.decimal_places
+        )
+
+
+@deconstructible
+class FileExtensionValidator:
+    message = _(
+        "File extension '%(extension)s' is not allowed. "
+        "Allowed extensions are: '%(allowed_extensions)s'."
+    )
+    code = 'invalid_extension'
+
+    def __init__(self, allowed_extensions=None, message=None, code=None):
+        if allowed_extensions is not None:
+            allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]
+        self.allowed_extensions = allowed_extensions
+        if message is not None:
+            self.message = message
+        if code is not None:
+            self.code = code
+
+    def __call__(self, value):
+        extension = Path(value.name).suffix[1:].lower()
+        if self.allowed_extensions is not None and extension not in self.allowed_extensions:
+            raise ValidationError(
+                self.message,
+                code=self.code,
+                params={
+                    'extension': extension,
+                    'allowed_extensions': ', '.join(self.allowed_extensions)
+                }
+            )
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, self.__class__) and
+            self.allowed_extensions == other.allowed_extensions and
+            self.message == other.message and
+            self.code == other.code
+        )
+
+
+def get_available_image_extensions():
+    try:
+        from PIL import Image
+    except ImportError:
+        return []
+    else:
+        Image.init()
+        return [ext.lower()[1:] for ext in Image.EXTENSION]
+
+
+def validate_image_file_extension(value):
+    return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)
+
+
+@deconstructible
+class ProhibitNullCharactersValidator:
+    """Validate that the string doesn't contain the null character."""
+    message = _('Null characters are not allowed.')
+    code = 'null_characters_not_allowed'
+
+    def __init__(self, message=None, code=None):
+        if message is not None:
+            self.message = message
+        if code is not None:
+            self.code = code
+
+    def __call__(self, value):
+        if '\x00' in str(value):
+            raise ValidationError(self.message, code=self.code)
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, self.__class__) and
+            self.message == other.message and
+            self.code == other.code
+        )
diff --git a/test_rfc1738.py b/test_rfc1738.py
new file mode 100644
index 0000000000..59b21beb15
--- /dev/null
+++ b/test_rfc1738.py
@@ -0,0 +1,50 @@
+# According to RFC 1738:
+# user = *[ uchar | ";" | "?" | "&" | "=" ]
+# password = *[ uchar | ";" | "?" | "&" | "=" ]
+# uchar = unreserved | escape
+# unreserved = alpha | digit | safe | extra
+# alpha = lowalpha | hialpha
+# digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
+# safe = "$" | "-" | "_" | "." | "+"
+# extra = "!" | "*" | "'" | "(" | ")" | ","
+
+# Characters that MUST be encoded: ":", "@", "/"
+# These are not allowed in userinfo without encoding
+
+import re
+
+# Build the allowed character set for username and password
+unreserved = r'[a-zA-Z0-9$\-_.+!*\'(),]'
+allowed_in_userinfo = unreserved + r'|[;?&=]|%[0-9a-fA-F]{2}'  # includes escaped chars
+
+# The pattern should be:
+# - username: one or more allowed chars
+# - optional: ":" followed by password (zero or more allowed chars)
+# - required: "@"
+
+userinfo_pattern = r'(?:(?:' + allowed_in_userinfo + r')+(?::(?:' + allowed_in_userinfo + r')*)?@)?'
+
+print("Proposed userinfo pattern:")
+print(userinfo_pattern)
+
+# Test it
+test_cases = [
+    ('user:pass@', True),
+    ('user@', True),
+    ('user:@', True),
+    (':pass@', True),
+    ('user%40name:pass@', True),  # @ encoded as %40
+    ('user:pass%2Fword@', True),  # / encoded as %2F
+    ('user/name:pass@', False),   # / not encoded
+    ('user@name:pass@', False),   # @ not encoded in username
+    ('user:pass:word@', False),   # : not encoded in password
+    ('user:pass/word@', False),   # / not encoded in password
+]
+
+pattern = re.compile('^' + userinfo_pattern + '$')
+print("\nTesting pattern:")
+for test, expected in test_cases:
+    match = pattern.match(test)
+    result = bool(match)
+    status = "PASS" if result == expected else "FAIL"
+    print("%s: '%s' -> %s (expected %s)" % (status, test, result, expected))
diff --git a/test_rfc1738_v2.py b/test_rfc1738_v2.py
new file mode 100644
index 0000000000..5bd17dd5c8
--- /dev/null
+++ b/test_rfc1738_v2.py
@@ -0,0 +1,63 @@
+import re
+
+# Build the allowed character set for username and password
+unreserved = r'[a-zA-Z0-9$\-_.+!*\'(),]'
+allowed_in_userinfo = unreserved + r'|[;?&=]|%[0-9a-fA-F]{2}'  # includes escaped chars
+
+# The pattern should be:
+# - optional username: zero or more allowed chars
+# - optional: ":" followed by password (zero or more allowed chars)
+# - required: "@"
+# Note: At least username OR password must be present
+
+userinfo_pattern = r'(?:(?:' + allowed_in_userinfo + r')*(?::(?:' + allowed_in_userinfo + r')*)?@)'
+
+print("Proposed userinfo pattern:")
+print(userinfo_pattern)
+
+# Test it
+test_cases = [
+    ('user:pass@', True),
+    ('user@', True),
+    ('user:@', True),
+    (':pass@', True),
+    ('@', True),  # Edge case - empty userinfo
+    ('user%40name:pass@', True),  # @ encoded as %40
+    ('user:pass%2Fword@', True),  # / encoded as %2F
+    ('user/name:pass@', False),   # / not encoded
+    ('user@name:pass@', False),   # @ not encoded in username
+    ('user:pass:word@', False),   # : not encoded in password
+    ('user:pass/word@', False),   # / not encoded in password
+]
+
+pattern = re.compile('^' + userinfo_pattern + '$')
+print("\nTesting pattern:")
+for test, expected in test_cases:
+    match = pattern.match(test)
+    result = bool(match)
+    status = "PASS" if result == expected else "FAIL"
+    print("%s: '%s' -> %s (expected %s)" % (status, test, result, expected))
+    
+# Now test with full URLs
+print("\n\nTesting with full URLs:")
+full_urls = [
+    ('http://user:pass@example.com', True),
+    ('http://user@example.com', True),
+    ('http://foo/bar@example.com', False),
+    ('http://user@pass@example.com', False),
+    ('http://user:pass:word@example.com', False),
+    ('http://user:pass/word@example.com', False),
+    ('http://user%3Apass@example.com', True),
+    ('http://user%40pass@example.com', True),
+    ('http://user:pass%2Fword@example.com', True),
+]
+
+# Build full URL pattern (simplified)
+url_pattern = r'^(?:[a-z0-9\.\-\+]*)://' + r'(?:' + userinfo_pattern + r')?' + r'([^/?#]+)(?:[/?#].*)?$'
+url_re = re.compile(url_pattern, re.IGNORECASE)
+
+for url, expected in full_urls:
+    match = url_re.match(url)
+    result = bool(match)
+    status = "PASS" if result == expected else "FAIL"
+    print("%s: '%s' -> %s (expected %s)" % (status, url, result, expected))
diff --git a/test_url_comprehensive.py b/test_url_comprehensive.py
new file mode 100644
index 0000000000..02e0037b92
--- /dev/null
+++ b/test_url_comprehensive.py
@@ -0,0 +1,87 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.core.validators import URLValidator
+from django.core.exceptions import ValidationError
+
+# Test cases
+test_cases = [
+    # (URL, should_be_valid, description)
+    ('http://foo/bar@example.com', True, 'Path with @ - Currently parsed as host=foo, path=/bar@example.com'),
+    ('http://foo:bar@example.com', True, 'Valid userinfo'),
+    ('http://user:pass/word@example.com', False, '/ in password must be encoded'),
+    ('http://user@pass@example.com', False, '@ in username must be encoded'),
+    ('http://user:pass:word@example.com', False, ': in password must be encoded'),
+    ('http://user:pass@example.com', True, 'Valid userinfo'),
+    ('http://user%3Apass@example.com', True, ': encoded as %3A in username'),
+    ('http://user%40pass@example.com', True, '@ encoded as %40 in username'),
+    ('http://user:pass%2Fword@example.com', True, '/ encoded as %2F in password'),
+    ('http://user:p%40ss@example.com', True, '@ encoded as %40 in password'),
+    ('http://user:p%3Ass@example.com', True, ': encoded as %3A in password'),
+    # Edge cases
+    ('http://:pass@example.com', True, 'Empty username'),
+    ('http://user:@example.com', True, 'Empty password'),
+    ('http://@example.com', True, 'Empty userinfo with @'),
+    # Query string edge case mentioned in issue
+    ('http://example.com?m=foo@example.com', True, '@ in query string is valid'),
+    ('http://example.com?m=foo/bar@example.com', True, '@ and / in query string are valid'),
+]
+
+validator = URLValidator()
+
+print("Testing URLs with URLValidator:")
+print("-" * 80)
+print("%-50s %-10s %-10s %s" % ("URL", "Expected", "Actual", "Status"))
+print("-" * 80)
+
+passed = 0
+failed = 0
+
+for url, expected, desc in test_cases:
+    try:
+        validator(url)
+        actual = True
+    except ValidationError:
+        actual = False
+    
+    status = "PASS" if actual == expected else "FAIL"
+    if status == "PASS":
+        passed += 1
+    else:
+        failed += 1
+        
+    print("%-50s %-10s %-10s %s" % (url[:50], expected, actual, status))
+    if status == "FAIL":
+        print("  Description: %s" % desc)
+
+print("-" * 80)
+print("Passed: %d, Failed: %d" % (passed, failed))
+
+# Let's also check what the regex actually captures
+print("\n\nRegex analysis:")
+print("-" * 80)
+import re
+print("Current userinfo pattern in URLValidator:")
+print(validator.regex.pattern)
diff --git a/test_url_issue.py b/test_url_issue.py
new file mode 100644
index 0000000000..51e61f9802
--- /dev/null
+++ b/test_url_issue.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.core.validators import URLValidator
+from django.core.exceptions import ValidationError
+
+# Test cases mentioned in the issue
+test_urls = [
+    # Should be invalid according to RFC 1738
+    'http://foo/bar@example.com',
+    'http://foo:bar@example.com',  # This is currently valid but should check if : in password is encoded
+    'http://user:pass/word@example.com',  # / in password should be encoded
+    'http://user@pass@example.com',  # @ in username should be encoded
+    'http://user:pass:word@example.com',  # : in password should be encoded
+    
+    # Valid cases (for comparison)
+    'http://user:pass@example.com',
+    'http://user%3Apass@example.com',  # : encoded as %3A
+    'http://user%40pass@example.com',  # @ encoded as %40
+    'http://user:pass%2Fword@example.com',  # / encoded as %2F
+]
+
+validator = URLValidator()
+
+print("Testing URLs with URLValidator:")
+print("-" * 60)
+for url in test_urls:
+    try:
+        validator(url)
+        print("VALID: %s" % url)
+    except ValidationError:
+        print("INVALID: %s" % url)
+        
+print("\n" + "-" * 60)
+print("\nTesting regex pattern directly:")
+print("-" * 60)
+
+import re
+# Let's extract and test the user:pass pattern specifically
+user_pass_pattern = r'(?:\S+(?::\S*)?@)?'
+for url in test_urls:
+    # Extract the part between scheme and host
+    match = re.match(r'^(https?://)([^/]+)', url)
+    if match:
+        scheme = match.group(1)
+        rest = match.group(2)
+        if '@' in rest:
+            userinfo_host = rest.split('@')
+            userinfo = userinfo_host[0]
+            print("URL: %s" % url)
+            print("  User info: %s" % userinfo)
+            print("  Contains invalid chars: "),
+            invalid_chars = []
+            if ':' in userinfo and userinfo.count(':') > 1:
+                invalid_chars.append(': (multiple colons)')
+            if '/' in userinfo:
+                invalid_chars.append('/')
+            if '@' in userinfo:
+                invalid_chars.append('@')
+            if invalid_chars:
+                print(", ".join(invalid_chars))
+            else:
+                print("None")
+        print("")
diff --git a/test_url_parsing.py b/test_url_parsing.py
new file mode 100644
index 0000000000..c68daaa528
--- /dev/null
+++ b/test_url_parsing.py
@@ -0,0 +1,20 @@
+from urllib.parse import urlsplit
+
+test_urls = [
+    'http://foo/bar@example.com',
+    'http://user@pass@example.com',
+    'http://user:pass:word@example.com',
+    'http://user:pass/word@example.com',
+]
+
+print("URL parsing analysis:")
+print("-" * 60)
+for url in test_urls:
+    parts = urlsplit(url)
+    print("\nURL: %s" % url)
+    print("  scheme: %s" % parts.scheme)
+    print("  netloc: %s" % parts.netloc)
+    print("  path: %s" % parts.path)
+    print("  username: %s" % parts.username)
+    print("  password: %s" % parts.password)
+    print("  hostname: %s" % parts.hostname)
diff --git a/url_validator.patch b/url_validator.patch
new file mode 100644
index 0000000000..be382106d0
--- /dev/null
+++ b/url_validator.patch
@@ -0,0 +1,24 @@
+--- django/core/validators.py.orig	2024-01-01 00:00:00.000000000 +0000
++++ django/core/validators.py	2024-01-01 00:00:00.000000000 +0000
+@@ -92,9 +92,19 @@
+     )
+     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'
+ 
++    # Characters allowed in userinfo (username and password) according to RFC 1738
++    # user = *[ uchar | ";" | "?" | "&" | "=" ]
++    # password = *[ uchar | ";" | "?" | "&" | "=" ]
++    # uchar = unreserved | escape
++    # unreserved = alpha | digit | safe | extra
++    # safe = "$" | "-" | "_" | "." | "+"
++    # extra = "!" | "*" | "'" | "(" | ")" | ","
++    # escape = "%" hex hex
++    # Within the user and password field, any ":", "@", or "/" must be encoded.
++    userinfo_chars = r"[a-zA-Z0-9$\-_.+!*'(),;?&=]|%[0-9a-fA-F]{2}"
++    userinfo_re = r'(?:(?:' + userinfo_chars + r')+(?::(?:' + userinfo_chars + r')*)?@)?'
++
+     regex = _lazy_re_compile(
+         r'^(?:[a-z0-9\.\-\+]*)://'  # scheme is validated separately
+-        r'(?:\S+(?::\S*)?@)?'  # user:pass authentication
++        userinfo_re +  # user:pass authentication
+         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'
+         r'(?::\d{2,5})?'  # port
