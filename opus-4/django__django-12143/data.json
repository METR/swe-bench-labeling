{"instance_id": "django__django-12143", "score": "C", "diff": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f..effc5e9296 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,7 @@ class ModelAdmin(BaseModelAdmin):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(self.model._meta.pk.name)))\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\ndiff --git a/test_pk_name_escape.py b/test_pk_name_escape.py\nnew file mode 100644\nindex 0000000000..97274f317b\n--- /dev/null\n+++ b/test_pk_name_escape.py\n@@ -0,0 +1,35 @@\n+\"\"\"\n+Test to ensure pk names with special characters are also escaped.\n+\"\"\"\n+import re\n+\n+# Test the fixed implementation\n+def test_pk_name_escape():\n+    # Although pk names generally follow Python identifier rules,\n+    # let's test that we're escaping them too\n+    test_cases = [\n+        (\"form\", \"id\"),           # Normal case\n+        (\"form[0]\", \"id\"),        # Prefix with special chars\n+        (\"form\", \"id$test\"),      # PK name with special char (hypothetical)\n+        (\"form.*\", \"id+test\"),    # Both with special chars\n+    ]\n+    \n+    for prefix, pk_name in test_cases:\n+        print(f\"\\nTesting prefix='{prefix}', pk_name='{pk_name}'\")\n+        try:\n+            # Fixed implementation\n+            pattern = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(pk_name)))\n+            print(f\"Pattern: {pattern.pattern}\")\n+            \n+            # Test key that should match\n+            test_key = f\"{prefix}-1-{pk_name}\"\n+            if pattern.match(test_key):\n+                print(f\"SUCCESS: '{test_key}' matches correctly\")\n+            else:\n+                print(f\"FAIL: '{test_key}' does not match\")\n+                \n+        except re.error as e:\n+            print(f\"Error: {e}\")\n+\n+if __name__ == \"__main__\":\n+    test_pk_name_escape()\ndiff --git a/test_regex_escape.py b/test_regex_escape.py\nnew file mode 100644\nindex 0000000000..62ec0fb948\n--- /dev/null\n+++ b/test_regex_escape.py\n@@ -0,0 +1,41 @@\n+import re\n+\n+# Test case to demonstrate the issue\n+def test_regex_special_chars():\n+    # Test various problematic prefixes\n+    test_cases = [\n+        (\"form[0]\", \"form[0]-1-id\"),      # Contains [ and ]\n+        (\"form(+)\", \"form(+)-1-id\"),      # Contains ( and ) and +\n+        (\"form.*\", \"form.*-1-id\"),        # Contains . and *\n+        (\"form$end\", \"form$end-1-id\"),    # Contains $\n+        (\"form\\\\test\", \"form\\\\test-1-id\") # Contains \\\n+    ]\n+    \n+    for prefix, test_key in test_cases:\n+        print(f\"\\nTesting prefix: '{prefix}'\")\n+        pk_name = \"id\"\n+        \n+        # Current implementation (problematic)\n+        try:\n+            pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, pk_name))\n+            print(f\"Pattern without escaping: {pk_pattern.pattern}\")\n+            # Test if it matches\n+            if pk_pattern.match(test_key):\n+                print(f\"Without escaping: '{test_key}' matches (might be wrong!)\")\n+            else:\n+                print(f\"Without escaping: '{test_key}' does not match\")\n+        except re.error as e:\n+            print(f\"Error without escaping: {e}\")\n+        \n+        # Fixed implementation\n+        pk_pattern_fixed = re.compile(r'{}-\\d+-{}$'.format(re.escape(prefix), re.escape(pk_name)))\n+        print(f\"Pattern with escaping: {pk_pattern_fixed.pattern}\")\n+        \n+        # The fixed pattern should match correctly\n+        if pk_pattern_fixed.match(test_key):\n+            print(f\"With escaping: '{test_key}' matches correctly\")\n+        else:\n+            print(f\"With escaping: '{test_key}' does not match\")\n+\n+if __name__ == \"__main__\":\n+    test_regex_special_chars()\ndiff --git a/test_regex_escape_fix.py b/test_regex_escape_fix.py\nnew file mode 100644\nindex 0000000000..cdd0d73d96\n--- /dev/null\n+++ b/test_regex_escape_fix.py\n@@ -0,0 +1,92 @@\n+\"\"\"\n+Test for the regex escape fix in admin options.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.test import TestCase, RequestFactory\n+from django.contrib.admin.options import ModelAdmin\n+from django.db import models\n+from django.contrib.admin.sites import AdminSite\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+sys.path.insert(0, '/testbed')\n+\n+# Configure Django\n+from django.conf import settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+# Define a simple model for testing\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class TestModelAdmin(ModelAdmin):\n+    list_display = ('name',)\n+    list_editable = ('name',)\n+\n+\n+class RegexEscapeTest(TestCase):\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.site = AdminSite()\n+        self.model_admin = TestModelAdmin(TestModel, self.site)\n+        \n+    def test_get_edited_object_pks_with_special_chars(self):\n+        \"\"\"Test that prefixes with regex special characters are properly escaped.\"\"\"\n+        # Test various problematic prefixes\n+        test_cases = [\n+            (\"form[0]\", [\"123\", \"456\"]),      # Contains [ and ]\n+            (\"form(+)\", [\"789\", \"012\"]),      # Contains ( and ) and +\n+            (\"form.*\", [\"345\", \"678\"]),       # Contains . and *\n+            (\"form$end\", [\"901\", \"234\"]),     # Contains $\n+            (\"form\\\\test\", [\"567\", \"890\"])    # Contains \\\n+        ]\n+        \n+        for prefix, expected_pks in test_cases:\n+            with self.subTest(prefix=prefix):\n+                # Create POST data with the given prefix\n+                data = {}\n+                for i, pk in enumerate(expected_pks):\n+                    data[f'{prefix}-{i}-id'] = pk\n+                    data[f'{prefix}-{i}-name'] = f'Test {i}'\n+                \n+                # Add some data that shouldn't match\n+                data['other-0-id'] = '999'\n+                data[f'{prefix}_wrong-0-id'] = '888'\n+                \n+                request = self.factory.post('/', data=data)\n+                \n+                # This should not raise any regex errors\n+                try:\n+                    pks = self.model_admin._get_edited_object_pks(request, prefix)\n+                    self.assertEqual(sorted(pks), sorted(expected_pks))\n+                except Exception as e:\n+                    self.fail(f\"Failed with prefix '{prefix}': {e}\")\n+\n+\n+if __name__ == '__main__':\n+    # Run the test\n+    import unittest\n+    unittest.main()\n", "gold_standard_diff": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 137e6faa0f37..85896bed7e23 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1631,7 +1631,9 @@ def change_view(self, request, object_id, form_url='', extra_context=None):\n \n     def _get_edited_object_pks(self, request, prefix):\n         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n-        pk_pattern = re.compile(r'{}-\\d+-{}$'.format(prefix, self.model._meta.pk.name))\n+        pk_pattern = re.compile(\n+            r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)\n+        )\n         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n \n     def _get_list_editable_queryset(self, request, prefix):\ndiff --git a/docs/releases/2.2.8.txt b/docs/releases/2.2.8.txt\nindex 0c2b3eabdf39..e9bd1ed1cb68 100644\n--- a/docs/releases/2.2.8.txt\n+++ b/docs/releases/2.2.8.txt\n@@ -10,4 +10,6 @@ Django 2.2.8 fixes several bugs in 2.2.7 and adds compatibility with Python\n Bugfixes\n ========\n \n-* ...\n+* Fixed a data loss possibility in the admin changelist view when a custom\n+  :ref:`formset's prefix <formset-prefix>` contains regular expression special\n+  characters, e.g. `'$'` (:ticket:`31031`).\ndiff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 05490b061a68..8cb6f7eff9cc 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -844,6 +844,26 @@ def test_get_list_editable_queryset(self):\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n         self.assertEqual(queryset.count(), 2)\n \n+    def test_get_list_editable_queryset_with_regex_chars_in_prefix(self):\n+        a = Swallow.objects.create(origin='Swallow A', load=4, speed=1)\n+        Swallow.objects.create(origin='Swallow B', load=2, speed=2)\n+        data = {\n+            'form$-TOTAL_FORMS': '2',\n+            'form$-INITIAL_FORMS': '2',\n+            'form$-MIN_NUM_FORMS': '0',\n+            'form$-MAX_NUM_FORMS': '1000',\n+            'form$-0-uuid': str(a.pk),\n+            'form$-0-load': '10',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix='form$')\n+        self.assertEqual(queryset.count(), 1)\n+\n     def test_changelist_view_list_editable_changed_objects_uses_filter(self):\n         \"\"\"list_editable edits use a filtered queryset to limit memory usage.\"\"\"\n         a = Swallow.objects.create(origin='Swallow A', load=4, speed=1)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12143"}