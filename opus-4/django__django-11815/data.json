{"instance_id": "django__django-11815", "score": "C", "diff": "diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379..4275f91a7f 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,8 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        imports = {'import %s' % module}\n+        return \"%s.%s[%r]\" % (module, enum_class.__name__, self.value.name), imports\n \n \n class FloatSerializer(BaseSimpleSerializer):\ndiff --git a/test_enum_comprehensive.py b/test_enum_comprehensive.py\nnew file mode 100644\nindex 0000000000..bbcc250440\n--- /dev/null\n+++ b/test_enum_comprehensive.py\n@@ -0,0 +1,92 @@\n+#!/usr/bin/env python\n+\"\"\"Comprehensive test for Enum migration serialization.\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+from enum import Enum, IntEnum\n+from django.utils.translation import gettext_lazy as _\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Test different Enum types\n+class Status(Enum):\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    \n+    def __str__(self):\n+        return self.name\n+\n+class Priority(IntEnum):\n+    LOW = 1\n+    MEDIUM = 2\n+    HIGH = 3\n+\n+class Color(Enum):\n+    RED = 'red'\n+    GREEN = 'green'\n+    BLUE = 'blue'\n+\n+# Test the serialization\n+from django.db.migrations.serializer import serializer_factory\n+\n+print(\"Testing different Enum types:\")\n+print(\"-\" * 50)\n+\n+# Test 1: Enum with translated values\n+serializer = serializer_factory(Status.GOOD)\n+result, imports = serializer.serialize()\n+print(f\"Status.GOOD: {result}\")\n+assert result == \"__main__.Status['GOOD']\", f\"Expected __main__.Status['GOOD'], got {result}\"\n+\n+# Test 2: IntEnum\n+serializer = serializer_factory(Priority.HIGH)\n+result, imports = serializer.serialize()\n+print(f\"Priority.HIGH: {result}\")\n+assert result == \"__main__.Priority['HIGH']\", f\"Expected __main__.Priority['HIGH'], got {result}\"\n+\n+# Test 3: Enum with string values\n+serializer = serializer_factory(Color.RED)\n+result, imports = serializer.serialize()\n+print(f\"Color.RED: {result}\")\n+assert result == \"__main__.Color['RED']\", f\"Expected __main__.Color['RED'], got {result}\"\n+\n+print(\"\\nAll tests passed!\")\n+\n+# Test that the serialized form can be evaluated\n+print(\"\\nTesting deserialization:\")\n+print(\"-\" * 50)\n+\n+# Test evaluation of serialized forms\n+test_cases = [\n+    (Status.GOOD, \"__main__.Status['GOOD']\"),\n+    (Priority.HIGH, \"__main__.Priority['HIGH']\"),\n+    (Color.RED, \"__main__.Color['RED']\"),\n+]\n+\n+for original, serialized in test_cases:\n+    # Remove module prefix for evaluation\n+    eval_str = serialized.replace(\"__main__.\", \"\")\n+    result = eval(eval_str)\n+    print(f\"{serialized} -> {result}\")\n+    assert result == original, f\"Deserialization failed: {result} != {original}\"\n+\n+print(\"\\nAll deserialization tests passed!\")\ndiff --git a/test_enum_migration.py b/test_enum_migration.py\nnew file mode 100644\nindex 0000000000..d34675ebb6\n--- /dev/null\n+++ b/test_enum_migration.py\n@@ -0,0 +1,58 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to reproduce the Enum migration issue.\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+from enum import Enum\n+from django.utils.translation import gettext_lazy as _\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Define the Enum and Model as in the issue\n+class Status(Enum):\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    \n+    def __str__(self):\n+        return self.name\n+\n+class Item(models.Model):\n+    status = models.CharField(default=Status.GOOD, max_length=128)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the serialization\n+from django.db.migrations.serializer import serializer_factory\n+\n+# Serialize the default value\n+serializer = serializer_factory(Status.GOOD)\n+result, imports = serializer.serialize()\n+print(\"Current serialization:\")\n+print(f\"Result: {result}\")\n+print(f\"Imports: {imports}\")\n+print()\n+\n+# What we expect\n+print(\"Expected serialization:\")\n+print(f\"Result: __main__.Status['GOOD']\")\n+print(f\"Imports: {{'import __main__'}}\")\ndiff --git a/test_enum_translation.py b/test_enum_translation.py\nnew file mode 100644\nindex 0000000000..7124f049e1\n--- /dev/null\n+++ b/test_enum_translation.py\n@@ -0,0 +1,72 @@\n+#!/usr/bin/env python\n+\"\"\"Test Enum migration serialization with translations.\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+from enum import Enum\n+from django.utils.translation import gettext_lazy as _, activate\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+    USE_I18N=True,\n+    LANGUAGE_CODE='en',\n+)\n+\n+django.setup()\n+\n+# Define the Enum with translated values as in the issue\n+class Status(Enum):\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    \n+    def __str__(self):\n+        return self.name\n+\n+# Test the serialization\n+from django.db.migrations.serializer import serializer_factory\n+\n+print(\"Testing Enum with lazy translations:\")\n+print(\"-\" * 50)\n+\n+# Serialize the enum value\n+serializer = serializer_factory(Status.GOOD)\n+result, imports = serializer.serialize()\n+print(f\"Serialized: {result}\")\n+\n+# Try to evaluate the serialized string to recreate the enum\n+# This simulates what happens when migrations are run\n+try:\n+    # First, let's test with the current language\n+    print(\"\\nWith original language (en):\")\n+    eval_str = result.replace(\"__main__.\", \"\")\n+    recreated = eval(eval_str)\n+    print(f\"Recreated successfully: {recreated}\")\n+    print(f\"Are they equal? {recreated == Status.GOOD}\")\n+    \n+    # Now let's simulate what happens when the language changes\n+    # (This would normally happen if migrations are run with a different language setting)\n+    print(\"\\nSimulating language change...\")\n+    # We can't actually change the translation, but we can show that\n+    # using the name-based approach works regardless of the value\n+    \n+except Exception as e:\n+    print(f\"Error recreating enum: {e}\")\n+\n+print(\"\\nChecking that name-based access always works:\")\n+print(f\"Status['GOOD'] == Status.GOOD: {Status['GOOD'] == Status.GOOD}\")\n+print(f\"Status['BAD'] == Status.BAD: {Status['BAD'] == Status.BAD}\")\ndiff --git a/test_enum_translation_regression.py b/test_enum_translation_regression.py\nnew file mode 100644\nindex 0000000000..70953cb2de\n--- /dev/null\n+++ b/test_enum_translation_regression.py\n@@ -0,0 +1,74 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Test case to ensure the enum translation issue is fixed.\n+This test simulates the exact scenario described in the issue.\n+\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+from enum import Enum\n+from django.utils.translation import gettext_lazy as _\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'test_app',\n+    ],\n+    USE_I18N=True,\n+    LANGUAGE_CODE='en',\n+)\n+\n+django.setup()\n+\n+# Define the exact same model from the issue\n+class Status(Enum):\n+    GOOD = _('Good')\n+    BAD = _('Bad')\n+    \n+    def __str__(self):\n+        return self.name\n+\n+class Item(models.Model):\n+    status = models.CharField(default=Status.GOOD, max_length=128)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the migration writer\n+from django.db.migrations.writer import MigrationWriter\n+\n+field = models.CharField(default=Status.GOOD, max_length=128)\n+serialized, imports = MigrationWriter.serialize(field)\n+\n+print(\"Migration field serialization:\")\n+print(f\"Serialized: {serialized}\")\n+print()\n+\n+# The key test: ensure we can recreate the Status enum from the serialized form\n+# even if 'Good' is not a valid value (simulating translation change)\n+print(\"Testing that serialized form uses enum name, not value:\")\n+\n+# Extract the default value part from serialized string\n+import re\n+match = re.search(r\"default=([^,)]+)\", serialized)\n+if match:\n+    default_part = match.group(1)\n+    print(f\"Default value in migration: {default_part}\")\n+    \n+    # Check that it uses the name-based access\n+    assert \"Status['GOOD']\" in default_part, f\"Expected Status['GOOD'] but got {default_part}\"\n+    print(\"\u2713 Correctly uses name-based access (Status['GOOD'])\")\n+else:\n+    print(\"\u2717 Could not extract default value from serialized string\")\n+\n+print(\"\\nTest passed! The migration will work even if translations change.\")\ndiff --git a/test_promise_handling.py b/test_promise_handling.py\nnew file mode 100644\nindex 0000000000..7a4221b384\n--- /dev/null\n+++ b/test_promise_handling.py\n@@ -0,0 +1,39 @@\n+#!/usr/bin/env python\n+\"\"\"Test how Promise objects are handled in serialization.\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.utils.translation import gettext_lazy as _\n+from django.utils.functional import Promise\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_I18N=True,\n+    LANGUAGE_CODE='en',\n+)\n+\n+django.setup()\n+\n+# Test Promise handling\n+lazy_string = _('Good')\n+print(f\"Type of lazy string: {type(lazy_string)}\")\n+print(f\"Is it a Promise? {isinstance(lazy_string, Promise)}\")\n+print(f\"String value: {str(lazy_string)}\")\n+\n+# Direct serialization of Promise\n+from django.db.migrations.serializer import serializer_factory\n+\n+serializer = serializer_factory(lazy_string)\n+result, imports = serializer.serialize()\n+print(f\"\\nDirect serialization of Promise:\")\n+print(f\"Result: {result}\")\n+print(f\"Imports: {imports}\")\ndiff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f97d76e9ad..39c9ab47b9 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -267,15 +267,15 @@ class WriterTests(SimpleTestCase):\n \n         self.assertSerializedResultEqual(\n             TextEnum.A,\n-            (\"migrations.test_writer.TextEnum('a-value')\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.TextEnum['A']\", {'import migrations.test_writer'})\n         )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n-            (\"migrations.test_writer.BinaryEnum(b'a-value')\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.BinaryEnum['A']\", {'import migrations.test_writer'})\n         )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n-            (\"migrations.test_writer.IntEnum(2)\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.IntEnum['B']\", {'import migrations.test_writer'})\n         )\n \n         field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])\n@@ -283,27 +283,27 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string,\n             \"models.CharField(choices=[\"\n-            \"('a-value', migrations.test_writer.TextEnum('a-value')), \"\n-            \"('value-b', migrations.test_writer.TextEnum('value-b'))], \"\n-            \"default=migrations.test_writer.TextEnum('value-b'))\"\n+            \"('a-value', migrations.test_writer.TextEnum['A']), \"\n+            \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n+            \"default=migrations.test_writer.TextEnum['B'])\"\n         )\n         field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.CharField(choices=[\"\n-            \"(b'a-value', migrations.test_writer.BinaryEnum(b'a-value')), \"\n-            \"(b'value-b', migrations.test_writer.BinaryEnum(b'value-b'))], \"\n-            \"default=migrations.test_writer.BinaryEnum(b'value-b'))\"\n+            \"(b'a-value', migrations.test_writer.BinaryEnum['A']), \"\n+            \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n+            \"default=migrations.test_writer.BinaryEnum['B'])\"\n         )\n         field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[\"\n-            \"(1, migrations.test_writer.IntEnum(1)), \"\n-            \"(2, migrations.test_writer.IntEnum(2))], \"\n-            \"default=migrations.test_writer.IntEnum(1))\"\n+            \"(1, migrations.test_writer.IntEnum['A']), \"\n+            \"(2, migrations.test_writer.IntEnum['B'])], \"\n+            \"default=migrations.test_writer.IntEnum['A'])\"\n         )\n \n     def test_serialize_choices(self):\ndiff --git a/tests/migrations/test_writer.py.bak b/tests/migrations/test_writer.py.bak\nnew file mode 100644\nindex 0000000000..f97d76e9ad\n--- /dev/null\n+++ b/tests/migrations/test_writer.py.bak\n@@ -0,0 +1,714 @@\n+import datetime\n+import decimal\n+import enum\n+import functools\n+import math\n+import os\n+import re\n+import uuid\n+from unittest import mock\n+\n+import custom_migration_operations.more_operations\n+import custom_migration_operations.operations\n+\n+from django import get_version\n+from django.conf import SettingsReference, settings\n+from django.core.validators import EmailValidator, RegexValidator\n+from django.db import migrations, models\n+from django.db.migrations.serializer import BaseSerializer\n+from django.db.migrations.writer import MigrationWriter, OperationWriter\n+from django.test import SimpleTestCase\n+from django.utils.deconstruct import deconstructible\n+from django.utils.functional import SimpleLazyObject\n+from django.utils.timezone import get_default_timezone, get_fixed_timezone, utc\n+from django.utils.translation import gettext_lazy as _\n+\n+from .models import FoodManager, FoodQuerySet\n+\n+\n+class Money(decimal.Decimal):\n+    def deconstruct(self):\n+        return (\n+            '%s.%s' % (self.__class__.__module__, self.__class__.__name__),\n+            [str(self)],\n+            {}\n+        )\n+\n+\n+class TestModel1:\n+    def upload_to(self):\n+        return '/somewhere/dynamic/'\n+    thing = models.FileField(upload_to=upload_to)\n+\n+\n+class OperationWriterTests(SimpleTestCase):\n+\n+    def test_empty_signature(self):\n+        operation = custom_migration_operations.operations.TestOperation()\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.TestOperation(\\n'\n+            '),'\n+        )\n+\n+    def test_args_signature(self):\n+        operation = custom_migration_operations.operations.ArgsOperation(1, 2)\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.ArgsOperation(\\n'\n+            '    arg1=1,\\n'\n+            '    arg2=2,\\n'\n+            '),'\n+        )\n+\n+    def test_kwargs_signature(self):\n+        operation = custom_migration_operations.operations.KwargsOperation(kwarg1=1)\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.KwargsOperation(\\n'\n+            '    kwarg1=1,\\n'\n+            '),'\n+        )\n+\n+    def test_args_kwargs_signature(self):\n+        operation = custom_migration_operations.operations.ArgsKwargsOperation(1, 2, kwarg2=4)\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.ArgsKwargsOperation(\\n'\n+            '    arg1=1,\\n'\n+            '    arg2=2,\\n'\n+            '    kwarg2=4,\\n'\n+            '),'\n+        )\n+\n+    def test_nested_args_signature(self):\n+        operation = custom_migration_operations.operations.ArgsOperation(\n+            custom_migration_operations.operations.ArgsOperation(1, 2),\n+            custom_migration_operations.operations.KwargsOperation(kwarg1=3, kwarg2=4)\n+        )\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.ArgsOperation(\\n'\n+            '    arg1=custom_migration_operations.operations.ArgsOperation(\\n'\n+            '        arg1=1,\\n'\n+            '        arg2=2,\\n'\n+            '    ),\\n'\n+            '    arg2=custom_migration_operations.operations.KwargsOperation(\\n'\n+            '        kwarg1=3,\\n'\n+            '        kwarg2=4,\\n'\n+            '    ),\\n'\n+            '),'\n+        )\n+\n+    def test_multiline_args_signature(self):\n+        operation = custom_migration_operations.operations.ArgsOperation(\"test\\n    arg1\", \"test\\narg2\")\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            \"custom_migration_operations.operations.ArgsOperation(\\n\"\n+            \"    arg1='test\\\\n    arg1',\\n\"\n+            \"    arg2='test\\\\narg2',\\n\"\n+            \"),\"\n+        )\n+\n+    def test_expand_args_signature(self):\n+        operation = custom_migration_operations.operations.ExpandArgsOperation([1, 2])\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.ExpandArgsOperation(\\n'\n+            '    arg=[\\n'\n+            '        1,\\n'\n+            '        2,\\n'\n+            '    ],\\n'\n+            '),'\n+        )\n+\n+    def test_nested_operation_expand_args_signature(self):\n+        operation = custom_migration_operations.operations.ExpandArgsOperation(\n+            arg=[\n+                custom_migration_operations.operations.KwargsOperation(\n+                    kwarg1=1,\n+                    kwarg2=2,\n+                ),\n+            ]\n+        )\n+        buff, imports = OperationWriter(operation, indentation=0).serialize()\n+        self.assertEqual(imports, {'import custom_migration_operations.operations'})\n+        self.assertEqual(\n+            buff,\n+            'custom_migration_operations.operations.ExpandArgsOperation(\\n'\n+            '    arg=[\\n'\n+            '        custom_migration_operations.operations.KwargsOperation(\\n'\n+            '            kwarg1=1,\\n'\n+            '            kwarg2=2,\\n'\n+            '        ),\\n'\n+            '    ],\\n'\n+            '),'\n+        )\n+\n+\n+class WriterTests(SimpleTestCase):\n+    \"\"\"\n+    Tests the migration writer (makes migration files from Migration instances)\n+    \"\"\"\n+\n+    def safe_exec(self, string, value=None):\n+        d = {}\n+        try:\n+            exec(string, globals(), d)\n+        except Exception as e:\n+            if value:\n+                self.fail(\"Could not exec %r (from value %r): %s\" % (string.strip(), value, e))\n+            else:\n+                self.fail(\"Could not exec %r: %s\" % (string.strip(), e))\n+        return d\n+\n+    def serialize_round_trip(self, value):\n+        string, imports = MigrationWriter.serialize(value)\n+        return self.safe_exec(\"%s\\ntest_value_result = %s\" % (\"\\n\".join(imports), string), value)['test_value_result']\n+\n+    def assertSerializedEqual(self, value):\n+        self.assertEqual(self.serialize_round_trip(value), value)\n+\n+    def assertSerializedResultEqual(self, value, target):\n+        self.assertEqual(MigrationWriter.serialize(value), target)\n+\n+    def assertSerializedFieldEqual(self, value):\n+        new_value = self.serialize_round_trip(value)\n+        self.assertEqual(value.__class__, new_value.__class__)\n+        self.assertEqual(value.max_length, new_value.max_length)\n+        self.assertEqual(value.null, new_value.null)\n+        self.assertEqual(value.unique, new_value.unique)\n+\n+    def test_serialize_numbers(self):\n+        self.assertSerializedEqual(1)\n+        self.assertSerializedEqual(1.2)\n+        self.assertTrue(math.isinf(self.serialize_round_trip(float(\"inf\"))))\n+        self.assertTrue(math.isinf(self.serialize_round_trip(float(\"-inf\"))))\n+        self.assertTrue(math.isnan(self.serialize_round_trip(float(\"nan\"))))\n+\n+        self.assertSerializedEqual(decimal.Decimal('1.3'))\n+        self.assertSerializedResultEqual(\n+            decimal.Decimal('1.3'),\n+            (\"Decimal('1.3')\", {'from decimal import Decimal'})\n+        )\n+\n+        self.assertSerializedEqual(Money('1.3'))\n+        self.assertSerializedResultEqual(\n+            Money('1.3'),\n+            (\"migrations.test_writer.Money('1.3')\", {'import migrations.test_writer'})\n+        )\n+\n+    def test_serialize_constants(self):\n+        self.assertSerializedEqual(None)\n+        self.assertSerializedEqual(True)\n+        self.assertSerializedEqual(False)\n+\n+    def test_serialize_strings(self):\n+        self.assertSerializedEqual(b\"foobar\")\n+        string, imports = MigrationWriter.serialize(b\"foobar\")\n+        self.assertEqual(string, \"b'foobar'\")\n+        self.assertSerializedEqual(\"f\u00f6ob\u00e1r\")\n+        string, imports = MigrationWriter.serialize(\"foobar\")\n+        self.assertEqual(string, \"'foobar'\")\n+\n+    def test_serialize_multiline_strings(self):\n+        self.assertSerializedEqual(b\"foo\\nbar\")\n+        string, imports = MigrationWriter.serialize(b\"foo\\nbar\")\n+        self.assertEqual(string, \"b'foo\\\\nbar'\")\n+        self.assertSerializedEqual(\"f\u00f6o\\nb\u00e1r\")\n+        string, imports = MigrationWriter.serialize(\"foo\\nbar\")\n+        self.assertEqual(string, \"'foo\\\\nbar'\")\n+\n+    def test_serialize_collections(self):\n+        self.assertSerializedEqual({1: 2})\n+        self.assertSerializedEqual([\"a\", 2, True, None])\n+        self.assertSerializedEqual({2, 3, \"eighty\"})\n+        self.assertSerializedEqual({\"lalalala\": [\"yeah\", \"no\", \"maybe\"]})\n+        self.assertSerializedEqual(_('Hello'))\n+\n+    def test_serialize_builtin_types(self):\n+        self.assertSerializedEqual([list, tuple, dict, set, frozenset])\n+        self.assertSerializedResultEqual(\n+            [list, tuple, dict, set, frozenset],\n+            (\"[list, tuple, dict, set, frozenset]\", set())\n+        )\n+\n+    def test_serialize_lazy_objects(self):\n+        pattern = re.compile(r'^foo$')\n+        lazy_pattern = SimpleLazyObject(lambda: pattern)\n+        self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n+\n+    def test_serialize_enums(self):\n+        class TextEnum(enum.Enum):\n+            A = 'a-value'\n+            B = 'value-b'\n+\n+        class BinaryEnum(enum.Enum):\n+            A = b'a-value'\n+            B = b'value-b'\n+\n+        class IntEnum(enum.IntEnum):\n+            A = 1\n+            B = 2\n+\n+        self.assertSerializedResultEqual(\n+            TextEnum.A,\n+            (\"migrations.test_writer.TextEnum('a-value')\", {'import migrations.test_writer'})\n+        )\n+        self.assertSerializedResultEqual(\n+            BinaryEnum.A,\n+            (\"migrations.test_writer.BinaryEnum(b'a-value')\", {'import migrations.test_writer'})\n+        )\n+        self.assertSerializedResultEqual(\n+            IntEnum.B,\n+            (\"migrations.test_writer.IntEnum(2)\", {'import migrations.test_writer'})\n+        )\n+\n+        field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('a-value', migrations.test_writer.TextEnum('a-value')), \"\n+            \"('value-b', migrations.test_writer.TextEnum('value-b'))], \"\n+            \"default=migrations.test_writer.TextEnum('value-b'))\"\n+        )\n+        field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"(b'a-value', migrations.test_writer.BinaryEnum(b'a-value')), \"\n+            \"(b'value-b', migrations.test_writer.BinaryEnum(b'value-b'))], \"\n+            \"default=migrations.test_writer.BinaryEnum(b'value-b'))\"\n+        )\n+        field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.IntegerField(choices=[\"\n+            \"(1, migrations.test_writer.IntEnum(1)), \"\n+            \"(2, migrations.test_writer.IntEnum(2))], \"\n+            \"default=migrations.test_writer.IntEnum(1))\"\n+        )\n+\n+    def test_serialize_choices(self):\n+        class TextChoices(models.TextChoices):\n+            A = 'A', 'A value'\n+            B = 'B', 'B value'\n+\n+        class IntegerChoices(models.IntegerChoices):\n+            A = 1, 'One'\n+            B = 2, 'Two'\n+\n+        class DateChoices(datetime.date, models.Choices):\n+            DATE_1 = 1969, 7, 20, 'First date'\n+            DATE_2 = 1969, 11, 19, 'Second date'\n+\n+        self.assertSerializedResultEqual(TextChoices.A, (\"'A'\", set()))\n+        self.assertSerializedResultEqual(IntegerChoices.A, ('1', set()))\n+        self.assertSerializedResultEqual(\n+            DateChoices.DATE_1,\n+            ('datetime.date(1969, 7, 20)', {'import datetime'}),\n+        )\n+        field = models.CharField(default=TextChoices.B, choices=TextChoices.choices)\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n+            \"default='B')\",\n+        )\n+        field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices.choices)\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n+        )\n+        field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices.choices)\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.DateField(choices=[\"\n+            \"(datetime.date(1969, 7, 20), 'First date'), \"\n+            \"(datetime.date(1969, 11, 19), 'Second date')], \"\n+            \"default=datetime.date(1969, 11, 19))\"\n+        )\n+\n+    def test_serialize_uuid(self):\n+        self.assertSerializedEqual(uuid.uuid1())\n+        self.assertSerializedEqual(uuid.uuid4())\n+\n+        uuid_a = uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\n+        uuid_b = uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\n+        self.assertSerializedResultEqual(\n+            uuid_a,\n+            (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {'import uuid'})\n+        )\n+        self.assertSerializedResultEqual(\n+            uuid_b,\n+            (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {'import uuid'})\n+        )\n+\n+        field = models.UUIDField(choices=((uuid_a, 'UUID A'), (uuid_b, 'UUID B')), default=uuid_a)\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.UUIDField(choices=[\"\n+            \"(uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'), 'UUID A'), \"\n+            \"(uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2'), 'UUID B')], \"\n+            \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\"\n+        )\n+\n+    def test_serialize_functions(self):\n+        with self.assertRaisesMessage(ValueError, 'Cannot serialize function: lambda'):\n+            self.assertSerializedEqual(lambda x: 42)\n+        self.assertSerializedEqual(models.SET_NULL)\n+        string, imports = MigrationWriter.serialize(models.SET(42))\n+        self.assertEqual(string, 'models.SET(42)')\n+        self.serialize_round_trip(models.SET(42))\n+\n+    def test_serialize_datetime(self):\n+        self.assertSerializedEqual(datetime.datetime.utcnow())\n+        self.assertSerializedEqual(datetime.datetime.utcnow)\n+        self.assertSerializedEqual(datetime.datetime.today())\n+        self.assertSerializedEqual(datetime.datetime.today)\n+        self.assertSerializedEqual(datetime.date.today())\n+        self.assertSerializedEqual(datetime.date.today)\n+        self.assertSerializedEqual(datetime.datetime.now().time())\n+        self.assertSerializedEqual(datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone()))\n+        self.assertSerializedEqual(datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180)))\n+        self.assertSerializedResultEqual(\n+            datetime.datetime(2014, 1, 1, 1, 1),\n+            (\"datetime.datetime(2014, 1, 1, 1, 1)\", {'import datetime'})\n+        )\n+        self.assertSerializedResultEqual(\n+            datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),\n+            (\n+                \"datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc)\",\n+                {'import datetime', 'from django.utils.timezone import utc'},\n+            )\n+        )\n+\n+    def test_serialize_fields(self):\n+        self.assertSerializedFieldEqual(models.CharField(max_length=255))\n+        self.assertSerializedResultEqual(\n+            models.CharField(max_length=255),\n+            (\"models.CharField(max_length=255)\", {\"from django.db import models\"})\n+        )\n+        self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n+        self.assertSerializedResultEqual(\n+            models.TextField(null=True, blank=True),\n+            (\"models.TextField(blank=True, null=True)\", {'from django.db import models'})\n+        )\n+\n+    def test_serialize_settings(self):\n+        self.assertSerializedEqual(SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\"))\n+        self.assertSerializedResultEqual(\n+            SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n+            (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"})\n+        )\n+\n+    def test_serialize_iterators(self):\n+        self.assertSerializedResultEqual(\n+            ((x, x * x) for x in range(3)),\n+            (\"((0, 0), (1, 1), (2, 4))\", set())\n+        )\n+\n+    def test_serialize_compiled_regex(self):\n+        \"\"\"\n+        Make sure compiled regex can be serialized.\n+        \"\"\"\n+        regex = re.compile(r'^\\w+$')\n+        self.assertSerializedEqual(regex)\n+\n+    def test_serialize_class_based_validators(self):\n+        \"\"\"\n+        Ticket #22943: Test serialization of class-based validators, including\n+        compiled regexes.\n+        \"\"\"\n+        validator = RegexValidator(message=\"hello\")\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"django.core.validators.RegexValidator(message='hello')\")\n+        self.serialize_round_trip(validator)\n+\n+        # Test with a compiled regex.\n+        validator = RegexValidator(regex=re.compile(r'^\\w+$'))\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\")\n+        self.serialize_round_trip(validator)\n+\n+        # Test a string regex with flag\n+        validator = RegexValidator(r'^[0-9]+$', flags=re.S)\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"django.core.validators.RegexValidator('^[0-9]+$', flags=re.RegexFlag(16))\")\n+        self.serialize_round_trip(validator)\n+\n+        # Test message and code\n+        validator = RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', 'invalid')\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', 'invalid')\")\n+        self.serialize_round_trip(validator)\n+\n+        # Test with a subclass.\n+        validator = EmailValidator(message=\"hello\")\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"django.core.validators.EmailValidator(message='hello')\")\n+        self.serialize_round_trip(validator)\n+\n+        validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(EmailValidator)(message=\"hello\")\n+        string = MigrationWriter.serialize(validator)[0]\n+        self.assertEqual(string, \"migrations.test_writer.EmailValidator(message='hello')\")\n+\n+        validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(message=\"hello\")\n+        with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n+            MigrationWriter.serialize(validator)\n+\n+        validator = deconstructible(path=\"django.core.validators.EmailValidator2\")(EmailValidator)(message=\"hello\")\n+        with self.assertRaisesMessage(ValueError, \"Could not find object EmailValidator2 in django.core.validators.\"):\n+            MigrationWriter.serialize(validator)\n+\n+    def test_serialize_empty_nonempty_tuple(self):\n+        \"\"\"\n+        Ticket #22679: makemigrations generates invalid code for (an empty\n+        tuple) default_permissions = ()\n+        \"\"\"\n+        empty_tuple = ()\n+        one_item_tuple = ('a',)\n+        many_items_tuple = ('a', 'b', 'c')\n+        self.assertSerializedEqual(empty_tuple)\n+        self.assertSerializedEqual(one_item_tuple)\n+        self.assertSerializedEqual(many_items_tuple)\n+\n+    def test_serialize_range(self):\n+        string, imports = MigrationWriter.serialize(range(1, 5))\n+        self.assertEqual(string, 'range(1, 5)')\n+        self.assertEqual(imports, set())\n+\n+    def test_serialize_builtins(self):\n+        string, imports = MigrationWriter.serialize(range)\n+        self.assertEqual(string, 'range')\n+        self.assertEqual(imports, set())\n+\n+    def test_serialize_unbound_method_reference(self):\n+        \"\"\"An unbound method used within a class body can be serialized.\"\"\"\n+        self.serialize_round_trip(TestModel1.thing)\n+\n+    def test_serialize_local_function_reference(self):\n+        \"\"\"A reference in a local scope can't be serialized.\"\"\"\n+        class TestModel2:\n+            def upload_to(self):\n+                return \"somewhere dynamic\"\n+            thing = models.FileField(upload_to=upload_to)\n+\n+        with self.assertRaisesMessage(ValueError, 'Could not find function upload_to in migrations.test_writer'):\n+            self.serialize_round_trip(TestModel2.thing)\n+\n+    def test_serialize_managers(self):\n+        self.assertSerializedEqual(models.Manager())\n+        self.assertSerializedResultEqual(\n+            FoodQuerySet.as_manager(),\n+            ('migrations.models.FoodQuerySet.as_manager()', {'import migrations.models'})\n+        )\n+        self.assertSerializedEqual(FoodManager('a', 'b'))\n+        self.assertSerializedEqual(FoodManager('x', 'y', c=3, d=4))\n+\n+    def test_serialize_frozensets(self):\n+        self.assertSerializedEqual(frozenset())\n+        self.assertSerializedEqual(frozenset(\"let it go\"))\n+\n+    def test_serialize_set(self):\n+        self.assertSerializedEqual(set())\n+        self.assertSerializedResultEqual(set(), ('set()', set()))\n+        self.assertSerializedEqual({'a'})\n+        self.assertSerializedResultEqual({'a'}, (\"{'a'}\", set()))\n+\n+    def test_serialize_timedelta(self):\n+        self.assertSerializedEqual(datetime.timedelta())\n+        self.assertSerializedEqual(datetime.timedelta(minutes=42))\n+\n+    def test_serialize_functools_partial(self):\n+        value = functools.partial(datetime.timedelta, 1, seconds=2)\n+        result = self.serialize_round_trip(value)\n+        self.assertEqual(result.func, value.func)\n+        self.assertEqual(result.args, value.args)\n+        self.assertEqual(result.keywords, value.keywords)\n+\n+    def test_serialize_functools_partialmethod(self):\n+        value = functools.partialmethod(datetime.timedelta, 1, seconds=2)\n+        result = self.serialize_round_trip(value)\n+        self.assertIsInstance(result, functools.partialmethod)\n+        self.assertEqual(result.func, value.func)\n+        self.assertEqual(result.args, value.args)\n+        self.assertEqual(result.keywords, value.keywords)\n+\n+    def test_serialize_type_none(self):\n+        self.assertSerializedEqual(type(None))\n+\n+    def test_simple_migration(self):\n+        \"\"\"\n+        Tests serializing a simple migration.\n+        \"\"\"\n+        fields = {\n+            'charfield': models.DateTimeField(default=datetime.datetime.utcnow),\n+            'datetimefield': models.DateTimeField(default=datetime.datetime.utcnow),\n+        }\n+\n+        options = {\n+            'verbose_name': 'My model',\n+            'verbose_name_plural': 'My models',\n+        }\n+\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                migrations.CreateModel(\"MyModel\", tuple(fields.items()), options, (models.Model,)),\n+                migrations.CreateModel(\"MyModel2\", tuple(fields.items()), bases=(models.Model,)),\n+                migrations.CreateModel(\n+                    name=\"MyModel3\", fields=tuple(fields.items()), options=options, bases=(models.Model,)\n+                ),\n+                migrations.DeleteModel(\"MyModel\"),\n+                migrations.AddField(\"OtherModel\", \"datetimefield\", fields[\"datetimefield\"]),\n+            ],\n+            \"dependencies\": [(\"testapp\", \"some_other_one\")],\n+        })\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        # We don't test the output formatting - that's too fragile.\n+        # Just make sure it runs for now, and that things look alright.\n+        result = self.safe_exec(output)\n+        self.assertIn(\"Migration\", result)\n+\n+    def test_migration_path(self):\n+        test_apps = [\n+            'migrations.migrations_test_apps.normal',\n+            'migrations.migrations_test_apps.with_package_model',\n+            'migrations.migrations_test_apps.without_init_file',\n+        ]\n+\n+        base_dir = os.path.dirname(os.path.dirname(__file__))\n+\n+        for app in test_apps:\n+            with self.modify_settings(INSTALLED_APPS={'append': app}):\n+                migration = migrations.Migration('0001_initial', app.split('.')[-1])\n+                expected_path = os.path.join(base_dir, *(app.split('.') + ['migrations', '0001_initial.py']))\n+                writer = MigrationWriter(migration)\n+                self.assertEqual(writer.path, expected_path)\n+\n+    def test_custom_operation(self):\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                custom_migration_operations.operations.TestOperation(),\n+                custom_migration_operations.operations.CreateModel(),\n+                migrations.CreateModel(\"MyModel\", (), {}, (models.Model,)),\n+                custom_migration_operations.more_operations.TestOperation()\n+            ],\n+            \"dependencies\": []\n+        })\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        result = self.safe_exec(output)\n+        self.assertIn(\"custom_migration_operations\", result)\n+        self.assertNotEqual(\n+            result['custom_migration_operations'].operations.TestOperation,\n+            result['custom_migration_operations'].more_operations.TestOperation\n+        )\n+\n+    def test_sorted_imports(self):\n+        \"\"\"\n+        #24155 - Tests ordering of imports.\n+        \"\"\"\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                migrations.AddField(\"mymodel\", \"myfield\", models.DateTimeField(\n+                    default=datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),\n+                )),\n+            ]\n+        })\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        self.assertIn(\n+            \"import datetime\\n\"\n+            \"from django.db import migrations, models\\n\"\n+            \"from django.utils.timezone import utc\\n\",\n+            output\n+        )\n+\n+    def test_migration_file_header_comments(self):\n+        \"\"\"\n+        Test comments at top of file.\n+        \"\"\"\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": []\n+        })\n+        dt = datetime.datetime(2015, 7, 31, 4, 40, 0, 0, tzinfo=utc)\n+        with mock.patch('django.db.migrations.writer.now', lambda: dt):\n+            for include_header in (True, False):\n+                with self.subTest(include_header=include_header):\n+                    writer = MigrationWriter(migration, include_header)\n+                    output = writer.as_string()\n+\n+                    self.assertEqual(\n+                        include_header,\n+                        output.startswith(\n+                            \"# Generated by Django %s on 2015-07-31 04:40\\n\\n\" % get_version()\n+                        )\n+                    )\n+                    if not include_header:\n+                        # Make sure the output starts with something that's not\n+                        # a comment or indentation or blank line\n+                        self.assertRegex(output.splitlines(keepends=True)[0], r\"^[^#\\s]+\")\n+\n+    def test_models_import_omitted(self):\n+        \"\"\"\n+        django.db.models shouldn't be imported if unused.\n+        \"\"\"\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                migrations.AlterModelOptions(\n+                    name='model',\n+                    options={'verbose_name': 'model', 'verbose_name_plural': 'models'},\n+                ),\n+            ]\n+        })\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        self.assertIn(\"from django.db import migrations\\n\", output)\n+\n+    def test_deconstruct_class_arguments(self):\n+        # Yes, it doesn't make sense to use a class as a default for a\n+        # CharField. It does make sense for custom fields though, for example\n+        # an enumfield that takes the enum class as an argument.\n+        class DeconstructibleInstances:\n+            def deconstruct(self):\n+                return ('DeconstructibleInstances', [], {})\n+\n+        string = MigrationWriter.serialize(models.CharField(default=DeconstructibleInstances))[0]\n+        self.assertEqual(string, \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\")\n+\n+    def test_register_serializer(self):\n+        class ComplexSerializer(BaseSerializer):\n+            def serialize(self):\n+                return 'complex(%r)' % self.value, {}\n+\n+        MigrationWriter.register_serializer(complex, ComplexSerializer)\n+        self.assertSerializedEqual(complex(1, 2))\n+        MigrationWriter.unregister_serializer(complex)\n+        with self.assertRaisesMessage(ValueError, 'Cannot serialize: (1+2j)'):\n+            self.assertSerializedEqual(complex(1, 2))\n+\n+    def test_register_non_serializer(self):\n+        with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n+            MigrationWriter.register_serializer(complex, TestModel1)\n", "gold_standard_diff": "From f0adf3b9b7a19cdee05368ff0c0c2d087f011180 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Tue, 24 Sep 2019 23:42:35 +0200\nSubject: [PATCH] Fixed #30774 -- Made serialization in migrations use members\n names for Enums.\n\n---\n django/db/migrations/serializer.py |  7 +++--\n tests/migrations/test_writer.py    | 46 +++++++++++++++++++++---------\n 2 files changed, 37 insertions(+), 16 deletions(-)\n\ndiff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py\nindex 27b5cbd379df..8aa6a0493571 100644\n--- a/django/db/migrations/serializer.py\n+++ b/django/db/migrations/serializer.py\n@@ -120,9 +120,10 @@ class EnumSerializer(BaseSerializer):\n     def serialize(self):\n         enum_class = self.value.__class__\n         module = enum_class.__module__\n-        v_string, v_imports = serializer_factory(self.value.value).serialize()\n-        imports = {'import %s' % module, *v_imports}\n-        return \"%s.%s(%s)\" % (module, enum_class.__name__, v_string), imports\n+        return (\n+            '%s.%s[%r]' % (module, enum_class.__name__, self.value.name),\n+            {'import %s' % module},\n+        )\n \n \n class FloatSerializer(BaseSimpleSerializer):\ndiff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f97d76e9adc6..6295a6799248 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -257,6 +257,10 @@ class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n \n+        class TextTranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('value-b')\n+\n         class BinaryEnum(enum.Enum):\n             A = b'a-value'\n             B = b'value-b'\n@@ -267,15 +271,19 @@ class IntEnum(enum.IntEnum):\n \n         self.assertSerializedResultEqual(\n             TextEnum.A,\n-            (\"migrations.test_writer.TextEnum('a-value')\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.TextEnum['A']\", {'import migrations.test_writer'})\n+        )\n+        self.assertSerializedResultEqual(\n+            TextTranslatedEnum.A,\n+            (\"migrations.test_writer.TextTranslatedEnum['A']\", {'import migrations.test_writer'})\n         )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n-            (\"migrations.test_writer.BinaryEnum(b'a-value')\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.BinaryEnum['A']\", {'import migrations.test_writer'})\n         )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n-            (\"migrations.test_writer.IntEnum(2)\", {'import migrations.test_writer'})\n+            (\"migrations.test_writer.IntEnum['B']\", {'import migrations.test_writer'})\n         )\n \n         field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])\n@@ -283,27 +291,39 @@ class IntEnum(enum.IntEnum):\n         self.assertEqual(\n             string,\n             \"models.CharField(choices=[\"\n-            \"('a-value', migrations.test_writer.TextEnum('a-value')), \"\n-            \"('value-b', migrations.test_writer.TextEnum('value-b'))], \"\n-            \"default=migrations.test_writer.TextEnum('value-b'))\"\n+            \"('a-value', migrations.test_writer.TextEnum['A']), \"\n+            \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n+            \"default=migrations.test_writer.TextEnum['B'])\"\n+        )\n+        field = models.CharField(\n+            default=TextTranslatedEnum.A,\n+            choices=[(m.value, m) for m in TextTranslatedEnum],\n+        )\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('a-value', migrations.test_writer.TextTranslatedEnum['A']), \"\n+            \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n+            \"default=migrations.test_writer.TextTranslatedEnum['A'])\"\n         )\n         field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.CharField(choices=[\"\n-            \"(b'a-value', migrations.test_writer.BinaryEnum(b'a-value')), \"\n-            \"(b'value-b', migrations.test_writer.BinaryEnum(b'value-b'))], \"\n-            \"default=migrations.test_writer.BinaryEnum(b'value-b'))\"\n+            \"(b'a-value', migrations.test_writer.BinaryEnum['A']), \"\n+            \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n+            \"default=migrations.test_writer.BinaryEnum['B'])\"\n         )\n         field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[\"\n-            \"(1, migrations.test_writer.IntEnum(1)), \"\n-            \"(2, migrations.test_writer.IntEnum(2))], \"\n-            \"default=migrations.test_writer.IntEnum(1))\"\n+            \"(1, migrations.test_writer.IntEnum['A']), \"\n+            \"(2, migrations.test_writer.IntEnum['B'])], \"\n+            \"default=migrations.test_writer.IntEnum['A'])\"\n         )\n \n     def test_serialize_choices(self):\n@@ -454,7 +474,7 @@ def test_serialize_class_based_validators(self):\n         # Test a string regex with flag\n         validator = RegexValidator(r'^[0-9]+$', flags=re.S)\n         string = MigrationWriter.serialize(validator)[0]\n-        self.assertEqual(string, \"django.core.validators.RegexValidator('^[0-9]+$', flags=re.RegexFlag(16))\")\n+        self.assertEqual(string, \"django.core.validators.RegexValidator('^[0-9]+$', flags=re.RegexFlag['DOTALL'])\")\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11815"}