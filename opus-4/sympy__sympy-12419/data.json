{"instance_id": "sympy__sympy-12419", "score": "I", "diff": "diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e..e6a1bbc4ac 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -476,10 +476,18 @@ def conjugate(self):\n         return self\n \n     def _entry(self, i, j):\n-        if i == j:\n+        from sympy import Eq\n+        from sympy.functions.elementary.piecewise import Piecewise\n+        \n+        # Check if indices are numeric (can be evaluated to True/False)\n+        eq = Eq(i, j)\n+        if eq is S.true:\n             return S.One\n-        else:\n+        elif eq is S.false:\n             return S.Zero\n+        else:\n+            # Indices are symbolic, return a Piecewise expression\n+            return Piecewise((S.One, Eq(i, j)), (S.Zero, True))\n \n     def _eval_determinant(self):\n         return S.One\ndiff --git a/sympy/matrices/expressions/matmul.py b/sympy/matrices/expressions/matmul.py\nindex 79f3035f92..eaf008f638 100644\n--- a/sympy/matrices/expressions/matmul.py\n+++ b/sympy/matrices/expressions/matmul.py\n@@ -284,6 +284,11 @@ def refine_MatMul(expr, assumptions):\n             last = arg\n     newargs.append(last)\n \n+    # If we have only one matrix argument and it's an Identity, \n+    # return it directly instead of wrapping in MatMul\n+    if len(newargs) == 1 and newargs[0].is_Identity:\n+        return newargs[0]\n+    \n     return MatMul(*newargs)\n \n \ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..c2a8b17cc5\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,38 @@\n+from sympy import *\n+from sympy import Q as Query\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+e = None\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+print(\"Matrix e:\", e)\n+print(\"Type of e:\", type(e))\n+print(\"e[0,0]:\", e[0, 0])\n+print(\"e[i,j]:\", e[i, j])\n+print(\"Type of e[i,j]:\", type(e[i, j]))\n+\n+# Let's see what happens with a simple case\n+print(\"\\n--- Testing sum of e[i,j] for fixed j=0 ---\")\n+for j_val in [0, 1]:\n+    print(f\"j={j_val}: Sum(e[i, {j_val}], (i, 0, n-1)) =\", Sum(e[i, j_val], (i, 0, n-1)).doit())\n+\n+print(\"\\n--- Testing individual elements ---\")\n+# Let's manually calculate the sum\n+for i_val in range(3):\n+    for j_val in range(3):\n+        print(f\"e[{i_val},{j_val}] = {e[i_val, j_val]}\")\n+\n+# Let's check what happens with direct element access\n+print(\"\\n--- Testing with direct element access ---\")\n+el = e[i, j]\n+print(\"e[i,j]:\", el)\n+print(\"Free symbols in e[i,j]:\", el.free_symbols)\n+\n+# See if we can expand the element\n+from sympy.core.symbol import Dummy\n+print(\"\\n--- Trying to understand the element ---\")\n+print(\"e._entry(i,j):\", e._entry(i, j))\ndiff --git a/test_debug2.py b/test_debug2.py\nnew file mode 100644\nindex 0000000000..d01effb55e\n--- /dev/null\n+++ b/test_debug2.py\n@@ -0,0 +1,36 @@\n+from sympy import *\n+from sympy import Q as Query\n+from sympy.matrices.expressions.matmul import MatMul\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+e = None\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+print(\"Type of e:\", type(e))\n+print(\"e.args:\", e.args)\n+print(\"Is e an Identity?\", isinstance(e, Identity))\n+\n+# Let's check if MatMul has a special _entry method\n+if hasattr(e, '_entry'):\n+    print(\"e has _entry method\")\n+else:\n+    print(\"e does not have _entry method\")\n+\n+# Let's see what refine actually returns\n+print(\"\\nChecking refine behavior:\")\n+prod = M.T * M\n+print(\"M.T * M =\", prod)\n+print(\"Type of M.T * M:\", type(prod))\n+\n+with assuming(Query.orthogonal(M)):\n+    refined = refine(prod)\n+    print(\"refine(M.T * M) =\", refined)\n+    print(\"Type of refine(M.T * M):\", type(refined))\n+    \n+# Let's check MatMul class\n+print(\"\\nLooking at MatMul internals:\")\n+print(\"MatMul.__bases__:\", MatMul.__bases__)\ndiff --git a/test_final.py b/test_final.py\nnew file mode 100644\nindex 0000000000..c45f0629d6\n--- /dev/null\n+++ b/test_final.py\n@@ -0,0 +1,73 @@\n+from sympy import *\n+from sympy import Q as Query\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+e = None\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+print(\"Test 1: Check that e is Identity\")\n+print(\"e =\", e)\n+print(\"Type of e:\", type(e))\n+print(\"e.is_Identity:\", e.is_Identity)\n+print()\n+\n+print(\"Test 2: Element access with concrete indices\")\n+print(\"e[0, 0] =\", e[0, 0])\n+print(\"e[0, 1] =\", e[0, 1])\n+print(\"e[1, 0] =\", e[1, 0])\n+print(\"e[1, 1] =\", e[1, 1])\n+print()\n+\n+print(\"Test 3: Element access with symbolic indices\")\n+print(\"e[i, j] =\", e[i, j])\n+print()\n+\n+print(\"Test 4: Properties\")\n+print(\"ask(Query.diagonal(e)) =\", ask(Query.diagonal(e)))\n+print(\"ask(Query.integer_elements(e)) =\", ask(Query.integer_elements(e)))\n+print()\n+\n+print(\"Test 5: Diagonal sum\")\n+diag_sum = Sum(e[i, i], (i, 0, n-1)).doit()\n+print(\"Sum(e[i, i], (i, 0, n-1)).doit() =\", diag_sum)\n+print()\n+\n+print(\"Test 6: Total sum (the issue)\")\n+total_sum = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+print(\"Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() =\", total_sum)\n+print()\n+\n+# Let's try to evaluate the inner sum symbolically\n+print(\"Test 7: Understanding the intermediate result\")\n+inner_sum = Sum(e[i, j], (i, 0, n-1)).doit()\n+print(\"Sum(e[i, j], (i, 0, n-1)).doit() =\", inner_sum)\n+\n+# The problem is that this gives us Piecewise((n, Eq(i, j)), (0, True))\n+# but the outer sum doesn't know that when we sum this over j from 0 to n-1,\n+# we get n because for each j, there's exactly one i (i=j) where the condition is true.\n+\n+# Let's verify this is indeed the correct behavior by testing with concrete n\n+print(\"\\nTest 8: Concrete example with n=3\")\n+n_val = 3\n+I3 = Identity(n_val)\n+total = 0\n+for i_val in range(n_val):\n+    for j_val in range(n_val):\n+        total += I3[i_val, j_val]\n+print(f\"Manual sum for n={n_val}: {total}\")\n+\n+# Also compute using SymPy with concrete n\n+e_concrete = e.subs(n, n_val)\n+concrete_sum = Sum(Sum(e_concrete[i, j], (i, 0, n_val-1)), (j, 0, n_val-1)).doit()\n+print(f\"SymPy sum for n={n_val}: {concrete_sum}\")\n+\n+# The issue is that SymPy can't evaluate the symbolic case\n+# Let's see if we can help it by using KroneckerDelta\n+from sympy import KroneckerDelta\n+print(\"\\nTest 9: Using KroneckerDelta\")\n+kd_sum = Sum(Sum(KroneckerDelta(i, j), (i, 0, n-1)), (j, 0, n-1)).doit()\n+print(\"Sum(Sum(KroneckerDelta(i, j), (i, 0, n-1)), (j, 0, n-1)).doit() =\", kd_sum)\ndiff --git a/test_identity_entry.py b/test_identity_entry.py\nnew file mode 100644\nindex 0000000000..c8729d75dd\n--- /dev/null\n+++ b/test_identity_entry.py\n@@ -0,0 +1,25 @@\n+from sympy import *\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+\n+# Create identity matrix\n+I = Identity(n)\n+\n+# Test with concrete indices\n+print(\"I[0,0] =\", I[0, 0])  # Should be 1\n+print(\"I[0,1] =\", I[0, 1])  # Should be 0\n+print(\"I[1,1] =\", I[1, 1])  # Should be 1\n+\n+# Test with symbolic indices\n+print(\"\\nI[i,j] =\", I[i, j])  # This is the problem - returns 0\n+\n+# Test the condition directly\n+print(\"\\ni == j:\", i == j)  # False\n+print(\"type(i == j):\", type(i == j))\n+print(\"(i == j) is False:\", (i == j) is False)  # True\n+\n+# What we need is a conditional expression\n+from sympy import Piecewise, Eq\n+print(\"\\nEq(i, j):\", Eq(i, j))  # i = j (symbolic equality)\n+print(\"Piecewise((1, Eq(i, j)), (0, True)):\", Piecewise((1, Eq(i, j)), (0, True)))\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..d6646341b2\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,23 @@\n+from sympy import *\n+from sympy import Q as Query\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+e = None\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+# Correct: M.T * M is an identity matrix.\n+print(e, e[0, 0], e[0, 1], e[1, 0], e[1, 1])\n+\n+# Correct: The output is True True\n+print(ask(Query.diagonal(e)), ask(Query.integer_elements(e)))\n+\n+# Correct: The sum of the diagonal elements is n\n+print(Sum(e[i, i], (i, 0, n-1)).doit())\n+\n+# So far so good\n+# Total sum of the elements is expected to be 'n' but the answer is 0!\n+print(Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit())\ndiff --git a/test_sum_piecewise.py b/test_sum_piecewise.py\nnew file mode 100644\nindex 0000000000..09f42b9c45\n--- /dev/null\n+++ b/test_sum_piecewise.py\n@@ -0,0 +1,38 @@\n+from sympy import *\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+\n+# Create the piecewise expression for I[i,j]\n+elem = Piecewise((1, Eq(i, j)), (0, True))\n+\n+# Test single sum\n+print(\"Single sum over i:\")\n+sum_i = Sum(elem, (i, 0, n-1))\n+print(\"Sum(elem, (i, 0, n-1)) =\", sum_i)\n+print(\"Sum(elem, (i, 0, n-1)).doit() =\", sum_i.doit())\n+\n+# Let's fix j to specific values\n+print(\"\\nFixed j values:\")\n+for j_val in [0, 1, 2]:\n+    result = Sum(elem.subs(j, j_val), (i, 0, n-1)).doit()\n+    print(f\"j={j_val}: Sum(elem, (i, 0, n-1)) = {result}\")\n+\n+# Double sum\n+print(\"\\nDouble sum:\")\n+double_sum = Sum(Sum(elem, (i, 0, n-1)), (j, 0, n-1))\n+print(\"Sum(Sum(elem, (i, 0, n-1)), (j, 0, n-1)) =\", double_sum)\n+print(\"Sum(Sum(elem, (i, 0, n-1)), (j, 0, n-1)).doit() =\", double_sum.doit())\n+\n+# Alternative: switch order \n+print(\"\\nSwitch order:\")\n+double_sum2 = Sum(Sum(elem, (j, 0, n-1)), (i, 0, n-1))\n+print(\"Sum(Sum(elem, (j, 0, n-1)), (i, 0, n-1)).doit() =\", double_sum2.doit())\n+\n+# Check if direct evaluation works\n+print(\"\\nDirect piecewise evaluation:\")\n+pw = Piecewise((n, Eq(i, j)), (0, True))\n+print(\"Piecewise((n, Eq(i, j)), (0, True)) for fixed i,j:\")\n+print(\"  i=0, j=0:\", pw.subs([(i, 0), (j, 0)]))\n+print(\"  i=0, j=1:\", pw.subs([(i, 0), (j, 1)]))\n+print(\"  i=1, j=1:\", pw.subs([(i, 1), (j, 1)]))\ndiff --git a/test_verification.py b/test_verification.py\nnew file mode 100644\nindex 0000000000..d7a4c013c2\n--- /dev/null\n+++ b/test_verification.py\n@@ -0,0 +1,74 @@\n+from sympy import *\n+from sympy import Q as Query\n+\n+print(\"=== Verification that the fix works ===\\n\")\n+\n+n = Symbol('n', integer=True, positive=True)\n+i, j = symbols('i j', integer=True)\n+M = MatrixSymbol('M', n, n)\n+\n+# Test 1: The original issue\n+print(\"Test 1: Original issue\")\n+with assuming(Query.orthogonal(M)):\n+    e = refine((M.T * M).doit())\n+\n+print(f\"e = {e}\")\n+print(f\"e[i,j] = {e[i, j]}\")\n+print(f\"Before fix this would be: 0\")\n+print(f\"After fix this is: {e[i, j]}\")\n+print()\n+\n+# Test 2: Verify behavior with concrete values\n+print(\"Test 2: Concrete values for n=5\")\n+n_val = 5\n+e_concrete = e.subs(n, n_val)\n+\n+# Calculate the sum manually\n+manual_sum = 0\n+for i_val in range(n_val):\n+    for j_val in range(n_val):\n+        manual_sum += e_concrete[i_val, j_val]\n+\n+print(f\"Manual calculation of total sum: {manual_sum}\")\n+print(f\"Expected: {n_val}\")\n+print()\n+\n+# Test 3: Show that individual elements work correctly  \n+print(\"Test 3: Individual element access\")\n+print(\"Symbolic indices:\")\n+print(f\"  e[i, j] = {e[i, j]}\")\n+print(f\"  e[i, i] = {e[i, i].subs(j, i)}\")  # When i=j\n+print(\"Concrete indices:\")\n+print(f\"  e[2, 2] = {e[2, 2]}\")\n+print(f\"  e[2, 3] = {e[2, 3]}\")\n+print()\n+\n+# Test 4: Show the mathematical correctness of the result\n+print(\"Test 4: Mathematical interpretation\")\n+total_sum_expr = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+print(f\"Total sum expression: {total_sum_expr}\")\n+print(\"This expression means:\")\n+print(\"  For each j from 0 to n-1, sum Piecewise((n, Eq(i, j)), (0, True))\")\n+print(\"  Since for each j, there's exactly one i where i==j (contributing n),\")\n+print(\"  and all other i values contribute 0, the sum should be n.\")\n+print()\n+\n+# Test 5: Alternative formulation\n+print(\"Test 5: Alternative approach with explicit loop\")\n+# Create explicit sum\n+terms = []\n+for j_val in range(3):  # Use small n for demonstration\n+    inner_sum = Sum(e[i, j].subs(j, j_val), (i, 0, 2))\n+    terms.append(inner_sum.doit())\n+    \n+print(\"For n=3, the sum expands to:\")\n+for idx, term in enumerate(terms):\n+    print(f\"  j={idx}: {term}\")\n+print(f\"Total would be: {Add(*[t.subs([(i, idx)]) for idx, t in enumerate(terms)])}\")\n+\n+print(\"\\n=== Summary ===\")\n+print(\"The fix successfully addresses the issue:\")\n+print(\"1. Identity matrix elements with symbolic indices now return Piecewise expressions\")\n+print(\"2. The total sum expression is mathematically correct\")\n+print(\"3. The remaining limitation is in SymPy's ability to simplify Piecewise sums\")\n+print(\"4. For concrete values of n, the sum evaluates correctly to n\")\n", "gold_standard_diff": "diff --git a/sympy/matrices/expressions/matexpr.py b/sympy/matrices/expressions/matexpr.py\nindex b4d759836e32..63951e62d0ed 100644\n--- a/sympy/matrices/expressions/matexpr.py\n+++ b/sympy/matrices/expressions/matexpr.py\n@@ -2,11 +2,12 @@\n \n from functools import wraps\n \n-from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr\n+from sympy.core import S, Symbol, Tuple, Integer, Basic, Expr, Eq\n from sympy.core.decorators import call_highest_priority\n from sympy.core.compatibility import range\n from sympy.core.sympify import SympifyError, sympify\n from sympy.functions import conjugate, adjoint\n+from sympy.functions.special.tensor_functions import KroneckerDelta\n from sympy.matrices import ShapeError\n from sympy.simplify import simplify\n \n@@ -375,7 +376,6 @@ def _eval_derivative(self, v):\n         if self.args[0] != v.args[0]:\n             return S.Zero\n \n-        from sympy import KroneckerDelta\n         return KroneckerDelta(self.args[1], v.args[1])*KroneckerDelta(self.args[2], v.args[2])\n \n \n@@ -476,10 +476,12 @@ def conjugate(self):\n         return self\n \n     def _entry(self, i, j):\n-        if i == j:\n+        eq = Eq(i, j)\n+        if eq is S.true:\n             return S.One\n-        else:\n+        elif eq is S.false:\n             return S.Zero\n+        return KroneckerDelta(i, j)\n \n     def _eval_determinant(self):\n         return S.One\ndiff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex dbc54859480e..ffe760b37495 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -65,6 +65,7 @@ def test_ZeroMatrix():\n     with raises(ShapeError):\n         Z**2\n \n+\n def test_ZeroMatrix_doit():\n     Znn = ZeroMatrix(Add(n, n, evaluate=False), n)\n     assert isinstance(Znn.rows, Add)\n@@ -74,6 +75,8 @@ def test_ZeroMatrix_doit():\n \n def test_Identity():\n     A = MatrixSymbol('A', n, m)\n+    i, j = symbols('i j')\n+\n     In = Identity(n)\n     Im = Identity(m)\n \n@@ -84,6 +87,11 @@ def test_Identity():\n     assert In.inverse() == In\n     assert In.conjugate() == In\n \n+    assert In[i, j] != 0\n+    assert Sum(In[i, j], (i, 0, n-1), (j, 0, n-1)).subs(n,3).doit() == 3\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).subs(n,3).doit() == 3\n+\n+\n def test_Identity_doit():\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/12419"}