{"instance_id": "matplotlib__matplotlib-22719", "score": "I", "diff": "diff --git a/lib/matplotlib/category.py b/lib/matplotlib/category.py\nindex c823b68fd9..03affbf2bc 100644\n--- a/lib/matplotlib/category.py\n+++ b/lib/matplotlib/category.py\n@@ -24,221 +24,3 @@ _log = logging.getLogger(__name__)\n \n \n class StrCategoryConverter(units.ConversionInterface):\n-    @staticmethod\n-    def convert(value, unit, axis):\n-        \"\"\"\n-        Convert strings in *value* to floats using mapping information stored\n-        in the *unit* object.\n-\n-        Parameters\n-        ----------\n-        value : str or iterable\n-            Value or list of values to be converted.\n-        unit : `.UnitData`\n-            An object mapping strings to integers.\n-        axis : `~matplotlib.axis.Axis`\n-            The axis on which the converted value is plotted.\n-\n-            .. note:: *axis* is unused.\n-\n-        Returns\n-        -------\n-        float or ndarray[float]\n-        \"\"\"\n-        if unit is None:\n-            raise ValueError(\n-                'Missing category information for StrCategoryConverter; '\n-                'this might be caused by unintendedly mixing categorical and '\n-                'numeric data')\n-        StrCategoryConverter._validate_unit(unit)\n-        # dtype = object preserves numerical pass throughs\n-        values = np.atleast_1d(np.array(value, dtype=object))\n-        # pass through sequence of non binary numbers\n-        with _api.suppress_matplotlib_deprecation_warning():\n-            is_numlike = all(units.ConversionInterface.is_numlike(v)\n-                             and not isinstance(v, (str, bytes))\n-                             for v in values)\n-        if is_numlike:\n-            _api.warn_deprecated(\n-                \"3.5\", message=\"Support for passing numbers through unit \"\n-                \"converters is deprecated since %(since)s and support will be \"\n-                \"removed %(removal)s; use Axis.convert_units instead.\")\n-            return np.asarray(values, dtype=float)\n-        # force an update so it also does type checking\n-        unit.update(values)\n-        return np.vectorize(unit._mapping.__getitem__, otypes=[float])(values)\n-\n-    @staticmethod\n-    def axisinfo(unit, axis):\n-        \"\"\"\n-        Set the default axis ticks and labels.\n-\n-        Parameters\n-        ----------\n-        unit : `.UnitData`\n-            object string unit information for value\n-        axis : `~matplotlib.axis.Axis`\n-            axis for which information is being set\n-\n-            .. note:: *axis* is not used\n-\n-        Returns\n-        -------\n-        `~matplotlib.units.AxisInfo`\n-            Information to support default tick labeling\n-\n-        \"\"\"\n-        StrCategoryConverter._validate_unit(unit)\n-        # locator and formatter take mapping dict because\n-        # args need to be pass by reference for updates\n-        majloc = StrCategoryLocator(unit._mapping)\n-        majfmt = StrCategoryFormatter(unit._mapping)\n-        return units.AxisInfo(majloc=majloc, majfmt=majfmt)\n-\n-    @staticmethod\n-    def default_units(data, axis):\n-        \"\"\"\n-        Set and update the `~matplotlib.axis.Axis` units.\n-\n-        Parameters\n-        ----------\n-        data : str or iterable of str\n-        axis : `~matplotlib.axis.Axis`\n-            axis on which the data is plotted\n-\n-        Returns\n-        -------\n-        `.UnitData`\n-            object storing string to integer mapping\n-        \"\"\"\n-        # the conversion call stack is default_units -> axis_info -> convert\n-        if axis.units is None:\n-            axis.set_units(UnitData(data))\n-        else:\n-            axis.units.update(data)\n-        return axis.units\n-\n-    @staticmethod\n-    def _validate_unit(unit):\n-        if not hasattr(unit, '_mapping'):\n-            raise ValueError(\n-                f'Provided unit \"{unit}\" is not valid for a categorical '\n-                'converter, as it does not have a _mapping attribute.')\n-\n-\n-class StrCategoryLocator(ticker.Locator):\n-    \"\"\"Tick at every integer mapping of the string data.\"\"\"\n-    def __init__(self, units_mapping):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        units_mapping : dict\n-            Mapping of category names (str) to indices (int).\n-        \"\"\"\n-        self._units = units_mapping\n-\n-    def __call__(self):\n-        # docstring inherited\n-        return list(self._units.values())\n-\n-    def tick_values(self, vmin, vmax):\n-        # docstring inherited\n-        return self()\n-\n-\n-class StrCategoryFormatter(ticker.Formatter):\n-    \"\"\"String representation of the data at every tick.\"\"\"\n-    def __init__(self, units_mapping):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        units_mapping : dict\n-            Mapping of category names (str) to indices (int).\n-        \"\"\"\n-        self._units = units_mapping\n-\n-    def __call__(self, x, pos=None):\n-        # docstring inherited\n-        return self.format_ticks([x])[0]\n-\n-    def format_ticks(self, values):\n-        # docstring inherited\n-        r_mapping = {v: self._text(k) for k, v in self._units.items()}\n-        return [r_mapping.get(round(val), '') for val in values]\n-\n-    @staticmethod\n-    def _text(value):\n-        \"\"\"Convert text values into utf-8 or ascii strings.\"\"\"\n-        if isinstance(value, bytes):\n-            value = value.decode(encoding='utf-8')\n-        elif not isinstance(value, str):\n-            value = str(value)\n-        return value\n-\n-\n-class UnitData:\n-    def __init__(self, data=None):\n-        \"\"\"\n-        Create mapping between unique categorical values and integer ids.\n-\n-        Parameters\n-        ----------\n-        data : iterable\n-            sequence of string values\n-        \"\"\"\n-        self._mapping = OrderedDict()\n-        self._counter = itertools.count()\n-        if data is not None:\n-            self.update(data)\n-\n-    @staticmethod\n-    def _str_is_convertible(val):\n-        \"\"\"\n-        Helper method to check whether a string can be parsed as float or date.\n-        \"\"\"\n-        try:\n-            float(val)\n-        except ValueError:\n-            try:\n-                dateutil.parser.parse(val)\n-            except (ValueError, TypeError):\n-                # TypeError if dateutil >= 2.8.1 else ValueError\n-                return False\n-        return True\n-\n-    def update(self, data):\n-        \"\"\"\n-        Map new values to integer identifiers.\n-\n-        Parameters\n-        ----------\n-        data : iterable of str or bytes\n-\n-        Raises\n-        ------\n-        TypeError\n-            If elements in *data* are neither str nor bytes.\n-        \"\"\"\n-        data = np.atleast_1d(np.array(data, dtype=object))\n-        # check if convertible to number:\n-        convertible = True\n-        for val in OrderedDict.fromkeys(data):\n-            # OrderedDict just iterates over unique values in data.\n-            _api.check_isinstance((str, bytes), value=val)\n-            if convertible:\n-                # this will only be called so long as convertible is True.\n-                convertible = self._str_is_convertible(val)\n-            if val not in self._mapping:\n-                self._mapping[val] = next(self._counter)\n-        if convertible:\n-            _log.info('Using categorical units to plot a list of strings '\n-                      'that are all parsable as floats or dates. If these '\n-                      'strings should be plotted as numbers, cast to the '\n-                      'appropriate data type before plotting.')\n-\n-\n-# Register the converter with Matplotlib's unit framework\n-units.registry[str] = StrCategoryConverter()\n-units.registry[np.str_] = StrCategoryConverter()\n-units.registry[bytes] = StrCategoryConverter()\n-units.registry[np.bytes_] = StrCategoryConverter()\n", "gold_standard_diff": "diff --git a/lib/matplotlib/category.py b/lib/matplotlib/category.py\nindex c823b68fd9c7..55f21a57ca96 100644\n--- a/lib/matplotlib/category.py\n+++ b/lib/matplotlib/category.py\n@@ -58,7 +58,7 @@ def convert(value, unit, axis):\n             is_numlike = all(units.ConversionInterface.is_numlike(v)\n                              and not isinstance(v, (str, bytes))\n                              for v in values)\n-        if is_numlike:\n+        if values.size and is_numlike:\n             _api.warn_deprecated(\n                 \"3.5\", message=\"Support for passing numbers through unit \"\n                 \"converters is deprecated since %(since)s and support will be \"\n@@ -230,7 +230,7 @@ def update(self, data):\n                 convertible = self._str_is_convertible(val)\n             if val not in self._mapping:\n                 self._mapping[val] = next(self._counter)\n-        if convertible:\n+        if data.size and convertible:\n             _log.info('Using categorical units to plot a list of strings '\n                       'that are all parsable as floats or dates. If these '\n                       'strings should be plotted as numbers, cast to the '\ndiff --git a/lib/matplotlib/tests/test_category.py b/lib/matplotlib/tests/test_category.py\nindex f0e424bd8e6e..6eb590d6e82d 100644\n--- a/lib/matplotlib/tests/test_category.py\n+++ b/lib/matplotlib/tests/test_category.py\n@@ -307,6 +307,15 @@ def test_overriding_units_in_plot(fig_test, fig_ref):\n         assert y_units is ax.yaxis.units\n \n \n+def test_no_deprecation_on_empty_data():\n+    \"\"\"\n+    Smoke test to check that no deprecation warning is emitted. See #22640.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    ax.plot([], [])\n+\n+\n def test_hist():\n     fig, ax = plt.subplots()\n     n, bins, patches = ax.hist(['a', 'b', 'a', 'c', 'ff'])\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/22719"}