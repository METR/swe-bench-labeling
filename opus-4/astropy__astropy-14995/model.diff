diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py
index 4153dfccb2..943803bbf8 100644
--- a/astropy/nddata/mixins/ndarithmetic.py
+++ b/astropy/nddata/mixins/ndarithmetic.py
@@ -522,6 +522,12 @@ class NDArithmeticMixin:
             return deepcopy(operand.mask)
         elif operand is None:
             return deepcopy(self.mask)
+        elif operand is not None and operand.mask is None:
+            # operand exists but has no mask, return a copy of self.mask
+            return deepcopy(self.mask)
+        elif self.mask is None:
+            # self has no mask but operand has a mask, return a copy of operand.mask
+            return deepcopy(operand.mask)
         else:
             # Now lets calculate the resulting mask (operation enforces copy)
             return handle_mask(self.mask, operand.mask, **kwds)
diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py
index 8c461155ab..ed7130d788 100644
--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py
+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py
@@ -314,6 +314,59 @@ def test_arithmetics_data_masks_invalid():
         nd1.divide(nd2)
 
 
+def test_arithmetics_mask_propagation_with_bitwise_or():
+    """Test mask propagation when one operand has no mask and handle_mask=np.bitwise_or"""
+    # This tests the fix for the issue where mask propagation fails when one operand
+    # doesn't have a mask and handle_mask is set to np.bitwise_or
+    
+    # Setup test data
+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])
+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])
+    
+    nd_nomask = NDDataArithmetic(array)
+    nd_mask = NDDataArithmetic(array, mask=mask)
+    
+    # Test 1: mask * constant (mask * no mask) 
+    result = nd_mask.multiply(1., handle_mask=np.bitwise_or)
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 2: mask * no mask NDData
+    result = nd_mask.multiply(nd_nomask, handle_mask=np.bitwise_or)
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 3: no mask * mask (reverse order)
+    result = nd_nomask.multiply(nd_mask, handle_mask=np.bitwise_or)  
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 4: mask + constant
+    result = nd_mask.add(1., handle_mask=np.bitwise_or)
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 5: mask - no mask
+    result = nd_mask.subtract(nd_nomask, handle_mask=np.bitwise_or)
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 6: mask / constant
+    result = nd_mask.divide(2., handle_mask=np.bitwise_or)
+    assert result.mask is not None
+    assert_array_equal(result.mask, mask)
+    
+    # Test 7: both have masks - ensure bitwise_or still works correctly
+    mask1 = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
+    mask2 = np.array([[1, 0, 0], [0, 0, 1], [0, 1, 0]])
+    nd1 = NDDataArithmetic(array, mask=mask1)
+    nd2 = NDDataArithmetic(array * 2, mask=mask2)
+    
+    result = nd1.multiply(nd2, handle_mask=np.bitwise_or)
+    expected_mask = np.bitwise_or(mask1, mask2)
+    assert_array_equal(result.mask, expected_mask)
+
+
 # Covering:
 # both have uncertainties (data and uncertainty without unit)
 # tested against manually determined resulting uncertainties to verify the
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1 @@
+
diff --git a/pyproject.toml b/pyproject.toml
index 15bb49f22b..dc9c3c5f37 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["setuptools",
+requires = ["setuptools==68.0.0",
             "setuptools_scm>=6.2",
             "cython==0.29.34",
             "oldest-supported-numpy",
