{"instance_id": "matplotlib__matplotlib-26466", "score": "I", "diff": "diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py\nindex 934c5677ac..ae9a0bf1fa 100644\n--- a/lib/matplotlib/axes/_axes.py\n+++ b/lib/matplotlib/axes/_axes.py\n@@ -705,13 +705,12 @@ class Axes(_AxesBase):\n                  arrowprops=None, annotation_clip=None, **kwargs):\n         # Signature must match Annotation. This is verified in\n         # test_annotate_signature().\n+        xy = np.array(xy)  # Create a copy of xy\n+        if xytext is not None:\n+            xytext = np.array(xytext)  # Create a copy of xytext if it's not None\n         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,\n                              textcoords=textcoords, arrowprops=arrowprops,\n                              annotation_clip=annotation_clip, **kwargs)\n-        a.set_transform(mtransforms.IdentityTransform())\n-        if kwargs.get('clip_on', False) and a.get_clip_path() is None:\n-            a.set_clip_path(self.patch)\n-        self._add_text(a)\n         return a\n     annotate.__doc__ = mtext.Annotation.__init__.__doc__\n     #### Lines and spans\n", "gold_standard_diff": "From 8f1141ba7a4da33e6c0da5f8b2c76f8487ffb8de Mon Sep 17 00:00:00 2001\nFrom: Antony Lee <anntzer.lee@gmail.com>\nDate: Mon, 7 Aug 2023 10:15:49 +0200\nSubject: [PATCH] Make annotate/OffsetFrom unaffected by later mutation of\n coordinates.\n\nThe unpacking (`x, y = xy`) is safe wrt. units (we already perform the\nsame unpacking later when actually computing coordinates) and prevents\nlater mutation of the input array from affecting the artist (or the\nOffsetFrom instance), which is consistent with other artists.\n\nWhile at it, also inline OffsetFrom._get_scale, which is a one-liner.\n---\n lib/matplotlib/tests/test_text.py | 18 +++++++++++++++++-\n lib/matplotlib/text.py            | 20 ++++++--------------\n 2 files changed, 23 insertions(+), 15 deletions(-)\n\ndiff --git a/lib/matplotlib/tests/test_text.py b/lib/matplotlib/tests/test_text.py\nindex 47121b7a2262..45bc2d2cc24d 100644\n--- a/lib/matplotlib/tests/test_text.py\n+++ b/lib/matplotlib/tests/test_text.py\n@@ -16,7 +16,7 @@\n import matplotlib.transforms as mtransforms\n from matplotlib.testing.decorators import check_figures_equal, image_comparison\n from matplotlib.testing._markers import needs_usetex\n-from matplotlib.text import Text, Annotation\n+from matplotlib.text import Text, Annotation, OffsetFrom\n \n pyparsing_version = parse_version(pyparsing.__version__)\n \n@@ -988,3 +988,19 @@ def test_text_math_antialiased_off_default_vs_manual(fig_test, fig_ref):\n \n     mpl.rcParams['text.antialiased'] = False\n     fig_ref.text(0.5, 0.5, r\"OutsideMath $I\\'m \\sqrt{2}$\")\n+\n+\n+@check_figures_equal(extensions=[\"png\"])\n+def test_annotate_and_offsetfrom_copy_input(fig_test, fig_ref):\n+    # Both approaches place the text (10, 0) pixels away from the center of the line.\n+    ax = fig_test.add_subplot()\n+    l, = ax.plot([0, 2], [0, 2])\n+    of_xy = np.array([.5, .5])\n+    ax.annotate(\"foo\", textcoords=OffsetFrom(l, of_xy), xytext=(10, 0),\n+                xy=(0, 0))  # xy is unused.\n+    of_xy[:] = 1\n+    ax = fig_ref.add_subplot()\n+    l, = ax.plot([0, 2], [0, 2])\n+    an_xy = np.array([.5, .5])\n+    ax.annotate(\"foo\", xy=an_xy, xycoords=l, xytext=(10, 0), textcoords=\"offset points\")\n+    an_xy[:] = 2\ndiff --git a/lib/matplotlib/text.py b/lib/matplotlib/text.py\nindex d4922fc51774..a3ab785756fc 100644\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -1389,7 +1389,8 @@ def __init__(self, artist, ref_coord, unit=\"points\"):\n             The screen units to use (pixels or points) for the offset input.\n         \"\"\"\n         self._artist = artist\n-        self._ref_coord = ref_coord\n+        x, y = ref_coord  # Make copy when ref_coord is an array (and check the shape).\n+        self._ref_coord = x, y\n         self.set_unit(unit)\n \n     def set_unit(self, unit):\n@@ -1407,13 +1408,6 @@ def get_unit(self):\n         \"\"\"Return the unit for input to the transform used by ``__call__``.\"\"\"\n         return self._unit\n \n-    def _get_scale(self, renderer):\n-        unit = self.get_unit()\n-        if unit == \"pixels\":\n-            return 1.\n-        else:\n-            return renderer.points_to_pixels(1.)\n-\n     def __call__(self, renderer):\n         \"\"\"\n         Return the offset transform.\n@@ -1443,11 +1437,8 @@ def __call__(self, renderer):\n             x, y = self._artist.transform(self._ref_coord)\n         else:\n             _api.check_isinstance((Artist, BboxBase, Transform), artist=self._artist)\n-\n-        sc = self._get_scale(renderer)\n-        tr = Affine2D().scale(sc).translate(x, y)\n-\n-        return tr\n+        scale = 1 if self._unit == \"pixels\" else renderer.points_to_pixels(1)\n+        return Affine2D().scale(scale).translate(x, y)\n \n \n class _AnnotationBase:\n@@ -1456,7 +1447,8 @@ def __init__(self,\n                  xycoords='data',\n                  annotation_clip=None):\n \n-        self.xy = xy\n+        x, y = xy  # Make copy when xy is an array (and check the shape).\n+        self.xy = x, y\n         self.xycoords = xycoords\n         self.set_annotation_clip(annotation_clip)\n \n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/26466"}