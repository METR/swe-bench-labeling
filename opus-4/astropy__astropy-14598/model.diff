diff --git a/pyproject.toml b/pyproject.toml
index 243782fdfc..b2688da2a5 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,5 @@
 [build-system]
-requires = ["setuptools",
+requires = ["setuptools==68.0.0",
             "setuptools_scm>=6.2",
             "wheel",
             "cython==0.29.30",
diff --git a/test_continue_flow.py b/test_continue_flow.py
new file mode 100644
index 0000000000..9f241d5d8a
--- /dev/null
+++ b/test_continue_flow.py
@@ -0,0 +1,42 @@
+from astropy.io import fits
+
+# Test a specific case where it fails
+n = 65
+value = "x" * n + "''"
+print(f"Original value: '{value}'")
+print(f"Length: {len(value)}")
+
+# Create a card
+card1 = fits.Card('CONFIG', value)
+print(f"\nCard1 image:\n{repr(str(card1))}")
+
+# The card is split into multiple lines
+lines = []
+for i in range(0, len(str(card1)), 80):
+    lines.append(str(card1)[i:i+80])
+    
+print("\nCard lines:")
+for i, line in enumerate(lines):
+    print(f"Line {i}: {repr(line)}")
+
+# Now parse it back
+card2 = fits.Card.fromstring(str(card1))
+print(f"\nCard2 value: '{card2.value}'")
+print(f"Values equal: {card1.value == card2.value}")
+
+# Let's check what _parse_value would see
+# The CONTINUE card has '''' which should parse to ''
+print("\n\nManual parsing of CONTINUE line:")
+continue_line = lines[1]
+value_part = continue_line[10:].strip()
+print(f"Value part of CONTINUE: {repr(value_part)}")
+
+import re
+_strg = r"\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )"
+strg_re = re.compile(_strg)
+match = strg_re.match(value_part)
+if match:
+    captured = match.group('strg')
+    print(f"Regex captured: {repr(captured)}")
+    value_after_sub = re.sub("''", "'", captured)
+    print(f"After re.sub: {repr(value_after_sub)}")
diff --git a/test_fits_format.py b/test_fits_format.py
new file mode 100644
index 0000000000..179b40c3d6
--- /dev/null
+++ b/test_fits_format.py
@@ -0,0 +1,80 @@
+# In FITS format:
+# Python string -> FITS card representation
+# "hello"      -> 'hello    '
+# "hello'"     -> 'hello''  '  (single quote is escaped as '')
+# "hello''"    -> 'hello'''' '  (two quotes are escaped as '''')
+# ""           -> ''          
+
+# When parsing back:
+# FITS 'hello    ' -> regex captures "hello    " -> strip -> "hello"
+# FITS 'hello''  ' -> regex captures "hello''  " -> replace '' with ' -> "hello'"
+# FITS 'hello'''''' -> regex captures "hello''''" -> replace '' with ' -> "hello''"
+# FITS ''         -> regex captures "" -> ""
+
+# The issue seems to be with CONTINUE cards specifically
+# Let's trace through what happens:
+
+# Original Python value: "x" * 65 + "''"
+# This has 67 characters ending with two single quotes
+
+# When formatted to FITS:
+# It needs to be 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''''
+# That's 1 + 65 + 4 + 1 = 71 chars for the quoted value
+# Plus "CONFIG  = " is 10 chars, total 81 chars
+# So it needs CONTINUE
+
+# First card:  CONFIG  = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''&'
+# Second card: CONTINUE  ''''
+
+# When parsing the CONTINUE card:
+# The value part is ''''
+# The regex matches '(.*)' and captures ''
+# Then replace("''", "'") converts it to '
+# But this is wrong! The captured '' represents a single quote in FITS format
+
+print("Testing FITS string format understanding:")
+import re
+
+_strg = r"\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )"
+strg_re = re.compile(_strg)
+
+# In _parse_value (line 771), it does:
+# value = re.sub("''", "'", m.group("strg"))
+# This is correct for converting FITS escaped quotes to Python
+
+# But in _split (line 862) for CONTINUE cards, it does:
+# value = value.rstrip().replace("''", "'")
+# This is ALSO trying to convert FITS escaped quotes
+
+# The issue is that both are doing the conversion!
+# When we have FITS string 'hello''''':
+# - The regex captures "hello''"
+# - _parse_value converts '' to ' giving "hello'"
+# But for CONTINUE cards in _split:
+# - The regex captures "''" from ''''
+# - Then it ALSO does replace giving "'"
+
+# So the fix is: in _split, we should NOT do the replace because
+# _parse_value will do it later when the full string is parsed
+
+test_cases = [
+    # (FITS representation, expected Python value)
+    ("''", ""),  # Empty string
+    ("''''", "'"),  # Single quote
+    ("''''''", "''"),  # Two quotes
+    ("'hello'''", "hello'"),  # String ending with quote
+    ("'hello'''''", "hello''"),  # String ending with two quotes
+]
+
+for fits_str, expected in test_cases:
+    m = strg_re.match(fits_str)
+    if m:
+        captured = m.group('strg')
+        # This is what _parse_value does
+        parsed = re.sub("''", "'", captured)
+        print(f"FITS: {fits_str:12} -> captured: {repr(captured):8} -> parsed: {repr(parsed):8} (expected: {repr(expected)})")
+        
+        # Now what _split does (wrongly)
+        split_result = captured.rstrip().replace("''", "'")
+        if split_result != parsed:
+            print(f"  WARNING: _split gives different result: {repr(split_result)}")
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..1c36059efc
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,54 @@
+import re
+
+# Test the current behavior
+_strg = r"\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )"
+_comm_field = r"(?P<comm_field>(?P<sepr>/ *)(?P<comm>(.|\n)*))"
+_strg_comment_RE = re.compile(f"({_strg})? *{_comm_field}?")
+
+# Test case: CONTINUE card with ''''
+vc = "''''"
+m = _strg_comment_RE.match(vc)
+if m:
+    value = m.group("strg") or ""
+    print(f"Original extracted value: '{value}'")
+    
+    # Current behavior - this is wrong!
+    value_current = value.rstrip().replace("''", "'")
+    print(f"Current behavior result: '{value_current}'")
+    
+    # The issue is that the regex already handles escaped quotes
+    # We should NOT do the replace on CONTINUE cards
+    # For the main card, line 771 in _parse_value does: value = re.sub("''", "'", m.group("strg"))
+    # This is correct because it's converting FITS escaped quotes to Python strings
+    
+    # But in _split for CONTINUE cards, we're double-processing
+    # The regex extracts the content between quotes, which for '''' is ''
+    # Then replace("''", "'") incorrectly converts it to '
+    
+    # The fix should be to remove the replace() call on line 862
+    value_fixed = value.rstrip()
+    print(f"Fixed behavior result: '{value_fixed}'")
+
+print("\n\nTest with actual string:")
+# When we have a string like "xxx''" in Python
+# It gets formatted in FITS as 'xxx''''
+# When split to CONTINUE, the tail becomes ''''
+# The regex correctly extracts '' from ''''
+# But then replace("''", "'") wrongly converts it to '
+
+test_values = [
+    ("''''", "Empty string escaped"),
+    ("'test'''", "String with trailing escaped quote"),
+    ("'test''test'", "String with escaped quote in middle"),
+]
+
+for test_val, desc in test_values:
+    print(f"\n{desc}: {test_val}")
+    m = _strg_comment_RE.match(test_val)
+    if m:
+        value = m.group("strg") or ""
+        print(f"  Regex extracted: '{value}'")
+        value_current = value.rstrip().replace("''", "'")
+        print(f"  Current (buggy): '{value_current}'")
+        value_fixed = value.rstrip()
+        print(f"  Fixed: '{value_fixed}'")
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..2a90fc7648
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,37 @@
+from astropy.io import fits
+
+# Test 1: Original test case
+print("Test 1: Double quotes at the end")
+for n in range(60, 70):
+    card1 = fits.Card('CONFIG', "x" * n + "''")
+    card2 = fits.Card.fromstring(str(card1))
+    print(n, len(card1.value), card1.value == card2.value)
+    if card1.value != card2.value:
+        print(f"  Card1 value: '{card1.value}'")
+        print(f"  Card2 value: '{card2.value}'")
+        print(f"  Card1 str: '{str(card1)}'")
+
+print("\nTest 2: Double quotes in the middle")
+for n in range(50, 70):
+    card1 = fits.Card('CONFIG', "x" * n + "''" + "x"*10)
+    card2 = fits.Card.fromstring(str(card1))
+    print(n, len(card1.value), card1.value == card2.value)
+    if card1.value != card2.value:
+        print(f"  Card1 value: '{card1.value}'")
+        print(f"  Card2 value: '{card2.value}'")
+
+print("\nTest 3: Analyze just card formatting")
+for n in [65, 67, 68, 69]:
+    card1 = fits.Card('CONFIG', "x" * n + "''")
+    print(f"\nn={n}:")
+    print(f"  Value: '{card1.value}'")
+    print(f"  Card string: '{str(card1)}'")
+    print(f"  Card length: {len(str(card1))}")
+    # Let's check what's happening with the trailing quote
+    card_str = str(card1)
+    if card_str.endswith("' "):
+        print("  Ends with single quote and space")
+    elif card_str.endswith("''"):
+        print("  Ends with double quotes")
+    elif card_str.rstrip().endswith("'"):
+        print("  Ends with single quote (after stripping)")
diff --git a/test_regex.py b/test_regex.py
new file mode 100644
index 0000000000..b96f119c91
--- /dev/null
+++ b/test_regex.py
@@ -0,0 +1,34 @@
+import re
+
+# The regex from card.py
+_strg = r"\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )"
+
+test_strings = [
+    "'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'''",
+    "'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''&'",
+    "''''"
+]
+
+strg_re = re.compile(_strg)
+
+for test_str in test_strings:
+    match = strg_re.match(test_str)
+    if match:
+        print(f"Input: {test_str}")
+        print(f"Matched strg: '{match.group('strg')}'")
+        # Apply the replacement from line 771
+        value = re.sub("''", "'", match.group('strg'))
+        print(f"After re.sub: '{value}'")
+        print()
+    else:
+        print(f"No match for: {test_str}")
+        print()
+
+# Let's look at the actual CONTINUE card string
+continue_str = "''''"
+print(f"\nAnalyzing CONTINUE card value: {continue_str}")
+match = strg_re.match(continue_str)
+if match:
+    print(f"Matched strg: '{match.group('strg')}'")
+    value = re.sub("''", "'", match.group('strg'))
+    print(f"After re.sub: '{value}'")
diff --git a/test_regex2.py b/test_regex2.py
new file mode 100644
index 0000000000..2d091a7947
--- /dev/null
+++ b/test_regex2.py
@@ -0,0 +1,55 @@
+import re
+
+# The regex from card.py
+_strg = r"\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )"
+
+# Let's break down the regex pattern:
+# \' - Match a single quote at the start
+# (?P<strg>(...)) - Named capture group 'strg'
+#   [ -~]+? - One or more printable ASCII chars (non-greedy)
+#   | - OR  
+#   \'\' - Two single quotes
+#   | - OR
+#   (empty) - Nothing
+#   *? - Zero or more spaces (non-greedy)
+# \' - Match a single quote at the end
+# (?=$|/| ) - Lookahead: end of string, slash, or space
+
+# The issue is that the regex matches greedily and includes the double quotes
+
+# Let's test different patterns
+test_cases = [
+    ("''''", "Empty string with escaped quotes"),
+    ("'''&'", "Empty string with continuation &"),
+    ("'test'''", "String ending with escaped quote"),
+    ("'test''&'", "String ending with escaped quote and continuation"),
+]
+
+strg_re = re.compile(_strg)
+
+for test_str, desc in test_cases:
+    print(f"\nTest: {test_str} ({desc})")
+    match = strg_re.match(test_str)
+    if match:
+        captured = match.group('strg')
+        print(f"  Captured: '{captured}'")
+        value = re.sub("''", "'", captured)
+        print(f"  After re.sub: '{value}'")
+        
+        # Show what the string looks like in the regex
+        print(f"  Full match: '{match.group(0)}'")
+        print(f"  Start: {match.start()}, End: {match.end()}")
+    else:
+        print("  No match!")
+
+# Now let's see what happens when parsing a full CONTINUE card
+print("\n\nFull CONTINUE card parsing:")
+continue_card = "CONTINUE  ''''                                                                  "
+# Extract the value part (after position 10)
+value_part = continue_card[10:].strip()
+print(f"Value part: '{value_part}'")
+match = strg_re.match(value_part)
+if match:
+    print(f"Matched strg: '{match.group('strg')}'")
+    value = re.sub("''", "'", match.group('strg'))
+    print(f"After re.sub: '{value}'")
