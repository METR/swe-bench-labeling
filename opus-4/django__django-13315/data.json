{"instance_id": "django__django-13315", "score": "C", "diff": "diff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a1..f993bb9c98 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -100,7 +100,7 @@ def apply_limit_choices_to_to_formfield(formfield):\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n         if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to).distinct()\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\ndiff --git a/test_limit_choices_to_distinct.py b/test_limit_choices_to_distinct.py\nnew file mode 100644\nindex 0000000000..1675b62eba\n--- /dev/null\n+++ b/test_limit_choices_to_distinct.py\n@@ -0,0 +1,62 @@\n+\"\"\"\n+Test for limit_choices_to with Q objects involving joins to ensure no duplicates.\n+\"\"\"\n+from django import forms\n+from django.db import models\n+from django.test import TestCase\n+from django.forms.models import modelform_factory\n+\n+\n+class LimitChoicesDistinctTests(TestCase):\n+    \"\"\"\n+    Test that limit_choices_to with Q objects on ForeignKey fields \n+    doesn't produce duplicate options when the query involves joins.\n+    \"\"\"\n+    \n+    def test_limit_choices_to_q_object_no_duplicates(self):\n+        \"\"\"\n+        When using limit_choices_to with a Q object that involves joins,\n+        the resulting queryset should not contain duplicates.\n+        \"\"\"\n+        # Create test models\n+        class Tag(models.Model):\n+            name = models.CharField(max_length=50)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+        \n+        class Article(models.Model):\n+            title = models.CharField(max_length=100)\n+            tags = models.ManyToManyField(Tag)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+        \n+        class Comment(models.Model):\n+            article = models.ForeignKey(\n+                Article, \n+                on_delete=models.CASCADE,\n+                limit_choices_to=models.Q(tags__name='important')\n+            )\n+            text = models.TextField()\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+        \n+        # Create test data\n+        tag1 = Tag.objects.create(name='important')\n+        tag2 = Tag.objects.create(name='important')\n+        article = Article.objects.create(title='Test Article')\n+        article.tags.add(tag1, tag2)\n+        \n+        # Create form and check queryset\n+        CommentForm = modelform_factory(Comment, fields=['article', 'text'])\n+        form = CommentForm()\n+        \n+        # The article should appear only once in the queryset\n+        article_list = list(form.fields['article'].queryset)\n+        self.assertEqual(len(article_list), 1)\n+        self.assertEqual(article_list[0], article)\n+        \n+        # Verify the queryset is distinct\n+        self.assertEqual(form.fields['article'].queryset.count(), 1)\ndiff --git a/test_limit_choices_to_duplicates.py b/test_limit_choices_to_duplicates.py\nnew file mode 100644\nindex 0000000000..46c88dfb09\n--- /dev/null\n+++ b/test_limit_choices_to_duplicates.py\n@@ -0,0 +1,86 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Now create test models\n+from django.db import models\n+from django.forms.models import modelform_factory\n+\n+class Tag(models.Model):\n+    name = models.CharField(max_length=50)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Article(models.Model):\n+    title = models.CharField(max_length=100)\n+    tags = models.ManyToManyField(Tag)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Comment(models.Model):\n+    article = models.ForeignKey(\n+        Article, \n+        on_delete=models.CASCADE,\n+        limit_choices_to=models.Q(tags__name='important')\n+    )\n+    text = models.TextField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Tag)\n+    schema_editor.create_model(Article)\n+    schema_editor.create_model(Comment)\n+\n+# Create test data\n+tag1 = Tag.objects.create(name='important')\n+tag2 = Tag.objects.create(name='important')  # Another tag with same name\n+tag3 = Tag.objects.create(name='not-important')\n+article = Article.objects.create(title='Test Article')\n+article.tags.add(tag1, tag2)  # Adding two tags that match the filter\n+\n+# Create a form\n+CommentForm = modelform_factory(Comment, fields=['article', 'text'])\n+form = CommentForm()\n+\n+# Check the queryset\n+queryset = form.fields['article'].queryset\n+print(f\"Queryset SQL: {queryset.query}\")\n+print(f\"Number of items in queryset: {queryset.count()}\")\n+print(f\"Items: {list(queryset)}\")\n+\n+# Check if duplicates exist\n+from collections import Counter\n+article_ids = [a.id for a in queryset]\n+print(f\"Article IDs: {article_ids}\")\n+duplicates = [item for item, count in Counter(article_ids).items() if count > 1]\n+if duplicates:\n+    print(f\"DUPLICATES FOUND: {duplicates}\")\n+else:\n+    print(\"No duplicates found\")\n", "gold_standard_diff": "From 556fa4bbba5ba86bc1646a86fb11ab55405d4aa4 Mon Sep 17 00:00:00 2001\nFrom: alvinshaita <alvinshaita@gmail.com>\nDate: Mon, 17 Aug 2020 06:39:10 +0300\nSubject: [PATCH] Fixed #1891, Fixed #11707 -- Prevented duplicates with\n limit_choices_to on multi-value relations.\n\n---\n django/forms/models.py      | 12 +++++--\n tests/model_forms/models.py |  9 +++--\n tests/model_forms/tests.py  | 67 +++++++++++++++++++++++++++++++++++++\n 3 files changed, 84 insertions(+), 4 deletions(-)\n\ndiff --git a/django/forms/models.py b/django/forms/models.py\nindex 5d115458a131..0591cdf338de 100644\n--- a/django/forms/models.py\n+++ b/django/forms/models.py\n@@ -97,10 +97,18 @@ def model_to_dict(instance, fields=None, exclude=None):\n \n def apply_limit_choices_to_to_formfield(formfield):\n     \"\"\"Apply limit_choices_to to the formfield's queryset if needed.\"\"\"\n+    from django.db.models import Exists, OuterRef, Q\n     if hasattr(formfield, 'queryset') and hasattr(formfield, 'get_limit_choices_to'):\n         limit_choices_to = formfield.get_limit_choices_to()\n-        if limit_choices_to is not None:\n-            formfield.queryset = formfield.queryset.complex_filter(limit_choices_to)\n+        if limit_choices_to:\n+            complex_filter = limit_choices_to\n+            if not isinstance(complex_filter, Q):\n+                complex_filter = Q(**limit_choices_to)\n+            complex_filter &= Q(pk=OuterRef('pk'))\n+            # Use Exists() to avoid potential duplicates.\n+            formfield.queryset = formfield.queryset.filter(\n+                Exists(formfield.queryset.model._base_manager.filter(complex_filter)),\n+            )\n \n \n def fields_for_model(model, fields=None, exclude=None, widgets=None,\ndiff --git a/tests/model_forms/models.py b/tests/model_forms/models.py\nindex 1a2102f89889..4e9ed2b1e435 100644\n--- a/tests/model_forms/models.py\n+++ b/tests/model_forms/models.py\n@@ -411,9 +411,14 @@ class StumpJoke(models.Model):\n         Character,\n         models.CASCADE,\n         limit_choices_to=today_callable_dict,\n-        related_name=\"+\",\n+        related_name='jokes',\n     )\n-    has_fooled_today = models.ManyToManyField(Character, limit_choices_to=today_callable_q, related_name=\"+\")\n+    has_fooled_today = models.ManyToManyField(\n+        Character,\n+        limit_choices_to=today_callable_q,\n+        related_name='jokes_today',\n+    )\n+    funny = models.BooleanField(default=False)\n \n \n # Model for #13776\ndiff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 9e900e35f48b..d7bd768e7bd5 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -16,6 +16,7 @@\n )\n from django.template import Context, Template\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.test.utils import isolate_apps\n \n from .models import (\n     Article, ArticleStatus, Author, Author1, Award, BetterWriter, BigInt, Book,\n@@ -2829,6 +2830,72 @@ def test_callable_called_each_time_form_is_instantiated(self):\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates(self):\n+        joke1 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke2 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke3 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.marley,\n+        )\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+\n \n class FormFieldCallbackTests(SimpleTestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/13315"}