{"instance_id": "django__django-13568", "score": "C", "diff": "diff --git a/django/contrib/auth/checks.py b/django/contrib/auth/checks.py\nindex 65fc266f7e..c153dbf9ad 100644\n--- a/django/contrib/auth/checks.py\n+++ b/django/contrib/auth/checks.py\n@@ -52,7 +52,25 @@ def check_user_model(app_configs=None, **kwargs):\n         )\n \n     # Check that the username field is unique\n-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:\n+    username_field = cls._meta.get_field(cls.USERNAME_FIELD)\n+    \n+    # Check if field has unique=True\n+    is_unique = username_field.unique\n+    \n+    # Check if field is part of a UniqueConstraint\n+    if not is_unique:\n+        from django.db.models import UniqueConstraint\n+        for constraint in cls._meta.constraints:\n+            if isinstance(constraint, UniqueConstraint) and constraint.condition is None:\n+                # Check if USERNAME_FIELD is in the constraint fields\n+                if cls.USERNAME_FIELD in constraint.fields:\n+                    # Check if it's a single field constraint (equivalent to unique=True)\n+                    # or part of a composite unique constraint\n+                    if len(constraint.fields) == 1:\n+                        is_unique = True\n+                        break\n+    \n+    if not is_unique:\n         if (settings.AUTHENTICATION_BACKENDS ==\n                 ['django.contrib.auth.backends.ModelBackend']):\n             errors.append(\ndiff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex cfaa4063f8..edbb2e2412 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -85,6 +85,82 @@ class UserModelChecksTests(SimpleTestCase):\n                 ),\n             ])\n \n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserWithUniqueConstraint')\n+    def test_username_unique_with_constraint(self):\n+        \"\"\"\n+        USERNAME_FIELD defined with UniqueConstraint should not raise auth.E003.\n+        \"\"\"\n+        from django.db.models import UniqueConstraint\n+        \n+        class CustomUserWithUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+            \n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='username_unique')\n+                ]\n+        \n+        # After our fix, UniqueConstraint should be recognized and no errors should be raised\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [])\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserWithCompositeUniqueConstraint')\n+    def test_username_with_composite_unique_constraint(self):\n+        \"\"\"\n+        USERNAME_FIELD in a composite UniqueConstraint should still raise auth.E003.\n+        \"\"\"\n+        from django.db.models import UniqueConstraint\n+        \n+        class CustomUserWithCompositeUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            domain = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+            \n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username', 'domain'], name='username_domain_unique')\n+                ]\n+        \n+        # Composite constraints should still trigger the error since username alone is not unique\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [\n+            checks.Error(\n+                \"'CustomUserWithCompositeUniqueConstraint.username' must be \"\n+                \"unique because it is named as the 'USERNAME_FIELD'.\",\n+                obj=CustomUserWithCompositeUniqueConstraint,\n+                id='auth.E003',\n+            ),\n+        ])\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserWithConditionalUniqueConstraint')\n+    def test_username_with_conditional_unique_constraint(self):\n+        \"\"\"\n+        USERNAME_FIELD in a conditional UniqueConstraint should still raise auth.E003.\n+        \"\"\"\n+        from django.db.models import UniqueConstraint, Q\n+        \n+        class CustomUserWithConditionalUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            is_active = models.BooleanField(default=True)\n+            USERNAME_FIELD = 'username'\n+            \n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], condition=Q(is_active=True), name='username_unique_active')\n+                ]\n+        \n+        # Conditional constraints should still trigger the error since it's not unconditionally unique\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [\n+            checks.Error(\n+                \"'CustomUserWithConditionalUniqueConstraint.username' must be \"\n+                \"unique because it is named as the 'USERNAME_FIELD'.\",\n+                obj=CustomUserWithConditionalUniqueConstraint,\n+                id='auth.E003',\n+            ),\n+        ])\n+\n     @override_settings(AUTH_USER_MODEL='auth_tests.BadUser')\n     def test_is_anonymous_authenticated_methods(self):\n         \"\"\"\n", "gold_standard_diff": "From f7963615eb7286fa8bff9b294c28452cf13738d0 Mon Sep 17 00:00:00 2001\nFrom: Hannes Ljungberg <hannes.ljungberg@gmail.com>\nDate: Mon, 19 Oct 2020 16:15:17 +0200\nSubject: [PATCH] Fixed #32121 -- Fixed detecting uniqueness of USERNAME_FIELD\n when using Meta.constraints.\n\nCo-authored-by: Simon Charette <charettes@users.noreply.github.com>\n---\n django/contrib/auth/checks.py   |  5 ++-\n tests/auth_tests/test_checks.py | 56 +++++++++++++++++++++++++++++++++\n 2 files changed, 60 insertions(+), 1 deletion(-)\n\ndiff --git a/django/contrib/auth/checks.py b/django/contrib/auth/checks.py\nindex 65fc266f7e0b..c08ed8a49a7b 100644\n--- a/django/contrib/auth/checks.py\n+++ b/django/contrib/auth/checks.py\n@@ -52,7 +52,10 @@ def check_user_model(app_configs=None, **kwargs):\n         )\n \n     # Check that the username field is unique\n-    if not cls._meta.get_field(cls.USERNAME_FIELD).unique:\n+    if not cls._meta.get_field(cls.USERNAME_FIELD).unique and not any(\n+        constraint.fields == (cls.USERNAME_FIELD,)\n+        for constraint in cls._meta.total_unique_constraints\n+    ):\n         if (settings.AUTHENTICATION_BACKENDS ==\n                 ['django.contrib.auth.backends.ModelBackend']):\n             errors.append(\ndiff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex cfaa4063f83f..4dc1ef4aec6b 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -4,6 +4,7 @@\n from django.contrib.auth.models import AbstractBaseUser\n from django.core import checks\n from django.db import models\n+from django.db.models import Q, UniqueConstraint\n from django.test import (\n     SimpleTestCase, override_settings, override_system_checks,\n )\n@@ -85,6 +86,61 @@ def test_username_non_unique(self):\n                 ),\n             ])\n \n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserPartiallyUnique')\n+    def test_username_partially_unique(self):\n+        class CustomUserPartiallyUnique(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(\n+                        fields=['username'],\n+                        name='partial_username_unique',\n+                        condition=Q(password__isnull=False),\n+                    ),\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [\n+            checks.Error(\n+                \"'CustomUserPartiallyUnique.username' must be unique because \"\n+                \"it is named as the 'USERNAME_FIELD'.\",\n+                obj=CustomUserPartiallyUnique,\n+                id='auth.E003',\n+            ),\n+        ])\n+        with self.settings(AUTHENTICATION_BACKENDS=['my.custom.backend']):\n+            errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+            self.assertEqual(errors, [\n+                checks.Warning(\n+                    \"'CustomUserPartiallyUnique.username' is named as the \"\n+                    \"'USERNAME_FIELD', but it is not unique.\",\n+                    hint=(\n+                        'Ensure that your authentication backend(s) can '\n+                        'handle non-unique usernames.'\n+                    ),\n+                    obj=CustomUserPartiallyUnique,\n+                    id='auth.W004',\n+                ),\n+            ])\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserUniqueConstraint')\n+    def test_username_unique_with_model_constraint(self):\n+        class CustomUserUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='username_unique'),\n+                ]\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+        with self.settings(AUTHENTICATION_BACKENDS=['my.custom.backend']):\n+            errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+            self.assertEqual(errors, [])\n+\n     @override_settings(AUTH_USER_MODEL='auth_tests.BadUser')\n     def test_is_anonymous_authenticated_methods(self):\n         \"\"\"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13568"}