From 34664ce4ce2ee298d57137a0f94961b45d3f043f Mon Sep 17 00:00:00 2001
From: Takeshi KOMIYA <i.tkomiya@gmail.com>
Date: Thu, 2 Sep 2021 02:25:31 +0900
Subject: [PATCH] Fix #9576: py domain: Literal typehint was converted to a
 cross reference

The content of Literal typehint should not be converted to cross
references.
---
 CHANGES                  |  1 +
 sphinx/domains/python.py | 12 ++++++++++--
 tests/test_domain_py.py  | 21 +++++++++++++++++++++
 3 files changed, 32 insertions(+), 2 deletions(-)

diff --git a/CHANGES b/CHANGES
index c7e781de868..33487cacaf3 100644
--- a/CHANGES
+++ b/CHANGES
@@ -40,6 +40,7 @@ Bugs fixed
 * #9267: html theme: CSS and JS files added by theme were loaded twice
 * #9585: py domain: ``:type:`` option for :rst:dir:`py:property` directive does
   not create a hyperlink
+* #9576: py domain: Literal typehint was converted to a cross reference
 * #9535 comment: C++, fix parsing of defaulted function parameters that are
   function pointers.
 * #9564: smartquotes: don't adjust typography for text with
diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index 9875a9f4b65..ee93edfce7b 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -123,7 +123,7 @@ def unparse(node: ast.AST) -> List[Node]:
             if node.value is Ellipsis:
                 return [addnodes.desc_sig_punctuation('', "...")]
             else:
-                return [nodes.Text(node.value)]
+                return [nodes.Text(repr(node.value))]
         elif isinstance(node, ast.Expr):
             return unparse(node.value)
         elif isinstance(node, ast.Index):
@@ -149,6 +149,12 @@ def unparse(node: ast.AST) -> List[Node]:
             result.append(addnodes.desc_sig_punctuation('', '['))
             result.extend(unparse(node.slice))
             result.append(addnodes.desc_sig_punctuation('', ']'))
+
+            # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal
+            if result[0] in ('Literal', 'typing.Literal'):
+                for i, subnode in enumerate(result[1:], start=1):
+                    if isinstance(subnode, nodes.Text):
+                        result[i] = nodes.literal('', '', subnode)
             return result
         elif isinstance(node, ast.Tuple):
             if node.elts:
@@ -179,7 +185,9 @@ def unparse(node: ast.AST) -> List[Node]:
         tree = ast_parse(annotation)
         result = unparse(tree)
         for i, node in enumerate(result):
-            if isinstance(node, nodes.Text) and node.strip():
+            if isinstance(node, nodes.literal):
+                result[i] = node[0]
+            elif isinstance(node, nodes.Text) and node.strip():
                 result[i] = type_to_xref(str(node), env)
         return result
     except SyntaxError:
diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py
index 067febcf495..b111e5276c0 100644
--- a/tests/test_domain_py.py
+++ b/tests/test_domain_py.py
@@ -342,6 +342,27 @@ def test_parse_annotation(app):
     assert_node(doctree[0], pending_xref, refdomain="py", reftype="obj", reftarget="None")
 
 
+@pytest.mark.skipif(sys.version_info < (3, 8), reason='python 3.8+ is required.')
+def test_parse_annotation_Literal(app):
+    doctree = _parse_annotation("Literal[True, False]", app.env)
+    assert_node(doctree, ([pending_xref, "Literal"],
+                          [desc_sig_punctuation, "["],
+                          "True",
+                          [desc_sig_punctuation, ", "],
+                          "False",
+                          [desc_sig_punctuation, "]"]))
+
+    doctree = _parse_annotation("typing.Literal[0, 1, 'abc']", app.env)
+    assert_node(doctree, ([pending_xref, "typing.Literal"],
+                          [desc_sig_punctuation, "["],
+                          "0",
+                          [desc_sig_punctuation, ", "],
+                          "1",
+                          [desc_sig_punctuation, ", "],
+                          "'abc'",
+                          [desc_sig_punctuation, "]"]))
+
+
 def test_pyfunction_signature(app):
     text = ".. py:function:: hello(name: str) -> str"
     doctree = restructuredtext.parse(app, text)
