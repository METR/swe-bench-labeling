{"instance_id": "django__django-13344", "score": "I", "diff": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..b0a46ccbce\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,109 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.exception import convert_exception_to_response\n+from asgiref.sync import sync_to_async\n+\n+\n+# The actual issue happens when Django's middleware loading creates this scenario:\n+# 1. An async handler/middleware is wrapped in convert_exception_to_response\n+# 2. That becomes the get_response for the next middleware\n+# 3. The next middleware's __call__ returns a coroutine\n+# 4. That coroutine is then passed as get_response to another middleware\n+# 5. When THAT middleware is wrapped by convert_exception_to_response, it sees\n+#    the get_response is NOT a coroutine function (it's a middleware instance)\n+# 6. So it creates a sync wrapper\n+# 7. The sync wrapper calls the middleware, which returns a coroutine\n+# 8. That coroutine gets passed to process_response of the first middleware!\n+\n+class FirstMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"\\nFirstMiddleware.process_response:\")\n+        print(f\"  - response type: {type(response)}\")\n+        print(f\"  - is coroutine: {asyncio.iscoroutine(response)}\")\n+        if asyncio.iscoroutine(response):\n+            print(\"\\n*** BUG REPRODUCED: FirstMiddleware received a coroutine! ***\")\n+        return response\n+\n+\n+class SecondMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"\\nSecondMiddleware.process_response:\")\n+        print(f\"  - response type: {type(response)}\")\n+        return response\n+\n+\n+def reproduce_issue():\n+    print(\"=== Reproducing the Django ASGI Middleware Issue ===\\n\")\n+    \n+    # Step 1: Create an async view\n+    async def view(request):\n+        print(\"View executed\")\n+        return HttpResponse(\"Hello World\")\n+    \n+    # Step 2: Wrap it like Django does\n+    handler = convert_exception_to_response(view)\n+    print(f\"1. view wrapped, handler is coroutine function: {asyncio.iscoroutinefunction(handler)}\")\n+    \n+    # Step 3: Create SecondMiddleware with this async handler\n+    second_mw = SecondMiddleware(handler)\n+    print(f\"2. SecondMiddleware created, it is coroutine function: {asyncio.iscoroutinefunction(second_mw)}\")\n+    print(f\"   second_mw.get_response is coroutine function: {asyncio.iscoroutinefunction(second_mw.get_response)}\")\n+    \n+    # Step 4: Wrap SecondMiddleware with convert_exception_to_response\n+    # This is where the issue starts - convert_exception_to_response sees second_mw\n+    # is NOT a coroutine function (even though calling it returns a coroutine)\n+    handler = convert_exception_to_response(second_mw)\n+    print(f\"3. SecondMiddleware wrapped, handler is coroutine function: {asyncio.iscoroutinefunction(handler)}\")\n+    \n+    # Step 5: Create FirstMiddleware\n+    first_mw = FirstMiddleware(handler)\n+    print(f\"4. FirstMiddleware created\")\n+    \n+    # Now simulate what happens when this chain is called\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    print(\"\\n=== Calling the middleware chain ===\")\n+    \n+    # The first middleware is called\n+    # Since its get_response is NOT a coroutine function (it's the sync wrapper from step 4)\n+    # it goes through the sync path in __call__\n+    print(\"\\nFirstMiddleware.__call__ executes...\")\n+    print(f\"  - first_mw.get_response is coroutine function: {asyncio.iscoroutinefunction(first_mw.get_response)}\")\n+    \n+    # This will call the sync path which calls self.get_response(request)\n+    # But self.get_response is the sync wrapper from convert_exception_to_response\n+    # That sync wrapper will call second_mw(request), which returns a coroutine!\n+    \n+    # Let's trace this manually:\n+    print(\"\\nManually tracing the issue:\")\n+    \n+    # first_mw.__call__ sync path calls:\n+    response = first_mw.get_response(request)  # This is the sync wrapper\n+    print(f\"\\n5. first_mw.get_response(request) returned: {type(response)}\")\n+    print(f\"   Is coroutine: {asyncio.iscoroutine(response)}\")\n+    \n+    if asyncio.iscoroutine(response):\n+        print(\"\\n*** The sync wrapper returned a coroutine! ***\")\n+        print(\"*** This coroutine will be passed to process_response ***\")\n+    \n+    # Now first_mw.process_response gets called with this coroutine\n+    if hasattr(first_mw, 'process_response'):\n+        first_mw.process_response(request, response)\n+\n+\n+if __name__ == \"__main__\":\n+    reproduce_issue()\ndiff --git a/test_coroutine_issue.py b/test_coroutine_issue.py\nnew file mode 100644\nindex 0000000000..dbddbc6488\n--- /dev/null\n+++ b/test_coroutine_issue.py\n@@ -0,0 +1,87 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.exception import convert_exception_to_response\n+\n+\n+class TestMiddleware(MiddlewareMixin):\n+    def __init__(self, get_response):\n+        super().__init__(get_response)\n+        print(f\"TestMiddleware init: get_response is coroutine function? {asyncio.iscoroutinefunction(get_response)}\")\n+    \n+    def process_response(self, request, response):\n+        print(f\"TestMiddleware.process_response: response type = {type(response)}\")\n+        print(f\"Is coroutine? {asyncio.iscoroutine(response)}\")\n+        return response\n+\n+\n+async def test_direct_call():\n+    # Create an async handler\n+    async def async_handler(request):\n+        return HttpResponse(\"Hello\")\n+    \n+    # Wrap it as Django does\n+    handler = convert_exception_to_response(async_handler)\n+    \n+    # Create middleware  \n+    middleware = TestMiddleware(handler)\n+    \n+    # Test calling the middleware directly (not awaiting)\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    print(\"\\n=== Testing direct middleware call ===\")\n+    result = middleware(request)\n+    print(f\"Result type: {type(result)}\")\n+    print(f\"Is coroutine? {asyncio.iscoroutine(result)}\")\n+    \n+    if asyncio.iscoroutine(result):\n+        print(\"\\nAwaiting the coroutine...\")\n+        final_result = await result\n+        print(f\"Final result type: {type(final_result)}\")\n+\n+\n+def test_sync_call():\n+    # Create a sync handler\n+    def sync_handler(request):\n+        return HttpResponse(\"Hello\")\n+    \n+    # Wrap it\n+    handler = convert_exception_to_response(sync_handler)\n+    \n+    # Create middleware  \n+    middleware = TestMiddleware(handler)\n+    \n+    # Test calling the middleware\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    print(\"\\n=== Testing sync middleware call ===\")\n+    result = middleware(request)\n+    print(f\"Result type: {type(result)}\")\n+    print(f\"Is coroutine? {asyncio.iscoroutine(result)}\")\n+\n+\n+if __name__ == \"__main__\":\n+    # Test sync version\n+    test_sync_call()\n+    \n+    # Test async version\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    loop.run_until_complete(test_direct_call())\ndiff --git a/test_final_issue.py b/test_final_issue.py\nnew file mode 100644\nindex 0000000000..4e641c2a20\n--- /dev/null\n+++ b/test_final_issue.py\n@@ -0,0 +1,115 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings first\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.exception import convert_exception_to_response\n+\n+\n+# Create an async handler that mimics Django's _get_response_async\n+async def async_handler(request):\n+    print(\"async_handler called\")\n+    return HttpResponse(\"Test\")\n+\n+\n+# Manual simulation of Django's load_middleware for 2 middlewares\n+def test_issue():\n+    print(\"=== Simulating Django's load_middleware ===\\n\")\n+    \n+    class FirstMiddleware(MiddlewareMixin):\n+        def process_response(self, request, response):\n+            print(f\"FirstMiddleware.process_response: response type = {type(response)}\")\n+            if asyncio.iscoroutine(response):\n+                print(\"!!! BUG: FirstMiddleware received a coroutine in process_response !!!\")\n+            return response\n+\n+    class SecondMiddleware(MiddlewareMixin):\n+        def process_response(self, request, response):\n+            print(f\"SecondMiddleware.process_response: response type = {type(response)}\")\n+            return response\n+    \n+    # Start with async handler wrapped in convert_exception_to_response\n+    handler = convert_exception_to_response(async_handler)\n+    \n+    # Create SecondMiddleware instance\n+    second_mw = SecondMiddleware(handler)\n+    \n+    # THIS IS THE KEY: convert_exception_to_response wraps the middleware instance\n+    # When the middleware has an async get_response, its __call__ returns a coroutine\n+    handler = convert_exception_to_response(second_mw)\n+    \n+    # Create FirstMiddleware instance  \n+    first_mw = FirstMiddleware(handler)\n+    \n+    # No final adapt_method_mode for the first middleware in Django's implementation\n+    \n+    # Now let's trace what happens\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    # When ASGIHandler calls the middleware chain...\n+    print(\"Starting the middleware chain...\\n\")\n+    \n+    # Check what first_mw's get_response is\n+    print(f\"first_mw.get_response is async? {asyncio.iscoroutinefunction(first_mw.get_response)}\")\n+    \n+    # This will trigger first_mw.__call__ which will return __acall__ coroutine\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    \n+    async def run_chain():\n+        # This is what ASGIHandler does - it awaits the result\n+        result = await first_mw(request)\n+        print(f\"\\nFinal result type: {type(result)}\")\n+    \n+    loop.run_until_complete(run_chain())\n+\n+\n+# But wait, let me also check what happens when we don't await in between\n+def test_unwrapped_call():\n+    print(\"\\n\\n=== Testing what happens with sync middleware adapter ===\\n\")\n+    \n+    class TestMiddleware(MiddlewareMixin):\n+        def process_response(self, request, response):\n+            print(f\"TestMiddleware.process_response called with: {type(response)}\")\n+            if asyncio.iscoroutine(response):\n+                print(\"!!! ERROR: Received coroutine in process_response !!!\")\n+            return response\n+    \n+    # Create async handler\n+    async def handler(request):\n+        return HttpResponse(\"Test\")\n+    \n+    # Wrap it\n+    wrapped_handler = convert_exception_to_response(handler)\n+    \n+    # Create middleware\n+    mw = TestMiddleware(wrapped_handler)\n+    \n+    # The issue: What if something calls mw synchronously but doesn't await?\n+    # This could happen with adapters\n+    \n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    # This returns a coroutine because __call__ returns __acall__\n+    result = mw(request)\n+    print(f\"Direct call to middleware returns: {type(result)}\")\n+    \n+\n+if __name__ == \"__main__\":\n+    test_issue()\n+    test_unwrapped_call()\ndiff --git a/test_middleware_async.py b/test_middleware_async.py\nnew file mode 100644\nindex 0000000000..857e330d88\n--- /dev/null\n+++ b/test_middleware_async.py\n@@ -0,0 +1,67 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+\n+\n+class DummyMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"DummyMiddleware.process_response: request={request.__class__}, response={response.__class__}\")\n+        print(f\"Is coroutine? {asyncio.iscoroutine(response)}\")\n+        return response\n+\n+\n+class SecondDummyMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"SecondDummyMiddleware.process_response: request={request.__class__}, response={response.__class__}\")\n+        print(f\"Is coroutine? {asyncio.iscoroutine(response)}\")\n+        return response\n+\n+\n+# Simulate Django's middleware loading\n+def test_middleware_chain():\n+    # Import convert_exception_to_response like Django does\n+    from django.core.handlers.exception import convert_exception_to_response\n+    \n+    # Create a simple view that returns HttpResponse\n+    async def view(request):\n+        return HttpResponse(\"Hello\")\n+    \n+    # Create middleware instances with convert_exception_to_response wrapper\n+    # This mimics what Django does in load_middleware\n+    handler = convert_exception_to_response(view)\n+    second_middleware = SecondDummyMiddleware(handler)\n+    handler = convert_exception_to_response(second_middleware)\n+    first_middleware = DummyMiddleware(handler)\n+    \n+    # Create a mock request\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    # Call the middleware chain\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    \n+    # Test async mode\n+    if asyncio.iscoroutinefunction(first_middleware.get_response):\n+        response = loop.run_until_complete(first_middleware(request))\n+    else:\n+        response = first_middleware(request)\n+    \n+    print(f\"Final response: {response.__class__}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_middleware_chain()\ndiff --git a/test_middleware_chain.py b/test_middleware_chain.py\nnew file mode 100644\nindex 0000000000..46a3810263\n--- /dev/null\n+++ b/test_middleware_chain.py\n@@ -0,0 +1,70 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.exception import convert_exception_to_response\n+\n+\n+class FirstMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"FirstMiddleware.process_response: response type = {type(response)}\")\n+        print(f\"Is coroutine? {asyncio.iscoroutine(response)}\")\n+        if asyncio.iscoroutine(response):\n+            print(\"ERROR: FirstMiddleware received a coroutine instead of HttpResponse!\")\n+        return response\n+\n+\n+class SecondMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"SecondMiddleware.process_response: response type = {type(response)}\")\n+        print(f\"Is coroutine? {asyncio.iscoroutine(response)}\")\n+        return response\n+\n+\n+async def test_middleware_loading():\n+    # This simulates Django's load_middleware process\n+    \n+    # 1. Start with the core handler (simulating _get_response_async)\n+    async def core_handler(request):\n+        print(\"Core handler called\")\n+        return HttpResponse(\"Hello World\")\n+    \n+    # 2. Wrap with convert_exception_to_response\n+    handler = convert_exception_to_response(core_handler)\n+    handler_is_async = True\n+    \n+    # 3. Add SecondMiddleware (reverse order)\n+    mw_instance = SecondMiddleware(handler)\n+    handler = convert_exception_to_response(mw_instance)\n+    \n+    # 4. Add FirstMiddleware\n+    mw_instance = FirstMiddleware(handler)\n+    # No wrapping for the outermost middleware\n+    \n+    # Now test the chain\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    # Call the middleware chain\n+    print(\"=== Starting middleware chain ===\")\n+    response = await mw_instance(request)\n+    print(f\"Final response type: {type(response)}\")\n+    print(\"=== End middleware chain ===\")\n+\n+\n+if __name__ == \"__main__\":\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    loop.run_until_complete(test_middleware_loading())\ndiff --git a/test_middleware_chain_issue.py b/test_middleware_chain_issue.py\nnew file mode 100644\nindex 0000000000..2e17994787\n--- /dev/null\n+++ b/test_middleware_chain_issue.py\n@@ -0,0 +1,91 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.exception import convert_exception_to_response\n+\n+\n+class FirstMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"FirstMiddleware.process_response: response type = {type(response)}\")\n+        if asyncio.iscoroutine(response):\n+            print(\"ERROR: FirstMiddleware received a coroutine instead of HttpResponse!\")\n+        return response\n+\n+\n+class SecondMiddleware(MiddlewareMixin):  \n+    def process_response(self, request, response):\n+        print(f\"SecondMiddleware.process_response: response type = {type(response)}\")\n+        return response\n+\n+\n+async def test_nested_middleware_issue():\n+    print(\"=== Testing the nested middleware coroutine issue ===\\n\")\n+    \n+    # Create async view\n+    async def view(request):\n+        print(\"View called\")\n+        return HttpResponse(\"Hello\")\n+    \n+    # Wrap view\n+    handler = convert_exception_to_response(view)\n+    \n+    # Create second middleware with async handler\n+    second_mw = SecondMiddleware(handler)\n+    \n+    # NOW HERE'S THE KEY: What if FirstMiddleware tries to call second_mw directly?\n+    # This simulates what might happen in complex middleware setups\n+    \n+    class FirstMiddlewareWithDirectCall(MiddlewareMixin):\n+        def __init__(self, get_response):\n+            super().__init__(get_response)\n+            self.second_mw = second_mw\n+            \n+        def process_response(self, request, response):\n+            print(f\"FirstMiddlewareWithDirectCall.process_response: response type = {type(response)}\")\n+            if asyncio.iscoroutine(response):\n+                print(\"ERROR: FirstMiddleware received a coroutine instead of HttpResponse!\")\n+            return response\n+            \n+        async def __acall__(self, request):\n+            # Instead of calling self.get_response, imagine it calls second_mw directly\n+            # This could happen in custom middleware logic\n+            response = self.second_mw(request)  # This returns a coroutine!\n+            print(f\"After calling second_mw: response type = {type(response)}\")\n+            \n+            if hasattr(self, 'process_response'):\n+                # Now process_response gets a coroutine!\n+                response = await sync_to_async(\n+                    self.process_response,\n+                    thread_sensitive=True,\n+                )(request, response)\n+            return response\n+    \n+    from asgiref.sync import sync_to_async\n+    \n+    # Create the problematic middleware\n+    first_mw = FirstMiddlewareWithDirectCall(handler)\n+    \n+    # Test\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    result = await first_mw(request)\n+    print(f\"\\nFinal result type: {type(result)}\")\n+\n+\n+if __name__ == \"__main__\":\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    loop.run_until_complete(test_nested_middleware_issue())\ndiff --git a/test_real_issue.py b/test_real_issue.py\nnew file mode 100644\nindex 0000000000..60da140e39\n--- /dev/null\n+++ b/test_real_issue.py\n@@ -0,0 +1,63 @@\n+import asyncio\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    DEFAULT_CHARSET='utf-8',\n+    MIDDLEWARE=[\n+        'test_real_issue.FirstMiddleware',\n+        'test_real_issue.SecondMiddleware',\n+    ]\n+)\n+django.setup()\n+\n+from django.http import HttpResponse\n+from django.utils.deprecation import MiddlewareMixin\n+from django.core.handlers.base import BaseHandler\n+\n+\n+class FirstMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"FirstMiddleware.process_response: response={type(response)}\")\n+        if asyncio.iscoroutine(response):\n+            print(\"BUG CONFIRMED: FirstMiddleware received a coroutine!\")\n+        return response\n+\n+\n+class SecondMiddleware(MiddlewareMixin):\n+    def process_response(self, request, response):\n+        print(f\"SecondMiddleware.process_response: response={type(response)}\")\n+        return response\n+\n+\n+# Let's trace through Django's actual flow\n+class DebugHandler(BaseHandler):\n+    async def _get_response_async(self, request):\n+        print(\"_get_response_async called\")\n+        return HttpResponse(\"Test response\")\n+\n+\n+async def test_actual_django_flow():\n+    # Create handler and load middleware\n+    handler = DebugHandler()\n+    handler.load_middleware(is_async=True)\n+    \n+    # Create a mock ASGI request\n+    class MockRequest:\n+        pass\n+    \n+    request = MockRequest()\n+    \n+    # Call the middleware chain\n+    print(\"=== Starting middleware chain ===\")\n+    response = await handler._middleware_chain(request)\n+    print(f\"Final response: {type(response)}\")\n+\n+\n+if __name__ == \"__main__\":\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    loop.run_until_complete(test_actual_django_flow())\n", "gold_standard_diff": "diff --git a/django/contrib/sessions/middleware.py b/django/contrib/sessions/middleware.py\nindex 95ad30ce7fca..cb8c1ff45b8d 100644\n--- a/django/contrib/sessions/middleware.py\n+++ b/django/contrib/sessions/middleware.py\n@@ -13,9 +13,7 @@ class SessionMiddleware(MiddlewareMixin):\n     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n     #   def __init__(self, get_response):\n     def __init__(self, get_response=None):\n-        self._get_response_none_deprecation(get_response)\n-        self.get_response = get_response\n-        self._async_check()\n+        super().__init__(get_response)\n         engine = import_module(settings.SESSION_ENGINE)\n         self.SessionStore = engine.SessionStore\n \ndiff --git a/django/middleware/cache.py b/django/middleware/cache.py\nindex e92f768fa3ce..97bb199eff72 100644\n--- a/django/middleware/cache.py\n+++ b/django/middleware/cache.py\n@@ -64,13 +64,12 @@ class UpdateCacheMiddleware(MiddlewareMixin):\n     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n     #   def __init__(self, get_response):\n     def __init__(self, get_response=None):\n-        self._get_response_none_deprecation(get_response)\n+        super().__init__(get_response)\n         self.cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n         self.page_timeout = None\n         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n         self.cache = caches[self.cache_alias]\n-        self.get_response = get_response\n \n     def _should_update_cache(self, request, response):\n         return hasattr(request, '_cache_update_cache') and request._cache_update_cache\n@@ -128,11 +127,10 @@ class FetchFromCacheMiddleware(MiddlewareMixin):\n     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n     #   def __init__(self, get_response):\n     def __init__(self, get_response=None):\n-        self._get_response_none_deprecation(get_response)\n+        super().__init__(get_response)\n         self.key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n         self.cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n         self.cache = caches[self.cache_alias]\n-        self.get_response = get_response\n \n     def process_request(self, request):\n         \"\"\"\n@@ -173,8 +171,7 @@ class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):\n     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n     #   def __init__(self, get_response, cache_timeout=None, page_timeout=None, **kwargs):\n     def __init__(self, get_response=None, cache_timeout=None, page_timeout=None, **kwargs):\n-        self._get_response_none_deprecation(get_response)\n-        self.get_response = get_response\n+        super().__init__(get_response)\n         # We need to differentiate between \"provided, but using default value\",\n         # and \"not provided\". If the value is provided using a default, then\n         # we fall back to system defaults. If it is not provided at all,\n@@ -184,20 +181,18 @@ def __init__(self, get_response=None, cache_timeout=None, page_timeout=None, **k\n             key_prefix = kwargs['key_prefix']\n             if key_prefix is None:\n                 key_prefix = ''\n+            self.key_prefix = key_prefix\n         except KeyError:\n-            key_prefix = settings.CACHE_MIDDLEWARE_KEY_PREFIX\n-        self.key_prefix = key_prefix\n-\n+            pass\n         try:\n             cache_alias = kwargs['cache_alias']\n             if cache_alias is None:\n                 cache_alias = DEFAULT_CACHE_ALIAS\n+            self.cache_alias = cache_alias\n+            self.cache = caches[self.cache_alias]\n         except KeyError:\n-            cache_alias = settings.CACHE_MIDDLEWARE_ALIAS\n-        self.cache_alias = cache_alias\n+            pass\n \n-        if cache_timeout is None:\n-            cache_timeout = settings.CACHE_MIDDLEWARE_SECONDS\n-        self.cache_timeout = cache_timeout\n+        if cache_timeout is not None:\n+            self.cache_timeout = cache_timeout\n         self.page_timeout = page_timeout\n-        self.cache = caches[self.cache_alias]\ndiff --git a/django/middleware/security.py b/django/middleware/security.py\nindex 035c329efb48..44921cd22b94 100644\n--- a/django/middleware/security.py\n+++ b/django/middleware/security.py\n@@ -9,7 +9,7 @@ class SecurityMiddleware(MiddlewareMixin):\n     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n     #   def __init__(self, get_response):\n     def __init__(self, get_response=None):\n-        self._get_response_none_deprecation(get_response)\n+        super().__init__(get_response)\n         self.sts_seconds = settings.SECURE_HSTS_SECONDS\n         self.sts_include_subdomains = settings.SECURE_HSTS_INCLUDE_SUBDOMAINS\n         self.sts_preload = settings.SECURE_HSTS_PRELOAD\n@@ -19,7 +19,6 @@ def __init__(self, get_response=None):\n         self.redirect_host = settings.SECURE_SSL_HOST\n         self.redirect_exempt = [re.compile(r) for r in settings.SECURE_REDIRECT_EXEMPT]\n         self.referrer_policy = settings.SECURE_REFERRER_POLICY\n-        self.get_response = get_response\n \n     def process_request(self, request):\n         path = request.path.lstrip(\"/\")\ndiff --git a/docs/releases/3.1.1.txt b/docs/releases/3.1.1.txt\nindex 84f9020c53a9..68c02392bd5d 100644\n--- a/docs/releases/3.1.1.txt\n+++ b/docs/releases/3.1.1.txt\n@@ -48,3 +48,6 @@ Bugfixes\n   ``CommonPasswordValidator`` and ``settings.py`` generated by the\n   :djadmin:`startproject` command, when user didn't have permissions to all\n   intermediate directories in a Django installation path (:ticket:`31912`).\n+\n+* Fixed detecting an async ``get_response`` callable in various builtin\n+  middlewares (:ticket:`31928`).\ndiff --git a/docs/spelling_wordlist b/docs/spelling_wordlist\nindex c6720f4de674..727d9cf66eb7 100644\n--- a/docs/spelling_wordlist\n+++ b/docs/spelling_wordlist\n@@ -371,6 +371,7 @@ metre\n MiB\n micrometre\n middleware\n+middlewares\n migrationname\n millimetre\n Minification\ndiff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 865f0cefc803..c26183f5b255 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -2083,6 +2083,7 @@ def test_constructor(self):\n         self.assertEqual(middleware.cache_timeout, 30)\n         self.assertEqual(middleware.key_prefix, 'middlewareprefix')\n         self.assertEqual(middleware.cache_alias, 'other')\n+        self.assertEqual(middleware.cache, self.other_cache)\n \n         # If more arguments are being passed in construction, it's being used\n         # as a decorator. First, test with \"defaults\":\n@@ -2092,6 +2093,7 @@ def test_constructor(self):\n         self.assertEqual(as_view_decorator.key_prefix, '')\n         # Value of DEFAULT_CACHE_ALIAS from django.core.cache\n         self.assertEqual(as_view_decorator.cache_alias, 'default')\n+        self.assertEqual(as_view_decorator.cache, self.default_cache)\n \n         # Next, test with custom values:\n         as_view_decorator_with_custom = CacheMiddleware(\n@@ -2101,6 +2103,21 @@ def test_constructor(self):\n         self.assertEqual(as_view_decorator_with_custom.cache_timeout, 60)\n         self.assertEqual(as_view_decorator_with_custom.key_prefix, 'foo')\n         self.assertEqual(as_view_decorator_with_custom.cache_alias, 'other')\n+        self.assertEqual(as_view_decorator_with_custom.cache, self.other_cache)\n+\n+    def test_update_cache_middleware_constructor(self):\n+        middleware = UpdateCacheMiddleware(empty_response)\n+        self.assertEqual(middleware.cache_timeout, 30)\n+        self.assertIsNone(middleware.page_timeout)\n+        self.assertEqual(middleware.key_prefix, 'middlewareprefix')\n+        self.assertEqual(middleware.cache_alias, 'other')\n+        self.assertEqual(middleware.cache, self.other_cache)\n+\n+    def test_fetch_cache_middleware_constructor(self):\n+        middleware = FetchFromCacheMiddleware(empty_response)\n+        self.assertEqual(middleware.key_prefix, 'middlewareprefix')\n+        self.assertEqual(middleware.cache_alias, 'other')\n+        self.assertEqual(middleware.cache, self.other_cache)\n \n     def test_middleware(self):\n         middleware = CacheMiddleware(hello_world_view)\ndiff --git a/tests/deprecation/test_middleware_mixin.py b/tests/deprecation/test_middleware_mixin.py\nindex c90aeb836091..4f410a77c8da 100644\n--- a/tests/deprecation/test_middleware_mixin.py\n+++ b/tests/deprecation/test_middleware_mixin.py\n@@ -1,15 +1,31 @@\n+import asyncio\n import threading\n \n from asgiref.sync import async_to_sync\n \n+from django.contrib.admindocs.middleware import XViewMiddleware\n+from django.contrib.auth.middleware import (\n+    AuthenticationMiddleware, RemoteUserMiddleware,\n+)\n+from django.contrib.flatpages.middleware import FlatpageFallbackMiddleware\n+from django.contrib.messages.middleware import MessageMiddleware\n+from django.contrib.redirects.middleware import RedirectFallbackMiddleware\n from django.contrib.sessions.middleware import SessionMiddleware\n+from django.contrib.sites.middleware import CurrentSiteMiddleware\n from django.db import connection\n from django.http.request import HttpRequest\n from django.http.response import HttpResponse\n from django.middleware.cache import (\n     CacheMiddleware, FetchFromCacheMiddleware, UpdateCacheMiddleware,\n )\n-from django.middleware.common import CommonMiddleware\n+from django.middleware.clickjacking import XFrameOptionsMiddleware\n+from django.middleware.common import (\n+    BrokenLinkEmailsMiddleware, CommonMiddleware,\n+)\n+from django.middleware.csrf import CsrfViewMiddleware\n+from django.middleware.gzip import GZipMiddleware\n+from django.middleware.http import ConditionalGetMiddleware\n+from django.middleware.locale import LocaleMiddleware\n from django.middleware.security import SecurityMiddleware\n from django.test import SimpleTestCase\n from django.utils.deprecation import MiddlewareMixin, RemovedInDjango40Warning\n@@ -20,30 +36,57 @@ class MiddlewareMixinTests(SimpleTestCase):\n     Deprecation warning is raised when using get_response=None.\n     \"\"\"\n     msg = 'Passing None for the middleware get_response argument is deprecated.'\n+    middlewares = [\n+        AuthenticationMiddleware,\n+        BrokenLinkEmailsMiddleware,\n+        CacheMiddleware,\n+        CommonMiddleware,\n+        ConditionalGetMiddleware,\n+        CsrfViewMiddleware,\n+        CurrentSiteMiddleware,\n+        FetchFromCacheMiddleware,\n+        FlatpageFallbackMiddleware,\n+        GZipMiddleware,\n+        LocaleMiddleware,\n+        MessageMiddleware,\n+        RedirectFallbackMiddleware,\n+        RemoteUserMiddleware,\n+        SecurityMiddleware,\n+        SessionMiddleware,\n+        UpdateCacheMiddleware,\n+        XFrameOptionsMiddleware,\n+        XViewMiddleware,\n+    ]\n \n     def test_deprecation(self):\n-        with self.assertRaisesMessage(RemovedInDjango40Warning, self.msg):\n-            CommonMiddleware()\n+        for middleware in self.middlewares:\n+            with self.subTest(middleware=middleware):\n+                with self.assertRaisesMessage(RemovedInDjango40Warning, self.msg):\n+                    middleware()\n \n     def test_passing_explicit_none(self):\n-        with self.assertRaisesMessage(RemovedInDjango40Warning, self.msg):\n-            CommonMiddleware(None)\n-\n-    def test_subclass_deprecation(self):\n-        \"\"\"\n-        Deprecation warning is raised in subclasses overriding __init__()\n-        without calling super().\n-        \"\"\"\n-        for middleware in [\n-            SessionMiddleware,\n-            CacheMiddleware,\n-            FetchFromCacheMiddleware,\n-            UpdateCacheMiddleware,\n-            SecurityMiddleware,\n-        ]:\n+        for middleware in self.middlewares:\n             with self.subTest(middleware=middleware):\n                 with self.assertRaisesMessage(RemovedInDjango40Warning, self.msg):\n-                    middleware()\n+                    middleware(None)\n+\n+    def test_coroutine(self):\n+        async def async_get_response(request):\n+            return HttpResponse()\n+\n+        def sync_get_response(request):\n+            return HttpResponse()\n+\n+        for middleware in self.middlewares:\n+            with self.subTest(middleware=middleware.__qualname__):\n+                # Middleware appears as coroutine if get_function is\n+                # a coroutine.\n+                middleware_instance = middleware(async_get_response)\n+                self.assertIs(asyncio.iscoroutinefunction(middleware_instance), True)\n+                # Middleware doesn't appear as coroutine if get_function is not\n+                # a coroutine.\n+                middleware_instance = middleware(sync_get_response)\n+                self.assertIs(asyncio.iscoroutinefunction(middleware_instance), False)\n \n     def test_sync_to_async_uses_base_thread_and_connection(self):\n         \"\"\"\ndiff --git a/tests/runtests.py b/tests/runtests.py\nindex db32da13eb8f..db1fd65dd273 100755\n--- a/tests/runtests.py\n+++ b/tests/runtests.py\n@@ -90,8 +90,9 @@\n # avoid \"RuntimeError: Model class X doesn't declare an explicit app_label\n # and isn't in an application in INSTALLED_APPS.\"\n CONTRIB_TESTS_TO_APPS = {\n-    'flatpages_tests': 'django.contrib.flatpages',\n-    'redirects_tests': 'django.contrib.redirects',\n+    'deprecation': ['django.contrib.flatpages', 'django.contrib.redirects'],\n+    'flatpages_tests': ['django.contrib.flatpages'],\n+    'redirects_tests': ['django.contrib.redirects'],\n }\n \n \n@@ -228,7 +229,9 @@ def _module_match_label(module_label, label):\n         )\n \n         if module_name in CONTRIB_TESTS_TO_APPS and module_found_in_labels:\n-            settings.INSTALLED_APPS.append(CONTRIB_TESTS_TO_APPS[module_name])\n+            for contrib_app in CONTRIB_TESTS_TO_APPS[module_name]:\n+                if contrib_app not in settings.INSTALLED_APPS:\n+                    settings.INSTALLED_APPS.append(contrib_app)\n \n         if module_found_in_labels and module_label not in installed_app_names:\n             if verbosity >= 2:\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13344"}