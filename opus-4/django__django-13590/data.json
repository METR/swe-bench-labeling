{"instance_id": "django__django-13590", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf395..f843c60089 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1077,10 +1077,10 @@ class Query(BaseExpression):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            return type(value)(*(\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n-            )\n+            ))\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..4b82743522\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,39 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from collections import namedtuple\n+from datetime import datetime\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+sys.path.insert(0, '/testbed')\n+django.setup()\n+\n+# Create a test to demonstrate the fix works\n+from django.db.models.sql.query import Query\n+\n+# Create a named tuple\n+DateRange = namedtuple('DateRange', ['near', 'far'])\n+\n+# Create a test query object\n+query = Query(None)\n+\n+# Test the resolve_lookup_value method with a named tuple\n+date_range = DateRange(near=datetime(2020, 1, 1), far=datetime(2020, 12, 31))\n+\n+try:\n+    result = query.resolve_lookup_value(date_range, None, None)\n+    print(f\"Success! Named tuple resolution now works correctly\")\n+    print(f\"Input: {date_range}\")\n+    print(f\"Output: {result}\")\n+    print(f\"Output type: {type(result)}\")\n+    assert isinstance(result, DateRange), \"Result should be a DateRange named tuple\"\n+    assert result.near == datetime(2020, 1, 1), \"Near date should be preserved\"\n+    assert result.far == datetime(2020, 12, 31), \"Far date should be preserved\"\n+    print(\"All assertions passed!\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+    sys.exit(1)\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..0b4091ec6c\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,31 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from collections import namedtuple\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+sys.path.insert(0, '/testbed')\n+django.setup()\n+\n+# Create a test to reproduce the issue\n+from django.db.models.sql.query import Query\n+\n+# Create a named tuple\n+DateRange = namedtuple('DateRange', ['near', 'far'])\n+\n+# Create a test query object\n+query = Query(None)\n+\n+# Test the resolve_lookup_value method with a named tuple\n+date_range = DateRange(near='2020-01-01', far='2020-12-31')\n+\n+try:\n+    result = query.resolve_lookup_value(date_range, None, None)\n+    print(f\"Success! Result: {result}\")\n+except TypeError as e:\n+    print(f\"Error reproduced: {e}\")\n+    print(f\"Error type: {type(e)}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_namedtuple_fix.py b/test_namedtuple_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_namedtuple_range.py b/test_namedtuple_range.py\nnew file mode 100644\nindex 0000000000..5da3546286\n--- /dev/null\n+++ b/test_namedtuple_range.py\n@@ -0,0 +1,30 @@\n+from collections import namedtuple\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Q\n+\n+# Create a named tuple for testing\n+DateRange = namedtuple('DateRange', ['near', 'far'])\n+\n+class TestModel(models.Model):\n+    created = models.DateTimeField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class NamedTupleRangeTest(TestCase):\n+    def test_named_tuple_in_range_filter(self):\n+        \"\"\"Test that named tuples work correctly in __range filters.\"\"\"\n+        from datetime import datetime\n+        \n+        # Create test data\n+        date_range = DateRange(\n+            near=datetime(2020, 1, 1),\n+            far=datetime(2020, 12, 31)\n+        )\n+        \n+        # This should not raise an error\n+        queryset = TestModel.objects.filter(created__range=date_range)\n+        \n+        # Force evaluation to trigger resolve_lookup_value\n+        list(queryset)\n", "gold_standard_diff": "From a56586eafeb6d1212bc291d1a2e7d33c87edbc33 Mon Sep 17 00:00:00 2001\nFrom: Adam Johnson <me@adamj.eu>\nDate: Fri, 23 Oct 2020 10:33:10 +0100\nSubject: [PATCH] Fixed #32134 -- Fixed crash of __range lookup with\n namedtuple.\n\nRegression in 8be79984dce7d819879a6e594ca69c5f95a08378.\n\nThanks Gordon Wrigley for the report.\n---\n django/db/models/sql/query.py |  6 +++++-\n tests/expressions/tests.py    | 10 +++++++++-\n 2 files changed, 14 insertions(+), 2 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 4648daf39567..ee98984826e9 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1077,10 +1077,14 @@ def resolve_lookup_value(self, value, can_reuse, allow_joins):\n         elif isinstance(value, (list, tuple)):\n             # The items of the iterable may be expressions and therefore need\n             # to be resolved independently.\n-            return type(value)(\n+            values = (\n                 self.resolve_lookup_value(sub_value, can_reuse, allow_joins)\n                 for sub_value in value\n             )\n+            type_ = type(value)\n+            if hasattr(type_, '_make'):  # namedtuple\n+                return type_(*values)\n+            return type_(values)\n         return value\n \n     def solve_lookup_type(self, lookup):\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex ceeed3aeb19d..2762dc3a1b10 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -2,6 +2,7 @@\n import pickle\n import unittest\n import uuid\n+from collections import namedtuple\n from copy import deepcopy\n from decimal import Decimal\n from unittest import mock\n@@ -813,7 +814,7 @@ def setUpTestData(cls):\n         Company.objects.create(name='5040 Ltd', num_employees=50, num_chairs=40, ceo=ceo)\n         Company.objects.create(name='5050 Ltd', num_employees=50, num_chairs=50, ceo=ceo)\n         Company.objects.create(name='5060 Ltd', num_employees=50, num_chairs=60, ceo=ceo)\n-        Company.objects.create(name='99300 Ltd', num_employees=99, num_chairs=300, ceo=ceo)\n+        cls.c5 = Company.objects.create(name='99300 Ltd', num_employees=99, num_chairs=300, ceo=ceo)\n \n     def test_in_lookup_allows_F_expressions_and_expressions_for_integers(self):\n         # __in lookups can use F() expressions for integers.\n@@ -884,6 +885,13 @@ def test_range_lookup_allows_F_expressions_and_expressions_for_integers(self):\n             ordered=False\n         )\n \n+    def test_range_lookup_namedtuple(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertSequenceEqual(qs, [self.c5])\n+\n     @unittest.skipUnless(connection.vendor == 'sqlite',\n                          \"This defensive test only works on databases that don't validate parameter types\")\n     def test_complex_expressions_do_not_introduce_sql_injection_via_untrusted_string_inclusion(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13590"}