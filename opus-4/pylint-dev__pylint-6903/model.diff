diff --git a/pylint/lint/run.py b/pylint/lint/run.py
index a7e5d5574..c23565b1a 100644
--- a/pylint/lint/run.py
+++ b/pylint/lint/run.py
@@ -52,12 +52,12 @@ def _query_cpu() -> int | None:
         with open("/sys/fs/cgroup/cpu/cpu.cfs_period_us", encoding="utf-8") as file:
             cpu_period = int(file.read().rstrip())
         # Divide quota by period and you should get num of allotted CPU to the container, rounded down if fractional.
-        avail_cpu = int(cpu_quota / cpu_period)
+        avail_cpu = int(cpu_quota / cpu_period) or 1
     elif Path("/sys/fs/cgroup/cpu/cpu.shares").is_file():
         with open("/sys/fs/cgroup/cpu/cpu.shares", encoding="utf-8") as file:
             cpu_shares = int(file.read().rstrip())
         # For AWS, gives correct value * 1024.
-        avail_cpu = int(cpu_shares / 1024)
+        avail_cpu = int(cpu_shares / 1024) or 1
     return avail_cpu
 
 
@@ -76,8 +76,8 @@ def _cpu_count() -> int:
     else:
         cpu_count = 1
     if cpu_share is not None:
-        return min(cpu_share, cpu_count)
-    return cpu_count
+        return max(1, min(cpu_share, cpu_count))
+    return max(1, cpu_count)
 
 
 UNUSED_PARAM_SENTINEL = object()
diff --git a/tests/lint/test_run_cpu_count.py b/tests/lint/test_run_cpu_count.py
new file mode 100644
index 000000000..458f74e99
--- /dev/null
+++ b/tests/lint/test_run_cpu_count.py
@@ -0,0 +1,109 @@
+# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
+# Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
+
+"""Tests for CPU count detection in containerized environments."""
+
+from pathlib import Path
+from unittest.mock import mock_open, patch
+
+import pytest
+
+from pylint.lint.run import _cpu_count, _query_cpu
+
+
+class TestCPUCount:
+    """Test CPU count detection."""
+
+    def test_query_cpu_kubernetes_low_shares(self):
+        """Test that _query_cpu returns at least 1 when cpu.shares is very low (Kubernetes case)."""
+        mock_files = {
+            "/sys/fs/cgroup/cpu/cpu.cfs_quota_us": "-1",
+            "/sys/fs/cgroup/cpu/cpu.cfs_period_us": "100000",
+            "/sys/fs/cgroup/cpu/cpu.shares": "2",
+        }
+
+        def mock_path_is_file(self):
+            return str(self) in mock_files
+
+        def mock_open_file(filename, *args, **kwargs):
+            if filename in mock_files:
+                return mock_open(read_data=mock_files[filename])()
+            raise FileNotFoundError(filename)
+
+        with patch.object(Path, "is_file", mock_path_is_file):
+            with patch("builtins.open", mock_open_file):
+                result = _query_cpu()
+                # Should return 1 instead of 0 (2/1024 = 0.00195 -> int() = 0 -> fixed to 1)
+                assert result == 1
+
+    def test_query_cpu_low_quota_period_ratio(self):
+        """Test that _query_cpu returns at least 1 when quota/period ratio is less than 1."""
+        mock_files = {
+            "/sys/fs/cgroup/cpu/cpu.cfs_quota_us": "50000",
+            "/sys/fs/cgroup/cpu/cpu.cfs_period_us": "100000",
+            "/sys/fs/cgroup/cpu/cpu.shares": "1024",
+        }
+
+        def mock_path_is_file(self):
+            return str(self) in mock_files
+
+        def mock_open_file(filename, *args, **kwargs):
+            if filename in mock_files:
+                return mock_open(read_data=mock_files[filename])()
+            raise FileNotFoundError(filename)
+
+        with patch.object(Path, "is_file", mock_path_is_file):
+            with patch("builtins.open", mock_open_file):
+                result = _query_cpu()
+                # Should return 1 instead of 0 (50000/100000 = 0.5 -> int() = 0 -> fixed to 1)
+                assert result == 1
+
+    def test_cpu_count_never_returns_zero(self):
+        """Test that _cpu_count never returns 0, even when _query_cpu would return 0."""
+        # Mock a scenario where both _query_cpu would return None and cpu_count would be 0
+        with patch("pylint.lint.run._query_cpu", return_value=None):
+            # Remove sched_getaffinity from os module
+            with patch("os.sched_getaffinity", new=None):
+                with patch("pylint.lint.run.multiprocessing") as mock_mp:
+                    mock_mp.cpu_count.return_value = 0
+                    result = _cpu_count()
+                    # Should return 1 as a fallback
+                    assert result == 1
+
+    def test_cpu_count_respects_query_cpu_minimum(self):
+        """Test that _cpu_count returns at least 1 even when query_cpu returns 0."""
+        # This shouldn't happen with our fix, but let's ensure the safety net works
+        with patch("pylint.lint.run._query_cpu", return_value=0):
+            with patch("os.sched_getaffinity", return_value={0, 1}):  # 2 CPUs
+                result = _cpu_count()
+                # Should return 1 (max(1, min(0, 2)) = 1)
+                assert result == 1
+
+    def test_normal_cpu_shares(self):
+        """Test normal cpu.shares values work as expected."""
+        test_cases = [
+            (1024, 1),   # 1024 shares = 1 CPU
+            (2048, 2),   # 2048 shares = 2 CPUs
+            (4096, 4),   # 4096 shares = 4 CPUs
+        ]
+
+        for shares, expected in test_cases:
+            mock_files = {
+                "/sys/fs/cgroup/cpu/cpu.cfs_quota_us": "-1",
+                "/sys/fs/cgroup/cpu/cpu.cfs_period_us": "100000",
+                "/sys/fs/cgroup/cpu/cpu.shares": str(shares),
+            }
+
+            def mock_path_is_file(self):
+                return str(self) in mock_files
+
+            def mock_open_file(filename, *args, **kwargs):
+                if filename in mock_files:
+                    return mock_open(read_data=mock_files[filename])()
+                raise FileNotFoundError(filename)
+
+            with patch.object(Path, "is_file", mock_path_is_file):
+                with patch("builtins.open", mock_open_file):
+                    result = _query_cpu()
+                    assert result == expected
