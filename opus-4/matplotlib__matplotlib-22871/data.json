{"instance_id": "matplotlib__matplotlib-22871", "score": "C", "diff": "diff --git a/debug_dates.py b/debug_dates.py\nnew file mode 100644\nindex 0000000000..0f38f5d7f0\n--- /dev/null\n+++ b/debug_dates.py\n@@ -0,0 +1,9 @@\n+from datetime import datetime, timedelta\n+\n+initial = datetime(2021,2,14,0,0,0)\n+time_array = [initial + timedelta(days=x) for x in range(1,200)]\n+\n+print(f\"Start date: {time_array[0]}\")\n+print(f\"End date: {time_array[-1]}\")\n+print(f\"Months included: {set(dt.month for dt in time_array)}\")\n+print(f\"Years included: {set(dt.year for dt in time_array)}\")\ndiff --git a/debug_formatter.py b/debug_formatter.py\nnew file mode 100644\nindex 0000000000..ede4a83864\n--- /dev/null\n+++ b/debug_formatter.py\n@@ -0,0 +1,33 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+import numpy as np\n+\n+# Create time array - Feb to Sep 2021, no January included\n+initial = datetime(2021,2,14,0,0,0)\n+time_array = [initial + timedelta(days=x) for x in range(1,200)]\n+\n+# Create data array\n+data = [-x**2/20000 for x in range(1,200)]\n+\n+# Plot data\n+fig, ax = plt.subplots()\n+ax.plot(time_array, data) \n+\n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+\n+ax.xaxis.set_major_locator(locator)   \n+ax.xaxis.set_major_formatter(formatter)\n+\n+# Get the tick values and labels\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Number of ticks: {len(ticks)}\")\n+print(f\"Tick dates:\")\n+for i, tick in enumerate(ticks):\n+    date = mdates.num2date(tick)\n+    print(f\"  {i}: {date} -> '{labels[i]}'\")\n+print(f\"Offset string: '{offset}'\")\ndiff --git a/debug_formatter2.py b/debug_formatter2.py\nnew file mode 100644\nindex 0000000000..e761fc94ab\n--- /dev/null\n+++ b/debug_formatter2.py\n@@ -0,0 +1,61 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+import numpy as np\n+\n+# Create time array - Feb to Sep 2021, no January included\n+initial = datetime(2021,2,14,0,0,0)\n+time_array = [initial + timedelta(days=x) for x in range(1,200)]\n+\n+# Create data array\n+data = [-x**2/20000 for x in range(1,200)]\n+\n+# Plot data\n+fig, ax = plt.subplots()\n+ax.plot(time_array, data) \n+\n+locator = mdates.AutoDateLocator()\n+\n+# Create a custom ConciseDateFormatter to debug\n+class DebugConciseDateFormatter(mdates.ConciseDateFormatter):\n+    def format_ticks(self, values):\n+        tickdatetime = [mdates.num2date(value, tz=self._tz) for value in values]\n+        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n+        \n+        print(f\"\\nDEBUG: tickdate shape: {tickdate.shape}\")\n+        print(f\"DEBUG: tickdate:\\n{tickdate}\")\n+        \n+        # Determine the level\n+        for level in range(5, -1, -1):\n+            unique_vals = np.unique(tickdate[:, level])\n+            print(f\"DEBUG: Level {level} unique values: {unique_vals}\")\n+            if len(unique_vals) > 1:\n+                print(f\"DEBUG: Breaking at level {level}\")\n+                if level < 2:\n+                    print(f\"DEBUG: level < 2, setting show_offset = False\")\n+                break\n+        else:\n+            level = 5\n+            \n+        print(f\"DEBUG: Final level = {level}\")\n+        print(f\"DEBUG: show_offset = {self.show_offset}\")\n+        \n+        # Call parent method\n+        return super().format_ticks(values)\n+\n+formatter = DebugConciseDateFormatter(locator)\n+\n+ax.xaxis.set_major_locator(locator)   \n+ax.xaxis.set_major_formatter(formatter)\n+\n+# Get the tick values and labels\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"\\nNumber of ticks: {len(ticks)}\")\n+print(f\"Tick dates:\")\n+for i, tick in enumerate(ticks):\n+    date = mdates.num2date(tick)\n+    print(f\"  {i}: {date} -> '{labels[i]}'\")\n+print(f\"Offset string: '{offset}'\")\ndiff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex 4d8ddf3ee5..f923ccc9b8 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -838,6 +838,16 @@ class ConciseDateFormatter(ticker.Formatter):\n                     if '.' in labels[nn]:\n                         labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n \n+        # Fix for issue when months are shown but year is not displayed anywhere\n+        # When level is 1 (months) and offset is disabled, check if year would be shown\n+        if level == 1 and not show_offset:\n+            # Check if we have January (month=1) in the ticks\n+            # If we do, the year will be shown in that label due to zerofmts\n+            has_january = any(tickdate[nn][1] == 1 for nn in range(len(tickdate)))\n+            if not has_january:\n+                # No January, so year will not be shown. Enable offset to show it.\n+                show_offset = True\n+\n         if show_offset:\n             # set the offset string:\n             self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\ndiff --git a/test_bug_fix.py b/test_bug_fix.py\nnew file mode 100644\nindex 0000000000..8b13789179\n--- /dev/null\n+++ b/test_bug_fix.py\n@@ -0,0 +1 @@\n+\ndiff --git a/test_final_fix.py b/test_final_fix.py\nnew file mode 100644\nindex 0000000000..0f0908c579\n--- /dev/null\n+++ b/test_final_fix.py\n@@ -0,0 +1,31 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+\n+#create time array\n+initial = datetime(2021,2,14,0,0,0)\n+time_array = [initial + timedelta(days=x) for x in range(1,200)]\n+\n+#create data array\n+data = [-x**2/20000 for x in range(1,200)]\n+\n+#plot data\n+fig,ax = plt.subplots()\n+ax.plot(time_array,data) \n+        \n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+\n+ax.grid(True)\n+ax.set_ylabel(\"Temperature ($\\degree$C)\")\n+ax.xaxis.set_major_locator(locator)   \n+ax.xaxis.set_major_formatter(formatter)\n+\n+# Get the tick values and labels\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Tick labels: {labels}\")\n+print(f\"Offset string: '{offset}'\")\n+print(\"\\nThe year 2021 is now shown in the offset!\")\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..a430d1a84a\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,114 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+import numpy as np\n+\n+# Create a custom formatter to test the fix\n+class FixedConciseDateFormatter(mdates.ConciseDateFormatter):\n+    def format_ticks(self, values):\n+        tickdatetime = [mdates.num2date(value, tz=self._tz) for value in values]\n+        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n+\n+        # basic algorithm:\n+        # 1) only display a part of the date if it changes over the ticks.\n+        # 2) don't display the smaller part of the date if:\n+        #    it is always the same or if it is the start of the\n+        #    year, month, day etc.\n+        # fmt for most ticks at this level\n+        fmts = self.formats\n+        # format beginnings of days, months, years, etc.\n+        zerofmts = self.zero_formats\n+        # offset fmt are for the offset in the upper left of the\n+        # or lower right of the axis.\n+        offsetfmts = self.offset_formats\n+        show_offset = self.show_offset\n+\n+        # determine the level we will label at:\n+        # mostly 0: years,  1: months,  2: days,\n+        # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n+        for level in range(5, -1, -1):\n+            if len(np.unique(tickdate[:, level])) > 1:\n+                # ORIGINAL CODE:\n+                # if level < 2:\n+                #     show_offset = False\n+                break\n+            elif level == 0:\n+                # all tickdate are the same, so only micros might be different\n+                # set to the most precise (6: microseconds doesn't exist...)\n+                level = 5\n+\n+        # level is the basic level we will label at.\n+        # now loop through and decide the actual ticklabels\n+        zerovals = [0, 1, 1, 0, 0, 0, 0]\n+        labels = [''] * len(tickdate)\n+        for nn in range(len(tickdate)):\n+            if level < 5:\n+                if tickdate[nn][level] == zerovals[level]:\n+                    fmt = zerofmts[level]\n+                else:\n+                    fmt = fmts[level]\n+            else:\n+                # special handling for seconds + microseconds\n+                if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n+                        == 0):\n+                    fmt = zerofmts[level]\n+                else:\n+                    fmt = fmts[level]\n+            labels[nn] = tickdatetime[nn].strftime(fmt)\n+\n+        # special handling of seconds and microseconds:\n+        # strip extra zeros and decimal if possible.\n+        # this is complicated by two factors.  1) we have some level-4 strings\n+        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n+        # same number of decimals for each string (i.e. 0.5 and 1.0).\n+        if level >= 5:\n+            trailing_zeros = min(\n+                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n+                default=None)\n+            if trailing_zeros:\n+                for nn in range(len(labels)):\n+                    if '.' in labels[nn]:\n+                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n+\n+        # NEW LOGIC: Check if year is shown in any label when level=1\n+        if level == 1:  # months\n+            # Check if any label contains a 4-digit year\n+            year_in_labels = any(any(str(year) in label for year in range(1900, 2100)) \n+                                for label in labels)\n+            if not year_in_labels:\n+                # No year in labels, so we should show it in offset\n+                show_offset = True\n+\n+        if show_offset:\n+            # set the offset string:\n+            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n+            if self._usetex:\n+                self.offset_string = mdates._wrap_in_tex(self.offset_string)\n+        else:\n+            self.offset_string = ''\n+\n+        if self._usetex:\n+            return [mdates._wrap_in_tex(l) for l in labels]\n+        else:\n+            return labels\n+\n+\n+# Test the fix\n+print(\"Testing fix for single year without January (Feb-Sep 2021)\")\n+initial = datetime(2021, 2, 14)\n+time_array = [initial + timedelta(days=x) for x in range(1, 200)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(len(time_array)))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = FixedConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\ndiff --git a/test_fix_all_cases.py b/test_fix_all_cases.py\nnew file mode 100644\nindex 0000000000..0632247b6e\n--- /dev/null\n+++ b/test_fix_all_cases.py\n@@ -0,0 +1,156 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+import numpy as np\n+\n+# Create a custom formatter to test the fix\n+class FixedConciseDateFormatter(mdates.ConciseDateFormatter):\n+    def format_ticks(self, values):\n+        tickdatetime = [mdates.num2date(value, tz=self._tz) for value in values]\n+        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n+\n+        # basic algorithm:\n+        # 1) only display a part of the date if it changes over the ticks.\n+        # 2) don't display the smaller part of the date if:\n+        #    it is always the same or if it is the start of the\n+        #    year, month, day etc.\n+        # fmt for most ticks at this level\n+        fmts = self.formats\n+        # format beginnings of days, months, years, etc.\n+        zerofmts = self.zero_formats\n+        # offset fmt are for the offset in the upper left of the\n+        # or lower right of the axis.\n+        offsetfmts = self.offset_formats\n+        show_offset = self.show_offset\n+\n+        # determine the level we will label at:\n+        # mostly 0: years,  1: months,  2: days,\n+        # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n+        for level in range(5, -1, -1):\n+            if len(np.unique(tickdate[:, level])) > 1:\n+                if level < 2:\n+                    show_offset = False\n+                break\n+            elif level == 0:\n+                # all tickdate are the same, so only micros might be different\n+                # set to the most precise (6: microseconds doesn't exist...)\n+                level = 5\n+\n+        # level is the basic level we will label at.\n+        # now loop through and decide the actual ticklabels\n+        zerovals = [0, 1, 1, 0, 0, 0, 0]\n+        labels = [''] * len(tickdate)\n+        for nn in range(len(tickdate)):\n+            if level < 5:\n+                if tickdate[nn][level] == zerovals[level]:\n+                    fmt = zerofmts[level]\n+                else:\n+                    fmt = fmts[level]\n+            else:\n+                # special handling for seconds + microseconds\n+                if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n+                        == 0):\n+                    fmt = zerofmts[level]\n+                else:\n+                    fmt = fmts[level]\n+            labels[nn] = tickdatetime[nn].strftime(fmt)\n+\n+        # special handling of seconds and microseconds:\n+        # strip extra zeros and decimal if possible.\n+        # this is complicated by two factors.  1) we have some level-4 strings\n+        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n+        # same number of decimals for each string (i.e. 0.5 and 1.0).\n+        if level >= 5:\n+            trailing_zeros = min(\n+                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n+                default=None)\n+            if trailing_zeros:\n+                for nn in range(len(labels)):\n+                    if '.' in labels[nn]:\n+                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n+\n+        # NEW FIX: When level is 1 (months) and offset is disabled, \n+        # check if year is shown in any label \n+        if level == 1 and not show_offset:\n+            # Check if we have January (month=1) in the ticks\n+            # If we do, the year will be shown in that label\n+            has_january = any(tickdate[nn][1] == 1 for nn in range(len(tickdate)))\n+            if not has_january:\n+                # No January, so year won't be shown. Enable offset.\n+                show_offset = True\n+\n+        if show_offset:\n+            # set the offset string:\n+            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n+            if self._usetex:\n+                self.offset_string = mdates._wrap_in_tex(self.offset_string)\n+        else:\n+            self.offset_string = ''\n+\n+        if self._usetex:\n+            return [mdates._wrap_in_tex(l) for l in labels]\n+        else:\n+            return labels\n+\n+\n+# Test case 1: Multiple years\n+print(\"Test 1: Multiple years (2020-2022)\")\n+initial = datetime(2020, 1, 1)\n+time_array = [initial + timedelta(days=x*100) for x in range(10)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(10))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = FixedConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\n+print()\n+\n+# Test case 2: Single year, includes January\n+print(\"Test 2: Single year with January (Jan-Dec 2021)\")\n+initial = datetime(2021, 1, 1)\n+time_array = [initial + timedelta(days=x*30) for x in range(12)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(12))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = FixedConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\n+print()\n+\n+# Test case 3: Single year, no January (Feb-Sep 2021) - the bug case\n+print(\"Test 3: Single year without January (Feb-Sep 2021)\")\n+initial = datetime(2021, 2, 14)\n+time_array = [initial + timedelta(days=x) for x in range(1, 200)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(len(time_array)))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = FixedConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..e7024a6078\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,27 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+\n+#create time array\n+initial = datetime(2021,2,14,0,0,0)\n+time_array = [initial + timedelta(days=x) for x in range(1,200)]\n+\n+#create data array\n+data = [-x**2/20000 for x in range(1,200)]\n+\n+\n+#plot data\n+fig,ax = plt.subplots()\n+ax.plot(time_array,data) \n+        \n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+\n+ax.grid(True)\n+ax.set_ylabel(\"Temperature ($\\degree$C)\")\n+ax.xaxis.set_major_locator(locator)   \n+ax.xaxis.set_major_formatter(formatter)\n+fig.autofmt_xdate() #automatically makes the x-labels rotate\n+\n+plt.savefig('test_output.png')\n+print(\"Plot saved to test_output.png\")\ndiff --git a/test_multiple_years.py b/test_multiple_years.py\nnew file mode 100644\nindex 0000000000..787e02c705\n--- /dev/null\n+++ b/test_multiple_years.py\n@@ -0,0 +1,65 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.dates as mdates\n+from datetime import datetime, timedelta\n+\n+# Test case 1: Multiple years\n+print(\"Test 1: Multiple years (2020-2022)\")\n+initial = datetime(2020, 1, 1)\n+time_array = [initial + timedelta(days=x*100) for x in range(10)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(10))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\n+print()\n+\n+# Test case 2: Single year, includes January\n+print(\"Test 2: Single year with January (Jan-Dec 2021)\")\n+initial = datetime(2021, 1, 1)\n+time_array = [initial + timedelta(days=x*30) for x in range(12)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(12))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\n+print()\n+\n+# Test case 3: Single year, no January (Feb-Sep 2021) - the bug case\n+print(\"Test 3: Single year without January (Feb-Sep 2021)\")\n+initial = datetime(2021, 2, 14)\n+time_array = [initial + timedelta(days=x) for x in range(1, 200)]\n+\n+fig, ax = plt.subplots()\n+ax.plot(time_array, range(len(time_array)))\n+\n+locator = mdates.AutoDateLocator()\n+formatter = mdates.ConciseDateFormatter(locator)\n+ax.xaxis.set_major_locator(locator)\n+ax.xaxis.set_major_formatter(formatter)\n+\n+ticks = ax.get_xticks()\n+labels = formatter.format_ticks(ticks)\n+offset = formatter.get_offset()\n+\n+print(f\"Labels: {labels}\")\n+print(f\"Offset: '{offset}'\")\ndiff --git a/test_output.png b/test_output.png\nnew file mode 100644\nindex 0000000000..46c6cea9ee\nBinary files /dev/null and b/test_output.png differ\n", "gold_standard_diff": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex 4d8ddf3ee50b..c43e566242ad 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -796,8 +796,10 @@ def format_ticks(self, values):\n         # mostly 0: years,  1: months,  2: days,\n         # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n         for level in range(5, -1, -1):\n-            if len(np.unique(tickdate[:, level])) > 1:\n-                if level < 2:\n+            unique = np.unique(tickdate[:, level])\n+            if len(unique) > 1:\n+                # if 1 is included in unique, the year is shown in ticks\n+                if level < 2 and np.any(unique == 1):\n                     show_offset = False\n                 break\n             elif level == 0:\ndiff --git a/lib/matplotlib/tests/test_dates.py b/lib/matplotlib/tests/test_dates.py\nindex a78c39c560f7..5258da36a7e7 100644\n--- a/lib/matplotlib/tests/test_dates.py\n+++ b/lib/matplotlib/tests/test_dates.py\n@@ -630,6 +630,10 @@ def test_offset_changes():\n     ax.set_xlim(d1, d1 + datetime.timedelta(weeks=3))\n     fig.draw_without_rendering()\n     assert formatter.get_offset() == '1997-Jan'\n+    ax.set_xlim(d1 + datetime.timedelta(weeks=7),\n+                d1 + datetime.timedelta(weeks=30))\n+    fig.draw_without_rendering()\n+    assert formatter.get_offset() == '1997'\n     ax.set_xlim(d1, d1 + datetime.timedelta(weeks=520))\n     fig.draw_without_rendering()\n     assert formatter.get_offset() == ''\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/22871"}