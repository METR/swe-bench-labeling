{"instance_id": "pydata__xarray-6744", "score": "I", "diff": "diff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6..7459ddc1 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -268,12 +268,42 @@ class DataArrayRolling(Rolling[\"DataArray\"]):\n         self.window_labels = self.obj[self.dim[0]]\n \n     def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+        \"\"\"\n+        Iterate over the rolling windows.\n+\n+        Yields\n+        ------\n+        label : RollingKey\n+            The label of the window. When center is True, this is the label of the center\n+            element of the window. When center is False, this is the label of the last\n+            element in the window.\n+        window : DataArray\n+            A DataArray containing the data in the current window.\n+\n+        Notes\n+        -----\n+        The iteration accounts for the 'center' parameter, adjusting the window positions\n+        and labels accordingly.\n+        \"\"\"\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n-        for (label, start, stop) in zip(self.window_labels, starts, stops):\n+        window_size = int(self.window[0])\n+        half_window = window_size // 2\n+        data_size = len(self.window_labels)\n+        \n+        if self.center:\n+            stops = np.arange(window_size, data_size + half_window + 1)\n+            starts = stops - window_size\n+            starts = np.maximum(starts, 0)\n+            stops = np.minimum(stops, data_size)\n+            labels = self.window_labels[half_window:data_size]\n+        else:\n+            stops = np.arange(1, data_size + 1)\n+            starts = stops - window_size\n+            starts = np.maximum(starts, 0)\n+            labels = self.window_labels\n+\n+        for (label, start, stop) in zip(labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \n             counts = window.count(dim=self.dim[0])\n", "gold_standard_diff": "From 6eac7bd3860daeddd81d8cf35b4f99c52063c289 Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Sat, 2 Jul 2022 17:48:02 +0200\nSubject: [PATCH 1/5] new test_rolling module\n\n---\n xarray/tests/test_dataarray.py | 455 -----------------\n xarray/tests/test_dataset.py   | 330 -------------\n xarray/tests/test_rolling.py   | 880 +++++++++++++++++++++++++++++++++\n 3 files changed, 880 insertions(+), 785 deletions(-)\n create mode 100644 xarray/tests/test_rolling.py\n\ndiff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex e259353902c..309f4a01a02 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -43,7 +43,6 @@\n     requires_cupy,\n     requires_dask,\n     requires_iris,\n-    requires_numbagg,\n     requires_numexpr,\n     requires_pint,\n     requires_scipy,\n@@ -5907,368 +5906,6 @@ def test_isin(da) -> None:\n     assert_equal(result, expected)\n \n \n-@pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-def test_rolling_iter(da) -> None:\n-    rolling_obj = da.rolling(time=7)\n-    rolling_obj_mean = rolling_obj.mean()\n-\n-    assert len(rolling_obj.window_labels) == len(da[\"time\"])\n-    assert_identical(rolling_obj.window_labels, da[\"time\"])\n-\n-    for i, (label, window_da) in enumerate(rolling_obj):\n-        assert label == da[\"time\"].isel(time=i)\n-\n-        actual = rolling_obj_mean.isel(time=i)\n-        expected = window_da.mean(\"time\")\n-\n-        # TODO add assert_allclose_with_nan, which compares nan position\n-        # as well as the closeness of the values.\n-        assert_array_equal(actual.isnull(), expected.isnull())\n-        if (~actual.isnull()).sum() > 0:\n-            np.allclose(\n-                actual.values[actual.values.nonzero()],\n-                expected.values[expected.values.nonzero()],\n-            )\n-\n-\n-@pytest.mark.parametrize(\"da\", (1,), indirect=True)\n-def test_rolling_repr(da) -> None:\n-    rolling_obj = da.rolling(time=7)\n-    assert repr(rolling_obj) == \"DataArrayRolling [time->7]\"\n-    rolling_obj = da.rolling(time=7, center=True)\n-    assert repr(rolling_obj) == \"DataArrayRolling [time->7(center)]\"\n-    rolling_obj = da.rolling(time=7, x=3, center=True)\n-    assert repr(rolling_obj) == \"DataArrayRolling [time->7(center),x->3(center)]\"\n-\n-\n-@requires_dask\n-def test_repeated_rolling_rechunks() -> None:\n-\n-    # regression test for GH3277, GH2514\n-    dat = DataArray(np.random.rand(7653, 300), dims=(\"day\", \"item\"))\n-    dat_chunk = dat.chunk({\"item\": 20})\n-    dat_chunk.rolling(day=10).mean().rolling(day=250).std()\n-\n-\n-def test_rolling_doc(da) -> None:\n-    rolling_obj = da.rolling(time=7)\n-\n-    # argument substitution worked\n-    assert \"`mean`\" in rolling_obj.mean.__doc__\n-\n-\n-def test_rolling_properties(da) -> None:\n-    rolling_obj = da.rolling(time=4)\n-\n-    assert rolling_obj.obj.get_axis_num(\"time\") == 1\n-\n-    # catching invalid args\n-    with pytest.raises(ValueError, match=\"window must be > 0\"):\n-        da.rolling(time=-2)\n-\n-    with pytest.raises(ValueError, match=\"min_periods must be greater than zero\"):\n-        da.rolling(time=2, min_periods=0)\n-\n-\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"min\", \"max\", \"median\"))\n-@pytest.mark.parametrize(\"center\", (True, False, None))\n-@pytest.mark.parametrize(\"min_periods\", (1, None))\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-def test_rolling_wrapped_bottleneck(da, name, center, min_periods) -> None:\n-    bn = pytest.importorskip(\"bottleneck\", minversion=\"1.1\")\n-\n-    # Test all bottleneck functions\n-    rolling_obj = da.rolling(time=7, min_periods=min_periods)\n-\n-    func_name = f\"move_{name}\"\n-    actual = getattr(rolling_obj, name)()\n-    expected = getattr(bn, func_name)(\n-        da.values, window=7, axis=1, min_count=min_periods\n-    )\n-    assert_array_equal(actual.values, expected)\n-\n-    with pytest.warns(DeprecationWarning, match=\"Reductions are applied\"):\n-        getattr(rolling_obj, name)(dim=\"time\")\n-\n-    # Test center\n-    rolling_obj = da.rolling(time=7, center=center)\n-    actual = getattr(rolling_obj, name)()[\"time\"]\n-    assert_equal(actual, da[\"time\"])\n-\n-\n-@requires_dask\n-@pytest.mark.parametrize(\"name\", (\"mean\", \"count\"))\n-@pytest.mark.parametrize(\"center\", (True, False, None))\n-@pytest.mark.parametrize(\"min_periods\", (1, None))\n-@pytest.mark.parametrize(\"window\", (7, 8))\n-@pytest.mark.parametrize(\"backend\", [\"dask\"], indirect=True)\n-def test_rolling_wrapped_dask(da, name, center, min_periods, window) -> None:\n-    # dask version\n-    rolling_obj = da.rolling(time=window, min_periods=min_periods, center=center)\n-    actual = getattr(rolling_obj, name)().load()\n-    if name != \"count\":\n-        with pytest.warns(DeprecationWarning, match=\"Reductions are applied\"):\n-            getattr(rolling_obj, name)(dim=\"time\")\n-    # numpy version\n-    rolling_obj = da.load().rolling(time=window, min_periods=min_periods, center=center)\n-    expected = getattr(rolling_obj, name)()\n-\n-    # using all-close because rolling over ghost cells introduces some\n-    # precision errors\n-    assert_allclose(actual, expected)\n-\n-    # with zero chunked array GH:2113\n-    rolling_obj = da.chunk().rolling(\n-        time=window, min_periods=min_periods, center=center\n-    )\n-    actual = getattr(rolling_obj, name)().load()\n-    assert_allclose(actual, expected)\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, None))\n-def test_rolling_wrapped_dask_nochunk(center) -> None:\n-    # GH:2113\n-    pytest.importorskip(\"dask.array\")\n-\n-    da_day_clim = xr.DataArray(\n-        np.arange(1, 367), coords=[np.arange(1, 367)], dims=\"dayofyear\"\n-    )\n-    expected = da_day_clim.rolling(dayofyear=31, center=center).mean()\n-    actual = da_day_clim.chunk().rolling(dayofyear=31, center=center).mean()\n-    assert_allclose(actual, expected)\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-def test_rolling_pandas_compat(center, window, min_periods) -> None:\n-    s = pd.Series(np.arange(10))\n-    da = DataArray.from_series(s)\n-\n-    if min_periods is not None and window < min_periods:\n-        min_periods = window\n-\n-    s_rolling = s.rolling(window, center=center, min_periods=min_periods).mean()\n-    da_rolling = da.rolling(index=window, center=center, min_periods=min_periods).mean()\n-    da_rolling_np = da.rolling(\n-        index=window, center=center, min_periods=min_periods\n-    ).reduce(np.nanmean)\n-\n-    np.testing.assert_allclose(s_rolling.values, da_rolling.values)\n-    np.testing.assert_allclose(s_rolling.index, da_rolling[\"index\"])\n-    np.testing.assert_allclose(s_rolling.values, da_rolling_np.values)\n-    np.testing.assert_allclose(s_rolling.index, da_rolling_np[\"index\"])\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-def test_rolling_construct(center, window) -> None:\n-    s = pd.Series(np.arange(10))\n-    da = DataArray.from_series(s)\n-\n-    s_rolling = s.rolling(window, center=center, min_periods=1).mean()\n-    da_rolling = da.rolling(index=window, center=center, min_periods=1)\n-\n-    da_rolling_mean = da_rolling.construct(\"window\").mean(\"window\")\n-    np.testing.assert_allclose(s_rolling.values, da_rolling_mean.values)\n-    np.testing.assert_allclose(s_rolling.index, da_rolling_mean[\"index\"])\n-\n-    # with stride\n-    da_rolling_mean = da_rolling.construct(\"window\", stride=2).mean(\"window\")\n-    np.testing.assert_allclose(s_rolling.values[::2], da_rolling_mean.values)\n-    np.testing.assert_allclose(s_rolling.index[::2], da_rolling_mean[\"index\"])\n-\n-    # with fill_value\n-    da_rolling_mean = da_rolling.construct(\"window\", stride=2, fill_value=0.0).mean(\n-        \"window\"\n-    )\n-    assert da_rolling_mean.isnull().sum() == 0\n-    assert (da_rolling_mean == 0.0).sum() >= 0\n-\n-\n-@pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"max\"))\n-def test_rolling_reduce(da, center, min_periods, window, name) -> None:\n-    if min_periods is not None and window < min_periods:\n-        min_periods = window\n-\n-    if da.isnull().sum() > 1 and window == 1:\n-        # this causes all nan slices\n-        window = 2\n-\n-    rolling_obj = da.rolling(time=window, center=center, min_periods=min_periods)\n-\n-    # add nan prefix to numpy methods to get similar # behavior as bottleneck\n-    actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n-    expected = getattr(rolling_obj, name)()\n-    assert_allclose(actual, expected)\n-    assert actual.dims == expected.dims\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"max\"))\n-def test_rolling_reduce_nonnumeric(center, min_periods, window, name) -> None:\n-    da = DataArray(\n-        [0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7], dims=\"time\"\n-    ).isnull()\n-\n-    if min_periods is not None and window < min_periods:\n-        min_periods = window\n-\n-    rolling_obj = da.rolling(time=window, center=center, min_periods=min_periods)\n-\n-    # add nan prefix to numpy methods to get similar behavior as bottleneck\n-    actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n-    expected = getattr(rolling_obj, name)()\n-    assert_allclose(actual, expected)\n-    assert actual.dims == expected.dims\n-\n-\n-def test_rolling_count_correct() -> None:\n-    da = DataArray([0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7], dims=\"time\")\n-\n-    kwargs: list[dict[str, Any]] = [\n-        {\"time\": 11, \"min_periods\": 1},\n-        {\"time\": 11, \"min_periods\": None},\n-        {\"time\": 7, \"min_periods\": 2},\n-    ]\n-    expecteds = [\n-        DataArray([1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8], dims=\"time\"),\n-        DataArray(\n-            [\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-                np.nan,\n-            ],\n-            dims=\"time\",\n-        ),\n-        DataArray([np.nan, np.nan, 2, 3, 3, 4, 5, 5, 5, 5, 5], dims=\"time\"),\n-    ]\n-\n-    for kwarg, expected in zip(kwargs, expecteds):\n-        result = da.rolling(**kwarg).count()\n-        assert_equal(result, expected)\n-\n-        result = da.to_dataset(name=\"var1\").rolling(**kwarg).count()[\"var1\"]\n-        assert_equal(result, expected)\n-\n-\n-@pytest.mark.parametrize(\"da\", (1,), indirect=True)\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1))\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"max\"))\n-def test_ndrolling_reduce(da, center, min_periods, name) -> None:\n-    rolling_obj = da.rolling(time=3, x=2, center=center, min_periods=min_periods)\n-\n-    actual = getattr(rolling_obj, name)()\n-    expected = getattr(\n-        getattr(\n-            da.rolling(time=3, center=center, min_periods=min_periods), name\n-        )().rolling(x=2, center=center, min_periods=min_periods),\n-        name,\n-    )()\n-\n-    assert_allclose(actual, expected)\n-    assert actual.dims == expected.dims\n-\n-    if name in [\"mean\"]:\n-        # test our reimplementation of nanmean using np.nanmean\n-        expected = getattr(rolling_obj.construct({\"time\": \"tw\", \"x\": \"xw\"}), name)(\n-            [\"tw\", \"xw\"]\n-        )\n-        count = rolling_obj.count()\n-        if min_periods is None:\n-            min_periods = 1\n-        assert_allclose(actual, expected.where(count >= min_periods))\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False, (True, False)))\n-@pytest.mark.parametrize(\"fill_value\", (np.nan, 0.0))\n-def test_ndrolling_construct(center, fill_value) -> None:\n-    da = DataArray(\n-        np.arange(5 * 6 * 7).reshape(5, 6, 7).astype(float),\n-        dims=[\"x\", \"y\", \"z\"],\n-        coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"], \"y\": np.arange(6)},\n-    )\n-    actual = da.rolling(x=3, z=2, center=center).construct(\n-        x=\"x1\", z=\"z1\", fill_value=fill_value\n-    )\n-    if not isinstance(center, tuple):\n-        center = (center, center)\n-    expected = (\n-        da.rolling(x=3, center=center[0])\n-        .construct(x=\"x1\", fill_value=fill_value)\n-        .rolling(z=2, center=center[1])\n-        .construct(z=\"z1\", fill_value=fill_value)\n-    )\n-    assert_allclose(actual, expected)\n-\n-\n-@pytest.mark.parametrize(\n-    \"funcname, argument\",\n-    [\n-        (\"reduce\", (np.mean,)),\n-        (\"mean\", ()),\n-        (\"construct\", (\"window_dim\",)),\n-        (\"count\", ()),\n-    ],\n-)\n-def test_rolling_keep_attrs(funcname, argument) -> None:\n-    attrs_da = {\"da_attr\": \"test\"}\n-\n-    data = np.linspace(10, 15, 100)\n-    coords = np.linspace(1, 10, 100)\n-\n-    da = DataArray(\n-        data, dims=(\"coord\"), coords={\"coord\": coords}, attrs=attrs_da, name=\"name\"\n-    )\n-\n-    # attrs are now kept per default\n-    func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n-    result = func(*argument)\n-    assert result.attrs == attrs_da\n-    assert result.name == \"name\"\n-\n-    # discard attrs\n-    func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n-    result = func(*argument, keep_attrs=False)\n-    assert result.attrs == {}\n-    assert result.name == \"name\"\n-\n-    # test discard attrs using global option\n-    func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=False):\n-        result = func(*argument)\n-    assert result.attrs == {}\n-    assert result.name == \"name\"\n-\n-    # keyword takes precedence over global option\n-    func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=False):\n-        result = func(*argument, keep_attrs=True)\n-    assert result.attrs == attrs_da\n-    assert result.name == \"name\"\n-\n-    func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=True):\n-        result = func(*argument, keep_attrs=False)\n-    assert result.attrs == {}\n-    assert result.name == \"name\"\n-\n-\n def test_raise_no_warning_for_nan_in_binary_ops() -> None:\n     with assert_no_warnings():\n         xr.DataArray([1, 2, np.NaN]) > 0\n@@ -6546,98 +6183,6 @@ def test_fallback_to_iris_AuxCoord(self, coord_values) -> None:\n         assert result == expected\n \n \n-@requires_numbagg\n-@pytest.mark.parametrize(\"dim\", [\"time\", \"x\"])\n-@pytest.mark.parametrize(\n-    \"window_type, window\", [[\"span\", 5], [\"alpha\", 0.5], [\"com\", 0.5], [\"halflife\", 5]]\n-)\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-@pytest.mark.parametrize(\"func\", [\"mean\", \"sum\"])\n-def test_rolling_exp_runs(da, dim, window_type, window, func) -> None:\n-    import numbagg\n-\n-    if (\n-        Version(getattr(numbagg, \"__version__\", \"0.1.0\")) < Version(\"0.2.1\")\n-        and func == \"sum\"\n-    ):\n-        pytest.skip(\"rolling_exp.sum requires numbagg 0.2.1\")\n-\n-    da = da.where(da > 0.2)\n-\n-    rolling_exp = da.rolling_exp(window_type=window_type, **{dim: window})\n-    result = getattr(rolling_exp, func)()\n-    assert isinstance(result, DataArray)\n-\n-\n-@requires_numbagg\n-@pytest.mark.parametrize(\"dim\", [\"time\", \"x\"])\n-@pytest.mark.parametrize(\n-    \"window_type, window\", [[\"span\", 5], [\"alpha\", 0.5], [\"com\", 0.5], [\"halflife\", 5]]\n-)\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-def test_rolling_exp_mean_pandas(da, dim, window_type, window) -> None:\n-    da = da.isel(a=0).where(lambda x: x > 0.2)\n-\n-    result = da.rolling_exp(window_type=window_type, **{dim: window}).mean()\n-    assert isinstance(result, DataArray)\n-\n-    pandas_array = da.to_pandas()\n-    assert pandas_array.index.name == \"time\"\n-    if dim == \"x\":\n-        pandas_array = pandas_array.T\n-    expected = xr.DataArray(pandas_array.ewm(**{window_type: window}).mean()).transpose(\n-        *da.dims\n-    )\n-\n-    assert_allclose(expected.variable, result.variable)\n-\n-\n-@requires_numbagg\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-@pytest.mark.parametrize(\"func\", [\"mean\", \"sum\"])\n-def test_rolling_exp_keep_attrs(da, func) -> None:\n-    import numbagg\n-\n-    if (\n-        Version(getattr(numbagg, \"__version__\", \"0.1.0\")) < Version(\"0.2.1\")\n-        and func == \"sum\"\n-    ):\n-        pytest.skip(\"rolling_exp.sum requires numbagg 0.2.1\")\n-\n-    attrs = {\"attrs\": \"da\"}\n-    da.attrs = attrs\n-\n-    # Equivalent of `da.rolling_exp(time=10).mean`\n-    rolling_exp_func = getattr(da.rolling_exp(time=10), func)\n-\n-    # attrs are kept per default\n-    result = rolling_exp_func()\n-    assert result.attrs == attrs\n-\n-    # discard attrs\n-    result = rolling_exp_func(keep_attrs=False)\n-    assert result.attrs == {}\n-\n-    # test discard attrs using global option\n-    with set_options(keep_attrs=False):\n-        result = rolling_exp_func()\n-    assert result.attrs == {}\n-\n-    # keyword takes precedence over global option\n-    with set_options(keep_attrs=False):\n-        result = rolling_exp_func(keep_attrs=True)\n-    assert result.attrs == attrs\n-\n-    with set_options(keep_attrs=True):\n-        result = rolling_exp_func(keep_attrs=False)\n-    assert result.attrs == {}\n-\n-    with pytest.warns(\n-        UserWarning, match=\"Passing ``keep_attrs`` to ``rolling_exp`` has no effect.\"\n-    ):\n-        da.rolling_exp(time=10, keep_attrs=True)\n-\n-\n def test_no_dict() -> None:\n     d = DataArray()\n     with pytest.raises(AttributeError):\ndiff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex bc5bf1c0f1c..9c34630a2a8 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -49,7 +49,6 @@\n     requires_cftime,\n     requires_cupy,\n     requires_dask,\n-    requires_numbagg,\n     requires_numexpr,\n     requires_pint,\n     requires_scipy,\n@@ -6191,315 +6190,6 @@ def ds(request, backend):\n     return ds\n \n \n-@pytest.mark.parametrize(\n-    \"funcname, argument\",\n-    [\n-        (\"reduce\", (np.mean,)),\n-        (\"mean\", ()),\n-        (\"construct\", (\"window_dim\",)),\n-        (\"count\", ()),\n-    ],\n-)\n-def test_rolling_keep_attrs(funcname, argument) -> None:\n-    global_attrs = {\"units\": \"test\", \"long_name\": \"testing\"}\n-    da_attrs = {\"da_attr\": \"test\"}\n-    da_not_rolled_attrs = {\"da_not_rolled_attr\": \"test\"}\n-\n-    data = np.linspace(10, 15, 100)\n-    coords = np.linspace(1, 10, 100)\n-\n-    ds = Dataset(\n-        data_vars={\"da\": (\"coord\", data), \"da_not_rolled\": (\"no_coord\", data)},\n-        coords={\"coord\": coords},\n-        attrs=global_attrs,\n-    )\n-    ds.da.attrs = da_attrs\n-    ds.da_not_rolled.attrs = da_not_rolled_attrs\n-\n-    # attrs are now kept per default\n-    func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n-    result = func(*argument)\n-    assert result.attrs == global_attrs\n-    assert result.da.attrs == da_attrs\n-    assert result.da_not_rolled.attrs == da_not_rolled_attrs\n-    assert result.da.name == \"da\"\n-    assert result.da_not_rolled.name == \"da_not_rolled\"\n-\n-    # discard attrs\n-    func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n-    result = func(*argument, keep_attrs=False)\n-    assert result.attrs == {}\n-    assert result.da.attrs == {}\n-    assert result.da_not_rolled.attrs == {}\n-    assert result.da.name == \"da\"\n-    assert result.da_not_rolled.name == \"da_not_rolled\"\n-\n-    # test discard attrs using global option\n-    func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=False):\n-        result = func(*argument)\n-\n-    assert result.attrs == {}\n-    assert result.da.attrs == {}\n-    assert result.da_not_rolled.attrs == {}\n-    assert result.da.name == \"da\"\n-    assert result.da_not_rolled.name == \"da_not_rolled\"\n-\n-    # keyword takes precedence over global option\n-    func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=False):\n-        result = func(*argument, keep_attrs=True)\n-\n-    assert result.attrs == global_attrs\n-    assert result.da.attrs == da_attrs\n-    assert result.da_not_rolled.attrs == da_not_rolled_attrs\n-    assert result.da.name == \"da\"\n-    assert result.da_not_rolled.name == \"da_not_rolled\"\n-\n-    func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n-    with set_options(keep_attrs=True):\n-        result = func(*argument, keep_attrs=False)\n-\n-    assert result.attrs == {}\n-    assert result.da.attrs == {}\n-    assert result.da_not_rolled.attrs == {}\n-    assert result.da.name == \"da\"\n-    assert result.da_not_rolled.name == \"da_not_rolled\"\n-\n-\n-def test_rolling_properties(ds) -> None:\n-    # catching invalid args\n-    with pytest.raises(ValueError, match=\"window must be > 0\"):\n-        ds.rolling(time=-2)\n-    with pytest.raises(ValueError, match=\"min_periods must be greater than zero\"):\n-        ds.rolling(time=2, min_periods=0)\n-    with pytest.raises(KeyError, match=\"time2\"):\n-        ds.rolling(time2=2)\n-\n-\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"var\", \"min\", \"max\", \"median\"))\n-@pytest.mark.parametrize(\"center\", (True, False, None))\n-@pytest.mark.parametrize(\"min_periods\", (1, None))\n-@pytest.mark.parametrize(\"key\", (\"z1\", \"z2\"))\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-def test_rolling_wrapped_bottleneck(ds, name, center, min_periods, key) -> None:\n-    bn = pytest.importorskip(\"bottleneck\", minversion=\"1.1\")\n-\n-    # Test all bottleneck functions\n-    rolling_obj = ds.rolling(time=7, min_periods=min_periods)\n-\n-    func_name = f\"move_{name}\"\n-    actual = getattr(rolling_obj, name)()\n-    if key == \"z1\":  # z1 does not depend on 'Time' axis. Stored as it is.\n-        expected = ds[key]\n-    elif key == \"z2\":\n-        expected = getattr(bn, func_name)(\n-            ds[key].values, window=7, axis=0, min_count=min_periods\n-        )\n-    else:\n-        raise ValueError\n-    assert_array_equal(actual[key].values, expected)\n-\n-    # Test center\n-    rolling_obj = ds.rolling(time=7, center=center)\n-    actual = getattr(rolling_obj, name)()[\"time\"]\n-    assert_equal(actual, ds[\"time\"])\n-\n-\n-@requires_numbagg\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-def test_rolling_exp(ds) -> None:\n-\n-    result = ds.rolling_exp(time=10, window_type=\"span\").mean()\n-    assert isinstance(result, Dataset)\n-\n-\n-@requires_numbagg\n-@pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n-def test_rolling_exp_keep_attrs(ds) -> None:\n-\n-    attrs_global = {\"attrs\": \"global\"}\n-    attrs_z1 = {\"attr\": \"z1\"}\n-\n-    ds.attrs = attrs_global\n-    ds.z1.attrs = attrs_z1\n-\n-    # attrs are kept per default\n-    result = ds.rolling_exp(time=10).mean()\n-    assert result.attrs == attrs_global\n-    assert result.z1.attrs == attrs_z1\n-\n-    # discard attrs\n-    result = ds.rolling_exp(time=10).mean(keep_attrs=False)\n-    assert result.attrs == {}\n-    assert result.z1.attrs == {}\n-\n-    # test discard attrs using global option\n-    with set_options(keep_attrs=False):\n-        result = ds.rolling_exp(time=10).mean()\n-    assert result.attrs == {}\n-    assert result.z1.attrs == {}\n-\n-    # keyword takes precedence over global option\n-    with set_options(keep_attrs=False):\n-        result = ds.rolling_exp(time=10).mean(keep_attrs=True)\n-    assert result.attrs == attrs_global\n-    assert result.z1.attrs == attrs_z1\n-\n-    with set_options(keep_attrs=True):\n-        result = ds.rolling_exp(time=10).mean(keep_attrs=False)\n-    assert result.attrs == {}\n-    assert result.z1.attrs == {}\n-\n-    with pytest.warns(\n-        UserWarning, match=\"Passing ``keep_attrs`` to ``rolling_exp`` has no effect.\"\n-    ):\n-        ds.rolling_exp(time=10, keep_attrs=True)\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-def test_rolling_pandas_compat(center, window, min_periods) -> None:\n-    df = pd.DataFrame(\n-        {\n-            \"x\": np.random.randn(20),\n-            \"y\": np.random.randn(20),\n-            \"time\": np.linspace(0, 1, 20),\n-        }\n-    )\n-    ds = Dataset.from_dataframe(df)\n-\n-    if min_periods is not None and window < min_periods:\n-        min_periods = window\n-\n-    df_rolling = df.rolling(window, center=center, min_periods=min_periods).mean()\n-    ds_rolling = ds.rolling(index=window, center=center, min_periods=min_periods).mean()\n-\n-    np.testing.assert_allclose(df_rolling[\"x\"].values, ds_rolling[\"x\"].values)\n-    np.testing.assert_allclose(df_rolling.index, ds_rolling[\"index\"])\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-def test_rolling_construct(center, window) -> None:\n-    df = pd.DataFrame(\n-        {\n-            \"x\": np.random.randn(20),\n-            \"y\": np.random.randn(20),\n-            \"time\": np.linspace(0, 1, 20),\n-        }\n-    )\n-\n-    ds = Dataset.from_dataframe(df)\n-    df_rolling = df.rolling(window, center=center, min_periods=1).mean()\n-    ds_rolling = ds.rolling(index=window, center=center)\n-\n-    ds_rolling_mean = ds_rolling.construct(\"window\").mean(\"window\")\n-    np.testing.assert_allclose(df_rolling[\"x\"].values, ds_rolling_mean[\"x\"].values)\n-    np.testing.assert_allclose(df_rolling.index, ds_rolling_mean[\"index\"])\n-\n-    # with stride\n-    ds_rolling_mean = ds_rolling.construct(\"window\", stride=2).mean(\"window\")\n-    np.testing.assert_allclose(df_rolling[\"x\"][::2].values, ds_rolling_mean[\"x\"].values)\n-    np.testing.assert_allclose(df_rolling.index[::2], ds_rolling_mean[\"index\"])\n-    # with fill_value\n-    ds_rolling_mean = ds_rolling.construct(\"window\", stride=2, fill_value=0.0).mean(\n-        \"window\"\n-    )\n-    assert (ds_rolling_mean.isnull().sum() == 0).to_array(dim=\"vars\").all()\n-    assert (ds_rolling_mean[\"x\"] == 0.0).sum() >= 0\n-\n-\n-@pytest.mark.slow\n-@pytest.mark.parametrize(\"ds\", (1, 2), indirect=True)\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n-@pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"var\", \"min\", \"max\", \"median\"))\n-def test_rolling_reduce(ds, center, min_periods, window, name) -> None:\n-\n-    if min_periods is not None and window < min_periods:\n-        min_periods = window\n-\n-    if name == \"std\" and window == 1:\n-        pytest.skip(\"std with window == 1 is unstable in bottleneck\")\n-\n-    rolling_obj = ds.rolling(time=window, center=center, min_periods=min_periods)\n-\n-    # add nan prefix to numpy methods to get similar behavior as bottleneck\n-    actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n-    expected = getattr(rolling_obj, name)()\n-    assert_allclose(actual, expected)\n-    assert ds.dims == actual.dims\n-    # make sure the order of data_var are not changed.\n-    assert list(ds.data_vars.keys()) == list(actual.data_vars.keys())\n-\n-    # Make sure the dimension order is restored\n-    for key, src_var in ds.data_vars.items():\n-        assert src_var.dims == actual[key].dims\n-\n-\n-@pytest.mark.parametrize(\"ds\", (2,), indirect=True)\n-@pytest.mark.parametrize(\"center\", (True, False))\n-@pytest.mark.parametrize(\"min_periods\", (None, 1))\n-@pytest.mark.parametrize(\"name\", (\"sum\", \"max\"))\n-@pytest.mark.parametrize(\"dask\", (True, False))\n-def test_ndrolling_reduce(ds, center, min_periods, name, dask) -> None:\n-    if dask and has_dask:\n-        ds = ds.chunk({\"x\": 4})\n-\n-    rolling_obj = ds.rolling(time=4, x=3, center=center, min_periods=min_periods)\n-\n-    actual = getattr(rolling_obj, name)()\n-    expected = getattr(\n-        getattr(\n-            ds.rolling(time=4, center=center, min_periods=min_periods), name\n-        )().rolling(x=3, center=center, min_periods=min_periods),\n-        name,\n-    )()\n-    assert_allclose(actual, expected)\n-    assert actual.dims == expected.dims\n-\n-    # Do it in the opposite order\n-    expected = getattr(\n-        getattr(\n-            ds.rolling(x=3, center=center, min_periods=min_periods), name\n-        )().rolling(time=4, center=center, min_periods=min_periods),\n-        name,\n-    )()\n-\n-    assert_allclose(actual, expected)\n-    assert actual.dims == expected.dims\n-\n-\n-@pytest.mark.parametrize(\"center\", (True, False, (True, False)))\n-@pytest.mark.parametrize(\"fill_value\", (np.nan, 0.0))\n-@pytest.mark.parametrize(\"dask\", (True, False))\n-def test_ndrolling_construct(center, fill_value, dask) -> None:\n-    da = DataArray(\n-        np.arange(5 * 6 * 7).reshape(5, 6, 7).astype(float),\n-        dims=[\"x\", \"y\", \"z\"],\n-        coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"], \"y\": np.arange(6)},\n-    )\n-    ds = xr.Dataset({\"da\": da})\n-    if dask and has_dask:\n-        ds = ds.chunk({\"x\": 4})\n-\n-    actual = ds.rolling(x=3, z=2, center=center).construct(\n-        x=\"x1\", z=\"z1\", fill_value=fill_value\n-    )\n-    if not isinstance(center, tuple):\n-        center = (center, center)\n-    expected = (\n-        ds.rolling(x=3, center=center[0])\n-        .construct(x=\"x1\", fill_value=fill_value)\n-        .rolling(z=2, center=center[1])\n-        .construct(z=\"z1\", fill_value=fill_value)\n-    )\n-    assert_allclose(actual, expected)\n-\n-\n def test_raise_no_warning_for_nan_in_binary_ops() -> None:\n     with assert_no_warnings():\n         Dataset(data_vars={\"x\": (\"y\", [1, 2, np.NaN])}) > 0\n@@ -6511,26 +6201,6 @@ def test_raise_no_warning_assert_close(ds) -> None:\n     assert_allclose(ds, ds)\n \n \n-@pytest.mark.xfail(reason=\"See https://github.com/pydata/xarray/pull/4369 or docstring\")\n-@pytest.mark.filterwarnings(\"error\")\n-@pytest.mark.parametrize(\"ds\", (2,), indirect=True)\n-@pytest.mark.parametrize(\"name\", (\"mean\", \"max\"))\n-def test_raise_no_warning_dask_rolling_assert_close(ds, name) -> None:\n-    \"\"\"\n-    This is a puzzle \u2014 I can't easily find the source of the warning. It\n-    requires `assert_allclose` to be run, for the `ds` param to be 2, and is\n-    different for `mean` and `max`. `sum` raises no warning.\n-    \"\"\"\n-\n-    ds = ds.chunk({\"x\": 4})\n-\n-    rolling_obj = ds.rolling(time=4, x=3)\n-\n-    actual = getattr(rolling_obj, name)()\n-    expected = getattr(getattr(ds.rolling(time=4), name)().rolling(x=3), name)()\n-    assert_allclose(actual, expected)\n-\n-\n @pytest.mark.parametrize(\"dask\", [True, False])\n @pytest.mark.parametrize(\"edge_order\", [1, 2])\n def test_differentiate(dask, edge_order) -> None:\ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nnew file mode 100644\nindex 00000000000..b46dcb14211\n--- /dev/null\n+++ b/xarray/tests/test_rolling.py\n@@ -0,0 +1,880 @@\n+from __future__ import annotations\n+\n+from typing import Any\n+\n+import numpy as np\n+import pandas as pd\n+import pytest\n+from packaging.version import Version\n+\n+import xarray as xr\n+from xarray import DataArray, Dataset, set_options\n+from xarray.tests import (\n+    assert_allclose,\n+    assert_array_equal,\n+    assert_chunks_equal,\n+    assert_equal,\n+    assert_identical,\n+    assert_no_warnings,\n+    create_test_data,\n+    has_dask,\n+    raise_if_dask_computes,\n+    requires_bottleneck,\n+    requires_dask,\n+    requires_numbagg,\n+    requires_numexpr,\n+    requires_scipy,\n+)\n+\n+pytestmark = [\n+    pytest.mark.filterwarnings(\"error:Mean of empty slice\"),\n+    pytest.mark.filterwarnings(\"error:All-NaN (slice|axis) encountered\"),\n+]\n+\n+\n+# TODO: remove this duplication https://github.com/pydata/xarray/pull/6730\n+@pytest.fixture(params=[1])\n+def da(request, backend):\n+    if request.param == 1:\n+        times = pd.date_range(\"2000-01-01\", freq=\"1D\", periods=21)\n+        da = DataArray(\n+            np.random.random((3, 21, 4)),\n+            dims=(\"a\", \"time\", \"x\"),\n+            coords=dict(time=times),\n+        )\n+\n+    if request.param == 2:\n+        da = DataArray([0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7], dims=\"time\")\n+\n+    if request.param == \"repeating_ints\":\n+        da = DataArray(\n+            np.tile(np.arange(12), 5).reshape(5, 4, 3),\n+            coords={\"x\": list(\"abc\"), \"y\": list(\"defg\")},\n+            dims=list(\"zyx\"),\n+        )\n+\n+    if backend == \"dask\":\n+        return da.chunk()\n+    elif backend == \"numpy\":\n+        return da\n+    else:\n+        raise ValueError\n+\n+\n+# TODO: remove this duplication https://github.com/pydata/xarray/pull/6730\n+@pytest.fixture(params=[1])\n+def ds(request, backend):\n+    if request.param == 1:\n+        ds = Dataset(\n+            dict(\n+                z1=([\"y\", \"x\"], np.random.randn(2, 8)),\n+                z2=([\"time\", \"y\"], np.random.randn(10, 2)),\n+            ),\n+            dict(\n+                x=(\"x\", np.linspace(0, 1.0, 8)),\n+                time=(\"time\", np.linspace(0, 1.0, 10)),\n+                c=(\"y\", [\"a\", \"b\"]),\n+                y=range(2),\n+            ),\n+        )\n+    elif request.param == 2:\n+        ds = Dataset(\n+            dict(\n+                z1=([\"time\", \"y\"], np.random.randn(10, 2)),\n+                z2=([\"time\"], np.random.randn(10)),\n+                z3=([\"x\", \"time\"], np.random.randn(8, 10)),\n+            ),\n+            dict(\n+                x=(\"x\", np.linspace(0, 1.0, 8)),\n+                time=(\"time\", np.linspace(0, 1.0, 10)),\n+                c=(\"y\", [\"a\", \"b\"]),\n+                y=range(2),\n+            ),\n+        )\n+    elif request.param == 3:\n+        ds = create_test_data()\n+    else:\n+        raise ValueError\n+\n+    if backend == \"dask\":\n+        return ds.chunk()\n+\n+    return ds\n+\n+\n+class TestDataArrayRolling:\n+    @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n+    def test_rolling_iter(self, da) -> None:\n+        rolling_obj = da.rolling(time=7)\n+        rolling_obj_mean = rolling_obj.mean()\n+\n+        assert len(rolling_obj.window_labels) == len(da[\"time\"])\n+        assert_identical(rolling_obj.window_labels, da[\"time\"])\n+\n+        for i, (label, window_da) in enumerate(rolling_obj):\n+            assert label == da[\"time\"].isel(time=i)\n+\n+            actual = rolling_obj_mean.isel(time=i)\n+            expected = window_da.mean(\"time\")\n+\n+            # TODO add assert_allclose_with_nan, which compares nan position\n+            # as well as the closeness of the values.\n+            assert_array_equal(actual.isnull(), expected.isnull())\n+            if (~actual.isnull()).sum() > 0:\n+                np.allclose(\n+                    actual.values[actual.values.nonzero()],\n+                    expected.values[expected.values.nonzero()],\n+                )\n+\n+    @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n+    def test_rolling_repr(self, da) -> None:\n+        rolling_obj = da.rolling(time=7)\n+        assert repr(rolling_obj) == \"DataArrayRolling [time->7]\"\n+        rolling_obj = da.rolling(time=7, center=True)\n+        assert repr(rolling_obj) == \"DataArrayRolling [time->7(center)]\"\n+        rolling_obj = da.rolling(time=7, x=3, center=True)\n+        assert repr(rolling_obj) == \"DataArrayRolling [time->7(center),x->3(center)]\"\n+\n+    @requires_dask\n+    def test_repeated_rolling_rechunks(self) -> None:\n+\n+        # regression test for GH3277, GH2514\n+        dat = DataArray(np.random.rand(7653, 300), dims=(\"day\", \"item\"))\n+        dat_chunk = dat.chunk({\"item\": 20})\n+        dat_chunk.rolling(day=10).mean().rolling(day=250).std()\n+\n+    def test_rolling_doc(self, da) -> None:\n+        rolling_obj = da.rolling(time=7)\n+\n+        # argument substitution worked\n+        assert \"`mean`\" in rolling_obj.mean.__doc__\n+\n+    def test_rolling_properties(self, da) -> None:\n+        rolling_obj = da.rolling(time=4)\n+\n+        assert rolling_obj.obj.get_axis_num(\"time\") == 1\n+\n+        # catching invalid args\n+        with pytest.raises(ValueError, match=\"window must be > 0\"):\n+            da.rolling(time=-2)\n+\n+        with pytest.raises(ValueError, match=\"min_periods must be greater than zero\"):\n+            da.rolling(time=2, min_periods=0)\n+\n+    @pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"min\", \"max\", \"median\"))\n+    @pytest.mark.parametrize(\"center\", (True, False, None))\n+    @pytest.mark.parametrize(\"min_periods\", (1, None))\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    def test_rolling_wrapped_bottleneck(self, da, name, center, min_periods) -> None:\n+        bn = pytest.importorskip(\"bottleneck\", minversion=\"1.1\")\n+\n+        # Test all bottleneck functions\n+        rolling_obj = da.rolling(time=7, min_periods=min_periods)\n+\n+        func_name = f\"move_{name}\"\n+        actual = getattr(rolling_obj, name)()\n+        expected = getattr(bn, func_name)(\n+            da.values, window=7, axis=1, min_count=min_periods\n+        )\n+        assert_array_equal(actual.values, expected)\n+\n+        with pytest.warns(DeprecationWarning, match=\"Reductions are applied\"):\n+            getattr(rolling_obj, name)(dim=\"time\")\n+\n+        # Test center\n+        rolling_obj = da.rolling(time=7, center=center)\n+        actual = getattr(rolling_obj, name)()[\"time\"]\n+        assert_equal(actual, da[\"time\"])\n+\n+    @requires_dask\n+    @pytest.mark.parametrize(\"name\", (\"mean\", \"count\"))\n+    @pytest.mark.parametrize(\"center\", (True, False, None))\n+    @pytest.mark.parametrize(\"min_periods\", (1, None))\n+    @pytest.mark.parametrize(\"window\", (7, 8))\n+    @pytest.mark.parametrize(\"backend\", [\"dask\"], indirect=True)\n+    def test_rolling_wrapped_dask(self, da, name, center, min_periods, window) -> None:\n+        # dask version\n+        rolling_obj = da.rolling(time=window, min_periods=min_periods, center=center)\n+        actual = getattr(rolling_obj, name)().load()\n+        if name != \"count\":\n+            with pytest.warns(DeprecationWarning, match=\"Reductions are applied\"):\n+                getattr(rolling_obj, name)(dim=\"time\")\n+        # numpy version\n+        rolling_obj = da.load().rolling(\n+            time=window, min_periods=min_periods, center=center\n+        )\n+        expected = getattr(rolling_obj, name)()\n+\n+        # using all-close because rolling over ghost cells introduces some\n+        # precision errors\n+        assert_allclose(actual, expected)\n+\n+        # with zero chunked array GH:2113\n+        rolling_obj = da.chunk().rolling(\n+            time=window, min_periods=min_periods, center=center\n+        )\n+        actual = getattr(rolling_obj, name)().load()\n+        assert_allclose(actual, expected)\n+\n+    @pytest.mark.parametrize(\"center\", (True, None))\n+    def test_rolling_wrapped_dask_nochunk(self, center) -> None:\n+        # GH:2113\n+        pytest.importorskip(\"dask.array\")\n+\n+        da_day_clim = xr.DataArray(\n+            np.arange(1, 367), coords=[np.arange(1, 367)], dims=\"dayofyear\"\n+        )\n+        expected = da_day_clim.rolling(dayofyear=31, center=center).mean()\n+        actual = da_day_clim.chunk().rolling(dayofyear=31, center=center).mean()\n+        assert_allclose(actual, expected)\n+\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    def test_rolling_pandas_compat(self, center, window, min_periods) -> None:\n+        s = pd.Series(np.arange(10))\n+        da = DataArray.from_series(s)\n+\n+        if min_periods is not None and window < min_periods:\n+            min_periods = window\n+\n+        s_rolling = s.rolling(window, center=center, min_periods=min_periods).mean()\n+        da_rolling = da.rolling(\n+            index=window, center=center, min_periods=min_periods\n+        ).mean()\n+        da_rolling_np = da.rolling(\n+            index=window, center=center, min_periods=min_periods\n+        ).reduce(np.nanmean)\n+\n+        np.testing.assert_allclose(s_rolling.values, da_rolling.values)\n+        np.testing.assert_allclose(s_rolling.index, da_rolling[\"index\"])\n+        np.testing.assert_allclose(s_rolling.values, da_rolling_np.values)\n+        np.testing.assert_allclose(s_rolling.index, da_rolling_np[\"index\"])\n+\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    def test_rolling_construct(self, center, window) -> None:\n+        s = pd.Series(np.arange(10))\n+        da = DataArray.from_series(s)\n+\n+        s_rolling = s.rolling(window, center=center, min_periods=1).mean()\n+        da_rolling = da.rolling(index=window, center=center, min_periods=1)\n+\n+        da_rolling_mean = da_rolling.construct(\"window\").mean(\"window\")\n+        np.testing.assert_allclose(s_rolling.values, da_rolling_mean.values)\n+        np.testing.assert_allclose(s_rolling.index, da_rolling_mean[\"index\"])\n+\n+        # with stride\n+        da_rolling_mean = da_rolling.construct(\"window\", stride=2).mean(\"window\")\n+        np.testing.assert_allclose(s_rolling.values[::2], da_rolling_mean.values)\n+        np.testing.assert_allclose(s_rolling.index[::2], da_rolling_mean[\"index\"])\n+\n+        # with fill_value\n+        da_rolling_mean = da_rolling.construct(\"window\", stride=2, fill_value=0.0).mean(\n+            \"window\"\n+        )\n+        assert da_rolling_mean.isnull().sum() == 0\n+        assert (da_rolling_mean == 0.0).sum() >= 0\n+\n+    @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    @pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"std\", \"max\"))\n+    def test_rolling_reduce(self, da, center, min_periods, window, name) -> None:\n+        if min_periods is not None and window < min_periods:\n+            min_periods = window\n+\n+        if da.isnull().sum() > 1 and window == 1:\n+            # this causes all nan slices\n+            window = 2\n+\n+        rolling_obj = da.rolling(time=window, center=center, min_periods=min_periods)\n+\n+        # add nan prefix to numpy methods to get similar # behavior as bottleneck\n+        actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n+        expected = getattr(rolling_obj, name)()\n+        assert_allclose(actual, expected)\n+        assert actual.dims == expected.dims\n+\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    @pytest.mark.parametrize(\"name\", (\"sum\", \"max\"))\n+    def test_rolling_reduce_nonnumeric(self, center, min_periods, window, name) -> None:\n+        da = DataArray(\n+            [0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7], dims=\"time\"\n+        ).isnull()\n+\n+        if min_periods is not None and window < min_periods:\n+            min_periods = window\n+\n+        rolling_obj = da.rolling(time=window, center=center, min_periods=min_periods)\n+\n+        # add nan prefix to numpy methods to get similar behavior as bottleneck\n+        actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n+        expected = getattr(rolling_obj, name)()\n+        assert_allclose(actual, expected)\n+        assert actual.dims == expected.dims\n+\n+    def test_rolling_count_correct(self) -> None:\n+        da = DataArray([0, np.nan, 1, 2, np.nan, 3, 4, 5, np.nan, 6, 7], dims=\"time\")\n+\n+        kwargs: list[dict[str, Any]] = [\n+            {\"time\": 11, \"min_periods\": 1},\n+            {\"time\": 11, \"min_periods\": None},\n+            {\"time\": 7, \"min_periods\": 2},\n+        ]\n+        expecteds = [\n+            DataArray([1, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8], dims=\"time\"),\n+            DataArray(\n+                [\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                    np.nan,\n+                ],\n+                dims=\"time\",\n+            ),\n+            DataArray([np.nan, np.nan, 2, 3, 3, 4, 5, 5, 5, 5, 5], dims=\"time\"),\n+        ]\n+\n+        for kwarg, expected in zip(kwargs, expecteds):\n+            result = da.rolling(**kwarg).count()\n+            assert_equal(result, expected)\n+\n+            result = da.to_dataset(name=\"var1\").rolling(**kwarg).count()[\"var1\"]\n+            assert_equal(result, expected)\n+\n+    @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1))\n+    @pytest.mark.parametrize(\"name\", (\"sum\", \"mean\", \"max\"))\n+    def test_ndrolling_reduce(self, da, center, min_periods, name) -> None:\n+        rolling_obj = da.rolling(time=3, x=2, center=center, min_periods=min_periods)\n+\n+        actual = getattr(rolling_obj, name)()\n+        expected = getattr(\n+            getattr(\n+                da.rolling(time=3, center=center, min_periods=min_periods), name\n+            )().rolling(x=2, center=center, min_periods=min_periods),\n+            name,\n+        )()\n+\n+        assert_allclose(actual, expected)\n+        assert actual.dims == expected.dims\n+\n+        if name in [\"mean\"]:\n+            # test our reimplementation of nanmean using np.nanmean\n+            expected = getattr(rolling_obj.construct({\"time\": \"tw\", \"x\": \"xw\"}), name)(\n+                [\"tw\", \"xw\"]\n+            )\n+            count = rolling_obj.count()\n+            if min_periods is None:\n+                min_periods = 1\n+            assert_allclose(actual, expected.where(count >= min_periods))\n+\n+    @pytest.mark.parametrize(\"center\", (True, False, (True, False)))\n+    @pytest.mark.parametrize(\"fill_value\", (np.nan, 0.0))\n+    def test_ndrolling_construct(self, center, fill_value) -> None:\n+        da = DataArray(\n+            np.arange(5 * 6 * 7).reshape(5, 6, 7).astype(float),\n+            dims=[\"x\", \"y\", \"z\"],\n+            coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"], \"y\": np.arange(6)},\n+        )\n+        actual = da.rolling(x=3, z=2, center=center).construct(\n+            x=\"x1\", z=\"z1\", fill_value=fill_value\n+        )\n+        if not isinstance(center, tuple):\n+            center = (center, center)\n+        expected = (\n+            da.rolling(x=3, center=center[0])\n+            .construct(x=\"x1\", fill_value=fill_value)\n+            .rolling(z=2, center=center[1])\n+            .construct(z=\"z1\", fill_value=fill_value)\n+        )\n+        assert_allclose(actual, expected)\n+\n+    @pytest.mark.parametrize(\n+        \"funcname, argument\",\n+        [\n+            (\"reduce\", (np.mean,)),\n+            (\"mean\", ()),\n+            (\"construct\", (\"window_dim\",)),\n+            (\"count\", ()),\n+        ],\n+    )\n+    def test_rolling_keep_attrs(self, funcname, argument) -> None:\n+        attrs_da = {\"da_attr\": \"test\"}\n+\n+        data = np.linspace(10, 15, 100)\n+        coords = np.linspace(1, 10, 100)\n+\n+        da = DataArray(\n+            data, dims=(\"coord\"), coords={\"coord\": coords}, attrs=attrs_da, name=\"name\"\n+        )\n+\n+        # attrs are now kept per default\n+        func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n+        result = func(*argument)\n+        assert result.attrs == attrs_da\n+        assert result.name == \"name\"\n+\n+        # discard attrs\n+        func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n+        result = func(*argument, keep_attrs=False)\n+        assert result.attrs == {}\n+        assert result.name == \"name\"\n+\n+        # test discard attrs using global option\n+        func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=False):\n+            result = func(*argument)\n+        assert result.attrs == {}\n+        assert result.name == \"name\"\n+\n+        # keyword takes precedence over global option\n+        func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=False):\n+            result = func(*argument, keep_attrs=True)\n+        assert result.attrs == attrs_da\n+        assert result.name == \"name\"\n+\n+        func = getattr(da.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=True):\n+            result = func(*argument, keep_attrs=False)\n+        assert result.attrs == {}\n+        assert result.name == \"name\"\n+\n+\n+@requires_numbagg\n+class TestDataArrayRollingExp:\n+    @pytest.mark.parametrize(\"dim\", [\"time\", \"x\"])\n+    @pytest.mark.parametrize(\n+        \"window_type, window\",\n+        [[\"span\", 5], [\"alpha\", 0.5], [\"com\", 0.5], [\"halflife\", 5]],\n+    )\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    @pytest.mark.parametrize(\"func\", [\"mean\", \"sum\"])\n+    def test_rolling_exp_runs(self, da, dim, window_type, window, func) -> None:\n+        import numbagg\n+\n+        if (\n+            Version(getattr(numbagg, \"__version__\", \"0.1.0\")) < Version(\"0.2.1\")\n+            and func == \"sum\"\n+        ):\n+            pytest.skip(\"rolling_exp.sum requires numbagg 0.2.1\")\n+\n+        da = da.where(da > 0.2)\n+\n+        rolling_exp = da.rolling_exp(window_type=window_type, **{dim: window})\n+        result = getattr(rolling_exp, func)()\n+        assert isinstance(result, DataArray)\n+\n+    @pytest.mark.parametrize(\"dim\", [\"time\", \"x\"])\n+    @pytest.mark.parametrize(\n+        \"window_type, window\",\n+        [[\"span\", 5], [\"alpha\", 0.5], [\"com\", 0.5], [\"halflife\", 5]],\n+    )\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    def test_rolling_exp_mean_pandas(self, da, dim, window_type, window) -> None:\n+        da = da.isel(a=0).where(lambda x: x > 0.2)\n+\n+        result = da.rolling_exp(window_type=window_type, **{dim: window}).mean()\n+        assert isinstance(result, DataArray)\n+\n+        pandas_array = da.to_pandas()\n+        assert pandas_array.index.name == \"time\"\n+        if dim == \"x\":\n+            pandas_array = pandas_array.T\n+        expected = xr.DataArray(\n+            pandas_array.ewm(**{window_type: window}).mean()\n+        ).transpose(*da.dims)\n+\n+        assert_allclose(expected.variable, result.variable)\n+\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    @pytest.mark.parametrize(\"func\", [\"mean\", \"sum\"])\n+    def test_rolling_exp_keep_attrs(self, da, func) -> None:\n+        import numbagg\n+\n+        if (\n+            Version(getattr(numbagg, \"__version__\", \"0.1.0\")) < Version(\"0.2.1\")\n+            and func == \"sum\"\n+        ):\n+            pytest.skip(\"rolling_exp.sum requires numbagg 0.2.1\")\n+\n+        attrs = {\"attrs\": \"da\"}\n+        da.attrs = attrs\n+\n+        # Equivalent of `da.rolling_exp(time=10).mean`\n+        rolling_exp_func = getattr(da.rolling_exp(time=10), func)\n+\n+        # attrs are kept per default\n+        result = rolling_exp_func()\n+        assert result.attrs == attrs\n+\n+        # discard attrs\n+        result = rolling_exp_func(keep_attrs=False)\n+        assert result.attrs == {}\n+\n+        # test discard attrs using global option\n+        with set_options(keep_attrs=False):\n+            result = rolling_exp_func()\n+        assert result.attrs == {}\n+\n+        # keyword takes precedence over global option\n+        with set_options(keep_attrs=False):\n+            result = rolling_exp_func(keep_attrs=True)\n+        assert result.attrs == attrs\n+\n+        with set_options(keep_attrs=True):\n+            result = rolling_exp_func(keep_attrs=False)\n+        assert result.attrs == {}\n+\n+        with pytest.warns(\n+            UserWarning,\n+            match=\"Passing ``keep_attrs`` to ``rolling_exp`` has no effect.\",\n+        ):\n+            da.rolling_exp(time=10, keep_attrs=True)\n+\n+\n+class DatasetRolling:\n+    @pytest.mark.parametrize(\n+        \"funcname, argument\",\n+        [\n+            (\"reduce\", (np.mean,)),\n+            (\"mean\", ()),\n+            (\"construct\", (\"window_dim\",)),\n+            (\"count\", ()),\n+        ],\n+    )\n+    def test_rolling_keep_attrs(self, funcname, argument) -> None:\n+        global_attrs = {\"units\": \"test\", \"long_name\": \"testing\"}\n+        da_attrs = {\"da_attr\": \"test\"}\n+        da_not_rolled_attrs = {\"da_not_rolled_attr\": \"test\"}\n+\n+        data = np.linspace(10, 15, 100)\n+        coords = np.linspace(1, 10, 100)\n+\n+        ds = Dataset(\n+            data_vars={\"da\": (\"coord\", data), \"da_not_rolled\": (\"no_coord\", data)},\n+            coords={\"coord\": coords},\n+            attrs=global_attrs,\n+        )\n+        ds.da.attrs = da_attrs\n+        ds.da_not_rolled.attrs = da_not_rolled_attrs\n+\n+        # attrs are now kept per default\n+        func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n+        result = func(*argument)\n+        assert result.attrs == global_attrs\n+        assert result.da.attrs == da_attrs\n+        assert result.da_not_rolled.attrs == da_not_rolled_attrs\n+        assert result.da.name == \"da\"\n+        assert result.da_not_rolled.name == \"da_not_rolled\"\n+\n+        # discard attrs\n+        func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n+        result = func(*argument, keep_attrs=False)\n+        assert result.attrs == {}\n+        assert result.da.attrs == {}\n+        assert result.da_not_rolled.attrs == {}\n+        assert result.da.name == \"da\"\n+        assert result.da_not_rolled.name == \"da_not_rolled\"\n+\n+        # test discard attrs using global option\n+        func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=False):\n+            result = func(*argument)\n+\n+        assert result.attrs == {}\n+        assert result.da.attrs == {}\n+        assert result.da_not_rolled.attrs == {}\n+        assert result.da.name == \"da\"\n+        assert result.da_not_rolled.name == \"da_not_rolled\"\n+\n+        # keyword takes precedence over global option\n+        func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=False):\n+            result = func(*argument, keep_attrs=True)\n+\n+        assert result.attrs == global_attrs\n+        assert result.da.attrs == da_attrs\n+        assert result.da_not_rolled.attrs == da_not_rolled_attrs\n+        assert result.da.name == \"da\"\n+        assert result.da_not_rolled.name == \"da_not_rolled\"\n+\n+        func = getattr(ds.rolling(dim={\"coord\": 5}), funcname)\n+        with set_options(keep_attrs=True):\n+            result = func(*argument, keep_attrs=False)\n+\n+        assert result.attrs == {}\n+        assert result.da.attrs == {}\n+        assert result.da_not_rolled.attrs == {}\n+        assert result.da.name == \"da\"\n+        assert result.da_not_rolled.name == \"da_not_rolled\"\n+\n+    def test_rolling_properties(self, ds) -> None:\n+        # catching invalid args\n+        with pytest.raises(ValueError, match=\"window must be > 0\"):\n+            ds.rolling(time=-2)\n+        with pytest.raises(ValueError, match=\"min_periods must be greater than zero\"):\n+            ds.rolling(time=2, min_periods=0)\n+        with pytest.raises(KeyError, match=\"time2\"):\n+            ds.rolling(time2=2)\n+\n+    @pytest.mark.parametrize(\n+        \"name\", (\"sum\", \"mean\", \"std\", \"var\", \"min\", \"max\", \"median\")\n+    )\n+    @pytest.mark.parametrize(\"center\", (True, False, None))\n+    @pytest.mark.parametrize(\"min_periods\", (1, None))\n+    @pytest.mark.parametrize(\"key\", (\"z1\", \"z2\"))\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    def test_rolling_wrapped_bottleneck(\n+        self, ds, name, center, min_periods, key\n+    ) -> None:\n+        bn = pytest.importorskip(\"bottleneck\", minversion=\"1.1\")\n+\n+        # Test all bottleneck functions\n+        rolling_obj = ds.rolling(time=7, min_periods=min_periods)\n+\n+        func_name = f\"move_{name}\"\n+        actual = getattr(rolling_obj, name)()\n+        if key == \"z1\":  # z1 does not depend on 'Time' axis. Stored as it is.\n+            expected = ds[key]\n+        elif key == \"z2\":\n+            expected = getattr(bn, func_name)(\n+                ds[key].values, window=7, axis=0, min_count=min_periods\n+            )\n+        else:\n+            raise ValueError\n+        assert_array_equal(actual[key].values, expected)\n+\n+        # Test center\n+        rolling_obj = ds.rolling(time=7, center=center)\n+        actual = getattr(rolling_obj, name)()[\"time\"]\n+        assert_equal(actual, ds[\"time\"])\n+\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    def test_rolling_pandas_compat(self, center, window, min_periods) -> None:\n+        df = pd.DataFrame(\n+            {\n+                \"x\": np.random.randn(20),\n+                \"y\": np.random.randn(20),\n+                \"time\": np.linspace(0, 1, 20),\n+            }\n+        )\n+        ds = Dataset.from_dataframe(df)\n+\n+        if min_periods is not None and window < min_periods:\n+            min_periods = window\n+\n+        df_rolling = df.rolling(window, center=center, min_periods=min_periods).mean()\n+        ds_rolling = ds.rolling(\n+            index=window, center=center, min_periods=min_periods\n+        ).mean()\n+\n+        np.testing.assert_allclose(df_rolling[\"x\"].values, ds_rolling[\"x\"].values)\n+        np.testing.assert_allclose(df_rolling.index, ds_rolling[\"index\"])\n+\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    def test_rolling_construct(self, center, window) -> None:\n+        df = pd.DataFrame(\n+            {\n+                \"x\": np.random.randn(20),\n+                \"y\": np.random.randn(20),\n+                \"time\": np.linspace(0, 1, 20),\n+            }\n+        )\n+\n+        ds = Dataset.from_dataframe(df)\n+        df_rolling = df.rolling(window, center=center, min_periods=1).mean()\n+        ds_rolling = ds.rolling(index=window, center=center)\n+\n+        ds_rolling_mean = ds_rolling.construct(\"window\").mean(\"window\")\n+        np.testing.assert_allclose(df_rolling[\"x\"].values, ds_rolling_mean[\"x\"].values)\n+        np.testing.assert_allclose(df_rolling.index, ds_rolling_mean[\"index\"])\n+\n+        # with stride\n+        ds_rolling_mean = ds_rolling.construct(\"window\", stride=2).mean(\"window\")\n+        np.testing.assert_allclose(\n+            df_rolling[\"x\"][::2].values, ds_rolling_mean[\"x\"].values\n+        )\n+        np.testing.assert_allclose(df_rolling.index[::2], ds_rolling_mean[\"index\"])\n+        # with fill_value\n+        ds_rolling_mean = ds_rolling.construct(\"window\", stride=2, fill_value=0.0).mean(\n+            \"window\"\n+        )\n+        assert (ds_rolling_mean.isnull().sum() == 0).to_array(dim=\"vars\").all()\n+        assert (ds_rolling_mean[\"x\"] == 0.0).sum() >= 0\n+\n+    @pytest.mark.slow\n+    @pytest.mark.parametrize(\"ds\", (1, 2), indirect=True)\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1, 2, 3))\n+    @pytest.mark.parametrize(\"window\", (1, 2, 3, 4))\n+    @pytest.mark.parametrize(\n+        \"name\", (\"sum\", \"mean\", \"std\", \"var\", \"min\", \"max\", \"median\")\n+    )\n+    def test_rolling_reduce(self, ds, center, min_periods, window, name) -> None:\n+\n+        if min_periods is not None and window < min_periods:\n+            min_periods = window\n+\n+        if name == \"std\" and window == 1:\n+            pytest.skip(\"std with window == 1 is unstable in bottleneck\")\n+\n+        rolling_obj = ds.rolling(time=window, center=center, min_periods=min_periods)\n+\n+        # add nan prefix to numpy methods to get similar behavior as bottleneck\n+        actual = rolling_obj.reduce(getattr(np, \"nan%s\" % name))\n+        expected = getattr(rolling_obj, name)()\n+        assert_allclose(actual, expected)\n+        assert ds.dims == actual.dims\n+        # make sure the order of data_var are not changed.\n+        assert list(ds.data_vars.keys()) == list(actual.data_vars.keys())\n+\n+        # Make sure the dimension order is restored\n+        for key, src_var in ds.data_vars.items():\n+            assert src_var.dims == actual[key].dims\n+\n+    @pytest.mark.parametrize(\"ds\", (2,), indirect=True)\n+    @pytest.mark.parametrize(\"center\", (True, False))\n+    @pytest.mark.parametrize(\"min_periods\", (None, 1))\n+    @pytest.mark.parametrize(\"name\", (\"sum\", \"max\"))\n+    @pytest.mark.parametrize(\"dask\", (True, False))\n+    def test_ndrolling_reduce(self, ds, center, min_periods, name, dask) -> None:\n+        if dask and has_dask:\n+            ds = ds.chunk({\"x\": 4})\n+\n+        rolling_obj = ds.rolling(time=4, x=3, center=center, min_periods=min_periods)\n+\n+        actual = getattr(rolling_obj, name)()\n+        expected = getattr(\n+            getattr(\n+                ds.rolling(time=4, center=center, min_periods=min_periods), name\n+            )().rolling(x=3, center=center, min_periods=min_periods),\n+            name,\n+        )()\n+        assert_allclose(actual, expected)\n+        assert actual.dims == expected.dims\n+\n+        # Do it in the opposite order\n+        expected = getattr(\n+            getattr(\n+                ds.rolling(x=3, center=center, min_periods=min_periods), name\n+            )().rolling(time=4, center=center, min_periods=min_periods),\n+            name,\n+        )()\n+\n+        assert_allclose(actual, expected)\n+        assert actual.dims == expected.dims\n+\n+    @pytest.mark.parametrize(\"center\", (True, False, (True, False)))\n+    @pytest.mark.parametrize(\"fill_value\", (np.nan, 0.0))\n+    @pytest.mark.parametrize(\"dask\", (True, False))\n+    def test_ndrolling_construct(self, center, fill_value, dask) -> None:\n+        da = DataArray(\n+            np.arange(5 * 6 * 7).reshape(5, 6, 7).astype(float),\n+            dims=[\"x\", \"y\", \"z\"],\n+            coords={\"x\": [\"a\", \"b\", \"c\", \"d\", \"e\"], \"y\": np.arange(6)},\n+        )\n+        ds = xr.Dataset({\"da\": da})\n+        if dask and has_dask:\n+            ds = ds.chunk({\"x\": 4})\n+\n+        actual = ds.rolling(x=3, z=2, center=center).construct(\n+            x=\"x1\", z=\"z1\", fill_value=fill_value\n+        )\n+        if not isinstance(center, tuple):\n+            center = (center, center)\n+        expected = (\n+            ds.rolling(x=3, center=center[0])\n+            .construct(x=\"x1\", fill_value=fill_value)\n+            .rolling(z=2, center=center[1])\n+            .construct(z=\"z1\", fill_value=fill_value)\n+        )\n+        assert_allclose(actual, expected)\n+\n+    @pytest.mark.xfail(\n+        reason=\"See https://github.com/pydata/xarray/pull/4369 or docstring\"\n+    )\n+    @pytest.mark.filterwarnings(\"error\")\n+    @pytest.mark.parametrize(\"ds\", (2,), indirect=True)\n+    @pytest.mark.parametrize(\"name\", (\"mean\", \"max\"))\n+    def test_raise_no_warning_dask_rolling_assert_close(self, ds, name) -> None:\n+        \"\"\"\n+        This is a puzzle \u2014 I can't easily find the source of the warning. It\n+        requires `assert_allclose` to be run, for the `ds` param to be 2, and is\n+        different for `mean` and `max`. `sum` raises no warning.\n+        \"\"\"\n+\n+        ds = ds.chunk({\"x\": 4})\n+\n+        rolling_obj = ds.rolling(time=4, x=3)\n+\n+        actual = getattr(rolling_obj, name)()\n+        expected = getattr(getattr(ds.rolling(time=4), name)().rolling(x=3), name)()\n+        assert_allclose(actual, expected)\n+\n+\n+@requires_numbagg\n+class DatasetRollingExp:\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    def test_rolling_exp(self, ds) -> None:\n+\n+        result = ds.rolling_exp(time=10, window_type=\"span\").mean()\n+        assert isinstance(result, Dataset)\n+\n+    @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n+    def test_rolling_exp_keep_attrs(self, ds) -> None:\n+\n+        attrs_global = {\"attrs\": \"global\"}\n+        attrs_z1 = {\"attr\": \"z1\"}\n+\n+        ds.attrs = attrs_global\n+        ds.z1.attrs = attrs_z1\n+\n+        # attrs are kept per default\n+        result = ds.rolling_exp(time=10).mean()\n+        assert result.attrs == attrs_global\n+        assert result.z1.attrs == attrs_z1\n+\n+        # discard attrs\n+        result = ds.rolling_exp(time=10).mean(keep_attrs=False)\n+        assert result.attrs == {}\n+        assert result.z1.attrs == {}\n+\n+        # test discard attrs using global option\n+        with set_options(keep_attrs=False):\n+            result = ds.rolling_exp(time=10).mean()\n+        assert result.attrs == {}\n+        assert result.z1.attrs == {}\n+\n+        # keyword takes precedence over global option\n+        with set_options(keep_attrs=False):\n+            result = ds.rolling_exp(time=10).mean(keep_attrs=True)\n+        assert result.attrs == attrs_global\n+        assert result.z1.attrs == attrs_z1\n+\n+        with set_options(keep_attrs=True):\n+            result = ds.rolling_exp(time=10).mean(keep_attrs=False)\n+        assert result.attrs == {}\n+        assert result.z1.attrs == {}\n+\n+        with pytest.warns(\n+            UserWarning,\n+            match=\"Passing ``keep_attrs`` to ``rolling_exp`` has no effect.\",\n+        ):\n+            ds.rolling_exp(time=10, keep_attrs=True)\n\nFrom 3cf6f8b4cf18874edc938e33726fcdf486b2c9aa Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Sat, 2 Jul 2022 18:33:00 +0200\nSubject: [PATCH 2/5] fix rolling iter with center=True\n\n---\n xarray/core/rolling.py       |  9 ++++++---\n xarray/tests/test_rolling.py | 15 +++++----------\n 2 files changed, 11 insertions(+), 13 deletions(-)\n\ndiff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex aef290f6d7f..578836dcc60 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -267,12 +267,15 @@ def __init__(\n         # TODO legacy attribute\n         self.window_labels = self.obj[self.dim[0]]\n \n-    def __iter__(self) -> Iterator[tuple[RollingKey, DataArray]]:\n+    def __iter__(self) -> Iterator[tuple[DataArray, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n-        stops = np.arange(1, len(self.window_labels) + 1)\n+\n+        offset = int(self.window[0] + 1) // 2 if self.center[0] else 1\n+        stops = np.arange(offset, self.obj.sizes[self.dim[0]] + offset)\n         starts = stops - int(self.window[0])\n-        starts[: int(self.window[0])] = 0\n+        starts[: int(self.window[0]) - offset] = 0\n+\n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n             window = self.obj.isel({self.dim[0]: slice(start, stop)})\n \ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex b46dcb14211..a2496baeeff 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -104,8 +104,10 @@ def ds(request, backend):\n \n class TestDataArrayRolling:\n     @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-    def test_rolling_iter(self, da) -> None:\n-        rolling_obj = da.rolling(time=7)\n+    @pytest.mark.parametrize(\"center\", [True, False])\n+    @pytest.mark.parametrize(\"size\", [1, 2, 3, 7])\n+    def test_rolling_iter(self, da: DataArray, center: bool, size: int) -> None:\n+        rolling_obj = da.rolling(time=size, center=center)\n         rolling_obj_mean = rolling_obj.mean()\n \n         assert len(rolling_obj.window_labels) == len(da[\"time\"])\n@@ -117,14 +119,7 @@ def test_rolling_iter(self, da) -> None:\n             actual = rolling_obj_mean.isel(time=i)\n             expected = window_da.mean(\"time\")\n \n-            # TODO add assert_allclose_with_nan, which compares nan position\n-            # as well as the closeness of the values.\n-            assert_array_equal(actual.isnull(), expected.isnull())\n-            if (~actual.isnull()).sum() > 0:\n-                np.allclose(\n-                    actual.values[actual.values.nonzero()],\n-                    expected.values[expected.values.nonzero()],\n-                )\n+            np.testing.assert_allclose(actual.values, expected.values)\n \n     @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n     def test_rolling_repr(self, da) -> None:\n\nFrom be4f6e0b2900ddebddb1679baa03e7ab26d466fe Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Sat, 2 Jul 2022 18:37:23 +0200\nSubject: [PATCH 3/5] add fix to whats-new\n\n---\n doc/whats-new.rst | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex ca3d152a860..83afdf2fb5e 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -54,6 +54,9 @@ Bug fixes\n - :py:meth:`open_dataset` with dask and ``~`` in the path now resolves the home directory\n   instead of raising an error. (:issue:`6707`, :pull:`6710`)\n   By `Michael Niklas <https://github.com/headtr1ck>`_.\n+- :py:meth:`DataArrayRolling.__iter__` with ``center=True`` now works correctly.\n+  (:issue:`6739`, :pull:`6744`)\n+  By `Michael Niklas <https://github.com/headtr1ck>`_.\n \n Documentation\n ~~~~~~~~~~~~~\n\nFrom 868cc9cf38bb164fc9ee2c1a8db708c7e448e56a Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Sat, 2 Jul 2022 20:49:05 +0200\nSubject: [PATCH 4/5] fix DatasetRolling test names\n\n---\n xarray/tests/test_rolling.py | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex a2496baeeff..91088fa817d 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -541,7 +541,7 @@ def test_rolling_exp_keep_attrs(self, da, func) -> None:\n             da.rolling_exp(time=10, keep_attrs=True)\n \n \n-class DatasetRolling:\n+class TestDatasetRolling:\n     @pytest.mark.parametrize(\n         \"funcname, argument\",\n         [\n@@ -825,7 +825,7 @@ def test_raise_no_warning_dask_rolling_assert_close(self, ds, name) -> None:\n \n \n @requires_numbagg\n-class DatasetRollingExp:\n+class TestDatasetRollingExp:\n     @pytest.mark.parametrize(\"backend\", [\"numpy\"], indirect=True)\n     def test_rolling_exp(self, ds) -> None:\n \n\nFrom dd88f5d2ee137f932e1cd87233b0296b83bfba9b Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Sun, 3 Jul 2022 14:10:46 +0200\nSubject: [PATCH 5/5] small code simplification\n\n---\n xarray/core/rolling.py | 14 ++++++++------\n 1 file changed, 8 insertions(+), 6 deletions(-)\n\ndiff --git a/xarray/core/rolling.py b/xarray/core/rolling.py\nindex 578836dcc60..43a941b90d3 100644\n--- a/xarray/core/rolling.py\n+++ b/xarray/core/rolling.py\n@@ -271,15 +271,17 @@ def __iter__(self) -> Iterator[tuple[DataArray, DataArray]]:\n         if self.ndim > 1:\n             raise ValueError(\"__iter__ is only supported for 1d-rolling\")\n \n-        offset = int(self.window[0] + 1) // 2 if self.center[0] else 1\n-        stops = np.arange(offset, self.obj.sizes[self.dim[0]] + offset)\n-        starts = stops - int(self.window[0])\n-        starts[: int(self.window[0]) - offset] = 0\n+        dim0 = self.dim[0]\n+        window0 = int(self.window[0])\n+        offset = (window0 + 1) // 2 if self.center[0] else 1\n+        stops = np.arange(offset, self.obj.sizes[dim0] + offset)\n+        starts = stops - window0\n+        starts[: window0 - offset] = 0\n \n         for (label, start, stop) in zip(self.window_labels, starts, stops):\n-            window = self.obj.isel({self.dim[0]: slice(start, stop)})\n+            window = self.obj.isel({dim0: slice(start, stop)})\n \n-            counts = window.count(dim=self.dim[0])\n+            counts = window.count(dim=dim0)\n             window = window.where(counts >= self.min_periods)\n \n             yield (label, window)\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/6744"}