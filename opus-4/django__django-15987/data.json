{"instance_id": "django__django-15987", "score": "C", "diff": "diff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py\nindex ac97f13161..7b7b2e65f1 100644\n--- a/django/core/management/commands/loaddata.py\n+++ b/django/core/management/commands/loaddata.py\n@@ -362,12 +362,15 @@ class Command(BaseCommand):\n         \"\"\"\n         dirs = []\n         fixture_dirs = settings.FIXTURE_DIRS\n-        if len(fixture_dirs) != len(set(fixture_dirs)):\n+        # Convert all paths to strings for duplicate detection\n+        fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+        if len(fixture_dirs_str) != len(set(fixture_dirs_str)):\n             raise ImproperlyConfigured(\"settings.FIXTURE_DIRS contains duplicates.\")\n         for app_config in apps.get_app_configs():\n             app_label = app_config.label\n             app_dir = os.path.join(app_config.path, \"fixtures\")\n-            if app_dir in fixture_dirs:\n+            # Also convert to string when checking if app_dir is in fixture_dirs\n+            if app_dir in fixture_dirs_str:\n                 raise ImproperlyConfigured(\n                     \"'%s' is a default fixture directory for the '%s' app \"\n                     \"and cannot be listed in settings.FIXTURE_DIRS.\"\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..d3cf228b3e\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,43 @@\n+import os\n+from pathlib import Path\n+\n+# Test edge cases for os.fspath()\n+\n+# Test 1: Empty list\n+fixture_dirs = []\n+fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+print(f\"Empty list: {fixture_dirs_str}\")\n+\n+# Test 2: None value - this would raise TypeError\n+try:\n+    fixture_dirs = [None]\n+    fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+except TypeError as e:\n+    print(f\"None value error: {e}\")\n+\n+# Test 3: Bytes path (valid on Unix)\n+try:\n+    fixture_dirs = [b'/path/to/fixtures']\n+    fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+    print(f\"Bytes path: {fixture_dirs_str}\")\n+except Exception as e:\n+    print(f\"Bytes path error: {e}\")\n+\n+# Test 4: Integer (invalid)\n+try:\n+    fixture_dirs = [123]\n+    fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+except TypeError as e:\n+    print(f\"Integer error: {e}\")\n+\n+# Test 5: Custom path-like object\n+class CustomPath:\n+    def __init__(self, path):\n+        self._path = path\n+    \n+    def __fspath__(self):\n+        return self._path\n+\n+fixture_dirs = [CustomPath('/custom/path')]\n+fixture_dirs_str = [os.fspath(d) for d in fixture_dirs]\n+print(f\"Custom path-like object: {fixture_dirs_str}\")\ndiff --git a/test_fixture_dirs_path.py b/test_fixture_dirs_path.py\nnew file mode 100644\nindex 0000000000..f2617859f9\n--- /dev/null\n+++ b/test_fixture_dirs_path.py\n@@ -0,0 +1,48 @@\n+from pathlib import Path\n+\n+# Test showing the potential issue with Path duplicates\n+# Let's test various scenarios\n+\n+# Same path as Path objects\n+path1 = Path(\"/some/path\")\n+path2 = Path(\"/some/path\")\n+print(f\"Same path as Path objects:\")\n+print(f\"  path1 == path2: {path1 == path2}\")\n+print(f\"  len([path1, path2]) != len(set([path1, path2])): {len([path1, path2]) != len(set([path1, path2]))}\")\n+\n+# Different forms of the same path\n+path3 = Path(\"/some/./path\")  # With redundant ./\n+path4 = Path(\"/some/../some/path\")  # With ../\n+path5 = Path(\"/some//path\")  # With double slashes\n+\n+print(f\"\\nDifferent forms of same path:\")\n+print(f\"  path1: {path1}\")\n+print(f\"  path3 (with ./): {path3}\")\n+print(f\"  path4 (with ../): {path4}\")  \n+print(f\"  path5 (with //): {path5}\")\n+\n+print(f\"\\nEquality checks:\")\n+print(f\"  path1 == path3: {path1 == path3}\")\n+print(f\"  path1 == path4: {path1 == path4}\")\n+print(f\"  path1 == path5: {path1 == path5}\")\n+\n+print(f\"\\nSet uniqueness:\")\n+paths = [path1, path3, path4, path5]\n+print(f\"  Number of paths: {len(paths)}\")\n+print(f\"  Number of unique paths in set: {len(set(paths))}\")\n+print(f\"  Set contains: {set(paths)}\")\n+\n+# Let's also check what happens with relative vs absolute paths\n+rel_path = Path(\"some/path\")\n+abs_path = Path(\"/some/path\")\n+print(f\"\\nRelative vs absolute paths:\")\n+print(f\"  rel_path: {rel_path}\")\n+print(f\"  abs_path: {abs_path}\")\n+print(f\"  rel_path == abs_path: {rel_path == abs_path}\")\n+\n+# Check with mixed strings and Paths\n+print(f\"\\nMixed strings and Paths:\")\n+mixed = [\"/some/path\", Path(\"/some/path\")]\n+print(f\"  List: {mixed}\")\n+print(f\"  Set: {set(mixed)}\")\n+print(f\"  Duplicate detected: {len(mixed) != len(set(mixed))}\")\ndiff --git a/test_fixture_dirs_path_django.py b/test_fixture_dirs_path_django.py\nnew file mode 100644\nindex 0000000000..71036ca7aa\n--- /dev/null\n+++ b/test_fixture_dirs_path_django.py\n@@ -0,0 +1,51 @@\n+\"\"\"\n+Test case for loaddata command's handling of Path objects in FIXTURE_DIRS.\n+This test can be added to Django's test suite in tests/fixtures/tests.py\n+\"\"\"\n+import os\n+import tempfile\n+from pathlib import Path\n+\n+from django.core.exceptions import ImproperlyConfigured\n+from django.core.management import CommandError, call_command\n+from django.test import TestCase, override_settings\n+\n+\n+class FixtureDirsPathTests(TestCase):\n+    \"\"\"Test fixture directory handling with Path objects.\"\"\"\n+\n+    def test_fixture_dirs_with_path_duplicates(self):\n+        \"\"\"settings.FIXTURE_DIRS should detect duplicates even with Path objects.\"\"\"\n+        # String duplicates (existing behavior)\n+        with override_settings(FIXTURE_DIRS=['/path/to/fixtures', '/path/to/fixtures']):\n+            with self.assertRaisesMessage(ImproperlyConfigured, \"settings.FIXTURE_DIRS contains duplicates.\"):\n+                call_command('loaddata', 'dummy', verbosity=0)\n+\n+        # Path object duplicates\n+        with override_settings(FIXTURE_DIRS=[Path('/path/to/fixtures'), Path('/path/to/fixtures')]):\n+            with self.assertRaisesMessage(ImproperlyConfigured, \"settings.FIXTURE_DIRS contains duplicates.\"):\n+                call_command('loaddata', 'dummy', verbosity=0)\n+\n+        # Mixed string and Path duplicates (the bug that was fixed)\n+        with override_settings(FIXTURE_DIRS=['/path/to/fixtures', Path('/path/to/fixtures')]):\n+            with self.assertRaisesMessage(ImproperlyConfigured, \"settings.FIXTURE_DIRS contains duplicates.\"):\n+                call_command('loaddata', 'dummy', verbosity=0)\n+\n+    def test_fixture_dirs_with_path_objects(self):\n+        \"\"\"Path objects in FIXTURE_DIRS should work correctly.\"\"\"\n+        with tempfile.TemporaryDirectory() as temp_dir:\n+            # Create a fixture file\n+            fixture_dir = Path(temp_dir) / 'fixtures'\n+            fixture_dir.mkdir()\n+            fixture_file = fixture_dir / 'test.json'\n+            fixture_file.write_text('[]')\n+\n+            # Test with Path object in FIXTURE_DIRS\n+            with override_settings(FIXTURE_DIRS=[Path(temp_dir) / 'fixtures']):\n+                # This should work without errors (though the fixture is empty)\n+                call_command('loaddata', 'test', verbosity=0)\n+\n+            # Test with mixed strings and Path objects\n+            with override_settings(FIXTURE_DIRS=[str(fixture_dir), Path(temp_dir) / 'other']):\n+                # This should work without errors\n+                call_command('loaddata', 'test', verbosity=0)\ndiff --git a/test_fspath.py b/test_fspath.py\nnew file mode 100644\nindex 0000000000..f2c20519d2\n--- /dev/null\n+++ b/test_fspath.py\n@@ -0,0 +1,28 @@\n+import os\n+from pathlib import Path\n+\n+# Test that os.fspath works correctly with both strings and Path objects\n+test_string = \"/path/to/fixtures\"\n+test_path = Path(\"/path/to/fixtures\")\n+\n+print(f\"os.fspath('{test_string}') = '{os.fspath(test_string)}'\")\n+print(f\"os.fspath(Path('{test_path}')) = '{os.fspath(test_path)}'\")\n+print(f\"Both results are equal: {os.fspath(test_string) == os.fspath(test_path)}\")\n+\n+# Test with various path types\n+paths = [\n+    \"/path/to/fixtures\",\n+    Path(\"/path/to/fixtures\"),\n+    Path(\"/path/./to/fixtures\"),\n+    \"/path/./to/fixtures\",\n+]\n+\n+print(\"\\nConverting all to strings with os.fspath:\")\n+for p in paths:\n+    print(f\"  {repr(p)} -> '{os.fspath(p)}'\")\n+\n+# Verify that different representations become the same\n+print(f\"\\nComparing normalized paths:\")\n+normalized = [os.fspath(p) for p in paths[:2]]\n+print(f\"set({normalized}) = {set(normalized)}\")\n+print(f\"Duplicates detected: {len(normalized) != len(set(normalized))}\")\ndiff --git a/test_loaddata_fixture_dirs.py b/test_loaddata_fixture_dirs.py\nnew file mode 100644\nindex 0000000000..ecfab6b438\n--- /dev/null\n+++ b/test_loaddata_fixture_dirs.py\n@@ -0,0 +1,76 @@\n+\"\"\"Test for the loaddata command fixture directory duplicate detection issue.\"\"\"\n+import os\n+import sys\n+from pathlib import Path\n+from unittest.mock import Mock, patch\n+\n+# Add Django to the path\n+sys.path.insert(0, '/testbed')\n+\n+from django.conf import settings\n+from django.core.management.commands.loaddata import Command\n+from django.core.exceptions import ImproperlyConfigured\n+\n+# Configure Django settings\n+settings.configure(\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+\n+import django\n+django.setup()\n+\n+def test_fixture_dirs_with_path_duplicates():\n+    \"\"\"Test that duplicates are detected when FIXTURE_DIRS contains Path objects.\"\"\"\n+    \n+    # Test 1: String duplicates (should be detected - current behavior)\n+    print(\"Test 1: String duplicates\")\n+    with patch.object(settings, 'FIXTURE_DIRS', ['/path/to/fixtures', '/path/to/fixtures']):\n+        cmd = Command()\n+        cmd.app_label = None  # Initialize the attribute\n+        try:\n+            _ = cmd.fixture_dirs\n+            print(\"  FAILED: No exception raised for string duplicates\")\n+        except ImproperlyConfigured as e:\n+            print(f\"  PASSED: {e}\")\n+    \n+    # Test 2: Path object duplicates (should be detected)\n+    print(\"\\nTest 2: Path object duplicates\")\n+    with patch.object(settings, 'FIXTURE_DIRS', [Path('/path/to/fixtures'), Path('/path/to/fixtures')]):\n+        cmd = Command()\n+        cmd.app_label = None  # Initialize the attribute\n+        try:\n+            _ = cmd.fixture_dirs\n+            print(\"  FAILED: No exception raised for Path duplicates\")\n+        except ImproperlyConfigured as e:\n+            print(f\"  PASSED: {e}\")\n+    \n+    # Test 3: Mixed string and Path duplicates (currently NOT detected - this is the bug)\n+    print(\"\\nTest 3: Mixed string and Path duplicates (THE BUG)\")\n+    with patch.object(settings, 'FIXTURE_DIRS', ['/path/to/fixtures', Path('/path/to/fixtures')]):\n+        cmd = Command()\n+        cmd.app_label = None  # Initialize the attribute\n+        try:\n+            _ = cmd.fixture_dirs\n+            print(\"  FAILED: No exception raised for mixed string/Path duplicates - THIS IS THE BUG!\")\n+        except ImproperlyConfigured as e:\n+            print(f\"  PASSED: {e}\")\n+    \n+    # Test 4: No duplicates with mixed types (should pass)\n+    print(\"\\nTest 4: No duplicates with mixed types\")\n+    with patch.object(settings, 'FIXTURE_DIRS', ['/path/to/fixtures1', Path('/path/to/fixtures2')]):\n+        cmd = Command()\n+        cmd.app_label = None  # Initialize the attribute\n+        try:\n+            dirs = cmd.fixture_dirs\n+            print(f\"  PASSED: No exception raised, dirs={dirs[-2:]}\")  # Show last 2 (excluding '')\n+        except ImproperlyConfigured as e:\n+            print(f\"  FAILED: Unexpected exception: {e}\")\n+\n+if __name__ == '__main__':\n+    test_fixture_dirs_with_path_duplicates()\n", "gold_standard_diff": "From d4674bb7c05b9f7ce6fbdf2639d43beacec25ff8 Mon Sep 17 00:00:00 2001\nFrom: Claude Paroz <claude@2xlibre.net>\nDate: Tue, 23 Aug 2022 12:05:27 +0200\nSubject: [PATCH] Fixed #33949 -- Fixed fixture dirs duplicates with Path\n instances.\n\n---\n django/core/management/commands/loaddata.py |  2 +-\n tests/fixtures_regress/tests.py             | 14 ++++++++++++++\n 2 files changed, 15 insertions(+), 1 deletion(-)\n\ndiff --git a/django/core/management/commands/loaddata.py b/django/core/management/commands/loaddata.py\nindex ac97f1316159..6fae25540748 100644\n--- a/django/core/management/commands/loaddata.py\n+++ b/django/core/management/commands/loaddata.py\n@@ -367,7 +367,7 @@ def fixture_dirs(self):\n         for app_config in apps.get_app_configs():\n             app_label = app_config.label\n             app_dir = os.path.join(app_config.path, \"fixtures\")\n-            if app_dir in fixture_dirs:\n+            if app_dir in [str(d) for d in fixture_dirs]:\n                 raise ImproperlyConfigured(\n                     \"'%s' is a default fixture directory for the '%s' app \"\n                     \"and cannot be listed in settings.FIXTURE_DIRS.\"\ndiff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 8c9228f67517..ff796feb94f6 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -569,6 +569,20 @@ def test_fixture_dirs_with_default_fixture_path(self):\n         with self.assertRaisesMessage(ImproperlyConfigured, msg):\n             management.call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n \n+    @override_settings(FIXTURE_DIRS=[Path(_cur_dir) / \"fixtures\"])\n+    def test_fixture_dirs_with_default_fixture_path_as_pathlib(self):\n+        \"\"\"\n+        settings.FIXTURE_DIRS cannot contain a default fixtures directory\n+        for application (app/fixtures) in order to avoid repeated fixture loading.\n+        \"\"\"\n+        msg = (\n+            \"'%s' is a default fixture directory for the '%s' app \"\n+            \"and cannot be listed in settings.FIXTURE_DIRS.\"\n+            % (os.path.join(_cur_dir, \"fixtures\"), \"fixtures_regress\")\n+        )\n+        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            management.call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n+\n     @override_settings(\n         FIXTURE_DIRS=[\n             os.path.join(_cur_dir, \"fixtures_1\"),\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15987"}