diff --git a/django/core/management/commands/runserver.py b/django/core/management/commands/runserver.py
index 3c39f57e4d..67a36ef2b7 100644
--- a/django/core/management/commands/runserver.py
+++ b/django/core/management/commands/runserver.py
@@ -147,7 +147,7 @@ class Command(BaseCommand):
                 "version": self.get_version(),
                 "settings": settings.SETTINGS_MODULE,
                 "protocol": self.protocol,
-                "addr": "[%s]" % self.addr if self._raw_ipv6 else self.addr,
+                "addr": "[%s]" % self.addr if self._raw_ipv6 else ("0.0.0.0" if self.addr == "0" else self.addr),
                 "port": self.port,
                 "quit_command": quit_command,
             }
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..6c0066575b
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,84 @@
+#!/usr/bin/env python
+import os
+import sys
+
+# Add Django to path
+sys.path.insert(0, '/testbed')
+
+# Configure Django settings inline
+from django.conf import settings
+settings.configure(
+    DEBUG=True,
+    SECRET_KEY='test-key',
+    ALLOWED_HOSTS=['*'],
+    INSTALLED_APPS=[],
+)
+
+import django
+django.setup()
+
+# Now test directly
+from io import StringIO
+from django.core.management.commands.runserver import Command
+
+print("Testing Django runserver command output fix...")
+print("=" * 60)
+
+# Test case 1: '0:9001' should display as 'http://0.0.0.0:9001/'
+print("\nTest 1: runserver 0:9001")
+cmd = Command()
+cmd.stdout = StringIO()
+cmd.stderr = StringIO()
+
+# Parse the address
+options = {
+    'addrport': '0:9001',
+    'use_reloader': False,
+    'skip_checks': True,
+    'use_threading': False,
+    'use_ipv6': False,
+    'no_color': False
+}
+
+# Get parsed values
+try:
+    cmd.handle(**options)
+except SystemExit:
+    # This is expected - runserver tries to exit after binding
+    pass
+except Exception as e:
+    print(f"  Error during handle: {e}")
+    import traceback
+    traceback.print_exc()
+print(f"  Parsed addr: '{cmd.addr}'")
+print(f"  Parsed port: '{cmd.port}'")
+
+# Test the display logic
+addr_display = "[%s]" % cmd.addr if cmd._raw_ipv6 else ("0.0.0.0" if cmd.addr == "0" else cmd.addr)
+print(f"  Display addr: '{addr_display}'")
+print(f"  Expected: '0.0.0.0'")
+print(f"  Result: {'✓ PASS' if addr_display == '0.0.0.0' else '✗ FAIL'}")
+
+# Test case 2: Regular address should work normally
+print("\nTest 2: runserver 127.0.0.1:9002")
+cmd2 = Command()
+options2 = {
+    'addrport': '127.0.0.1:9002',
+    'use_reloader': False,
+    'skip_checks': True,
+    'use_threading': False,
+    'use_ipv6': False,
+    'no_color': False
+}
+try:
+    cmd2.handle(**options2)
+except (SystemExit, Exception):
+    pass
+addr_display2 = "[%s]" % cmd2.addr if cmd2._raw_ipv6 else ("0.0.0.0" if cmd2.addr == "0" else cmd2.addr)
+print(f"  Display addr: '{addr_display2}'")
+print(f"  Expected: '127.0.0.1'")
+print(f"  Result: {'✓ PASS' if addr_display2 == '127.0.0.1' else '✗ FAIL'}")
+
+print("\n" + "=" * 60)
+print("Summary: The fix correctly converts '0' to '0.0.0.0' for display")
+print("while preserving other addresses as-is.")
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..f4b23df239
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,33 @@
+import os
+import sys
+import django
+from io import StringIO
+
+# Add the Django project to the Python path
+sys.path.insert(0, '/testbed')
+
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')
+
+# Import after setting up Django
+from django.core.management.commands.runserver import Command
+
+# Create a command instance
+cmd = Command()
+cmd.stdout = StringIO()
+cmd.stderr = StringIO()
+
+# Test with '0:8000'
+try:
+    cmd.handle(addrport='0:8000', use_reloader=False, skip_checks=True, use_threading=False, use_ipv6=False)
+except Exception as e:
+    # Expected to fail when trying to bind
+    pass
+
+output = cmd.stdout.getvalue()
+print("Output from handle with '0:8000':")
+print(output)
+print("\nChecking URL in output:")
+if 'http://0:8000/' in output:
+    print("✗ Found 'http://0:8000/' - This is the bug!")
+if 'http://0.0.0.0:8000/' in output:
+    print("✓ Found 'http://0.0.0.0:8000/' - This is what we want!")
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..1521194a9c
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+import os
+import sys
+from io import StringIO
+
+# Add Django to path
+sys.path.insert(0, '/testbed')
+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'
+
+import django
+django.setup()
+
+from django.core.management.commands.runserver import Command
+
+# Test case 1: runserver 0:8000
+print("Testing 'runserver 0:8000':")
+cmd = Command()
+cmd.stdout = StringIO()
+cmd.stderr = StringIO()
+
+# Simulate the command line arguments
+options = {
+    'addrport': '0:8000',
+    'use_reloader': False,
+    'skip_checks': True,
+    'use_threading': False,
+    'use_ipv6': False,
+    'no_color': False
+}
+
+# Run handle to parse the address
+cmd.handle(**options)
+
+# The output is written during inner_run, let's check that directly
+cmd.stdout = StringIO()
+try:
+    cmd.inner_run(**options)
+except Exception:
+    # Expected to fail when trying to bind
+    pass
+
+output = cmd.stdout.getvalue()
+print(output)
+
+print("\nChecking the output:")
+if 'http://0:8000/' in output:
+    print("✗ Found 'http://0:8000/' - BUG NOT FIXED")
+else:
+    print("✓ Did not find 'http://0:8000/'")
+    
+if 'http://0.0.0.0:8000/' in output:
+    print("✓ Found 'http://0.0.0.0:8000/' - FIX WORKS!")
+else:
+    print("✗ Did not find 'http://0.0.0.0:8000/'")
+
+# Test case 2: Make sure normal addresses still work
+print("\n\nTesting 'runserver 127.0.0.1:8000':")
+cmd2 = Command()
+cmd2.stdout = StringIO()
+cmd2.stderr = StringIO()
+
+options2 = {
+    'addrport': '127.0.0.1:8000',
+    'use_reloader': False,
+    'skip_checks': True, 
+    'use_threading': False,
+    'use_ipv6': False,
+    'no_color': False
+}
+
+cmd2.handle(**options2)
+cmd2.stdout = StringIO()
+try:
+    cmd2.inner_run(**options2)
+except Exception:
+    pass
+
+output2 = cmd2.stdout.getvalue()
+if 'http://127.0.0.1:8000/' in output2:
+    print("✓ Normal addresses still work correctly")
+else:
+    print("✗ Normal addresses broken")
diff --git a/test_runserver_output.py b/test_runserver_output.py
new file mode 100644
index 0000000000..a970bc8416
--- /dev/null
+++ b/test_runserver_output.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+import os
+import sys
+import subprocess
+
+# Add Django to path
+sys.path.insert(0, '/testbed')
+
+# Create a minimal settings file
+settings_content = """
+DEBUG = True
+SECRET_KEY = 'test-key'
+ALLOWED_HOSTS = ['*']
+"""
+
+with open('/tmp/test_settings.py', 'w') as f:
+    f.write(settings_content)
+
+# Test the runserver command with different addresses
+test_cases = [
+    ('0:9001', 'http://0.0.0.0:9001/'),
+    ('127.0.0.1:9002', 'http://127.0.0.1:9002/'),
+    ('localhost:9003', 'http://localhost:9003/'),
+]
+
+for addr, expected_url in test_cases:
+    print(f"\nTesting 'python manage.py runserver {addr}':")
+    
+    # Run the command and capture output
+    env = os.environ.copy()
+    env['DJANGO_SETTINGS_MODULE'] = 'test_settings'
+    env['PYTHONPATH'] = '/tmp:' + env.get('PYTHONPATH', '')
+    
+    # Create a simple manage.py script
+    manage_content = """
+import os
+import sys
+
+if __name__ == "__main__":
+    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "test_settings")
+    from django.core.management import execute_from_command_line
+    execute_from_command_line(sys.argv)
+"""
+    
+    with open('/tmp/manage.py', 'w') as f:
+        f.write(manage_content)
+    
+    # Run the command with a timeout
+    cmd = [sys.executable, '/tmp/manage.py', 'runserver', '--noreload', addr]
+    try:
+        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, 
+                               text=True, env=env)
+        # Give it a moment to start and print the message
+        import time
+        time.sleep(0.5)
+        proc.terminate()
+        stdout, stderr = proc.communicate(timeout=1)
+        
+        output = stdout + stderr
+        
+        if expected_url in output:
+            print(f"✓ Found '{expected_url}' in output")
+        else:
+            print(f"✗ Did not find '{expected_url}' in output")
+            print(f"Output was: {output[:500]}...")  # Show first 500 chars
+            
+        # For addr '0:9001', make sure it doesn't show the wrong URL
+        if addr.startswith('0:') and 'http://0:' in output:
+            print("✗ Found incorrect 'http://0:' URL in output")
+            
+    except Exception as e:
+        print(f"Error running command: {e}")
diff --git a/test_runserver_zero.py b/test_runserver_zero.py
new file mode 100644
index 0000000000..3a9cce6a5a
--- /dev/null
+++ b/test_runserver_zero.py
@@ -0,0 +1,49 @@
+import os
+import sys
+import django
+from io import StringIO
+from django.core.management import call_command
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        SECRET_KEY='test-secret-key',
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        }
+    )
+    django.setup()
+
+# Test the runserver command with '0:8000'
+out = StringIO()
+err = StringIO()
+try:
+    # This will fail to actually start the server, but we just want to capture the output
+    call_command('runserver', '0:8000', stdout=out, stderr=err, skip_checks=True, use_reloader=False)
+except Exception as e:
+    # We expect this to fail since we're not actually running the server
+    pass
+
+output = out.getvalue()
+print("Output from 'runserver 0:8000':")
+print(output)
+print("\nChecking if output contains 'http://0:8000/' (should not):")
+if 'http://0:8000/' in output:
+    print("FOUND - This is the bug!")
+else:
+    print("NOT FOUND")
+    
+print("\nChecking if output contains 'http://0.0.0.0:8000/' (should):")
+if 'http://0.0.0.0:8000/' in output:
+    print("FOUND - This is what we want!")
+else:
+    print("NOT FOUND")
diff --git a/trace_runserver.py b/trace_runserver.py
new file mode 100644
index 0000000000..10243aa203
--- /dev/null
+++ b/trace_runserver.py
@@ -0,0 +1,48 @@
+#!/usr/bin/env python
+import os
+import sys
+import re
+
+# Add Django to path
+sys.path.insert(0, '/testbed')
+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'
+
+import django
+django.setup()
+
+# Import the regex from runserver  
+from django.core.management.commands.runserver import naiveip_re
+
+# Test regex parsing for '0:8000'
+test_input = '0:8000'
+m = re.match(naiveip_re, test_input)
+if m:
+    addr, ipv4, ipv6, fqdn, port = m.groups()
+    print(f"Input: {test_input}")
+    print(f"Parsed addr: '{addr}'")
+    print(f"Parsed port: '{port}'")
+    print(f"ipv4: {ipv4}")
+    print(f"ipv6: {ipv6}")
+    print(f"fqdn: {fqdn}")
+    
+# Now let's trace through the logic
+print("\nFollowing the logic in handle():")
+if not addr:
+    print("addr is falsy - would use default address")
+else:
+    print(f"addr is truthy ('{addr}') - will use this address as-is")
+    
+print(f"\nThe problem: '0' should be treated as '0.0.0.0' but it's displayed as-is")
+
+# Let's also check what happens at the OS level
+print("\nLet's see what Python's socket module does with address '0':")
+import socket
+try:
+    # Create a test socket
+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    s.bind(('0', 0))  # Bind to address '0' with any port
+    bound_addr = s.getsockname()
+    print(f"Socket bound to: {bound_addr}")
+    s.close()
+except Exception as e:
+    print(f"Error: {e}")
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 0000000000..7758460b09
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python
+"""
+This script verifies that the fix for displaying '0:8000' as '0.0.0.0:8000' works correctly.
+"""
+
+# First, let's check the logic directly
+addr = "0"
+_raw_ipv6 = False
+
+# This is the fixed line from runserver.py line 150
+display_addr = "[%s]" % addr if _raw_ipv6 else ("0.0.0.0" if addr == "0" else addr)
+
+print("Testing the fix logic directly:")
+print(f"Input addr: '{addr}'")
+print(f"Display addr: '{display_addr}'")
+print(f"Expected: '0.0.0.0'")
+print(f"Result: {'✓ PASS' if display_addr == '0.0.0.0' else '✗ FAIL'}")
+
+# Test other cases
+print("\nTesting other cases:")
+test_cases = [
+    ("0", False, "0.0.0.0"),
+    ("127.0.0.1", False, "127.0.0.1"),
+    ("localhost", False, "localhost"),
+    ("192.168.1.1", False, "192.168.1.1"),
+    ("::1", True, "[::1]"),
+]
+
+for addr, _raw_ipv6, expected in test_cases:
+    display_addr = "[%s]" % addr if _raw_ipv6 else ("0.0.0.0" if addr == "0" else addr)
+    status = "✓ PASS" if display_addr == expected else "✗ FAIL"
+    print(f"  addr='{addr}', ipv6={_raw_ipv6} -> '{display_addr}' (expected '{expected}') {status}")
