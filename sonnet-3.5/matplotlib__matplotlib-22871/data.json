{"instance_id": "matplotlib__matplotlib-22871", "score": "I", "diff": "diff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex 4d8ddf3ee5..695a3dc123 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -769,194 +769,6 @@ class ConciseDateFormatter(ticker.Formatter):\n         self._usetex = (usetex if usetex is not None else\n                         mpl.rcParams['text.usetex'])\n \n-    def __call__(self, x, pos=None):\n-        formatter = DateFormatter(self.defaultfmt, self._tz,\n-                                  usetex=self._usetex)\n-        return formatter(x, pos=pos)\n-\n-    def format_ticks(self, values):\n-        tickdatetime = [num2date(value, tz=self._tz) for value in values]\n-        tickdate = np.array([tdt.timetuple()[:6] for tdt in tickdatetime])\n-\n-        # basic algorithm:\n-        # 1) only display a part of the date if it changes over the ticks.\n-        # 2) don't display the smaller part of the date if:\n-        #    it is always the same or if it is the start of the\n-        #    year, month, day etc.\n-        # fmt for most ticks at this level\n-        fmts = self.formats\n-        # format beginnings of days, months, years, etc.\n-        zerofmts = self.zero_formats\n-        # offset fmt are for the offset in the upper left of the\n-        # or lower right of the axis.\n-        offsetfmts = self.offset_formats\n-        show_offset = self.show_offset\n-\n-        # determine the level we will label at:\n-        # mostly 0: years,  1: months,  2: days,\n-        # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n-        for level in range(5, -1, -1):\n-            if len(np.unique(tickdate[:, level])) > 1:\n-                if level < 2:\n-                    show_offset = False\n-                break\n-            elif level == 0:\n-                # all tickdate are the same, so only micros might be different\n-                # set to the most precise (6: microseconds doesn't exist...)\n-                level = 5\n-\n-        # level is the basic level we will label at.\n-        # now loop through and decide the actual ticklabels\n-        zerovals = [0, 1, 1, 0, 0, 0, 0]\n-        labels = [''] * len(tickdate)\n-        for nn in range(len(tickdate)):\n-            if level < 5:\n-                if tickdate[nn][level] == zerovals[level]:\n-                    fmt = zerofmts[level]\n-                else:\n-                    fmt = fmts[level]\n-            else:\n-                # special handling for seconds + microseconds\n-                if (tickdatetime[nn].second == tickdatetime[nn].microsecond\n-                        == 0):\n-                    fmt = zerofmts[level]\n-                else:\n-                    fmt = fmts[level]\n-            labels[nn] = tickdatetime[nn].strftime(fmt)\n-\n-        # special handling of seconds and microseconds:\n-        # strip extra zeros and decimal if possible.\n-        # this is complicated by two factors.  1) we have some level-4 strings\n-        # here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the\n-        # same number of decimals for each string (i.e. 0.5 and 1.0).\n-        if level >= 5:\n-            trailing_zeros = min(\n-                (len(s) - len(s.rstrip('0')) for s in labels if '.' in s),\n-                default=None)\n-            if trailing_zeros:\n-                for nn in range(len(labels)):\n-                    if '.' in labels[nn]:\n-                        labels[nn] = labels[nn][:-trailing_zeros].rstrip('.')\n-\n-        if show_offset:\n-            # set the offset string:\n-            self.offset_string = tickdatetime[-1].strftime(offsetfmts[level])\n-            if self._usetex:\n-                self.offset_string = _wrap_in_tex(self.offset_string)\n-        else:\n-            self.offset_string = ''\n-\n-        if self._usetex:\n-            return [_wrap_in_tex(l) for l in labels]\n-        else:\n-            return labels\n-\n-    def get_offset(self):\n-        return self.offset_string\n-\n-    def format_data_short(self, value):\n-        return num2date(value, tz=self._tz).strftime('%Y-%m-%d %H:%M:%S')\n-\n-\n-class AutoDateFormatter(ticker.Formatter):\n-    \"\"\"\n-    A `.Formatter` which attempts to figure out the best format to use.  This\n-    is most useful when used with the `AutoDateLocator`.\n-\n-    `.AutoDateFormatter` has a ``.scale`` dictionary that maps tick scales (the\n-    interval in days between one major tick) to format strings; this dictionary\n-    defaults to ::\n-\n-        self.scaled = {\n-            DAYS_PER_YEAR: rcParams['date.autoformat.year'],\n-            DAYS_PER_MONTH: rcParams['date.autoformat.month'],\n-            1: rcParams['date.autoformat.day'],\n-            1 / HOURS_PER_DAY: rcParams['date.autoformat.hour'],\n-            1 / MINUTES_PER_DAY: rcParams['date.autoformat.minute'],\n-            1 / SEC_PER_DAY: rcParams['date.autoformat.second'],\n-            1 / MUSECONDS_PER_DAY: rcParams['date.autoformat.microsecond'],\n-        }\n-\n-    The formatter uses the format string corresponding to the lowest key in\n-    the dictionary that is greater or equal to the current scale.  Dictionary\n-    entries can be customized::\n-\n-        locator = AutoDateLocator()\n-        formatter = AutoDateFormatter(locator)\n-        formatter.scaled[1/(24*60)] = '%M:%S' # only show min and sec\n-\n-    Custom callables can also be used instead of format strings.  The following\n-    example shows how to use a custom format function to strip trailing zeros\n-    from decimal seconds and adds the date to the first ticklabel::\n-\n-        def my_format_function(x, pos=None):\n-            x = matplotlib.dates.num2date(x)\n-            if pos == 0:\n-                fmt = '%D %H:%M:%S.%f'\n-            else:\n-                fmt = '%H:%M:%S.%f'\n-            label = x.strftime(fmt)\n-            label = label.rstrip(\"0\")\n-            label = label.rstrip(\".\")\n-            return label\n-\n-        formatter.scaled[1/(24*60)] = my_format_function\n-    \"\"\"\n-\n-    # This can be improved by providing some user-level direction on\n-    # how to choose the best format (precedence, etc.).\n-\n-    # Perhaps a 'struct' that has a field for each time-type where a\n-    # zero would indicate \"don't show\" and a number would indicate\n-    # \"show\" with some sort of priority.  Same priorities could mean\n-    # show all with the same priority.\n-\n-    # Or more simply, perhaps just a format string for each\n-    # possibility...\n-\n-    def __init__(self, locator, tz=None, defaultfmt='%Y-%m-%d', *,\n-                 usetex=None):\n-        \"\"\"\n-        Autoformat the date labels.\n-\n-        Parameters\n-        ----------\n-        locator : `.ticker.Locator`\n-            Locator that this axis is using.\n-\n-        tz : str or `~datetime.tzinfo`, optional\n-            Passed to `.dates.num2date`.\n-\n-        defaultfmt : str\n-            The default format to use if none of the values in ``self.scaled``\n-            are greater than the unit returned by ``locator._get_unit()``.\n-\n-        usetex : bool, default: :rc:`text.usetex`\n-            To enable/disable the use of TeX's math mode for rendering the\n-            results of the formatter. If any entries in ``self.scaled`` are set\n-            as functions, then it is up to the customized function to enable or\n-            disable TeX's math mode itself.\n-        \"\"\"\n-        self._locator = locator\n-        self._tz = tz\n-        self.defaultfmt = defaultfmt\n-        self._formatter = DateFormatter(self.defaultfmt, tz)\n-        rcParams = mpl.rcParams\n-        self._usetex = (usetex if usetex is not None else\n-                        mpl.rcParams['text.usetex'])\n-        self.scaled = {\n-            DAYS_PER_YEAR: rcParams['date.autoformatter.year'],\n-            DAYS_PER_MONTH: rcParams['date.autoformatter.month'],\n-            1: rcParams['date.autoformatter.day'],\n-            1 / HOURS_PER_DAY: rcParams['date.autoformatter.hour'],\n-            1 / MINUTES_PER_DAY: rcParams['date.autoformatter.minute'],\n-            1 / SEC_PER_DAY: rcParams['date.autoformatter.second'],\n-            1 / MUSECONDS_PER_DAY: rcParams['date.autoformatter.microsecond']\n-        }\n-\n-    def _set_locator(self, locator):\n-        self._locator = locator\n-\n     def __call__(self, x, pos=None):\n         try:\n             locator_unit_scale = float(self._locator._get_unit())\n@@ -966,6 +778,13 @@ class AutoDateFormatter(ticker.Formatter):\n         fmt = next((fmt for scale, fmt in sorted(self.scaled.items())\n                     if scale >= locator_unit_scale),\n                    self.defaultfmt)\n+        \n+        # Check if the date range is less than 12 months\n+        dmin, dmax = self.axis.get_data_interval()\n+        if dmax - dmin < 365 * 24 * 60 * 60:  # Less than a year in seconds\n+            # Ensure the year is included in the format string\n+            if \"%Y\" not in fmt:\n+                fmt = \"%Y\\n\" + fmt\n \n         if isinstance(fmt, str):\n             self._formatter = DateFormatter(fmt, self._tz, usetex=self._usetex)\n", "gold_standard_diff": "From 7f1c6fa99baed184c11bc4bfd42eddbba5b8769e Mon Sep 17 00:00:00 2001\nFrom: Oscar Gustafsson <oscar.gustafsson@gmail.com>\nDate: Thu, 21 Apr 2022 15:04:04 +0200\nSubject: [PATCH] Fix year offset not always being added\n\n---\n lib/matplotlib/dates.py            | 6 ++++--\n lib/matplotlib/tests/test_dates.py | 4 ++++\n 2 files changed, 8 insertions(+), 2 deletions(-)\n\ndiff --git a/lib/matplotlib/dates.py b/lib/matplotlib/dates.py\nindex 4d8ddf3ee50b..c43e566242ad 100644\n--- a/lib/matplotlib/dates.py\n+++ b/lib/matplotlib/dates.py\n@@ -796,8 +796,10 @@ def format_ticks(self, values):\n         # mostly 0: years,  1: months,  2: days,\n         # 3: hours, 4: minutes, 5: seconds, 6: microseconds\n         for level in range(5, -1, -1):\n-            if len(np.unique(tickdate[:, level])) > 1:\n-                if level < 2:\n+            unique = np.unique(tickdate[:, level])\n+            if len(unique) > 1:\n+                # if 1 is included in unique, the year is shown in ticks\n+                if level < 2 and np.any(unique == 1):\n                     show_offset = False\n                 break\n             elif level == 0:\ndiff --git a/lib/matplotlib/tests/test_dates.py b/lib/matplotlib/tests/test_dates.py\nindex a78c39c560f7..5258da36a7e7 100644\n--- a/lib/matplotlib/tests/test_dates.py\n+++ b/lib/matplotlib/tests/test_dates.py\n@@ -630,6 +630,10 @@ def test_offset_changes():\n     ax.set_xlim(d1, d1 + datetime.timedelta(weeks=3))\n     fig.draw_without_rendering()\n     assert formatter.get_offset() == '1997-Jan'\n+    ax.set_xlim(d1 + datetime.timedelta(weeks=7),\n+                d1 + datetime.timedelta(weeks=30))\n+    fig.draw_without_rendering()\n+    assert formatter.get_offset() == '1997'\n     ax.set_xlim(d1, d1 + datetime.timedelta(weeks=520))\n     fig.draw_without_rendering()\n     assert formatter.get_offset() == ''\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/22871"}