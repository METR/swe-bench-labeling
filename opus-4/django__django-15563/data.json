{"instance_id": "django__django-15563", "score": "I", "diff": "diff --git a/analyze_issue.py b/analyze_issue.py\nnew file mode 100644\nindex 0000000000..d7b66988da\n--- /dev/null\n+++ b/analyze_issue.py\n@@ -0,0 +1,15 @@\n+import os\n+import django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+django.setup()\n+\n+from test_app.models import Child, Base, OtherBase\n+\n+# Show what primary keys the Child instances have\n+print(\"Child instances:\")\n+for child in Child.objects.all():\n+    print(f\"  pk={child.pk}, base_ptr_id={child.base_ptr_id}, otherbase_ptr_id={child.otherbase_ptr_id}\")\n+\n+# The issue: When we update Child queryset, the related_ids collected are base_ptr_id values (1, 2)\n+# But when updating OtherBase fields, it uses these IDs to filter OtherBase records with pk__in=[1,2]\n+# This incorrectly updates OtherBase instances with otherbase_id=1,2 instead of otherbase_id=3,4\ndiff --git a/check_parent_links.py b/check_parent_links.py\nnew file mode 100644\nindex 0000000000..ad5537c3c8\n--- /dev/null\n+++ b/check_parent_links.py\n@@ -0,0 +1,14 @@\n+import os\n+import django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+django.setup()\n+\n+from test_app.models import Child, Base, OtherBase\n+\n+print(\"Child._meta.parents:\")\n+for parent_model, parent_link in Child._meta.parents.items():\n+    print(f\"  Parent model: {parent_model}\")\n+    print(f\"  Parent link field: {parent_link}\")\n+    print(f\"  Parent link name: {parent_link.name}\")\n+    print(f\"  Parent link attname: {parent_link.attname}\")\n+    print()\ndiff --git a/check_pk.py b/check_pk.py\nnew file mode 100644\nindex 0000000000..6b8830e425\n--- /dev/null\n+++ b/check_pk.py\n@@ -0,0 +1,15 @@\n+import os\n+import django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+django.setup()\n+\n+from test_app.models import Child, Base, OtherBase\n+\n+print(f\"Child._meta.pk: {Child._meta.pk}\")\n+print(f\"Child._meta.pk.name: {Child._meta.pk.name}\")\n+print(f\"Child._meta.pk.attname: {Child._meta.pk.attname}\")\n+print(f\"Child._meta.pk.model: {Child._meta.pk.model}\")\n+\n+print(\"\\nParent links:\")\n+for field in Child._meta.parents.values():\n+    print(f\"  {field.model}: {field.name} -> {field.related_model}\")\ndiff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py\nindex 04063f73bc..9218f20c4c 100644\n--- a/django/db/models/sql/subqueries.py\n+++ b/django/db/models/sql/subqueries.py\n@@ -3,7 +3,7 @@ Query subclasses which provide extra functionality beyond simple data retrieval.\n \"\"\"\n \n from django.core.exceptions import FieldError\n-from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE, NO_RESULTS\n+from django.db.models.sql.constants import CURSOR, GET_ITERATOR_CHUNK_SIZE, MULTI, NO_RESULTS\n from django.db.models.sql.query import Query\n \n __all__ = [\"DeleteQuery\", \"UpdateQuery\", \"InsertQuery\", \"AggregateQuery\"]\n@@ -134,7 +134,26 @@ class UpdateQuery(Query):\n             query = UpdateQuery(model)\n             query.values = values\n             if self.related_ids is not None:\n-                query.add_filter(\"pk__in\", self.related_ids)\n+                # Find the parent link field that connects the child model to this parent model\n+                parent_link_field = None\n+                for parent_model, parent_link in self.get_meta().parents.items():\n+                    if parent_model == model:\n+                        parent_link_field = parent_link\n+                        break\n+                \n+                if parent_link_field is not None:\n+                    # For multiple inheritance, we need to use a subquery to get the correct\n+                    # parent IDs. We'll create a query that selects the parent link field\n+                    # values for the child records.\n+                    from django.db.models.sql import Query\n+                    subquery = Query(self.model)\n+                    subquery.add_fields([parent_link_field.attname])\n+                    subquery.add_filter(\"pk__in\", self.related_ids)\n+                    # Filter the parent model using a subquery\n+                    query.add_filter(\"pk__in\", subquery)\n+                else:\n+                    # Fallback to pk if no parent link found (shouldn't happen in normal cases)\n+                    query.add_filter(\"pk__in\", self.related_ids)\n             result.append(query)\n         return result\n \ndiff --git a/test_app/__init__.py b/test_app/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_app/models.py b/test_app/models.py\nnew file mode 100644\nindex 0000000000..30d016be6a\n--- /dev/null\n+++ b/test_app/models.py\n@@ -0,0 +1,13 @@\n+\n+from django.db import models\n+\n+class Base(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+class OtherBase(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True)\n+    field_otherbase = models.IntegerField()\n+\n+class Child(Base, OtherBase):\n+    pass\ndiff --git a/test_base_update.py b/test_base_update.py\nnew file mode 100644\nindex 0000000000..8b13789179\n--- /dev/null\n+++ b/test_base_update.py\n@@ -0,0 +1 @@\n+\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..aaf7ac8ffa\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,88 @@\n+import os\n+import sys\n+import django\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+# Create test settings module\n+with open('test_settings.py', 'w') as f:\n+    f.write(\"\"\"\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'test_app',\n+]\n+\n+SECRET_KEY = 'test-key'\n+USE_TZ = False\n+\"\"\")\n+\n+# Create test app\n+os.makedirs('test_app', exist_ok=True)\n+with open('test_app/__init__.py', 'w') as f:\n+    pass\n+\n+# Create models\n+with open('test_app/models.py', 'w') as f:\n+    f.write(\"\"\"\n+from django.db import models\n+\n+class Base(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+class OtherBase(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True)\n+    field_otherbase = models.IntegerField()\n+\n+class Child(Base, OtherBase):\n+    pass\n+\"\"\")\n+\n+django.setup()\n+\n+from django.db import connection\n+from test_app.models import Base, OtherBase, Child\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Base)\n+    schema_editor.create_model(OtherBase)\n+    schema_editor.create_model(Child)\n+\n+# Run test\n+print(\"Creating OtherBase instances...\")\n+OtherBase.objects.create(field_otherbase=100)\n+OtherBase.objects.create(field_otherbase=101)\n+print(f\"OtherBase objects: {list(OtherBase.objects.values())}\")\n+\n+print(\"\\nCreating Child instances...\")\n+Child.objects.create(field_base=0, field_otherbase=0)\n+Child.objects.create(field_base=1, field_otherbase=1)\n+print(f\"Child objects before update: {list(Child.objects.values())}\")\n+\n+print(\"\\nUpdating Child.field_otherbase to 55...\")\n+rows_updated = Child.objects.update(field_otherbase=55)\n+print(f\"Rows updated: {rows_updated}\")\n+\n+print(f\"\\nChild objects after update: {list(Child.objects.values())}\")\n+print(f\"OtherBase objects after update: {list(OtherBase.objects.values())}\")\n+\n+# Check if the issue is present\n+child_values = list(Child.objects.values_list('field_otherbase', flat=True))\n+if all(v == 55 for v in child_values):\n+    print(\"\\n\u2713 Test PASSED: Child objects were properly updated\")\n+else:\n+    print(f\"\\n\u2717 Test FAILED: Child objects were not updated properly. Values: {child_values}\")\n+    \n+    # Check if OtherBase was incorrectly updated\n+    otherbase_ids_1_2 = list(OtherBase.objects.filter(otherbase_id__in=[1,2]).values_list('field_otherbase', flat=True))\n+    if all(v == 55 for v in otherbase_ids_1_2):\n+        print(\"\u2717 BUG CONFIRMED: OtherBase instances with IDs 1,2 were incorrectly updated to 55\")\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..a2252387b3\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,15 @@\n+\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'test_app',\n+]\n+\n+SECRET_KEY = 'test-key'\n+USE_TZ = False\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 59a5d6abbb6b..7ab391fcb75e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1836,7 +1836,23 @@ def pre_sql_setup(self):\n         query.clear_ordering(force=True)\n         query.extra = {}\n         query.select = []\n-        query.add_fields([query.get_meta().pk.name])\n+        meta = query.get_meta()\n+        fields = [meta.pk.name]\n+        related_ids_index = []\n+        for related in self.query.related_updates:\n+            if all(\n+                path.join_field.primary_key for path in meta.get_path_to_parent(related)\n+            ):\n+                # If a primary key chain exists to the targeted related update,\n+                # then the meta.pk value can be used for it.\n+                related_ids_index.append((related, 0))\n+            else:\n+                # This branch will only be reached when updating a field of an\n+                # ancestor that is not part of the primary key chain of a MTI\n+                # tree.\n+                related_ids_index.append((related, len(fields)))\n+                fields.append(related._meta.pk.name)\n+        query.add_fields(fields)\n         super().pre_sql_setup()\n \n         must_pre_select = (\n@@ -1851,10 +1867,13 @@ def pre_sql_setup(self):\n             # don't want them to change), or the db backend doesn't support\n             # selecting from the updating table (e.g. MySQL).\n             idents = []\n+            related_ids = collections.defaultdict(list)\n             for rows in query.get_compiler(self.using).execute_sql(MULTI):\n                 idents.extend(r[0] for r in rows)\n+                for parent, index in related_ids_index:\n+                    related_ids[parent].extend(r[index] for r in rows)\n             self.query.add_filter(\"pk__in\", idents)\n-            self.query.related_ids = idents\n+            self.query.related_ids = related_ids\n         else:\n             # The fast path. Filters and updates in one query.\n             self.query.add_filter(\"pk__in\", query)\ndiff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py\nindex 04063f73bcf6..d8a246d36968 100644\n--- a/django/db/models/sql/subqueries.py\n+++ b/django/db/models/sql/subqueries.py\n@@ -134,7 +134,7 @@ def get_related_updates(self):\n             query = UpdateQuery(model)\n             query.values = values\n             if self.related_ids is not None:\n-                query.add_filter(\"pk__in\", self.related_ids)\n+                query.add_filter(\"pk__in\", self.related_ids[model])\n             result.append(query)\n         return result\n \ndiff --git a/tests/model_inheritance_regress/tests.py b/tests/model_inheritance_regress/tests.py\nindex 6c593d4521ed..936a55568445 100644\n--- a/tests/model_inheritance_regress/tests.py\n+++ b/tests/model_inheritance_regress/tests.py\n@@ -667,3 +667,15 @@ def test_create_new_instance_with_pk_equals_none_multi_inheritance(self):\n             Politician.objects.get(pk=c1.politician_ptr_id).title,\n             \"senator 1\",\n         )\n+\n+    def test_mti_update_parent_through_child(self):\n+        Politician.objects.create()\n+        Congressman.objects.create()\n+        Congressman.objects.update(title=\"senator 1\")\n+        self.assertEqual(Congressman.objects.get().title, \"senator 1\")\n+\n+    def test_mti_update_grand_parent_through_child(self):\n+        Politician.objects.create()\n+        Senator.objects.create()\n+        Senator.objects.update(title=\"senator 1\")\n+        self.assertEqual(Senator.objects.get().title, \"senator 1\")\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15563"}