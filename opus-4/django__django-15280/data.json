{"instance_id": "django__django-15280", "score": "I", "diff": "diff --git a/test_deferred_issue.py b/test_deferred_issue.py\nnew file mode 100644\nindex 0000000000..444d7dabd7\n--- /dev/null\n+++ b/test_deferred_issue.py\n@@ -0,0 +1,100 @@\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+import django\n+from django.conf import settings\n+\n+# Configure minimal settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import Prefetch\n+\n+# Define test models\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(User)\n+    schema_editor.create_model(Profile)\n+\n+# Create test data\n+user = User.objects.create(\n+    email=\"test@example.com\",\n+    kind=\"ADMIN\",\n+)\n+Profile.objects.create(user=user, full_name=\"Test Tester\")\n+\n+# Test the query\n+queryset = User.objects.only(\"email\").prefetch_related(\n+    Prefetch(\n+        \"profile\",\n+        queryset=Profile.objects.prefetch_related(\n+            Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+        ),\n+    )\n+)\n+\n+# Execute the main queryset\n+from django.test.utils import CaptureQueriesContext\n+\n+with CaptureQueriesContext(connection) as queries:\n+    user = queryset.first()\n+    \n+print(f\"Queries executed when fetching user: {len(queries)}\")\n+for i, query in enumerate(queries):\n+    print(f\"Query {i+1}: {query['sql']}\")\n+\n+# Check deferred fields\n+print(f\"\\nOuter user deferred fields: {user.get_deferred_fields()}\")\n+print(f\"Inner user (profile.user) deferred fields: {user.profile.user.get_deferred_fields()}\")\n+\n+# Try to access the kind attribute\n+print(\"\\nAccessing user.profile.user.kind...\")\n+with CaptureQueriesContext(connection) as queries:\n+    kind = user.profile.user.kind\n+    \n+print(f\"Queries executed when accessing user.profile.user.kind: {len(queries)}\")\n+for i, query in enumerate(queries):\n+    print(f\"Query {i+1}: {query['sql']}\")\n+    \n+print(f\"\\nValue of kind: {kind}\")\n+print(f\"Expected: ADMIN, Got: {kind}, Match: {kind == 'ADMIN'}\")\n+\n+# Clean up\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.delete_model(Profile)\n+    schema_editor.delete_model(User)\ndiff --git a/test_issue_reproduce.py b/test_issue_reproduce.py\nnew file mode 100644\nindex 0000000000..5217dd91d3\n--- /dev/null\n+++ b/test_issue_reproduce.py\n@@ -0,0 +1,80 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.test import TestCase\n+\n+# Configure Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+django.setup()\n+\n+# Define test models\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the issue\n+from django.db import connection\n+from django.db.models import Prefetch\n+from django.test.utils import CaptureQueriesContext\n+\n+# Create the tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(User)\n+    schema_editor.create_model(Profile)\n+\n+# Create test data\n+user = User.objects.create(\n+    email=\"test@example.com\",\n+    kind=\"ADMIN\",\n+)\n+Profile.objects.create(user=user, full_name=\"Test Tester\")\n+\n+# Test the query\n+queryset = User.objects.only(\"email\").prefetch_related(\n+    Prefetch(\n+        \"profile\",\n+        queryset=Profile.objects.prefetch_related(\n+            Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+        ),\n+    )\n+)\n+\n+# Execute the main queryset\n+with CaptureQueriesContext(connection) as queries:\n+    user = queryset.first()\n+    \n+print(f\"Queries executed when fetching user: {len(queries)}\")\n+for i, query in enumerate(queries):\n+    print(f\"Query {i+1}: {query['sql']}\")\n+\n+# Check deferred fields\n+print(f\"\\nDeferred fields on user.profile.user: {user.profile.user.get_deferred_fields()}\")\n+\n+# Try to access the kind attribute\n+with CaptureQueriesContext(connection) as queries:\n+    kind = user.profile.user.kind\n+    \n+print(f\"\\nQueries executed when accessing user.profile.user.kind: {len(queries)}\")\n+for i, query in enumerate(queries):\n+    print(f\"Query {i+1}: {query['sql']}\")\n+    \n+print(f\"\\nValue of kind: {kind}\")\n+print(f\"Expected: ADMIN, Got: {kind}, Match: {kind == 'ADMIN'}\")\n+\n+# Clean up\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.delete_model(Profile)\n+    schema_editor.delete_model(User)\ndiff --git a/tests/prefetch_related/models.py b/tests/prefetch_related/models.py\nindex 0ded7e8b4a..fa40b044e5 100644\n--- a/tests/prefetch_related/models.py\n+++ b/tests/prefetch_related/models.py\n@@ -281,4 +281,23 @@ class Flea(models.Model):\n     id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n     current_room = models.ForeignKey(Room, models.SET_NULL, related_name='fleas', null=True)\n     pets_visited = models.ManyToManyField(Pet, related_name='fleas_hosted')\n+\n+\n+# Models for testing deferred fields with prefetch_related\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+\n+    class Meta:\n+        ordering = ['id']\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+\n+    class Meta:\n+        ordering = ['id']\n     people_visited = models.ManyToManyField(Person, related_name='fleas_hosted')\ndiff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 4ea7fccd5e..a1c5e60d05 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -13,7 +13,7 @@ from .models import (\n     Article, Author, Author2, AuthorAddress, AuthorWithAge, Bio, Book,\n     Bookmark, BookReview, BookWithYear, Comment, Department, Employee,\n     FavoriteAuthors, House, LessonEntry, ModelIterableSubclass, Person,\n-    Qualification, Reader, Room, TaggedItem, Teacher, WordEntry,\n+    Profile, Qualification, Reader, Room, TaggedItem, Teacher, User, WordEntry,\n )\n \n \n", "gold_standard_diff": "From f5233dce309543c826224be9dfa9c9f4f855f73c Mon Sep 17 00:00:00 2001\nFrom: Jamie Matthews <jamie@dabapps.com>\nDate: Tue, 4 Jan 2022 11:10:49 +0000\nSubject: [PATCH] Fixed #32511 -- Corrected handling prefetched nested reverse\n relationships.\n\nWhen prefetching a set of child objects related to a set of parent\nobjects, we usually want to populate the relationship back from the\nchild to the parent to avoid a query when accessing that relationship\nattribute. However, there's an edge case where the child queryset\nitself specifies a prefetch back to the parent. In that case, we want\nto use the prefetched relationship rather than populating the reverse\nrelationship from the parent.\n---\n AUTHORS                                       |  1 +\n .../db/models/fields/related_descriptors.py   |  5 ++--\n tests/prefetch_related/tests.py               | 26 +++++++++++++++++++\n 3 files changed, 30 insertions(+), 2 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex 3ca8ad40f523..77053c9568ac 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -423,6 +423,7 @@ answer newbie questions, and generally made Django that much better:\n     James Timmins <jameshtimmins@gmail.com>\n     James Turk <dev@jamesturk.net>\n     James Wheare <django@sparemint.com>\n+    Jamie Matthews <jamie@mtth.org>\n     Jannis Leidel <jannis@leidel.info>\n     Janos Guljas\n     Jan Pazdziora\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex d5aa9684003f..9c50ef16ce7a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -646,8 +646,9 @@ def get_prefetch_queryset(self, instances, queryset=None):\n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n             for rel_obj in queryset:\n-                instance = instances_dict[rel_obj_attr(rel_obj)]\n-                setattr(rel_obj, self.field.name, instance)\n+                if not self.field.is_cached(rel_obj):\n+                    instance = instances_dict[rel_obj_attr(rel_obj)]\n+                    setattr(rel_obj, self.field.name, instance)\n             cache_name = self.field.remote_field.get_cache_name()\n             return queryset, rel_obj_attr, instance_attr, False, cache_name, False\n \ndiff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 4ea7fccd5e6a..5040f3d88693 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1614,3 +1614,29 @@ def test_retrieves_results_from_prefetched_objects_cache(self):\n         with self.assertNumQueries(4):\n             # AuthorWithAge -> Author -> FavoriteAuthors, Book\n             self.assertSequenceEqual(authors, [self.author1, self.author2])\n+\n+\n+class NestedPrefetchTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        house = House.objects.create(name='Big house', address='123 Main St')\n+        cls.room = Room.objects.create(name='Kitchen', house=house)\n+\n+    def test_nested_prefetch_is_not_overwritten_by_related_object(self):\n+        \"\"\"\n+        The prefetched relationship is used rather than populating the reverse\n+        relationship from the parent, when prefetching a set of child objects\n+        related to a set of parent objects and the child queryset itself\n+        specifies a prefetch back to the parent.\n+        \"\"\"\n+        queryset = House.objects.only('name').prefetch_related(\n+            Prefetch('rooms', queryset=Room.objects.prefetch_related(\n+                Prefetch('house', queryset=House.objects.only('address')),\n+            )),\n+        )\n+        with self.assertNumQueries(3):\n+            house = queryset.first()\n+\n+        self.assertIs(Room.house.is_cached(self.room), True)\n+        with self.assertNumQueries(0):\n+            house.rooms.first().house.address\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15280"}