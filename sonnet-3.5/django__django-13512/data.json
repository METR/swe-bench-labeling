{"instance_id": "django__django-13512", "score": "I", "diff": "diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex a249f4cdbf..faa976d2d2 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -81,7 +81,7 @@ class JSONField(CheckFieldDefaultMixin, Field):\n     def get_prep_value(self, value):\n         if value is None:\n             return value\n-        return json.dumps(value, cls=self.encoder)\n+        return json.dumps(value, ensure_ascii=False, cls=self.encoder)\n \n     def get_transform(self, name):\n         transform = super().get_transform(name)\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex 79f2609c35..e69de29bb2 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -1,810 +0,0 @@\n-import operator\n-import uuid\n-from unittest import mock, skipIf\n-\n-from django import forms\n-from django.core import serializers\n-from django.core.exceptions import ValidationError\n-from django.core.serializers.json import DjangoJSONEncoder\n-from django.db import (\n-    DataError, IntegrityError, NotSupportedError, OperationalError, connection,\n-    models,\n-)\n-from django.db.models import Count, F, OuterRef, Q, Subquery, Transform, Value\n-from django.db.models.expressions import RawSQL\n-from django.db.models.fields.json import (\n-    KeyTextTransform, KeyTransform, KeyTransformFactory,\n-    KeyTransformTextLookupMixin,\n-)\n-from django.db.models.functions import Cast\n-from django.test import (\n-    SimpleTestCase, TestCase, skipIfDBFeature, skipUnlessDBFeature,\n-)\n-from django.test.utils import CaptureQueriesContext\n-\n-from .models import CustomJSONDecoder, JSONModel, NullableJSONModel\n-\n-\n-@skipUnlessDBFeature('supports_json_field')\n-class JSONFieldTests(TestCase):\n-    def test_invalid_value(self):\n-        msg = 'is not JSON serializable'\n-        with self.assertRaisesMessage(TypeError, msg):\n-            NullableJSONModel.objects.create(value={\n-                'uuid': uuid.UUID('d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475'),\n-            })\n-\n-    def test_custom_encoder_decoder(self):\n-        value = {'uuid': uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')}\n-        obj = NullableJSONModel(value_custom=value)\n-        obj.clean_fields()\n-        obj.save()\n-        obj.refresh_from_db()\n-        self.assertEqual(obj.value_custom, value)\n-\n-    def test_db_check_constraints(self):\n-        value = '{@!invalid json value 123 $!@#'\n-        with mock.patch.object(DjangoJSONEncoder, 'encode', return_value=value):\n-            with self.assertRaises((IntegrityError, DataError, OperationalError)):\n-                NullableJSONModel.objects.create(value_custom=value)\n-\n-\n-class TestMethods(SimpleTestCase):\n-    def test_deconstruct(self):\n-        field = models.JSONField()\n-        name, path, args, kwargs = field.deconstruct()\n-        self.assertEqual(path, 'django.db.models.JSONField')\n-        self.assertEqual(args, [])\n-        self.assertEqual(kwargs, {})\n-\n-    def test_deconstruct_custom_encoder_decoder(self):\n-        field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)\n-        name, path, args, kwargs = field.deconstruct()\n-        self.assertEqual(kwargs['encoder'], DjangoJSONEncoder)\n-        self.assertEqual(kwargs['decoder'], CustomJSONDecoder)\n-\n-    def test_get_transforms(self):\n-        @models.JSONField.register_lookup\n-        class MyTransform(Transform):\n-            lookup_name = 'my_transform'\n-        field = models.JSONField()\n-        transform = field.get_transform('my_transform')\n-        self.assertIs(transform, MyTransform)\n-        models.JSONField._unregister_lookup(MyTransform)\n-        models.JSONField._clear_cached_lookups()\n-        transform = field.get_transform('my_transform')\n-        self.assertIsInstance(transform, KeyTransformFactory)\n-\n-    def test_key_transform_text_lookup_mixin_non_key_transform(self):\n-        transform = Transform('test')\n-        msg = (\n-            'Transform should be an instance of KeyTransform in order to use '\n-            'this lookup.'\n-        )\n-        with self.assertRaisesMessage(TypeError, msg):\n-            KeyTransformTextLookupMixin(transform)\n-\n-\n-class TestValidation(SimpleTestCase):\n-    def test_invalid_encoder(self):\n-        msg = 'The encoder parameter must be a callable object.'\n-        with self.assertRaisesMessage(ValueError, msg):\n-            models.JSONField(encoder=DjangoJSONEncoder())\n-\n-    def test_invalid_decoder(self):\n-        msg = 'The decoder parameter must be a callable object.'\n-        with self.assertRaisesMessage(ValueError, msg):\n-            models.JSONField(decoder=CustomJSONDecoder())\n-\n-    def test_validation_error(self):\n-        field = models.JSONField()\n-        msg = 'Value must be valid JSON.'\n-        value = uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')\n-        with self.assertRaisesMessage(ValidationError, msg):\n-            field.clean({'uuid': value}, None)\n-\n-    def test_custom_encoder(self):\n-        field = models.JSONField(encoder=DjangoJSONEncoder)\n-        value = uuid.UUID('{d85e2076-b67c-4ee7-8c3a-2bf5a2cc2475}')\n-        field.clean({'uuid': value}, None)\n-\n-\n-class TestFormField(SimpleTestCase):\n-    def test_formfield(self):\n-        model_field = models.JSONField()\n-        form_field = model_field.formfield()\n-        self.assertIsInstance(form_field, forms.JSONField)\n-\n-    def test_formfield_custom_encoder_decoder(self):\n-        model_field = models.JSONField(encoder=DjangoJSONEncoder, decoder=CustomJSONDecoder)\n-        form_field = model_field.formfield()\n-        self.assertIs(form_field.encoder, DjangoJSONEncoder)\n-        self.assertIs(form_field.decoder, CustomJSONDecoder)\n-\n-\n-class TestSerialization(SimpleTestCase):\n-    test_data = (\n-        '[{\"fields\": {\"value\": %s}, '\n-        '\"model\": \"model_fields.jsonmodel\", \"pk\": null}]'\n-    )\n-    test_values = (\n-        # (Python value, serialized value),\n-        ({'a': 'b', 'c': None}, '{\"a\": \"b\", \"c\": null}'),\n-        ('abc', '\"abc\"'),\n-        ('{\"a\": \"a\"}', '\"{\\\\\"a\\\\\": \\\\\"a\\\\\"}\"'),\n-    )\n-\n-    def test_dumping(self):\n-        for value, serialized in self.test_values:\n-            with self.subTest(value=value):\n-                instance = JSONModel(value=value)\n-                data = serializers.serialize('json', [instance])\n-                self.assertJSONEqual(data, self.test_data % serialized)\n-\n-    def test_loading(self):\n-        for value, serialized in self.test_values:\n-            with self.subTest(value=value):\n-                instance = list(\n-                    serializers.deserialize('json', self.test_data % serialized)\n-                )[0].object\n-                self.assertEqual(instance.value, value)\n-\n-    def test_xml_serialization(self):\n-        test_xml_data = (\n-            '<django-objects version=\"1.0\">'\n-            '<object model=\"model_fields.nullablejsonmodel\">'\n-            '<field name=\"value\" type=\"JSONField\">%s'\n-            '</field></object></django-objects>'\n-        )\n-        for value, serialized in self.test_values:\n-            with self.subTest(value=value):\n-                instance = NullableJSONModel(value=value)\n-                data = serializers.serialize('xml', [instance], fields=['value'])\n-                self.assertXMLEqual(data, test_xml_data % serialized)\n-                new_instance = list(serializers.deserialize('xml', data))[0].object\n-                self.assertEqual(new_instance.value, instance.value)\n-\n-\n-@skipUnlessDBFeature('supports_json_field')\n-class TestSaveLoad(TestCase):\n-    def test_null(self):\n-        obj = NullableJSONModel(value=None)\n-        obj.save()\n-        obj.refresh_from_db()\n-        self.assertIsNone(obj.value)\n-\n-    @skipUnlessDBFeature('supports_primitives_in_json_field')\n-    def test_json_null_different_from_sql_null(self):\n-        json_null = NullableJSONModel.objects.create(value=Value('null'))\n-        json_null.refresh_from_db()\n-        sql_null = NullableJSONModel.objects.create(value=None)\n-        sql_null.refresh_from_db()\n-        # 'null' is not equal to NULL in the database.\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value=Value('null')),\n-            [json_null],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value=None),\n-            [json_null],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__isnull=True),\n-            [sql_null],\n-        )\n-        # 'null' is equal to NULL in Python (None).\n-        self.assertEqual(json_null.value, sql_null.value)\n-\n-    @skipUnlessDBFeature('supports_primitives_in_json_field')\n-    def test_primitives(self):\n-        values = [\n-            True,\n-            1,\n-            1.45,\n-            'String',\n-            '',\n-        ]\n-        for value in values:\n-            with self.subTest(value=value):\n-                obj = JSONModel(value=value)\n-                obj.save()\n-                obj.refresh_from_db()\n-                self.assertEqual(obj.value, value)\n-\n-    def test_dict(self):\n-        values = [\n-            {},\n-            {'name': 'John', 'age': 20, 'height': 180.3},\n-            {'a': True, 'b': {'b1': False, 'b2': None}},\n-        ]\n-        for value in values:\n-            with self.subTest(value=value):\n-                obj = JSONModel.objects.create(value=value)\n-                obj.refresh_from_db()\n-                self.assertEqual(obj.value, value)\n-\n-    def test_list(self):\n-        values = [\n-            [],\n-            ['John', 20, 180.3],\n-            [True, [False, None]],\n-        ]\n-        for value in values:\n-            with self.subTest(value=value):\n-                obj = JSONModel.objects.create(value=value)\n-                obj.refresh_from_db()\n-                self.assertEqual(obj.value, value)\n-\n-    def test_realistic_object(self):\n-        value = {\n-            'name': 'John',\n-            'age': 20,\n-            'pets': [\n-                {'name': 'Kit', 'type': 'cat', 'age': 2},\n-                {'name': 'Max', 'type': 'dog', 'age': 1},\n-            ],\n-            'courses': [\n-                ['A1', 'A2', 'A3'],\n-                ['B1', 'B2'],\n-                ['C1'],\n-            ],\n-        }\n-        obj = JSONModel.objects.create(value=value)\n-        obj.refresh_from_db()\n-        self.assertEqual(obj.value, value)\n-\n-\n-@skipUnlessDBFeature('supports_json_field')\n-class TestQuerying(TestCase):\n-    @classmethod\n-    def setUpTestData(cls):\n-        cls.primitives = [True, False, 'yes', 7, 9.6]\n-        values = [\n-            None,\n-            [],\n-            {},\n-            {'a': 'b', 'c': 14},\n-            {\n-                'a': 'b',\n-                'c': 14,\n-                'd': ['e', {'f': 'g'}],\n-                'h': True,\n-                'i': False,\n-                'j': None,\n-                'k': {'l': 'm'},\n-                'n': [None],\n-            },\n-            [1, [2]],\n-            {'k': True, 'l': False, 'foo': 'bax'},\n-            {\n-                'foo': 'bar',\n-                'baz': {'a': 'b', 'c': 'd'},\n-                'bar': ['foo', 'bar'],\n-                'bax': {'foo': 'bar'},\n-            },\n-        ]\n-        cls.objs = [\n-            NullableJSONModel.objects.create(value=value)\n-            for value in values\n-        ]\n-        if connection.features.supports_primitives_in_json_field:\n-            cls.objs.extend([\n-                NullableJSONModel.objects.create(value=value)\n-                for value in cls.primitives\n-            ])\n-        cls.raw_sql = '%s::jsonb' if connection.vendor == 'postgresql' else '%s'\n-\n-    def test_exact(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__exact={}),\n-            [self.objs[2]],\n-        )\n-\n-    def test_exact_complex(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__exact={'a': 'b', 'c': 14}),\n-            [self.objs[3]],\n-        )\n-\n-    def test_isnull(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__isnull=True),\n-            [self.objs[0]],\n-        )\n-\n-    def test_ordering_by_transform(self):\n-        mariadb = connection.vendor == 'mysql' and connection.mysql_is_mariadb\n-        values = [\n-            {'ord': 93, 'name': 'bar'},\n-            {'ord': 22.1, 'name': 'foo'},\n-            {'ord': -1, 'name': 'baz'},\n-            {'ord': 21.931902, 'name': 'spam'},\n-            {'ord': -100291029, 'name': 'eggs'},\n-        ]\n-        for field_name in ['value', 'value_custom']:\n-            with self.subTest(field=field_name):\n-                objs = [\n-                    NullableJSONModel.objects.create(**{field_name: value})\n-                    for value in values\n-                ]\n-                query = NullableJSONModel.objects.filter(\n-                    **{'%s__name__isnull' % field_name: False},\n-                ).order_by('%s__ord' % field_name)\n-                expected = [objs[4], objs[2], objs[3], objs[1], objs[0]]\n-                if mariadb or connection.vendor == 'oracle':\n-                    # MariaDB and Oracle return JSON values as strings.\n-                    expected = [objs[2], objs[4], objs[3], objs[1], objs[0]]\n-                self.assertSequenceEqual(query, expected)\n-\n-    def test_ordering_grouping_by_key_transform(self):\n-        base_qs = NullableJSONModel.objects.filter(value__d__0__isnull=False)\n-        for qs in (\n-            base_qs.order_by('value__d__0'),\n-            base_qs.annotate(key=KeyTransform('0', KeyTransform('d', 'value'))).order_by('key'),\n-        ):\n-            self.assertSequenceEqual(qs, [self.objs[4]])\n-        qs = NullableJSONModel.objects.filter(value__isnull=False)\n-        self.assertQuerysetEqual(\n-            qs.filter(value__isnull=False).annotate(\n-                key=KeyTextTransform('f', KeyTransform('1', KeyTransform('d', 'value'))),\n-            ).values('key').annotate(count=Count('key')).order_by('count'),\n-            [(None, 0), ('g', 1)],\n-            operator.itemgetter('key', 'count'),\n-        )\n-\n-    @skipIf(connection.vendor == 'oracle', \"Oracle doesn't support grouping by LOBs, see #24096.\")\n-    def test_ordering_grouping_by_count(self):\n-        qs = NullableJSONModel.objects.filter(\n-            value__isnull=False,\n-        ).values('value__d__0').annotate(count=Count('value__d__0')).order_by('count')\n-        self.assertQuerysetEqual(qs, [1, 11], operator.itemgetter('count'))\n-\n-    def test_order_grouping_custom_decoder(self):\n-        NullableJSONModel.objects.create(value_custom={'a': 'b'})\n-        qs = NullableJSONModel.objects.filter(value_custom__isnull=False)\n-        self.assertSequenceEqual(\n-            qs.values(\n-                'value_custom__a',\n-            ).annotate(\n-                count=Count('id'),\n-            ).order_by('value_custom__a'),\n-            [{'value_custom__a': 'b', 'count': 1}],\n-        )\n-\n-    def test_key_transform_raw_expression(self):\n-        expr = RawSQL(self.raw_sql, ['{\"x\": \"bar\"}'])\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__foo=KeyTransform('x', expr)),\n-            [self.objs[7]],\n-        )\n-\n-    def test_nested_key_transform_raw_expression(self):\n-        expr = RawSQL(self.raw_sql, ['{\"x\": {\"y\": \"bar\"}}'])\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__foo=KeyTransform('y', KeyTransform('x', expr))),\n-            [self.objs[7]],\n-        )\n-\n-    def test_key_transform_expression(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n-                key=KeyTransform('d', 'value'),\n-                chain=KeyTransform('0', 'key'),\n-                expr=KeyTransform('0', Cast('key', models.JSONField())),\n-            ).filter(chain=F('expr')),\n-            [self.objs[4]],\n-        )\n-\n-    def test_nested_key_transform_expression(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__d__0__isnull=False).annotate(\n-                key=KeyTransform('d', 'value'),\n-                chain=KeyTransform('f', KeyTransform('1', 'key')),\n-                expr=KeyTransform('f', KeyTransform('1', Cast('key', models.JSONField()))),\n-            ).filter(chain=F('expr')),\n-            [self.objs[4]],\n-        )\n-\n-    def test_has_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key='a'),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_has_key_null_value(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_key='j'),\n-            [self.objs[4]],\n-        )\n-\n-    def test_has_key_deep(self):\n-        tests = [\n-            (Q(value__baz__has_key='a'), self.objs[7]),\n-            (Q(value__has_key=KeyTransform('a', KeyTransform('baz', 'value'))), self.objs[7]),\n-            (Q(value__has_key=KeyTransform('c', KeyTransform('baz', 'value'))), self.objs[7]),\n-            (Q(value__d__1__has_key='f'), self.objs[4]),\n-            (\n-                Q(value__has_key=KeyTransform('f', KeyTransform('1', KeyTransform('d', 'value')))),\n-                self.objs[4],\n-            )\n-        ]\n-        for condition, expected in tests:\n-            with self.subTest(condition=condition):\n-                self.assertSequenceEqual(\n-                    NullableJSONModel.objects.filter(condition),\n-                    [expected],\n-                )\n-\n-    def test_has_key_list(self):\n-        obj = NullableJSONModel.objects.create(value=[{'a': 1}, {'b': 'x'}])\n-        tests = [\n-            Q(value__1__has_key='b'),\n-            Q(value__has_key=KeyTransform('b', KeyTransform(1, 'value'))),\n-            Q(value__has_key=KeyTransform('b', KeyTransform('1', 'value'))),\n-        ]\n-        for condition in tests:\n-            with self.subTest(condition=condition):\n-                self.assertSequenceEqual(\n-                    NullableJSONModel.objects.filter(condition),\n-                    [obj],\n-                )\n-\n-    def test_has_keys(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_keys=['a', 'c', 'h']),\n-            [self.objs[4]],\n-        )\n-\n-    def test_has_any_keys(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__has_any_keys=['c', 'l']),\n-            [self.objs[3], self.objs[4], self.objs[6]],\n-        )\n-\n-    @skipUnlessDBFeature('supports_json_field_contains')\n-    def test_contains(self):\n-        tests = [\n-            ({}, self.objs[2:5] + self.objs[6:8]),\n-            ({'baz': {'a': 'b', 'c': 'd'}}, [self.objs[7]]),\n-            ({'baz': {'a': 'b'}}, [self.objs[7]]),\n-            ({'baz': {'c': 'd'}}, [self.objs[7]]),\n-            ({'k': True, 'l': False}, [self.objs[6]]),\n-            ({'d': ['e', {'f': 'g'}]}, [self.objs[4]]),\n-            ({'d': ['e']}, [self.objs[4]]),\n-            ({'d': [{'f': 'g'}]}, [self.objs[4]]),\n-            ([1, [2]], [self.objs[5]]),\n-            ([1], [self.objs[5]]),\n-            ([[2]], [self.objs[5]]),\n-            ({'n': [None]}, [self.objs[4]]),\n-            ({'j': None}, [self.objs[4]]),\n-        ]\n-        for value, expected in tests:\n-            with self.subTest(value=value):\n-                qs = NullableJSONModel.objects.filter(value__contains=value)\n-                self.assertSequenceEqual(qs, expected)\n-\n-    @skipIfDBFeature('supports_json_field_contains')\n-    def test_contains_unsupported(self):\n-        msg = 'contains lookup is not supported on this database backend.'\n-        with self.assertRaisesMessage(NotSupportedError, msg):\n-            NullableJSONModel.objects.filter(\n-                value__contains={'baz': {'a': 'b', 'c': 'd'}},\n-            ).get()\n-\n-    @skipUnlessDBFeature(\n-        'supports_primitives_in_json_field',\n-        'supports_json_field_contains',\n-    )\n-    def test_contains_primitives(self):\n-        for value in self.primitives:\n-            with self.subTest(value=value):\n-                qs = NullableJSONModel.objects.filter(value__contains=value)\n-                self.assertIs(qs.exists(), True)\n-\n-    @skipUnlessDBFeature('supports_json_field_contains')\n-    def test_contained_by(self):\n-        qs = NullableJSONModel.objects.filter(value__contained_by={'a': 'b', 'c': 14, 'h': True})\n-        self.assertSequenceEqual(qs, self.objs[2:4])\n-\n-    @skipIfDBFeature('supports_json_field_contains')\n-    def test_contained_by_unsupported(self):\n-        msg = 'contained_by lookup is not supported on this database backend.'\n-        with self.assertRaisesMessage(NotSupportedError, msg):\n-            NullableJSONModel.objects.filter(value__contained_by={'a': 'b'}).get()\n-\n-    def test_deep_values(self):\n-        qs = NullableJSONModel.objects.values_list('value__k__l')\n-        expected_objs = [(None,)] * len(self.objs)\n-        expected_objs[4] = ('m',)\n-        self.assertSequenceEqual(qs, expected_objs)\n-\n-    @skipUnlessDBFeature('can_distinct_on_fields')\n-    def test_deep_distinct(self):\n-        query = NullableJSONModel.objects.distinct('value__k__l').values_list('value__k__l')\n-        self.assertSequenceEqual(query, [('m',), (None,)])\n-\n-    def test_isnull_key(self):\n-        # key__isnull=False works the same as has_key='key'.\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__a__isnull=True),\n-            self.objs[:3] + self.objs[5:],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__a__isnull=False),\n-            [self.objs[3], self.objs[4]],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__j__isnull=False),\n-            [self.objs[4]],\n-        )\n-\n-    def test_isnull_key_or_none(self):\n-        obj = NullableJSONModel.objects.create(value={'a': None})\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n-            self.objs[:3] + self.objs[5:] + [obj],\n-        )\n-\n-    def test_none_key(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__j=None),\n-            [self.objs[4]],\n-        )\n-\n-    def test_none_key_exclude(self):\n-        obj = NullableJSONModel.objects.create(value={'j': 1})\n-        if connection.vendor == 'oracle':\n-            # Oracle supports filtering JSON objects with NULL keys, but the\n-            # current implementation doesn't support it.\n-            self.assertSequenceEqual(\n-                NullableJSONModel.objects.exclude(value__j=None),\n-                self.objs[1:4] + self.objs[5:] + [obj],\n-            )\n-        else:\n-            self.assertSequenceEqual(NullableJSONModel.objects.exclude(value__j=None), [obj])\n-\n-    def test_shallow_list_lookup(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__0=1),\n-            [self.objs[5]],\n-        )\n-\n-    def test_shallow_obj_lookup(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__a='b'),\n-            [self.objs[3], self.objs[4]],\n-        )\n-\n-    def test_obj_subquery_lookup(self):\n-        qs = NullableJSONModel.objects.annotate(\n-            field=Subquery(NullableJSONModel.objects.filter(pk=OuterRef('pk')).values('value')),\n-        ).filter(field__a='b')\n-        self.assertSequenceEqual(qs, [self.objs[3], self.objs[4]])\n-\n-    def test_deep_lookup_objs(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__k__l='m'),\n-            [self.objs[4]],\n-        )\n-\n-    def test_shallow_lookup_obj_target(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__k={'l': 'm'}),\n-            [self.objs[4]],\n-        )\n-\n-    def test_deep_lookup_array(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__1__0=2),\n-            [self.objs[5]],\n-        )\n-\n-    def test_deep_lookup_mixed(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__d__1__f='g'),\n-            [self.objs[4]],\n-        )\n-\n-    def test_deep_lookup_transform(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__c__gt=2),\n-            [self.objs[3], self.objs[4]],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__c__gt=2.33),\n-            [self.objs[3], self.objs[4]],\n-        )\n-        self.assertIs(NullableJSONModel.objects.filter(value__c__lt=5).exists(), False)\n-\n-    def test_lookup_exclude(self):\n-        tests = [\n-            (Q(value__a='b'), [self.objs[0]]),\n-            (Q(value__foo='bax'), [self.objs[0], self.objs[7]]),\n-        ]\n-        for condition, expected in tests:\n-            self.assertSequenceEqual(\n-                NullableJSONModel.objects.exclude(condition),\n-                expected,\n-            )\n-            self.assertSequenceEqual(\n-                NullableJSONModel.objects.filter(~condition),\n-                expected,\n-            )\n-\n-    def test_lookup_exclude_nonexistent_key(self):\n-        # Values without the key are ignored.\n-        condition = Q(value__foo='bax')\n-        objs_with_value = [self.objs[6]]\n-        objs_with_different_value = [self.objs[0], self.objs[7]]\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.exclude(condition),\n-            objs_with_different_value,\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.exclude(~condition),\n-            objs_with_value,\n-        )\n-        self.assertCountEqual(\n-            NullableJSONModel.objects.filter(condition | ~condition),\n-            objs_with_value + objs_with_different_value,\n-        )\n-        self.assertCountEqual(\n-            NullableJSONModel.objects.exclude(condition & ~condition),\n-            objs_with_value + objs_with_different_value,\n-        )\n-        # Add the __isnull lookup to get an exhaustive set.\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.exclude(condition & Q(value__foo__isnull=False)),\n-            self.objs[0:6] + self.objs[7:],\n-        )\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(condition & Q(value__foo__isnull=False)),\n-            objs_with_value,\n-        )\n-\n-    @skipIf(\n-        connection.vendor == 'oracle',\n-        'Raises ORA-00600: internal error code on Oracle 18.',\n-    )\n-    def test_usage_in_subquery(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(\n-                id__in=NullableJSONModel.objects.filter(value__c=14),\n-            ),\n-            self.objs[3:5],\n-        )\n-\n-    @skipUnlessDBFeature('supports_json_field_contains')\n-    def test_array_key_contains(self):\n-        tests = [\n-            ([], [self.objs[7]]),\n-            ('bar', [self.objs[7]]),\n-            (['bar'], [self.objs[7]]),\n-            ('ar', []),\n-        ]\n-        for value, expected in tests:\n-            with self.subTest(value=value):\n-                self.assertSequenceEqual(\n-                    NullableJSONModel.objects.filter(value__bar__contains=value),\n-                    expected,\n-                )\n-\n-    def test_key_iexact(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='BaR').exists(), True)\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists(), False)\n-\n-    def test_key_in(self):\n-        tests = [\n-            ('value__c__in', [14], self.objs[3:5]),\n-            ('value__c__in', [14, 15], self.objs[3:5]),\n-            ('value__0__in', [1], [self.objs[5]]),\n-            ('value__0__in', [1, 3], [self.objs[5]]),\n-            ('value__foo__in', ['bar'], [self.objs[7]]),\n-            ('value__foo__in', ['bar', 'baz'], [self.objs[7]]),\n-            ('value__bar__in', [['foo', 'bar']], [self.objs[7]]),\n-            ('value__bar__in', [['foo', 'bar'], ['a']], [self.objs[7]]),\n-            ('value__bax__in', [{'foo': 'bar'}, {'a': 'b'}], [self.objs[7]]),\n-        ]\n-        for lookup, value, expected in tests:\n-            with self.subTest(lookup=lookup, value=value):\n-                self.assertSequenceEqual(\n-                    NullableJSONModel.objects.filter(**{lookup: value}),\n-                    expected,\n-                )\n-\n-    @skipUnlessDBFeature('supports_json_field_contains')\n-    def test_key_contains(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__contains='ar').exists(), False)\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__contains='bar').exists(), True)\n-\n-    def test_key_icontains(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__icontains='Ar').exists(), True)\n-\n-    def test_key_startswith(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__startswith='b').exists(), True)\n-\n-    def test_key_istartswith(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__istartswith='B').exists(), True)\n-\n-    def test_key_endswith(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__endswith='r').exists(), True)\n-\n-    def test_key_iendswith(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__iendswith='R').exists(), True)\n-\n-    def test_key_regex(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__regex=r'^bar$').exists(), True)\n-\n-    def test_key_iregex(self):\n-        self.assertIs(NullableJSONModel.objects.filter(value__foo__iregex=r'^bAr$').exists(), True)\n-\n-    @skipUnlessDBFeature('has_json_operators')\n-    def test_key_sql_injection(self):\n-        with CaptureQueriesContext(connection) as queries:\n-            self.assertIs(\n-                NullableJSONModel.objects.filter(**{\n-                    \"\"\"value__test' = '\"a\"') OR 1 = 1 OR ('d\"\"\": 'x',\n-                }).exists(),\n-                False,\n-            )\n-        self.assertIn(\n-            \"\"\".\"value\" -> 'test'' = ''\"a\"'') OR 1 = 1 OR (''d') = '\"x\"' \"\"\",\n-            queries[0]['sql'],\n-        )\n-\n-    @skipIfDBFeature('has_json_operators')\n-    def test_key_sql_injection_escape(self):\n-        query = str(JSONModel.objects.filter(**{\n-            \"\"\"value__test\") = '\"a\"' OR 1 = 1 OR (\"d\"\"\": 'x',\n-        }).query)\n-        self.assertIn('\"test\\\\\"', query)\n-        self.assertIn('\\\\\"d', query)\n-\n-    def test_key_escape(self):\n-        obj = NullableJSONModel.objects.create(value={'%total': 10})\n-        self.assertEqual(NullableJSONModel.objects.filter(**{'value__%total': 10}).get(), obj)\n-\n-    def test_none_key_and_exact_lookup(self):\n-        self.assertSequenceEqual(\n-            NullableJSONModel.objects.filter(value__a='b', value__j=None),\n-            [self.objs[4]],\n-        )\n-\n-    def test_lookups_with_key_transform(self):\n-        tests = (\n-            ('value__baz__has_key', 'c'),\n-            ('value__baz__has_keys', ['a', 'c']),\n-            ('value__baz__has_any_keys', ['a', 'x']),\n-            ('value__has_key', KeyTextTransform('foo', 'value')),\n-        )\n-        for lookup, value in tests:\n-            with self.subTest(lookup=lookup):\n-                self.assertIs(NullableJSONModel.objects.filter(\n-                    **{lookup: value},\n-                ).exists(), True)\n-\n-    @skipUnlessDBFeature('supports_json_field_contains')\n-    def test_contains_contained_by_with_key_transform(self):\n-        tests = [\n-            ('value__d__contains', 'e'),\n-            ('value__d__contains', [{'f': 'g'}]),\n-            ('value__contains', KeyTransform('bax', 'value')),\n-            ('value__baz__contains', {'a': 'b'}),\n-            ('value__baz__contained_by', {'a': 'b', 'c': 'd', 'e': 'f'}),\n-            (\n-                'value__contained_by',\n-                KeyTransform('x', RawSQL(\n-                    self.raw_sql,\n-                    ['{\"x\": {\"a\": \"b\", \"c\": 1, \"d\": \"e\"}}'],\n-                )),\n-            ),\n-        ]\n-        # For databases where {'f': 'g'} (without surrounding []) matches\n-        # [{'f': 'g'}].\n-        if not connection.features.json_key_contains_list_matching_requires_list:\n-            tests.append(('value__d__contains', {'f': 'g'}))\n-        for lookup, value in tests:\n-            with self.subTest(lookup=lookup, value=value):\n-                self.assertIs(NullableJSONModel.objects.filter(\n-                    **{lookup: value},\n-                ).exists(), True)\n", "gold_standard_diff": "From de81676b51e4dad510ef387c3ae625f9091fe57f Mon Sep 17 00:00:00 2001\nFrom: Qi Zhao <zhaoqi99@outlook.com>\nDate: Thu, 8 Oct 2020 21:51:14 +0800\nSubject: [PATCH] Fixed #32080 -- Fixed displaying Unicode chars in\n forms.JSONField and read-only JSONField values in admin.\n\n---\n AUTHORS                                         | 1 +\n django/contrib/admin/utils.py                   | 3 ++-\n django/forms/fields.py                          | 2 +-\n docs/releases/3.1.3.txt                         | 5 +++++\n tests/admin_utils/tests.py                      | 1 +\n tests/forms_tests/field_tests/test_jsonfield.py | 6 ++++++\n 6 files changed, 16 insertions(+), 2 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex 9253740857de..bb18fe15dbb4 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -749,6 +749,7 @@ answer newbie questions, and generally made Django that much better:\n     Priyansh Saxena <askpriyansh@gmail.com>\n     Przemys\u0142aw Buczkowski <przemub@przemub.pl>\n     Przemys\u0142aw Suliga <http://suligap.net>\n+    Qi Zhao <zhaoqi99@outlook.com>\n     Rachel Tobin <rmtobin@me.com>\n     Rachel Willmer <http://www.willmer.com/kb/>\n     Radek \u0160varz <https://www.svarz.cz/translate/>\ndiff --git a/django/contrib/admin/utils.py b/django/contrib/admin/utils.py\nindex 446083e65934..ba06da521105 100644\n--- a/django/contrib/admin/utils.py\n+++ b/django/contrib/admin/utils.py\n@@ -1,5 +1,6 @@\n import datetime\n import decimal\n+import json\n from collections import defaultdict\n \n from django.core.exceptions import FieldDoesNotExist\n@@ -400,7 +401,7 @@ def display_for_field(value, field, empty_value_display):\n         return format_html('<a href=\"{}\">{}</a>', value.url, value)\n     elif isinstance(field, models.JSONField) and value:\n         try:\n-            return field.get_prep_value(value)\n+            return json.dumps(value, ensure_ascii=False, cls=field.encoder)\n         except TypeError:\n             return display_for_value(value, empty_value_display)\n     else:\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 9de2c60b3537..17c7956b53f6 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -1258,7 +1258,7 @@ def bound_data(self, data, initial):\n     def prepare_value(self, value):\n         if isinstance(value, InvalidJSONInput):\n             return value\n-        return json.dumps(value, cls=self.encoder)\n+        return json.dumps(value, ensure_ascii=False, cls=self.encoder)\n \n     def has_changed(self, initial, data):\n         if super().has_changed(initial, data):\ndiff --git a/docs/releases/3.1.3.txt b/docs/releases/3.1.3.txt\nindex 853ec7a48d5e..e2bb2d0df3d3 100644\n--- a/docs/releases/3.1.3.txt\n+++ b/docs/releases/3.1.3.txt\n@@ -11,3 +11,8 @@ Bugfixes\n \n * Fixed a regression in Django 3.1.2 that caused the incorrect height of the\n   admin changelist search bar (:ticket:`32072`).\n+\n+* Fixed displaying Unicode characters in\n+  :class:`forms.JSONField <django.forms.JSONField>` and read-only\n+  :class:`models.JSONField <django.db.models.JSONField>` values in the admin\n+  (:ticket:`32080`).\ndiff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex a7594deda897..ce9f94dbb9b6 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -186,6 +186,7 @@ def test_json_display_for_field(self):\n             ({'a': {'b': 'c'}}, '{\"a\": {\"b\": \"c\"}}'),\n             (['a', 'b'], '[\"a\", \"b\"]'),\n             ('a', '\"a\"'),\n+            ({'a': '\u4f60\u597d \u4e16\u754c'}, '{\"a\": \"\u4f60\u597d \u4e16\u754c\"}'),\n             ({('a', 'b'): 'c'}, \"{('a', 'b'): 'c'}\"),  # Invalid JSON.\n         ]\n         for value, display_value in tests:\ndiff --git a/tests/forms_tests/field_tests/test_jsonfield.py b/tests/forms_tests/field_tests/test_jsonfield.py\nindex 915b180d0c41..46ef0005f631 100644\n--- a/tests/forms_tests/field_tests/test_jsonfield.py\n+++ b/tests/forms_tests/field_tests/test_jsonfield.py\n@@ -29,6 +29,12 @@ def test_prepare_value(self):\n         self.assertEqual(field.prepare_value({'a': 'b'}), '{\"a\": \"b\"}')\n         self.assertEqual(field.prepare_value(None), 'null')\n         self.assertEqual(field.prepare_value('foo'), '\"foo\"')\n+        self.assertEqual(field.prepare_value('\u4f60\u597d\uff0c\u4e16\u754c'), '\"\u4f60\u597d\uff0c\u4e16\u754c\"')\n+        self.assertEqual(field.prepare_value({'a': '\ud83d\ude00\ud83d\udc31'}), '{\"a\": \"\ud83d\ude00\ud83d\udc31\"}')\n+        self.assertEqual(\n+            field.prepare_value([\"\u4f60\u597d\uff0c\u4e16\u754c\", \"ja\u017a\u0144\"]),\n+            '[\"\u4f60\u597d\uff0c\u4e16\u754c\", \"ja\u017a\u0144\"]',\n+        )\n \n     def test_widget(self):\n         field = JSONField()\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13512"}