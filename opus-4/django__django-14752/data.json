{"instance_id": "django__django-14752", "score": "C", "diff": "diff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py\nindex 3903e4c98c..44e42a0b7d 100644\n--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -26,12 +26,19 @@ class AutocompleteJsonView(BaseListView):\n         context = self.get_context_data()\n         return JsonResponse({\n             'results': [\n-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+                self.serialize_result(obj, to_field_name)\n                 for obj in context['object_list']\n             ],\n             'pagination': {'more': context['page_obj'].has_next()},\n         })\n \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"\n+        Convert the provided model object to a dictionary that is\n+        added to the results list.\n+        \"\"\"\n+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+\n     def get_paginator(self, *args, **kwargs):\n         \"\"\"Use the ModelAdmin's paginator.\"\"\"\n         return self.model_admin.get_paginator(self.request, *args, **kwargs)\ndiff --git a/example_usage.py b/example_usage.py\nnew file mode 100644\nindex 0000000000..33cff3e57d\n--- /dev/null\n+++ b/example_usage.py\n@@ -0,0 +1,100 @@\n+\"\"\"\n+Example showing how the refactored AutocompleteJsonView simplifies customization.\n+\n+Before the refactoring, developers had to override the entire get() method.\n+Now they can simply override serialize_result() to add extra fields.\n+\"\"\"\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+\n+\n+# Example 1: Before refactoring (what users had to do)\n+print(\"=== BEFORE REFACTORING ===\")\n+print(\"Users had to override the entire get() method:\")\n+print('''\n+class CustomAutocompleteJsonView(AutocompleteJsonView):\n+    def get(self, request, *args, **kwargs):\n+        self.term, self.model_admin, self.source_field, to_field_name = self.process_request(request)\n+        if not self.has_perm(request):\n+            raise PermissionDenied\n+        self.object_list = self.get_queryset()\n+        context = self.get_context_data()\n+        return JsonResponse({\n+            'results': [\n+                {'id': str(getattr(obj, to_field_name)), 'text': str(obj), 'notes': obj.notes}\n+                for obj in context['object_list']\n+            ],\n+            'pagination': {'more': context['page_obj'].has_next()},\n+        })\n+''')\n+\n+# Example 2: After refactoring\n+print(\"\\n=== AFTER REFACTORING ===\")\n+print(\"Now users can simply override serialize_result():\")\n+print('''\n+class CustomAutocompleteJsonView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        result['notes'] = obj.notes\n+        return result\n+''')\n+\n+# Example 3: Multiple customizations\n+print(\"\\n=== REAL-WORLD EXAMPLE ===\")\n+print(\"Adding multiple fields for dynamic admin customization:\")\n+\n+class EnhancedAutocompleteJsonView(AutocompleteJsonView):\n+    \"\"\"Add extra fields for dynamic form updates.\"\"\"\n+    \n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        \n+        # Add commonly needed fields\n+        if hasattr(obj, 'email'):\n+            result['email'] = obj.email\n+        \n+        if hasattr(obj, 'is_active'):\n+            result['is_active'] = obj.is_active\n+            \n+        if hasattr(obj, 'department'):\n+            result['department'] = str(obj.department) if obj.department else ''\n+            \n+        if hasattr(obj, 'get_full_name'):\n+            result['full_name'] = obj.get_full_name()\n+            \n+        # Add metadata that can be used by JavaScript\n+        result['model'] = obj._meta.label\n+        result['pk_field'] = obj._meta.pk.name\n+        \n+        return result\n+\n+print('''\n+class EnhancedAutocompleteJsonView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        \n+        # Add commonly needed fields\n+        if hasattr(obj, 'email'):\n+            result['email'] = obj.email\n+        \n+        if hasattr(obj, 'is_active'):\n+            result['is_active'] = obj.is_active\n+            \n+        if hasattr(obj, 'department'):\n+            result['department'] = str(obj.department) if obj.department else ''\n+            \n+        if hasattr(obj, 'get_full_name'):\n+            result['full_name'] = obj.get_full_name()\n+            \n+        # Add metadata\n+        result['model'] = obj._meta.label\n+        result['pk_field'] = obj._meta.pk.name\n+        \n+        return result\n+''')\n+\n+print(\"\\n=== BENEFITS ===\")\n+print(\"1. Much cleaner and more maintainable code\")\n+print(\"2. No need to worry about future changes to get() method\")\n+print(\"3. Easy to add conditional fields based on object attributes\")\n+print(\"4. Can be reused across different model admins\")\n+print(\"5. Follows Django's design principles of extensibility\")\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 0000000000..fad5e42d77\n--- /dev/null\n+++ b/simple_test.py\n@@ -0,0 +1,52 @@\n+\"\"\"\n+Simple test to verify the refactored AutocompleteJsonView works correctly.\n+\"\"\"\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+\n+\n+# Test 1: Verify the serialize_result method exists\n+view = AutocompleteJsonView()\n+assert hasattr(view, 'serialize_result'), \"serialize_result method should exist\"\n+\n+# Test 2: Verify the method works correctly\n+class MockObj:\n+    id = 1\n+    name = \"Test Object\"\n+    def __str__(self):\n+        return self.name\n+\n+obj = MockObj()\n+result = view.serialize_result(obj, 'id')\n+print(\"Standard result:\", result)\n+assert result == {'id': '1', 'text': 'Test Object'}, f\"Unexpected result: {result}\"\n+\n+# Test 3: Verify it can be extended\n+class CustomAutocompleteJsonView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        # Add extra field\n+        result['extra'] = 'custom_data'\n+        return result\n+\n+custom_view = CustomAutocompleteJsonView()\n+custom_result = custom_view.serialize_result(obj, 'id')\n+print(\"Custom result:\", custom_result)\n+assert custom_result == {'id': '1', 'text': 'Test Object', 'extra': 'custom_data'}, f\"Unexpected custom result: {custom_result}\"\n+\n+# Test 4: Test with dict update approach\n+class ModernCustomAutocompleteJsonView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        result.update({'notes': 'extra notes'})\n+        return result\n+\n+modern_view = ModernCustomAutocompleteJsonView()\n+modern_result = modern_view.serialize_result(obj, 'id')\n+print(\"Modern result:\", modern_result)\n+assert modern_result == {'id': '1', 'text': 'Test Object', 'notes': 'extra notes'}, f\"Unexpected modern result: {modern_result}\"\n+\n+print(\"\\nAll tests passed! The refactoring works correctly.\")\n+print(\"\\nThe AutocompleteJsonView now has a serialize_result method that:\")\n+print(\"1. Can be easily overridden in subclasses\")\n+print(\"2. Maintains backward compatibility\")\n+print(\"3. Allows adding extra fields without rewriting the entire get() method\")\ndiff --git a/test_autocomplete_refactor.py b/test_autocomplete_refactor.py\nnew file mode 100644\nindex 0000000000..f6d12672e5\n--- /dev/null\n+++ b/test_autocomplete_refactor.py\n@@ -0,0 +1,209 @@\n+\"\"\"\n+Test the refactored AutocompleteJsonView functionality.\n+\"\"\"\n+import os\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_settings')\n+\n+import django\n+from django.conf import settings\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+            'django.contrib.sessions',\n+            'django.contrib.messages',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+            'django.contrib.messages.middleware.MessageMiddleware',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+        USE_TZ=True,\n+        ROOT_URLCONF=[],\n+    )\n+    django.setup()\n+\n+import json\n+from django.contrib import admin\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.contrib.auth.models import User, Group\n+from django.test import TestCase, RequestFactory\n+from django.contrib.admin.sites import AdminSite\n+from django.urls import path\n+\n+\n+class CustomAutocompleteJsonView(AutocompleteJsonView):\n+    \"\"\"Custom autocomplete view that adds extra fields.\"\"\"\n+    \n+    def serialize_result(self, obj, to_field_name):\n+        result = super().serialize_result(obj, to_field_name)\n+        # Add extra fields\n+        result['is_staff'] = obj.is_staff if hasattr(obj, 'is_staff') else False\n+        result['email'] = obj.email if hasattr(obj, 'email') else ''\n+        return result\n+\n+\n+class UserAdmin(admin.ModelAdmin):\n+    search_fields = ['username', 'email']\n+    \n+    def get_urls(self):\n+        urls = super().get_urls()\n+        custom_urls = [\n+            path('autocomplete/', CustomAutocompleteJsonView.as_view(admin_site=self.admin_site), name='custom_autocomplete'),\n+        ]\n+        return custom_urls + urls\n+\n+\n+class GroupAdmin(admin.ModelAdmin):\n+    search_fields = ['name']\n+\n+\n+class AutocompleteRefactorTest(TestCase):\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.admin_site = AdminSite()\n+        self.admin_site.register(User, UserAdmin)\n+        self.admin_site.register(Group, GroupAdmin)\n+        \n+        # Create test users\n+        self.user1 = User.objects.create_user(\n+            username='testuser1',\n+            email='user1@example.com',\n+            is_staff=True\n+        )\n+        self.user2 = User.objects.create_user(\n+            username='testuser2',\n+            email='user2@example.com',\n+            is_staff=False\n+        )\n+        self.admin_user = User.objects.create_superuser(\n+            username='admin',\n+            email='admin@example.com',\n+            password='admin'\n+        )\n+        \n+    def test_standard_autocomplete_view(self):\n+        \"\"\"Test that the standard AutocompleteJsonView still works.\"\"\"\n+        request = self.factory.get('/autocomplete/', {\n+            'term': 'test',\n+            'app_label': 'auth',\n+            'model_name': 'user',\n+            'field_name': 'groups'\n+        })\n+        request.user = self.admin_user\n+        \n+        view = AutocompleteJsonView()\n+        view.admin_site = self.admin_site\n+        response = view.get(request)\n+        \n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content)\n+        \n+        # Check structure\n+        self.assertIn('results', data)\n+        self.assertIn('pagination', data)\n+        \n+        # Results should have standard fields\n+        if data['results']:\n+            result = data['results'][0]\n+            self.assertIn('id', result)\n+            self.assertIn('text', result)\n+            # Should not have extra fields\n+            self.assertNotIn('is_staff', result)\n+            self.assertNotIn('email', result)\n+    \n+    def test_custom_autocomplete_view_with_extra_fields(self):\n+        \"\"\"Test that the custom AutocompleteJsonView adds extra fields.\"\"\"\n+        request = self.factory.get('/autocomplete/', {\n+            'term': 'test',\n+            'app_label': 'auth',\n+            'model_name': 'group',\n+            'field_name': 'user_set'\n+        })\n+        request.user = self.admin_user\n+        \n+        view = CustomAutocompleteJsonView()\n+        view.admin_site = self.admin_site\n+        response = view.get(request)\n+        \n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content)\n+        \n+        # Check structure\n+        self.assertIn('results', data)\n+        self.assertIn('pagination', data)\n+        \n+        # Results should have extra fields\n+        self.assertEqual(len(data['results']), 2)  # testuser1 and testuser2\n+        \n+        for result in data['results']:\n+            self.assertIn('id', result)\n+            self.assertIn('text', result)\n+            # Should have extra fields\n+            self.assertIn('is_staff', result)\n+            self.assertIn('email', result)\n+            \n+        # Check specific user data\n+        user1_result = next(r for r in data['results'] if 'testuser1' in r['text'])\n+        self.assertTrue(user1_result['is_staff'])\n+        self.assertEqual(user1_result['email'], 'user1@example.com')\n+        \n+        user2_result = next(r for r in data['results'] if 'testuser2' in r['text'])\n+        self.assertFalse(user2_result['is_staff'])\n+        self.assertEqual(user2_result['email'], 'user2@example.com')\n+    \n+    def test_serialize_result_method_exists(self):\n+        \"\"\"Test that the serialize_result method exists and has the correct signature.\"\"\"\n+        view = AutocompleteJsonView()\n+        self.assertTrue(hasattr(view, 'serialize_result'))\n+        \n+        # Test the method returns the expected format\n+        class MockObj:\n+            id = 1\n+            def __str__(self):\n+                return 'Test Object'\n+        \n+        obj = MockObj()\n+        result = view.serialize_result(obj, 'id')\n+        \n+        self.assertEqual(result, {'id': '1', 'text': 'Test Object'})\n+\n+\n+if __name__ == '__main__':\n+    import django\n+    from django.conf import settings\n+    \n+    if not settings.configured:\n+        settings.configure(\n+            DEBUG=True,\n+            DATABASES={\n+                'default': {\n+                    'ENGINE': 'django.db.backends.sqlite3',\n+                    'NAME': ':memory:',\n+                }\n+            },\n+            INSTALLED_APPS=[\n+                'django.contrib.contenttypes',\n+                'django.contrib.auth',\n+                'django.contrib.admin',\n+            ],\n+            SECRET_KEY='test-secret-key',\n+            USE_TZ=True,\n+        )\n+        django.setup()\n+    \n+    from django.test.utils import get_runner\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner()\n+    failures = test_runner.run_tests([\"__main__\"])\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..1f98c7f696\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,82 @@\n+\"\"\"\n+Test edge cases for the refactored serialize_result method.\n+\"\"\"\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+\n+\n+# Test 1: Object with None values\n+class ObjectWithNone:\n+    id = None\n+    name = None\n+    def __str__(self):\n+        return \"None Object\"\n+\n+view = AutocompleteJsonView()\n+obj = ObjectWithNone()\n+result = view.serialize_result(obj, 'id')\n+print(\"Test 1 - None values:\")\n+print(f\"  Result: {result}\")\n+assert result == {'id': 'None', 'text': 'None Object'}\n+\n+# Test 2: Object with special characters\n+class ObjectWithSpecialChars:\n+    id = 123\n+    def __str__(self):\n+        return \"Object with <>&\\\"' chars\"\n+\n+obj2 = ObjectWithSpecialChars()\n+result2 = view.serialize_result(obj2, 'id')\n+print(\"\\nTest 2 - Special characters:\")\n+print(f\"  Result: {result2}\")\n+assert result2 == {'id': '123', 'text': \"Object with <>&\\\"' chars\"}\n+\n+# Test 3: Object with Unicode\n+class ObjectWithUnicode:\n+    id = 456\n+    def __str__(self):\n+        return \"\u041e\u0431\u044a\u0435\u043a\u0442 with \u00e9mojis \ud83c\udf89\"\n+\n+obj3 = ObjectWithUnicode()\n+result3 = view.serialize_result(obj3, 'id')\n+print(\"\\nTest 3 - Unicode characters:\")\n+print(f\"  Result: {result3}\")\n+assert result3 == {'id': '456', 'text': \"\u041e\u0431\u044a\u0435\u043a\u0442 with \u00e9mojis \ud83c\udf89\"}\n+\n+# Test 4: Complex ID types\n+class ObjectWithUUID:\n+    import uuid\n+    id = uuid.UUID('12345678-1234-5678-1234-567812345678')\n+    def __str__(self):\n+        return \"UUID Object\"\n+\n+obj4 = ObjectWithUUID()\n+result4 = view.serialize_result(obj4, 'id')\n+print(\"\\nTest 4 - UUID as ID:\")\n+print(f\"  Result: {result4}\")\n+assert result4['id'] == '12345678-1234-5678-1234-567812345678'\n+\n+# Test 5: Custom field name\n+class ObjectWithCustomField:\n+    pk = 1\n+    custom_id = 999\n+    def __str__(self):\n+        return \"Custom Field Object\"\n+\n+obj5 = ObjectWithCustomField()\n+result5 = view.serialize_result(obj5, 'custom_id')\n+print(\"\\nTest 5 - Custom field name:\")\n+print(f\"  Result: {result5}\")\n+assert result5 == {'id': '999', 'text': 'Custom Field Object'}\n+\n+# Test 6: Method chaining still works\n+class ChainedCustomView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        return super().serialize_result(obj, to_field_name) | {'extra': 'data'} if hasattr({}, '__or__') else {**super().serialize_result(obj, to_field_name), 'extra': 'data'}\n+\n+chained_view = ChainedCustomView()\n+result6 = chained_view.serialize_result(obj5, 'pk')\n+print(\"\\nTest 6 - Method chaining:\")\n+print(f\"  Result: {result6}\")\n+assert 'extra' in result6\n+\n+print(\"\\n\u2705 All edge case tests passed!\")\n", "gold_standard_diff": "From 9b1158a7e0784686bbe5118a88d4804b99fa4fe1 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Mart=20S=C3=B5mermaa?= <mrts@users.noreply.github.com>\nDate: Sat, 7 Aug 2021 19:28:30 +0300\nSubject: [PATCH] Fixed #32993 -- Added AutocompleteJsonView.serialize_result()\n to allow customization.\n\n---\n AUTHORS                                     |  2 +-\n django/contrib/admin/views/autocomplete.py  | 12 +++++++++--\n tests/admin_views/test_autocomplete_view.py | 24 +++++++++++++++++++++\n 3 files changed, 35 insertions(+), 3 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex 3e4aa1aa2c37..ea10220756ac 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -610,7 +610,7 @@ answer newbie questions, and generally made Django that much better:\n     Martin Mahner <https://www.mahner.org/>\n     Martin Maney <http://www.chipy.org/Martin_Maney>\n     Martin von Gagern <gagern@google.com>\n-    Mart S\u00f5mermaa <http://mrts.pri.ee/>\n+    Mart S\u00f5mermaa <https://github.com/mrts>\n     Marty Alchin <gulopine@gamemusic.org>\n     Masashi Shibata <m.shibata1020@gmail.com>\n     masonsimon+django@gmail.com\ndiff --git a/django/contrib/admin/views/autocomplete.py b/django/contrib/admin/views/autocomplete.py\nindex 3903e4c98c92..26aff083b6dd 100644\n--- a/django/contrib/admin/views/autocomplete.py\n+++ b/django/contrib/admin/views/autocomplete.py\n@@ -11,7 +11,8 @@ class AutocompleteJsonView(BaseListView):\n \n     def get(self, request, *args, **kwargs):\n         \"\"\"\n-        Return a JsonResponse with search results of the form:\n+        Return a JsonResponse with search results as defined in\n+        serialize_result(), by default:\n         {\n             results: [{id: \"123\" text: \"foo\"}],\n             pagination: {more: true}\n@@ -26,12 +27,19 @@ def get(self, request, *args, **kwargs):\n         context = self.get_context_data()\n         return JsonResponse({\n             'results': [\n-                {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+                self.serialize_result(obj, to_field_name)\n                 for obj in context['object_list']\n             ],\n             'pagination': {'more': context['page_obj'].has_next()},\n         })\n \n+    def serialize_result(self, obj, to_field_name):\n+        \"\"\"\n+        Convert the provided model object to a dictionary that is added to the\n+        results list.\n+        \"\"\"\n+        return {'id': str(getattr(obj, to_field_name)), 'text': str(obj)}\n+\n     def get_paginator(self, *args, **kwargs):\n         \"\"\"Use the ModelAdmin's paginator.\"\"\"\n         return self.model_admin.get_paginator(self.request, *args, **kwargs)\ndiff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex aa978f7a832b..0685d0ac7521 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -1,3 +1,4 @@\n+import datetime\n import json\n from contextlib import contextmanager\n \n@@ -293,6 +294,29 @@ class PKOrderingQuestionAdmin(QuestionAdmin):\n             'pagination': {'more': False},\n         })\n \n+    def test_serialize_result(self):\n+        class AutocompleteJsonSerializeResultView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return {\n+                    **super().serialize_result(obj, to_field_name),\n+                    'posted': str(obj.posted),\n+                }\n+\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonSerializeResultView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [\n+                {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+                for q in Question.objects.order_by('-posted')\n+            ],\n+            'pagination': {'more': False},\n+        })\n+\n \n @override_settings(ROOT_URLCONF='admin_views.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14752"}