{"instance_id": "django__django-15563", "score": "I", "diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex 5c78c6e315..9135cd6d60 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -987,12 +987,26 @@ class QuerySet:\n         if self.query.is_sliced:\n             raise TypeError(\"Cannot update a query once a slice has been taken.\")\n         self._for_write = True\n-        query = self.query.chain(sql.UpdateQuery)\n-        query.add_update_values(kwargs)\n-        # Clear any annotations so that they won't be present in subqueries.\n-        query.annotations = {}\n-        with transaction.mark_for_rollback_on_error(using=self.db):\n-            rows = query.get_compiler(self.db).execute_sql(CURSOR)\n+        \n+        # Handle multiple inheritance\n+        base_tables = [\n+            base._meta.db_table\n+            for base in self.model.__bases__\n+            if hasattr(base, '_meta') and not base._meta.abstract\n+        ]\n+        \n+        rows = 0\n+        with transaction.atomic(using=self.db):\n+            for table in base_tables:\n+                query = self.query.clone()\n+                query.__class__ = sql.UpdateQuery\n+                query.model = self.model\n+                query.add_update_values(kwargs)\n+                query.table_map = {self.model._meta.db_table: table}\n+                # Clear any annotations so that they won't be present in subqueries.\n+                query.annotations = {}\n+                rows += query.get_compiler(self.db).execute_sql(CURSOR) or 0\n+        \n         self._result_cache = None\n         return rows\n \ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex c07a4b342a..bdde96b42f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -796,14 +796,21 @@ class Query(BaseExpression):\n         \"\"\"\n         alias_list = self.table_map.get(table_name)\n         if not create and alias_list:\n-            alias = alias_list[0]\n+            if isinstance(alias_list, list):\n+                alias = alias_list[0]\n+            else:\n+                alias = alias_list\n             self.alias_refcount[alias] += 1\n             return alias, False\n \n         # Create a new alias for this table.\n         if alias_list:\n-            alias = \"%s%d\" % (self.alias_prefix, len(self.alias_map) + 1)\n-            alias_list.append(alias)\n+            if isinstance(alias_list, list):\n+                alias = \"%s%d\" % (self.alias_prefix, len(self.alias_map) + 1)\n+                alias_list.append(alias)\n+            else:\n+                alias = \"%s%d\" % (self.alias_prefix, len(self.alias_map) + 1)\n+                self.table_map[table_name] = [alias_list, alias]\n         else:\n             # The first occurrence of a table uses the table name directly.\n             alias = (\ndiff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py\nindex 04063f73bc..dbf76eb409 100644\n--- a/django/db/models/sql/subqueries.py\n+++ b/django/db/models/sql/subqueries.py\n@@ -83,6 +83,8 @@ class UpdateQuery(Query):\n         query. This is the entry point for the public update() method on\n         querysets.\n         \"\"\"\n+        if not hasattr(self, 'related_updates'):\n+            self.related_updates = {}\n         values_seq = []\n         for name, val in values.items():\n             field = self.get_meta().get_field(name)\ndiff --git a/test_app/models.py b/test_app/models.py\nnew file mode 100644\nindex 0000000000..d2965ef7b1\n--- /dev/null\n+++ b/test_app/models.py\n@@ -0,0 +1,13 @@\n+\n+from django.db import models\n+\n+class Base(models.Model):\n+    base_id = models.AutoField(primary_key=True)\n+    field_base = models.IntegerField()\n+\n+class OtherBase(models.Model):\n+    otherbase_id = models.AutoField(primary_key=True)\n+    field_otherbase = models.IntegerField()\n+\n+class Child(Base, OtherBase):\n+    pass\n\\ No newline at end of file\ndiff --git a/test_multiple_inheritance_update.py b/test_multiple_inheritance_update.py\nnew file mode 100644\nindex 0000000000..029e7df5eb\n--- /dev/null\n+++ b/test_multiple_inheritance_update.py\n@@ -0,0 +1,47 @@\n+\n+import os\n+import django\n+import unittest\n+\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"test_project.settings\")\n+django.setup()\n+\n+from django.db import connection\n+from test_app.models import Base, OtherBase, Child\n+\n+class MultipleInheritanceUpdateTestCase(unittest.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.create_model(Base)\n+            schema_editor.create_model(OtherBase)\n+            schema_editor.create_model(Child)\n+\n+    def setUp(self):\n+        OtherBase.objects.create(field_otherbase=100)\n+        OtherBase.objects.create(field_otherbase=101)\n+        Child.objects.create(field_base=0, field_otherbase=0)\n+        Child.objects.create(field_base=1, field_otherbase=1)\n+\n+    def test_update_child(self):\n+        Child.objects.update(field_otherbase=55)\n+        \n+        # Check if Child instances are updated\n+        child_instances = Child.objects.values('field_otherbase')\n+        self.assertEqual(list(child_instances), [{'field_otherbase': 55}, {'field_otherbase': 55}])\n+        \n+        # Check if OtherBase instances are not affected\n+        otherbase_instances = OtherBase.objects.filter(otherbase_id__in=[1, 2]).values('field_otherbase')\n+        self.assertEqual(list(otherbase_instances), [{'field_otherbase': 100}, {'field_otherbase': 101}])\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        with connection.schema_editor() as schema_editor:\n+            schema_editor.delete_model(Child)\n+            schema_editor.delete_model(OtherBase)\n+            schema_editor.delete_model(Base)\n+        super().tearDownClass()\n+\n+if __name__ == '__main__':\n+    unittest.main()\n\\ No newline at end of file\ndiff --git a/test_project/settings.py b/test_project/settings.py\nnew file mode 100644\nindex 0000000000..1a60f90511\n--- /dev/null\n+++ b/test_project/settings.py\n@@ -0,0 +1,17 @@\n+\n+SECRET_KEY = 'dummy_secret_key'\n+DEBUG = True\n+INSTALLED_APPS = [\n+    'django.contrib.auth',\n+    'django.contrib.contenttypes',\n+    'django.contrib.sessions',\n+    'django.contrib.messages',\n+    'test_app',\n+]\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+USE_TZ = False\n\\ No newline at end of file\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 59a5d6abbb6b..7ab391fcb75e 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1836,7 +1836,23 @@ def pre_sql_setup(self):\n         query.clear_ordering(force=True)\n         query.extra = {}\n         query.select = []\n-        query.add_fields([query.get_meta().pk.name])\n+        meta = query.get_meta()\n+        fields = [meta.pk.name]\n+        related_ids_index = []\n+        for related in self.query.related_updates:\n+            if all(\n+                path.join_field.primary_key for path in meta.get_path_to_parent(related)\n+            ):\n+                # If a primary key chain exists to the targeted related update,\n+                # then the meta.pk value can be used for it.\n+                related_ids_index.append((related, 0))\n+            else:\n+                # This branch will only be reached when updating a field of an\n+                # ancestor that is not part of the primary key chain of a MTI\n+                # tree.\n+                related_ids_index.append((related, len(fields)))\n+                fields.append(related._meta.pk.name)\n+        query.add_fields(fields)\n         super().pre_sql_setup()\n \n         must_pre_select = (\n@@ -1851,10 +1867,13 @@ def pre_sql_setup(self):\n             # don't want them to change), or the db backend doesn't support\n             # selecting from the updating table (e.g. MySQL).\n             idents = []\n+            related_ids = collections.defaultdict(list)\n             for rows in query.get_compiler(self.using).execute_sql(MULTI):\n                 idents.extend(r[0] for r in rows)\n+                for parent, index in related_ids_index:\n+                    related_ids[parent].extend(r[index] for r in rows)\n             self.query.add_filter(\"pk__in\", idents)\n-            self.query.related_ids = idents\n+            self.query.related_ids = related_ids\n         else:\n             # The fast path. Filters and updates in one query.\n             self.query.add_filter(\"pk__in\", query)\ndiff --git a/django/db/models/sql/subqueries.py b/django/db/models/sql/subqueries.py\nindex 04063f73bcf6..d8a246d36968 100644\n--- a/django/db/models/sql/subqueries.py\n+++ b/django/db/models/sql/subqueries.py\n@@ -134,7 +134,7 @@ def get_related_updates(self):\n             query = UpdateQuery(model)\n             query.values = values\n             if self.related_ids is not None:\n-                query.add_filter(\"pk__in\", self.related_ids)\n+                query.add_filter(\"pk__in\", self.related_ids[model])\n             result.append(query)\n         return result\n \ndiff --git a/tests/model_inheritance_regress/tests.py b/tests/model_inheritance_regress/tests.py\nindex 6c593d4521ed..936a55568445 100644\n--- a/tests/model_inheritance_regress/tests.py\n+++ b/tests/model_inheritance_regress/tests.py\n@@ -667,3 +667,15 @@ def test_create_new_instance_with_pk_equals_none_multi_inheritance(self):\n             Politician.objects.get(pk=c1.politician_ptr_id).title,\n             \"senator 1\",\n         )\n+\n+    def test_mti_update_parent_through_child(self):\n+        Politician.objects.create()\n+        Congressman.objects.create()\n+        Congressman.objects.update(title=\"senator 1\")\n+        self.assertEqual(Congressman.objects.get().title, \"senator 1\")\n+\n+    def test_mti_update_grand_parent_through_child(self):\n+        Politician.objects.create()\n+        Senator.objects.create()\n+        Senator.objects.update(title=\"senator 1\")\n+        self.assertEqual(Senator.objects.get().title, \"senator 1\")\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15563"}