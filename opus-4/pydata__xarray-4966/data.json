{"instance_id": "pydata__xarray-4966", "score": "C", "diff": "diff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 00000000..abd75894\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,65 @@\n+import numpy as np\n+from xarray.coding.variables import UnsignedIntegerCoder\n+from xarray.core.variable import Variable\n+\n+print(\"=\" * 60)\n+print(\"Testing UnsignedIntegerCoder with OPeNDAP hack support\")\n+print(\"=\" * 60)\n+\n+coder = UnsignedIntegerCoder()\n+\n+# Test 1: Decode unsigned data marked as signed (OPeNDAP hack)\n+print(\"\\nTest 1: Decode unsigned data marked as signed (OPeNDAP hack)\")\n+data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+attrs = {\"_Unsigned\": \"false\"}\n+var = Variable(dims=(\"x\",), data=data, attrs=attrs)\n+decoded = coder.decode(var, name=\"test1\")\n+print(f\"  Input: {data} (dtype={data.dtype})\")\n+print(f\"  Output: {decoded.data} (dtype={decoded.dtype})\")\n+print(f\"  Expected: [-128, -1, 0, 1, 2, 127] (dtype=int8)\")\n+print(f\"  Success: {np.array_equal(decoded.data, np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8))}\")\n+\n+# Test 2: Encode signed data with _Unsigned=false (OPeNDAP hack)\n+print(\"\\nTest 2: Encode signed data with _Unsigned=false (OPeNDAP hack)\")\n+data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+encoding = {\"_Unsigned\": \"false\"}\n+var = Variable(dims=(\"x\",), data=data, encoding=encoding)\n+encoded = coder.encode(var, name=\"test2\")\n+print(f\"  Input: {data} (dtype={data.dtype})\")\n+print(f\"  Output: {encoded.data} (dtype={encoded.dtype})\")\n+print(f\"  Expected: [128, 255, 0, 1, 2, 127] (dtype=uint8)\")\n+print(f\"  Success: {np.array_equal(encoded.data, np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8))}\")\n+\n+# Test 3: Decode signed data marked as unsigned (NetCDF3 convention)\n+print(\"\\nTest 3: Decode signed data marked as unsigned (NetCDF3 convention)\")\n+data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+attrs = {\"_Unsigned\": \"true\"}\n+var = Variable(dims=(\"x\",), data=data, attrs=attrs)\n+decoded = coder.decode(var, name=\"test3\")\n+print(f\"  Input: {data} (dtype={data.dtype})\")\n+print(f\"  Output: {decoded.data} (dtype={decoded.dtype})\")\n+print(f\"  Expected: [128, 255, 0, 1, 2, 127] (dtype=uint8)\")\n+print(f\"  Success: {np.array_equal(decoded.data, np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8))}\")\n+\n+# Test 4: Encode unsigned data with _Unsigned=true (NetCDF3 convention)\n+print(\"\\nTest 4: Encode unsigned data with _Unsigned=true (NetCDF3 convention)\")\n+data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+encoding = {\"_Unsigned\": \"true\"}\n+var = Variable(dims=(\"x\",), data=data, encoding=encoding)\n+encoded = coder.encode(var, name=\"test4\")\n+print(f\"  Input: {data} (dtype={data.dtype})\")\n+print(f\"  Output: {encoded.data} (dtype={encoded.dtype})\")\n+print(f\"  Expected: [-128, -1, 0, 1, 2, 127] (dtype=int8)\")\n+print(f\"  Success: {np.array_equal(encoded.data, np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8))}\")\n+\n+# Test 5: No conversion when _Unsigned is not present\n+print(\"\\nTest 5: No conversion when _Unsigned is not present\")\n+data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+var = Variable(dims=(\"x\",), data=data)\n+decoded = coder.decode(var, name=\"test5\")\n+print(f\"  Input: {data} (dtype={data.dtype})\")\n+print(f\"  Output: {decoded.data} (dtype={decoded.dtype})\")\n+print(f\"  Expected: same as input\")\n+print(f\"  Success: {np.array_equal(decoded.data, data) and decoded.dtype == data.dtype}\")\n+\n+print(\"\\n\" + \"=\" * 60)\ndiff --git a/test_encode_signed.py b/test_encode_signed.py\nnew file mode 100644\nindex 00000000..37ef80d3\n--- /dev/null\n+++ b/test_encode_signed.py\n@@ -0,0 +1,30 @@\n+import numpy as np\n+from xarray.coding.variables import UnsignedIntegerCoder\n+from xarray.core.variable import Variable\n+\n+# Test encoding signed data to unsigned for OPeNDAP\n+# We need to add support for encoding signed data with _Unsigned=false\n+\n+# Create signed data\n+data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+encoding = {\"_Unsigned\": \"false\"}\n+var = Variable(dims=(\"x\",), data=data, encoding=encoding)\n+\n+print(\"Original variable:\")\n+print(f\"  dtype: {var.dtype}\")\n+print(f\"  data: {var.data}\")\n+print(f\"  encoding: {var.encoding}\")\n+\n+# Test the encoder\n+coder = UnsignedIntegerCoder()\n+encoded = coder.encode(var, name=\"test\")\n+\n+print(\"\\nEncoded variable:\")\n+print(f\"  dtype: {encoded.dtype}\")\n+print(f\"  data: {encoded.data}\")\n+print(f\"  attrs: {encoded.attrs}\")\n+print(f\"  encoding: {encoded.encoding}\")\n+\n+# What we expect: data should be converted to unsigned\n+expected = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+print(f\"\\nExpected data: {expected}\")\ndiff --git a/test_issue_simulation.py b/test_issue_simulation.py\nnew file mode 100644\nindex 00000000..7c7f71cd\n--- /dev/null\n+++ b/test_issue_simulation.py\n@@ -0,0 +1,68 @@\n+\"\"\"Simulate the exact issue described\"\"\"\n+import numpy as np\n+import xarray as xr\n+from xarray.coding.variables import UnsignedIntegerCoder\n+from xarray.core.variable import Variable\n+from xarray.conventions import decode_cf_variable\n+\n+# Simulate what pydap would return when accessing OPeNDAP data\n+# The test data should be: -128.0, -1.0, 0.0, 1.0, 2.0, nan, 127.0\n+# But pydap returns these as unsigned: 128, 255, 0, 1, 2, nan, 127\n+\n+# Create a test variable that simulates pydap output\n+test_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+test_var = Variable(\n+    dims=(\"test\",),\n+    data=test_data,\n+    attrs={\"_Unsigned\": \"false\"}\n+)\n+\n+print(\"Before decode_cf_variable:\")\n+print(f\"  data: {test_var.data}\")\n+print(f\"  dtype: {test_var.dtype}\")\n+print(f\"  attrs: {test_var.attrs}\")\n+\n+# Decode using decode_cf_variable (which is what xarray uses internally)\n+decoded_var = decode_cf_variable(\n+    name=\"test\",\n+    var=test_var,\n+    concat_characters=True,\n+    mask_and_scale=True,\n+    decode_times=True,\n+    decode_endianness=True,\n+    stack_char_dim=True,\n+    use_cftime=None,\n+    decode_timedelta=None\n+)\n+\n+print(\"\\nAfter decode_cf_variable:\")\n+print(f\"  data: {decoded_var.data}\")\n+print(f\"  dtype: {decoded_var.dtype}\")\n+print(f\"  attrs: {decoded_var.attrs}\")\n+\n+# Check that we get the expected signed values\n+expected = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+print(f\"\\nExpected: {expected}\")\n+print(f\"Success: {np.array_equal(decoded_var.data, expected)}\")\n+\n+# Also check that the warning is gone\n+import warnings\n+warnings.simplefilter(\"error\")  # Convert warnings to errors\n+\n+try:\n+    # This should NOT raise a warning anymore\n+    decoded_var = decode_cf_variable(\n+        name=\"test\",\n+        var=test_var,\n+        concat_characters=True,\n+        mask_and_scale=True,\n+        decode_times=True,\n+        decode_endianness=True,\n+        stack_char_dim=True,\n+        use_cftime=None,\n+        decode_timedelta=None\n+    )\n+    print(\"\\nNo warning raised - Good!\")\n+except Warning as w:\n+    print(f\"\\nWarning raised: {w}\")\n+    raise\ndiff --git a/test_opendap_unsigned.py b/test_opendap_unsigned.py\nnew file mode 100644\nindex 00000000..b2b742f5\n--- /dev/null\n+++ b/test_opendap_unsigned.py\n@@ -0,0 +1,98 @@\n+\"\"\"Test for OPeNDAP unsigned/signed byte handling\"\"\"\n+\n+import numpy as np\n+import pytest\n+from xarray.coding.variables import UnsignedIntegerCoder\n+from xarray.core.variable import Variable\n+\n+\n+def test_unsigned_false_opendap_hack():\n+    \"\"\"Test decoding of unsigned data with _Unsigned=false (OPeNDAP hack)\"\"\"\n+    # Simulate what pydap returns: unsigned bytes that should be interpreted as signed\n+    coder = UnsignedIntegerCoder()\n+    \n+    # Create unsigned data that represents signed values\n+    unsigned_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+    expected_signed = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+    \n+    # Test decode\n+    var = Variable(dims=(\"x\",), data=unsigned_data, attrs={\"_Unsigned\": \"false\"})\n+    decoded = coder.decode(var, name=\"test\")\n+    \n+    assert decoded.dtype == np.int8\n+    np.testing.assert_array_equal(decoded.data, expected_signed)\n+    assert \"_Unsigned\" not in decoded.attrs  # Attribute should be consumed\n+\n+\n+def test_encode_signed_with_unsigned_false():\n+    \"\"\"Test encoding of signed data with _Unsigned=false\"\"\"\n+    coder = UnsignedIntegerCoder()\n+    \n+    # Create signed data that should be encoded as unsigned for OPeNDAP\n+    signed_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+    expected_unsigned = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+    \n+    # Test encode\n+    var = Variable(dims=(\"x\",), data=signed_data, encoding={\"_Unsigned\": \"false\"})\n+    encoded = coder.encode(var, name=\"test\")\n+    \n+    assert encoded.dtype == np.uint8\n+    np.testing.assert_array_equal(encoded.data, expected_unsigned)\n+    assert encoded.attrs.get(\"_Unsigned\") == \"false\"  # Attribute should be in attrs\n+\n+\n+def test_no_change_when_unsigned_missing():\n+    \"\"\"Test that data is unchanged when _Unsigned attribute is missing\"\"\"\n+    coder = UnsignedIntegerCoder()\n+    \n+    # Test unsigned data without _Unsigned attribute\n+    unsigned_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+    var = Variable(dims=(\"x\",), data=unsigned_data)\n+    decoded = coder.decode(var, name=\"test\")\n+    \n+    assert decoded.dtype == np.uint8\n+    np.testing.assert_array_equal(decoded.data, unsigned_data)\n+    \n+    # Test signed data without _Unsigned attribute\n+    signed_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+    var = Variable(dims=(\"x\",), data=signed_data)\n+    decoded = coder.decode(var, name=\"test\")\n+    \n+    assert decoded.dtype == np.int8\n+    np.testing.assert_array_equal(decoded.data, signed_data)\n+\n+\n+def test_fillvalue_conversion():\n+    \"\"\"Test that _FillValue is properly converted\"\"\"\n+    coder = UnsignedIntegerCoder()\n+    \n+    # Test decode with _FillValue\n+    unsigned_data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+    var = Variable(\n+        dims=(\"x\",), \n+        data=unsigned_data, \n+        attrs={\"_Unsigned\": \"false\", \"_FillValue\": np.uint8(255)}\n+    )\n+    decoded = coder.decode(var, name=\"test\")\n+    \n+    assert decoded.attrs[\"_FillValue\"] == np.int8(-1)\n+    \n+    # Test encode with _FillValue\n+    signed_data = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+    var = Variable(\n+        dims=(\"x\",), \n+        data=signed_data, \n+        encoding={\"_Unsigned\": \"false\"},\n+        attrs={\"_FillValue\": np.int8(-1)}\n+    )\n+    encoded = coder.encode(var, name=\"test\")\n+    \n+    assert encoded.attrs[\"_FillValue\"] == np.uint8(255)\n+\n+\n+if __name__ == \"__main__\":\n+    test_unsigned_false_opendap_hack()\n+    test_encode_signed_with_unsigned_false()\n+    test_no_change_when_unsigned_missing()\n+    test_fillvalue_conversion()\n+    print(\"All tests passed!\")\ndiff --git a/test_unsigned_issue.py b/test_unsigned_issue.py\nnew file mode 100644\nindex 00000000..e9f03498\n--- /dev/null\n+++ b/test_unsigned_issue.py\n@@ -0,0 +1,31 @@\n+import xarray as xr\n+import numpy as np\n+from xarray.coding.variables import UnsignedIntegerCoder\n+from xarray.core.variable import Variable\n+\n+# Simulate what pydap returns: unsigned bytes with _Unsigned=False attribute\n+# The values [128, 255, 0, 1, 2, np.nan, 127] should be interpreted as\n+# [-128, -1, 0, 1, 2, np.nan, 127] when _Unsigned=False\n+\n+# Create a test variable like what pydap would return\n+data = np.array([128, 255, 0, 1, 2, 127], dtype=np.uint8)\n+attrs = {\"_Unsigned\": \"false\"}\n+var = Variable(dims=(\"x\",), data=data, attrs=attrs)\n+\n+print(\"Original variable:\")\n+print(f\"  dtype: {var.dtype}\")\n+print(f\"  data: {var.data}\")\n+print(f\"  attrs: {var.attrs}\")\n+\n+# Test the current decoder\n+coder = UnsignedIntegerCoder()\n+decoded = coder.decode(var, name=\"test\")\n+\n+print(\"\\nDecoded variable:\")\n+print(f\"  dtype: {decoded.dtype}\")\n+print(f\"  data: {decoded.data}\")\n+print(f\"  attrs: {decoded.attrs}\")\n+\n+# What we expect to see:\n+expected = np.array([-128, -1, 0, 1, 2, 127], dtype=np.int8)\n+print(f\"\\nExpected data: {expected}\")\ndiff --git a/xarray/coding/variables.py b/xarray/coding/variables.py\nindex b035ff82..df026132 100644\n--- a/xarray/coding/variables.py\n+++ b/xarray/coding/variables.py\n@@ -292,13 +292,21 @@ class UnsignedIntegerCoder(VariableCoder):\n         # https://www.unidata.ucar.edu/software/netcdf/docs/BestPractices.html\n         #     \"_Unsigned = \"true\" to indicate that\n         #      integer data should be treated as unsigned\"\n-        if encoding.get(\"_Unsigned\", \"false\") == \"true\":\n+        if encoding.get(\"_Unsigned\") == \"true\":\n             pop_to(encoding, attrs, \"_Unsigned\")\n             signed_dtype = np.dtype(\"i%s\" % data.dtype.itemsize)\n             if \"_FillValue\" in attrs:\n                 new_fill = signed_dtype.type(attrs[\"_FillValue\"])\n                 attrs[\"_FillValue\"] = new_fill\n             data = duck_array_ops.around(data).astype(signed_dtype)\n+        elif encoding.get(\"_Unsigned\") == \"false\" and data.dtype.kind == \"i\":\n+            # OPeNDAP hack: encode signed data as unsigned\n+            pop_to(encoding, attrs, \"_Unsigned\")\n+            unsigned_dtype = np.dtype(\"u%s\" % data.dtype.itemsize)\n+            if \"_FillValue\" in attrs:\n+                new_fill = unsigned_dtype.type(attrs[\"_FillValue\"])\n+                attrs[\"_FillValue\"] = new_fill\n+            data = duck_array_ops.around(data).astype(unsigned_dtype)\n \n         return Variable(dims, data, attrs, encoding)\n \n@@ -309,6 +317,7 @@ class UnsignedIntegerCoder(VariableCoder):\n             unsigned = pop_to(attrs, encoding, \"_Unsigned\")\n \n             if data.dtype.kind == \"i\":\n+                # NetCDF3 convention: signed data marked as unsigned\n                 if unsigned == \"true\":\n                     unsigned_dtype = np.dtype(\"u%s\" % data.dtype.itemsize)\n                     transform = partial(np.asarray, dtype=unsigned_dtype)\n@@ -316,6 +325,15 @@ class UnsignedIntegerCoder(VariableCoder):\n                     if \"_FillValue\" in attrs:\n                         new_fill = unsigned_dtype.type(attrs[\"_FillValue\"])\n                         attrs[\"_FillValue\"] = new_fill\n+            elif data.dtype.kind == \"u\":\n+                # OPeNDAP hack: unsigned data marked as signed\n+                if unsigned == \"false\":\n+                    signed_dtype = np.dtype(\"i%s\" % data.dtype.itemsize)\n+                    transform = partial(np.asarray, dtype=signed_dtype)\n+                    data = lazy_elemwise_func(data, transform, signed_dtype)\n+                    if \"_FillValue\" in attrs:\n+                        new_fill = signed_dtype.type(attrs[\"_FillValue\"])\n+                        attrs[\"_FillValue\"] = new_fill\n             else:\n                 warnings.warn(\n                     \"variable %r has _Unsigned attribute but is not \"\n", "gold_standard_diff": "From 17c89b27fa1675a072aeaf712f43fde168cdf3b9 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Tobias=20K=C3=B6lling?= <tobias.koelling@mpimet.mpg.de>\nDate: Fri, 26 Feb 2021 12:59:58 +0100\nSubject: [PATCH 1/2] conventions: decode unsigned integers to signed if\n _Unsigned=false\n\nnetCDF3 doesn't know unsigned while OPeNDAP doesn't know signed (bytes).\nDepending on which backend source is used, the original data is stored\nwith the wrong signedness and needs to be decoded based on the _Unsigned\nattribute. While the netCDF3 variant is already implemented, this commit\nadds the symmetric case covering OPeNDAP.\n\ncloses #4954\n---\n xarray/coding/variables.py  |  8 ++++++++\n xarray/tests/test_coding.py | 28 ++++++++++++++++++++++++++++\n 2 files changed, 36 insertions(+)\n\ndiff --git a/xarray/coding/variables.py b/xarray/coding/variables.py\nindex b035ff82086..938752c4efc 100644\n--- a/xarray/coding/variables.py\n+++ b/xarray/coding/variables.py\n@@ -316,6 +316,14 @@ def decode(self, variable, name=None):\n                     if \"_FillValue\" in attrs:\n                         new_fill = unsigned_dtype.type(attrs[\"_FillValue\"])\n                         attrs[\"_FillValue\"] = new_fill\n+            elif data.dtype.kind == \"u\":\n+                if unsigned == \"false\":\n+                    signed_dtype = np.dtype(\"i%s\" % data.dtype.itemsize)\n+                    transform = partial(np.asarray, dtype=signed_dtype)\n+                    data = lazy_elemwise_func(data, transform, signed_dtype)\n+                    if \"_FillValue\" in attrs:\n+                        new_fill = signed_dtype.type(attrs[\"_FillValue\"])\n+                        attrs[\"_FillValue\"] = new_fill\n             else:\n                 warnings.warn(\n                     \"variable %r has _Unsigned attribute but is not \"\ndiff --git a/xarray/tests/test_coding.py b/xarray/tests/test_coding.py\nindex e0df7782aa7..839f2fd1f2e 100644\n--- a/xarray/tests/test_coding.py\n+++ b/xarray/tests/test_coding.py\n@@ -117,3 +117,31 @@ def test_scaling_offset_as_list(scale_factor, add_offset):\n     encoded = coder.encode(original)\n     roundtripped = coder.decode(encoded)\n     assert_allclose(original, roundtripped)\n+\n+\n+@pytest.mark.parametrize(\"bits\", [1, 2, 4, 8])\n+def test_decode_unsigned_from_signed(bits):\n+    unsigned_dtype = np.dtype(f\"u{bits}\")\n+    signed_dtype = np.dtype(f\"i{bits}\")\n+    original_values = np.array([np.iinfo(unsigned_dtype).max], dtype=unsigned_dtype)\n+    encoded = xr.Variable(\n+        (\"x\",), original_values.astype(signed_dtype), attrs={\"_Unsigned\": \"true\"}\n+    )\n+    coder = variables.UnsignedIntegerCoder()\n+    decoded = coder.decode(encoded)\n+    assert decoded.dtype == unsigned_dtype\n+    assert decoded.values == original_values\n+\n+\n+@pytest.mark.parametrize(\"bits\", [1, 2, 4, 8])\n+def test_decode_signed_from_unsigned(bits):\n+    unsigned_dtype = np.dtype(f\"u{bits}\")\n+    signed_dtype = np.dtype(f\"i{bits}\")\n+    original_values = np.array([-1], dtype=signed_dtype)\n+    encoded = xr.Variable(\n+        (\"x\",), original_values.astype(unsigned_dtype), attrs={\"_Unsigned\": \"false\"}\n+    )\n+    coder = variables.UnsignedIntegerCoder()\n+    decoded = coder.decode(encoded)\n+    assert decoded.dtype == signed_dtype\n+    assert decoded.values == original_values\n\nFrom 76176f2eb456f07f1f1866b204af282e2caafc57 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Tobias=20K=C3=B6lling?= <tobias.koelling@mpimet.mpg.de>\nDate: Fri, 26 Feb 2021 13:21:29 +0100\nSubject: [PATCH 2/2] whats-new.rst: added _Unsigned = \"false\"\n\n---\n doc/whats-new.rst | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\ndiff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex ef7f5b43fdd..38fcdb471ac 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -14,6 +14,15 @@ What's New\n \n     np.random.seed(123456)\n \n+.. _whats-new.unreleased:\n+\n+unreleased\n+----------\n+\n+Bug fixes\n+~~~~~~~~~\n+- Decode values as signed if attribute `_Unsigned = \"false\"` (:issue:`4954`)\n+  By `Tobias K\u00f6lling <https://github.com/d70-t>`_.\n \n .. _whats-new.0.17.0:\n \n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/4966"}