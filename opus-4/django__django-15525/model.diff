diff --git a/django/core/serializers/base.py b/django/core/serializers/base.py
index da85cb4b92..a53789b578 100644
--- a/django/core/serializers/base.py
+++ b/django/core/serializers/base.py
@@ -336,7 +336,11 @@ def build_instance(Model, data, db):
         and hasattr(default_manager, "get_by_natural_key")
         and hasattr(Model, "natural_key")
     ):
-        natural_key = Model(**data).natural_key()
+        # Create a temporary instance for computing the natural key
+        # Set the database so that foreign key lookups use the correct database
+        temp_instance = Model(**data)
+        temp_instance._state.db = db
+        natural_key = temp_instance.natural_key()
         try:
             data[Model._meta.pk.attname] = Model._meta.pk.to_python(
                 default_manager.db_manager(db).get_by_natural_key(*natural_key).pk
diff --git a/test_loaddata_natural_keys.py b/test_loaddata_natural_keys.py
new file mode 100644
index 0000000000..4c26f6b245
--- /dev/null
+++ b/test_loaddata_natural_keys.py
@@ -0,0 +1,81 @@
+from django.db import models
+from django.test import TestCase, TransactionTestCase
+from django.core import serializers
+from django.core.management import call_command
+from io import StringIO
+import json
+
+
+class AuthorManager(models.Manager):
+    def get_by_natural_key(self, name):
+        return self.get(name=name)
+
+
+class Author(models.Model):
+    name = models.CharField(max_length=255, unique=True)
+    
+    objects = AuthorManager()
+    
+    def natural_key(self):
+        return (self.name,)
+    
+    class Meta:
+        app_label = 'test_loaddata'
+
+
+class BookManager(models.Manager):
+    def get_by_natural_key(self, title, author):
+        return self.get(title=title, author__name=author)
+
+
+class Book(models.Model):
+    title = models.CharField(max_length=255)
+    author = models.ForeignKey(Author, models.CASCADE, related_name="books")
+    
+    objects = BookManager()
+    
+    def natural_key(self):
+        return (self.title,) + self.author.natural_key()
+    
+    natural_key.dependencies = ["test_loaddata.Author"]
+    
+    class Meta:
+        app_label = 'test_loaddata'
+        unique_together = [["title", "author"]]
+
+
+class LoadDataNaturalKeysTest(TransactionTestCase):
+    databases = {'default', 'other'}
+    
+    def test_loaddata_with_natural_keys_on_non_default_db(self):
+        # Create test data
+        data = [
+            {
+                "model": "test_loaddata.author",
+                "fields": {
+                    "name": "JR Tolkien"
+                }
+            },
+            {
+                "model": "test_loaddata.book",
+                "fields": {
+                    "title": "The Ring",
+                    "author": ["JR Tolkien"]
+                }
+            }
+        ]
+        
+        json_data = json.dumps(data)
+        
+        # Load data into 'other' database
+        out = StringIO()
+        call_command('loaddata', '-', format='json', database='other', 
+                     stdin=StringIO(json_data), stdout=out)
+        
+        # Verify data was loaded correctly
+        from django.db import connections
+        with connections['other'].cursor() as cursor:
+            cursor.execute("SELECT COUNT(*) FROM test_loaddata_author")
+            self.assertEqual(cursor.fetchone()[0], 1)
+            cursor.execute("SELECT COUNT(*) FROM test_loaddata_book")
+            self.assertEqual(cursor.fetchone()[0], 1)
diff --git a/test_natural_key_fix.py b/test_natural_key_fix.py
new file mode 100644
index 0000000000..ed45ec0e75
--- /dev/null
+++ b/test_natural_key_fix.py
@@ -0,0 +1,119 @@
+"""
+Test script to verify the natural key foreign key fix
+"""
+import os
+import sys
+import django
+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'
+
+# Add the tests directory to the path
+sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'tests'))
+
+import django
+django.setup()
+
+from django.test import TransactionTestCase
+from django.db import models, connections
+from django.core import serializers
+import json
+from io import StringIO
+
+
+class AuthorManager(models.Manager):
+    def get_by_natural_key(self, name):
+        return self.get(name=name)
+
+
+class Author(models.Model):
+    name = models.CharField(max_length=255, unique=True)
+    
+    objects = AuthorManager()
+    
+    def natural_key(self):
+        return (self.name,)
+    
+    class Meta:
+        app_label = 'fixtures'
+
+
+class BookManager(models.Manager):
+    def get_by_natural_key(self, title, author):
+        return self.get(title=title, author__name=author)
+
+
+class Book(models.Model):
+    title = models.CharField(max_length=255)
+    author = models.ForeignKey(Author, models.CASCADE, related_name="books")
+    
+    objects = BookManager()
+    
+    def natural_key(self):
+        return (self.title,) + self.author.natural_key()
+    
+    natural_key.dependencies = ["fixtures.Author"]
+    
+    class Meta:
+        app_label = 'fixtures'
+        unique_together = [["title", "author"]]
+
+
+# Create tables in both databases
+print("Creating tables...")
+with connections['default'].schema_editor() as editor:
+    editor.create_model(Author)
+    editor.create_model(Book)
+    
+with connections['other'].schema_editor() as editor:
+    editor.create_model(Author)
+    editor.create_model(Book)
+
+# Test data
+data = [
+    {
+        "model": "fixtures.author",
+        "fields": {
+            "name": "JR Tolkien"
+        }
+    },
+    {
+        "model": "fixtures.book", 
+        "fields": {
+            "title": "The Ring",
+            "author": ["JR Tolkien"]
+        }
+    }
+]
+
+json_data = json.dumps(data)
+
+print("\nTesting loaddata with natural keys on non-default database...")
+try:
+    # This should work now with our fix
+    objs = list(serializers.deserialize("json", json_data, using="other"))
+    print(f"✓ Successfully deserialized {len(objs)} objects")
+    
+    for obj in objs:
+        obj.save()
+    print("✓ Successfully saved objects to 'other' database")
+    
+    # Verify data was saved to the correct database
+    authors_in_other = Author.objects.using('other').count()
+    books_in_other = Book.objects.using('other').count()
+    print(f"✓ Verified: {authors_in_other} authors and {books_in_other} books in 'other' database")
+    
+    # Ensure nothing was saved to default database
+    authors_in_default = Author.objects.using('default').count()
+    books_in_default = Book.objects.using('default').count()
+    print(f"✓ Verified: {authors_in_default} authors and {books_in_default} books in 'default' database (should be 0)")
+    
+    print("\n✅ TEST PASSED: Natural keys with foreign keys now work correctly on non-default databases!")
+    
+except Exception as e:
+    print(f"\n❌ TEST FAILED: {type(e).__name__}: {e}")
+    import traceback
+    traceback.print_exc()
+
+# Clean up
+print("\nCleaning up...")
+Author.objects.using('other').all().delete()
+Book.objects.using('other').all().delete()
diff --git a/test_natural_key_fk_fix.py b/test_natural_key_fk_fix.py
new file mode 100644
index 0000000000..670e3a1c22
--- /dev/null
+++ b/test_natural_key_fk_fix.py
@@ -0,0 +1,122 @@
+#!/usr/bin/env python
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        },
+        'other': {
+            'ENGINE': 'django.db.backends.sqlite3', 
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+from django.db import models, connections
+from django.core import serializers
+from io import StringIO
+import json
+
+
+class AuthorManager(models.Manager):
+    def get_by_natural_key(self, name):
+        return self.get(name=name)
+
+
+class Author(models.Model):
+    name = models.CharField(max_length=255, unique=True)
+    
+    objects = AuthorManager()
+    
+    def natural_key(self):
+        return (self.name,)
+    
+    class Meta:
+        app_label = 'testapp'
+        db_table = 'testapp_author'
+
+
+class BookManager(models.Manager):
+    def get_by_natural_key(self, title, author):
+        return self.get(title=title, author__name=author)
+
+
+class Book(models.Model):
+    title = models.CharField(max_length=255)
+    author = models.ForeignKey(Author, models.CASCADE, related_name="books")
+    
+    objects = BookManager()
+    
+    def natural_key(self):
+        return (self.title,) + self.author.natural_key()
+    
+    natural_key.dependencies = ["testapp.Author"]
+    
+    class Meta:
+        app_label = 'testapp'
+        db_table = 'testapp_book'
+        unique_together = [["title", "author"]]
+
+
+# Create tables
+with connections['default'].schema_editor() as editor:
+    editor.create_model(Author)
+    editor.create_model(Book)
+
+with connections['other'].schema_editor() as editor:
+    editor.create_model(Author)
+    editor.create_model(Book)
+
+# Test data
+data = [
+    {
+        "model": "testapp.author",
+        "fields": {
+            "name": "JR Tolkien"
+        }
+    },
+    {
+        "model": "testapp.book", 
+        "fields": {
+            "title": "The Ring",
+            "author": ["JR Tolkien"]
+        }
+    }
+]
+
+json_data = json.dumps(data)
+
+print("Testing loaddata with natural keys on non-default database...")
+try:
+    # This should fail with the current implementation
+    objs = list(serializers.deserialize("json", json_data, using="other"))
+    print(f"Deserialized {len(objs)} objects")
+    for obj in objs:
+        obj.save()
+    print("SUCCESS: Data loaded into 'other' database")
+    
+    # Verify
+    with connections['other'].cursor() as cursor:
+        cursor.execute("SELECT COUNT(*) FROM testapp_author")
+        print(f"Authors in 'other' DB: {cursor.fetchone()[0]}")
+        cursor.execute("SELECT COUNT(*) FROM testapp_book") 
+        print(f"Books in 'other' DB: {cursor.fetchone()[0]}")
+        
+except Exception as e:
+    print(f"FAILED with error: {type(e).__name__}: {e}")
+    import traceback
+    traceback.print_exc()
diff --git a/test_natural_key_fk_nondefault_db.py b/test_natural_key_fk_nondefault_db.py
new file mode 100644
index 0000000000..02c6892762
--- /dev/null
+++ b/test_natural_key_fk_nondefault_db.py
@@ -0,0 +1,136 @@
+"""
+Test to verify natural keys with foreign keys work on non-default databases
+"""
+import os
+import django
+from django.test import TransactionTestCase
+from django.db import models
+from django.core import serializers
+import json
+
+
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')
+django.setup()
+
+
+class NaturalKeyFKTests(TransactionTestCase):
+    databases = {'default', 'other'}
+    
+    def setUp(self):
+        # Define models dynamically for the test
+        class AuthorManager(models.Manager):
+            def get_by_natural_key(self, name):
+                return self.get(name=name)
+
+        class Author(models.Model):
+            name = models.CharField(max_length=255, unique=True)
+            
+            objects = AuthorManager()
+            
+            def natural_key(self):
+                return (self.name,)
+            
+            class Meta:
+                app_label = 'fixtures'
+                db_table = 'test_nk_author'
+
+        class BookManager(models.Manager):
+            def get_by_natural_key(self, title, author):
+                return self.get(title=title, author__name=author)
+
+        class Book(models.Model):
+            title = models.CharField(max_length=255)
+            author = models.ForeignKey(Author, models.CASCADE, related_name="test_books")
+            
+            objects = BookManager()
+            
+            def natural_key(self):
+                # This is the problematic case - natural key accesses foreign key
+                return (self.title,) + self.author.natural_key()
+            
+            natural_key.dependencies = ["fixtures.Author"]
+            
+            class Meta:
+                app_label = 'fixtures'
+                db_table = 'test_nk_book'
+                unique_together = [["title", "author"]]
+
+        self.Author = Author
+        self.Book = Book
+        
+        # Create tables
+        from django.db import connections
+        with connections['default'].schema_editor() as editor:
+            editor.create_model(Author)
+            editor.create_model(Book)
+            
+        with connections['other'].schema_editor() as editor:
+            editor.create_model(Author)
+            editor.create_model(Book)
+
+    def tearDown(self):
+        # Clean up tables
+        from django.db import connections
+        with connections['default'].schema_editor() as editor:
+            editor.delete_model(self.Book)
+            editor.delete_model(self.Author)
+            
+        with connections['other'].schema_editor() as editor:
+            editor.delete_model(self.Book)
+            editor.delete_model(self.Author)
+
+    def test_natural_key_with_fk_on_non_default_db(self):
+        """Test that natural keys that access foreign keys work on non-default databases"""
+        # Test data with natural keys
+        data = [
+            {
+                "model": "fixtures.author",
+                "fields": {
+                    "name": "JR Tolkien"
+                }
+            },
+            {
+                "model": "fixtures.book",
+                "fields": {
+                    "title": "The Lord of the Rings",
+                    "author": ["JR Tolkien"]  # Natural key reference
+                }
+            }
+        ]
+        
+        json_data = json.dumps(data)
+        
+        # Deserialize and save to 'other' database
+        # This should work with our fix (previously would fail with DoesNotExist)
+        objs = list(serializers.deserialize("json", json_data, using="other"))
+        
+        # Save objects
+        for obj in objs:
+            obj.save()
+        
+        # Verify data was saved to correct database
+        self.assertEqual(self.Author.objects.using('other').count(), 1)
+        self.assertEqual(self.Book.objects.using('other').count(), 1)
+        
+        # Verify correct relationships
+        book = self.Book.objects.using('other').get(title="The Lord of the Rings")
+        self.assertEqual(book.author.name, "JR Tolkien")
+        
+        # Ensure nothing was saved to default database
+        self.assertEqual(self.Author.objects.using('default').count(), 0)
+        self.assertEqual(self.Book.objects.using('default').count(), 0)
+
+
+if __name__ == '__main__':
+    # Run the test
+    test = NaturalKeyFKTests()
+    test.setUp()
+    try:
+        test.test_natural_key_with_fk_on_non_default_db()
+        print("✅ TEST PASSED: Natural keys with foreign keys work correctly on non-default databases!")
+    except Exception as e:
+        print(f"❌ TEST FAILED: {type(e).__name__}: {e}")
+        import traceback
+        traceback.print_exc()
+    finally:
+        test.tearDown()
