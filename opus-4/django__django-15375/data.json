{"instance_id": "django__django-15375", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex e3fdea6f3a..56aea0d47f 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -480,6 +480,8 @@ class Query(BaseExpression):\n                     annotation_select_mask.remove(alias)\n                 # Make sure the annotation_select wont use cached results.\n                 inner_query.set_annotation_mask(inner_query.annotation_select_mask)\n+            # Set the annotation mask for the outer query to include all annotations\n+            outer_query.set_annotation_mask(outer_query.annotations.keys())\n             if inner_query.select == () and not inner_query.default_cols and not inner_query.annotation_select_mask:\n                 # In case of Model.objects[0:3].count(), there would be no\n                 # field selected in the inner query, yet we must use a subquery.\ndiff --git a/test_aggregate_default.py b/test_aggregate_default.py\nnew file mode 100644\nindex 0000000000..70552ddd5a\n--- /dev/null\n+++ b/test_aggregate_default.py\n@@ -0,0 +1,84 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test model\n+from django.db import models\n+from django.db.models import F, Sum\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Book)\n+\n+# Create some test data\n+Book.objects.create(title=\"Book 1\")\n+Book.objects.create(title=\"Book 2\")\n+Book.objects.create(title=\"Book 3\")\n+\n+print(\"Testing aggregate with default after annotate...\")\n+\n+# This should work (without default)\n+try:\n+    result = Book.objects.annotate(idx=F(\"id\")).aggregate(Sum(\"id\"))\n+    print(f\"\u2713 Without default: {result}\")\n+except Exception as e:\n+    print(f\"\u2717 Without default failed: {e}\")\n+\n+# This should fail (with default)\n+try:\n+    result = Book.objects.annotate(idx=F(\"id\")).aggregate(Sum(\"id\", default=0))\n+    print(f\"\u2713 With default: {result}\")\n+except Exception as e:\n+    print(f\"\u2717 With default failed: {e}\")\n+\n+# Let's also check the SQL being generated\n+from django.db import connection\n+connection.queries_log.clear()\n+\n+# Get the queryset\n+qs = Book.objects.annotate(idx=F(\"id\"))\n+# Try to get the SQL for the aggregate with default\n+try:\n+    from django.db.models.sql.query import Query\n+    from django.db.models import Sum\n+    \n+    # Create a clone of the query\n+    query = qs.query.chain()\n+    query.add_annotation(Sum(\"id\", default=0), alias=\"id__sum\", is_summary=True)\n+    \n+    # Get the compiler\n+    compiler = query.get_compiler(using='default')\n+    sql, params = compiler.as_sql()\n+    print(f\"\\nGenerated SQL: {sql}\")\n+    print(f\"Params: {params}\")\n+except Exception as e:\n+    print(f\"\\nError generating SQL: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_debug_fix.py b/test_debug_fix.py\nnew file mode 100644\nindex 0000000000..d62bab6462\n--- /dev/null\n+++ b/test_debug_fix.py\n@@ -0,0 +1,57 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test model\n+from django.db import models\n+from django.db.models import F, Sum\n+from django.db.models.sql.query import Query\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Book)\n+\n+# Create some test data\n+Book.objects.create(title=\"Book 1\")\n+Book.objects.create(title=\"Book 2\")\n+Book.objects.create(title=\"Book 3\")\n+\n+# Let's trace the get_aggregation code path\n+print(\"Tracing get_aggregation()...\")\n+\n+qs = Book.objects.annotate(idx=F(\"id\"))\n+\n+# Manually recreate what happens in aggregate()\n+query = qs.query.chain()\n+query.add_annotation(Sum(\"id\", default=0), alias=\"id__sum\", is_summary=True)\n+\n+# Now let's call get_aggregation\n+result = query.get_aggregation('default', {'id__sum': Sum(\"id\", default=0)})\n+print(f\"Result: {result}\")\ndiff --git a/test_debug_fix2.py b/test_debug_fix2.py\nnew file mode 100644\nindex 0000000000..23b3d8bf78\n--- /dev/null\n+++ b/test_debug_fix2.py\n@@ -0,0 +1,90 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test model\n+from django.db import models\n+from django.db.models import F, Sum\n+from django.db.models.sql.query import Query\n+from django.db.models.sql.subqueries import AggregateQuery\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Book)\n+\n+# Create some test data\n+Book.objects.create(title=\"Book 1\")\n+Book.objects.create(title=\"Book 2\")\n+Book.objects.create(title=\"Book 3\")\n+\n+# Let's debug what happens when outer_query.annotations is populated\n+print(\"Debugging annotation mask...\")\n+\n+qs = Book.objects.annotate(idx=F(\"id\"))\n+query = qs.query.chain()\n+query.add_annotation(Sum(\"id\", default=0), alias=\"id__sum\", is_summary=True)\n+\n+# Trace the same steps as in get_aggregation\n+inner_query = query.clone()\n+inner_query.subquery = True\n+outer_query = AggregateQuery(Book, inner_query)\n+\n+# Print state before\n+print(f\"Before: outer_query.annotations = {outer_query.annotations}\")\n+print(f\"Before: outer_query.annotation_select_mask = {outer_query.annotation_select_mask}\")\n+\n+# Simulate the loop\n+relabels = {t: 'subquery' for t in inner_query.alias_map}\n+relabels[None] = 'subquery'\n+\n+for alias, expression in list(inner_query.annotation_select.items()):\n+    annotation_select_mask = inner_query.annotation_select_mask\n+    if expression.is_summary:\n+        expression, col_cnt = inner_query.rewrite_cols(expression, 0)\n+        outer_query.annotations[alias] = expression.relabeled_clone(relabels)\n+        print(f\"Added {alias} to outer_query.annotations\")\n+\n+# Apply our fix\n+outer_query.set_annotation_mask(outer_query.annotations.keys())\n+\n+print(f\"\\nAfter fix: outer_query.annotations = {outer_query.annotations}\")\n+print(f\"After fix: outer_query.annotation_select_mask = {outer_query.annotation_select_mask}\")\n+print(f\"After fix: outer_query.annotation_select = {outer_query.annotation_select}\")\n+\n+# Now test the SQL generation\n+compiler = outer_query.get_compiler(using='default')\n+try:\n+    sql, params = compiler.as_sql()\n+    print(f\"\\nSQL: {sql}\")\n+    print(f\"Params: {params}\")\n+except Exception as e:\n+    print(f\"\\nError: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_debug_fix3.py b/test_debug_fix3.py\nnew file mode 100644\nindex 0000000000..0398777636\n--- /dev/null\n+++ b/test_debug_fix3.py\n@@ -0,0 +1,65 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test model\n+from django.db import models\n+from django.db.models import F, Sum\n+from django.db.models.sql.query import Query\n+from django.db.models.sql.subqueries import AggregateQuery\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Book)\n+\n+# Create some test data\n+Book.objects.create(title=\"Book 1\")\n+Book.objects.create(title=\"Book 2\")\n+Book.objects.create(title=\"Book 3\")\n+\n+# Let's debug what's going on with the annotations\n+print(\"Debugging is_summary...\")\n+\n+qs = Book.objects.annotate(idx=F(\"id\"))\n+query = qs.query.chain()\n+query.add_annotation(Sum(\"id\", default=0), alias=\"id__sum\", is_summary=True)\n+\n+# Check annotation details\n+print(f\"query.annotations = {query.annotations}\")\n+for alias, expr in query.annotations.items():\n+    print(f\"  {alias}: {expr}, is_summary={getattr(expr, 'is_summary', 'NO ATTR')}\")\n+\n+# Trace the same steps as in get_aggregation\n+inner_query = query.clone()\n+inner_query.subquery = True\n+\n+print(f\"\\ninner_query.annotation_select = {inner_query.annotation_select}\")\n+for alias, expr in inner_query.annotation_select.items():\n+    print(f\"  {alias}: {expr}, is_summary={getattr(expr, 'is_summary', 'NO ATTR')}\")\ndiff --git a/test_debug_sql.py b/test_debug_sql.py\nnew file mode 100644\nindex 0000000000..85b8ed25a2\n--- /dev/null\n+++ b/test_debug_sql.py\n@@ -0,0 +1,89 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test model\n+from django.db import models\n+from django.db.models import F, Sum\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Book)\n+\n+# Create some test data\n+Book.objects.create(title=\"Book 1\")\n+Book.objects.create(title=\"Book 2\")\n+Book.objects.create(title=\"Book 3\")\n+\n+# Let's debug the SQL generation step by step\n+print(\"Debugging SQL generation...\")\n+\n+from django.db.models.sql.subqueries import AggregateQuery\n+from django.db.models.sql.compiler import SQLAggregateCompiler\n+\n+# Get the queryset with annotation\n+qs = Book.objects.annotate(idx=F(\"id\"))\n+\n+# Create the aggregate query as done in get_aggregation\n+query = qs.query.chain()\n+query.add_annotation(Sum(\"id\", default=0), alias=\"id__sum\", is_summary=True)\n+\n+# Check what happens when it creates the subquery\n+inner_query = query.clone()\n+inner_query.subquery = True\n+outer_query = AggregateQuery(Book, inner_query)\n+\n+# Check the annotations\n+print(f\"outer_query.annotation_select: {outer_query.annotation_select}\")\n+print(f\"inner_query.annotation_select: {inner_query.annotation_select}\")\n+\n+# Let's trace what's happening in the compiler\n+compiler = outer_query.get_compiler(using='default')\n+print(f\"compiler type: {type(compiler)}\")\n+\n+# Look at the SQL generation\n+try:\n+    sql, params = compiler.as_sql()\n+    print(f\"SQL: {sql}\")\n+    print(f\"Params: {params}\")\n+except Exception as e:\n+    print(f\"Error in as_sql: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+    \n+# Let's check what the annotation looks like after resolve_expression\n+from django.db.models import Sum\n+from django.db.models.functions.comparison import Coalesce\n+\n+sum_expr = Sum(\"id\", default=0)\n+resolved_expr = sum_expr.resolve_expression(query)\n+print(f\"\\nOriginal expression: {sum_expr}\")\n+print(f\"Resolved expression: {resolved_expr}\")\n+print(f\"Is it a Coalesce? {isinstance(resolved_expr, Coalesce)}\")\n", "gold_standard_diff": "From ff15eb918db00a5fa64b98578bcd3db85a535b1f Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Fri, 28 Jan 2022 15:27:23 +0100\nSubject: [PATCH] Fixed #33468 -- Fixed QuerySet.aggregate() after annotate()\n crash on aggregates with default.\n\nThanks Adam Johnson for the report.\n\nRegression in 501a8db46595b2d5b99c1d3b1146a832f43cdf1c.\n---\n django/db/models/aggregates.py |  4 +++-\n docs/releases/4.0.2.txt        |  4 ++++\n tests/aggregation/tests.py     | 12 ++++++++++++\n 3 files changed, 19 insertions(+), 1 deletion(-)\n\ndiff --git a/django/db/models/aggregates.py b/django/db/models/aggregates.py\nindex 8c4eae79068f..bc31b48d8d9c 100644\n--- a/django/db/models/aggregates.py\n+++ b/django/db/models/aggregates.py\n@@ -65,7 +65,9 @@ def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize\n         if hasattr(default, 'resolve_expression'):\n             default = default.resolve_expression(query, allow_joins, reuse, summarize)\n         c.default = None  # Reset the default argument before wrapping.\n-        return Coalesce(c, default, output_field=c._output_field_or_none)\n+        coalesce = Coalesce(c, default, output_field=c._output_field_or_none)\n+        coalesce.is_summary = c.is_summary\n+        return coalesce\n \n     @property\n     def default_alias(self):\ndiff --git a/docs/releases/4.0.2.txt b/docs/releases/4.0.2.txt\nindex af0f728c546d..b1ac91f7e923 100644\n--- a/docs/releases/4.0.2.txt\n+++ b/docs/releases/4.0.2.txt\n@@ -32,3 +32,7 @@ Bugfixes\n * Fixed a duplicate operation regression in Django 4.0 that caused a migration\n   crash when altering a primary key type for a concrete parent model referenced\n   by a foreign key (:ticket:`33462`).\n+\n+* Fixed a bug in Django 4.0 that caused a crash of ``QuerySet.aggregate()``\n+  after ``annotate()`` on an aggregate function with a\n+  :ref:`default <aggregate-default>` (:ticket:`33468`).\ndiff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 87ae945a7ebb..5c9aa5d53467 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1630,6 +1630,18 @@ def test_aggregation_default_passed_another_aggregate(self):\n         )\n         self.assertAlmostEqual(result['value'], Decimal('61.72'), places=2)\n \n+    def test_aggregation_default_after_annotation(self):\n+        result = Publisher.objects.annotate(\n+            double_num_awards=F('num_awards') * 2,\n+        ).aggregate(value=Sum('double_num_awards', default=0))\n+        self.assertEqual(result['value'], 40)\n+\n+    def test_aggregation_default_not_in_aggregate(self):\n+        result = Publisher.objects.annotate(\n+            avg_rating=Avg('book__rating', default=2.5),\n+        ).aggregate(Sum('num_awards'))\n+        self.assertEqual(result['num_awards__sum'], 20)\n+\n     def test_exists_none_with_aggregate(self):\n         qs = Book.objects.all().annotate(\n             count=Count('id'),\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15375"}