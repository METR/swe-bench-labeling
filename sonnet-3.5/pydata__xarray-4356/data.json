{"instance_id": "pydata__xarray-4356", "score": "C", "diff": "diff --git a/test_sum_min_count.py b/test_sum_min_count.py\nnew file mode 100644\nindex 00000000..f6c6b541\n--- /dev/null\n+++ b/test_sum_min_count.py\n@@ -0,0 +1,17 @@\n+import xarray as xr\n+import numpy as np\n+\n+da = xr.DataArray([[1., 2, 3], [4, 5, 6]])\n+result = da.sum([\"dim_0\", \"dim_1\"], min_count=1)\n+print(\"Result:\", result.values)\n+\n+# Test with some NaN values\n+da_with_nan = xr.DataArray([[1., np.nan, 3], [np.nan, 5, np.nan]])\n+result_with_nan = da_with_nan.sum([\"dim_0\", \"dim_1\"], min_count=1)\n+print(\"Result with NaN:\", result_with_nan.values)\n+\n+# Test with all NaN values\n+da_all_nan = xr.DataArray([[np.nan, np.nan], [np.nan, np.nan]])\n+result_all_nan = da_all_nan.sum([\"dim_0\", \"dim_1\"], min_count=1)\n+print(\"Result with all NaN:\", result_all_nan.values)\n+\ndiff --git a/xarray/core/nanops.py b/xarray/core/nanops.py\nindex 41c8d258..488f37df 100644\n--- a/xarray/core/nanops.py\n+++ b/xarray/core/nanops.py\n@@ -26,13 +26,14 @@ def _maybe_null_out(result, axis, mask, min_count=1):\n     \"\"\"\n     xarray version of pandas.core.nanops._maybe_null_out\n     \"\"\"\n-    if hasattr(axis, \"__len__\"):  # if tuple or list\n-        raise ValueError(\n-            \"min_count is not available for reduction with more than one dimensions.\"\n-        )\n-\n     if axis is not None and getattr(result, \"ndim\", False):\n-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0\n+        if hasattr(axis, \"__len__\"):  # if tuple or list\n+            axis_prod = np.prod([mask.shape[ax] for ax in axis])\n+            axis_sum = mask.sum(axis=axis)\n+        else:\n+            axis_prod = mask.shape[axis]\n+            axis_sum = mask.sum(axis=axis)\n+        null_mask = (axis_prod - axis_sum - min_count) < 0\n         if null_mask.any():\n             dtype, fill_value = dtypes.maybe_promote(result.dtype)\n             result = result.astype(dtype)\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 2652af5d9fd..901e2f7f281 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -28,8 +28,11 @@ New Features\n - Support multiple outputs in :py:func:`xarray.apply_ufunc` when using ``dask='parallelized'``. (:issue:`1815`, :pull:`4060`)\n   By `Kai M\u00fchlbauer <https://github.com/kmuehlbauer>`_.\n - :py:meth:`~xarray.DataArray.rolling` and :py:meth:`~xarray.Dataset.rolling`\n-  now accept more than 1 dimension.(:pull:`4219`)\n+  now accept more than 1 dimension. (:pull:`4219`)\n   By `Keisuke Fujii <https://github.com/fujiisoup>`_.\n+- ``min_count`` can be supplied to reductions such as ``.sum`` when specifying\n+  multiple dimension to reduce over. (:pull:`4356`) \n+  By `Maximilian Roos <https://github.com/max-sixty>`_.\n - Build ``CFTimeIndex.__repr__`` explicitly as :py:class:`pandas.Index`. Add ``calendar`` as a new\n   property for :py:class:`CFTimeIndex` and show ``calendar`` and ``length`` in\n   ``CFTimeIndex.__repr__`` (:issue:`2416`, :pull:`4092`)\ndiff --git a/xarray/core/nanops.py b/xarray/core/nanops.py\nindex 41c8d258d7a..bc7dc510817 100644\n--- a/xarray/core/nanops.py\n+++ b/xarray/core/nanops.py\n@@ -26,13 +26,9 @@ def _maybe_null_out(result, axis, mask, min_count=1):\n     \"\"\"\n     xarray version of pandas.core.nanops._maybe_null_out\n     \"\"\"\n-    if hasattr(axis, \"__len__\"):  # if tuple or list\n-        raise ValueError(\n-            \"min_count is not available for reduction with more than one dimensions.\"\n-        )\n \n     if axis is not None and getattr(result, \"ndim\", False):\n-        null_mask = (mask.shape[axis] - mask.sum(axis) - min_count) < 0\n+        null_mask = (np.take(mask.shape, axis).prod() - mask.sum(axis) - min_count) < 0\n         if null_mask.any():\n             dtype, fill_value = dtypes.maybe_promote(result.dtype)\n             result = result.astype(dtype)\ndiff --git a/xarray/tests/test_duck_array_ops.py b/xarray/tests/test_duck_array_ops.py\nindex b542dad998b..6db0b6eef87 100644\n--- a/xarray/tests/test_duck_array_ops.py\n+++ b/xarray/tests/test_duck_array_ops.py\n@@ -595,6 +595,24 @@ def test_min_count(dim_num, dtype, dask, func, aggdim):\n     assert_dask_array(actual, dask)\n \n \n+@pytest.mark.parametrize(\"dtype\", [float, int, np.float32, np.bool_])\n+@pytest.mark.parametrize(\"dask\", [False, True])\n+@pytest.mark.parametrize(\"func\", [\"sum\", \"prod\"])\n+def test_min_count_nd(dtype, dask, func):\n+    if dask and not has_dask:\n+        pytest.skip(\"requires dask\")\n+\n+    min_count = 3\n+    dim_num = 3\n+    da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)\n+    actual = getattr(da, func)(dim=[\"x\", \"y\", \"z\"], skipna=True, min_count=min_count)\n+    # Supplying all dims is equivalent to supplying `...` or `None`\n+    expected = getattr(da, func)(dim=..., skipna=True, min_count=min_count)\n+\n+    assert_allclose(actual, expected)\n+    assert_dask_array(actual, dask)\n+\n+\n @pytest.mark.parametrize(\"func\", [\"sum\", \"prod\"])\n def test_min_count_dataset(func):\n     da = construct_dataarray(2, dtype=float, contains_nan=True, dask=False)\n@@ -606,14 +624,15 @@ def test_min_count_dataset(func):\n \n @pytest.mark.parametrize(\"dtype\", [float, int, np.float32, np.bool_])\n @pytest.mark.parametrize(\"dask\", [False, True])\n+@pytest.mark.parametrize(\"skipna\", [False, True])\n @pytest.mark.parametrize(\"func\", [\"sum\", \"prod\"])\n-def test_multiple_dims(dtype, dask, func):\n+def test_multiple_dims(dtype, dask, skipna, func):\n     if dask and not has_dask:\n         pytest.skip(\"requires dask\")\n     da = construct_dataarray(3, dtype, contains_nan=True, dask=dask)\n \n-    actual = getattr(da, func)((\"x\", \"y\"))\n-    expected = getattr(getattr(da, func)(\"x\"), func)(\"y\")\n+    actual = getattr(da, func)((\"x\", \"y\"), skipna=skipna)\n+    expected = getattr(getattr(da, func)(\"x\", skipna=skipna), func)(\"y\", skipna=skipna)\n     assert_allclose(actual, expected)\n \n \n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/4356"}