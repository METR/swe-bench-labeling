{"instance_id": "django__django-11265", "score": "I", "diff": "diff --git a/debug_exclude.py b/debug_exclude.py\nnew file mode 100644\nindex 0000000000..4eef5b8540\n--- /dev/null\n+++ b/debug_exclude.py\n@@ -0,0 +1,67 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the project root to the Python path\n+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+        'tests.filtered_relation',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Now we can import models and test the issue\n+from django.db.models import FilteredRelation, Q\n+from tests.filtered_relation.models import Author, Book, Editor\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Editor)\n+    schema_editor.create_model(Book)\n+\n+# Create test data\n+Author.objects.all().delete()\n+Book.objects.all().delete()\n+Editor.objects.all().delete()\n+\n+author1 = Author.objects.create(name='Alice')\n+author2 = Author.objects.create(name='Jane')\n+editor_a = Editor.objects.create(name='a')\n+book1 = Book.objects.create(\n+    title='Poem by Alice',\n+    editor=editor_a,\n+    author=author1,\n+)\n+\n+# Test the filter\n+print(\"Testing filter:\")\n+qs_filter = Author.objects.annotate(\n+    book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+).filter(book_alice__isnull=False)\n+print(\"SQL:\", qs_filter.query)\n+print(\"Results:\", list(qs_filter))\n+\n+# Test the exclude  \n+print(\"\\nTesting exclude:\")\n+qs_exclude = Author.objects.annotate(\n+    book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+).exclude(book_alice__isnull=False)\n+print(\"SQL:\", qs_exclude.query)\n+print(\"Results:\", list(qs_exclude))\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d69c24419b..92df289303 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,9 @@ class Query(BaseExpression):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        # Copy the filtered relations and annotations so they can be resolved in the subquery\n+        query._filtered_relations = self._filtered_relations.copy()\n+        query.annotations = self.annotations.copy()\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..e84d0caad9\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,69 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the project root to the Python path\n+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+        'tests.filtered_relation',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Now we can import models and test the issue\n+from django.db.models import FilteredRelation, Q\n+from tests.filtered_relation.models import Author, Book, Editor\n+from django.db import connection\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Editor)\n+    schema_editor.create_model(Book)\n+\n+# Create test data\n+author1 = Author.objects.create(name='Alice')\n+author2 = Author.objects.create(name='Jane')\n+editor_a = Editor.objects.create(name='a')\n+book1 = Book.objects.create(\n+    title='Poem by Alice',\n+    editor=editor_a,\n+    author=author1,\n+)\n+\n+# Test the original filter (should work)\n+print(\"Testing filter (should work):\")\n+try:\n+    result = Author.objects.annotate(\n+        book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+    ).filter(book_alice__isnull=False)\n+    print(f\"Success: {list(result)}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+# Test the exclude (should fail with FieldError)\n+print(\"\\nTesting exclude (should fail):\")\n+try:\n+    result = Author.objects.annotate(\n+        book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+    ).exclude(book_alice__isnull=False)\n+    print(f\"Success: {list(result)}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex 5e85dff16c..4c86b8b7d8 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -98,6 +98,24 @@ class FilteredRelationTests(TestCase):\n             [self.author1]\n         )\n \n+    def test_with_join_exclude(self):\n+        # This test reproduces the issue where exclude doesn't work with FilteredRelation\n+        qs = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).exclude(book_alice__isnull=False)\n+        # Debug: print the SQL query\n+        print(\"\\nExclude Query SQL:\")\n+        print(str(qs.query))\n+        \n+        # Also test what filter would produce\n+        qs_filter = Author.objects.annotate(\n+            book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+        ).filter(book_alice__isnull=False)\n+        print(\"\\nFilter Query SQL:\")\n+        print(str(qs_filter.query))\n+        \n+        self.assertSequenceEqual(qs, [self.author2])\n+\n     def test_with_join_and_complex_condition(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n", "gold_standard_diff": "From 6b736dd0747dc77473f1f7b691c196ef5912d7dd Mon Sep 17 00:00:00 2001\nFrom: Rob <tienrobertnguyenn@gmail.com>\nDate: Tue, 7 May 2019 00:42:56 +1000\nSubject: [PATCH] Fixed #30349 -- Fixed QuerySet.exclude() on FilteredRelation.\n\nUsing annotated FilteredRelations raised a FieldError when coupled with\nexclude(). This is due to not passing filtered relation fields to the\nsubquery created in split_exclude(). We fixed this issue by passing the\nfiltered relation data to the newly created subquery.\n\nSecondly, in the case where an INNER JOIN is used in the excluded\nsubquery, the ORM would trim the filtered relation INNER JOIN in attempt\nto simplify the query. This will also remove the ON clause filters\ngenerated by the FilteredRelation. We added logic to not trim the INNER\nJOIN if it is from FilteredRelation.\n---\n django/db/models/sql/query.py    | 11 ++++++++---\n tests/filtered_relation/tests.py |  8 ++++++++\n 2 files changed, 16 insertions(+), 3 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d69c24419bd8..08d7faf1947c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,7 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        query._filtered_relations = self._filtered_relations\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\n@@ -2140,9 +2141,13 @@ def trim_start(self, names_with_path):\n             join_field.foreign_related_fields[0].name)\n         trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)\n         # Lets still see if we can trim the first join from the inner query\n-        # (that is, self). We can't do this for LEFT JOINs because we would\n-        # miss those rows that have nothing on the outer side.\n-        if self.alias_map[lookup_tables[trimmed_paths + 1]].join_type != LOUTER:\n+        # (that is, self). We can't do this for:\n+        # - LEFT JOINs because we would miss those rows that have nothing on\n+        #   the outer side,\n+        # - INNER JOINs from filtered relations because we would miss their\n+        #   filters.\n+        first_join = self.alias_map[lookup_tables[trimmed_paths + 1]]\n+        if first_join.join_type != LOUTER and not first_join.filtered_relation:\n             select_fields = [r[0] for r in join_field.related_fields]\n             select_alias = lookup_tables[trimmed_paths + 1]\n             self.unref_alias(lookup_tables[trimmed_paths])\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex 5e85dff16cda..52fe64dfa5fa 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -98,6 +98,14 @@ def test_with_join(self):\n             [self.author1]\n         )\n \n+    def test_with_exclude(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2],\n+        )\n+\n     def test_with_join_and_complex_condition(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11265"}