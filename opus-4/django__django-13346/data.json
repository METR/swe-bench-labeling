{"instance_id": "django__django-13346", "score": "C", "diff": "diff --git a/debug_lookups.py b/debug_lookups.py\nnew file mode 100644\nindex 0000000000..5d020eed29\n--- /dev/null\n+++ b/debug_lookups.py\n@@ -0,0 +1,67 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.db.models import lookups\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=False,\n+    )\n+    django.setup()\n+\n+# Define test model\n+class TestModel(models.Model):\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Let's check which lookups are registered on KeyTransform\n+from django.db.models.fields.json import KeyTransform\n+print(\"Registered lookups on KeyTransform:\")\n+for name, lookup in KeyTransform.get_lookups().items():\n+    print(f\"  {name}: {lookup}\")\n+\n+# Check if In is registered\n+print(f\"\\nIs 'in' lookup registered? {'in' in KeyTransform.get_lookups()}\")\n+\n+# Check what happens when we try to use __in\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(TestModel)\n+\n+TestModel.objects.create(data={'key': 0})\n+\n+# Try to understand the lookup resolution\n+qs = TestModel.objects.filter(data__key__in=[0])\n+print(\"\\nQueryset for data__key__in=[0]:\")\n+try:\n+    print(f\"Count: {qs.count()}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+    \n+# Let's trace what's happening with the query construction\n+import logging\n+logging.basicConfig(level=logging.DEBUG)\n+logger = logging.getLogger('django.db.backends')\n+logger.setLevel(logging.DEBUG)\n+\n+print(\"\\nTrying query with logging...\")\n+try:\n+    qs = TestModel.objects.filter(data__key__in=[0])\n+    list(qs)\n+except Exception as e:\n+    print(f\"Error executing query: {e}\")\ndiff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8..be6a811ba7 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -479,6 +479,43 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        # Get the base process_rhs from In lookup\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        \n+        # For MySQL, Oracle, and SQLite, we need to wrap values in JSON_EXTRACT\n+        # similar to how KeyTransformExact does it\n+        if connection.vendor == 'mysql':\n+            # MySQL requires JSON_EXTRACT for each value\n+            if self.rhs_is_direct_value():\n+                func = [\"JSON_EXTRACT(%s, '$')\"] * len(rhs_params)\n+                rhs = rhs % tuple(func)\n+        elif connection.vendor == 'oracle':\n+            # Oracle needs special handling for JSON values\n+            if self.rhs_is_direct_value():\n+                func = []\n+                new_params = []\n+                for value in rhs_params:\n+                    val = json.loads(value)\n+                    function = 'JSON_QUERY' if isinstance(val, (list, dict)) else 'JSON_VALUE'\n+                    func.append(\"%s('%s', '$.value')\" % (\n+                        function,\n+                        json.dumps({'value': val}),\n+                    ))\n+                # Replace placeholders with the JSON functions\n+                placeholders = rhs.strip('()').split(', ')\n+                rhs = '(' + ', '.join(func) + ')'\n+                rhs_params = []\n+        elif connection.vendor == 'sqlite':\n+            # SQLite also needs JSON_EXTRACT for proper comparison\n+            if self.rhs_is_direct_value():\n+                func = [\"JSON_EXTRACT(%s, '$')\" if value != 'null' else '%s' for value in rhs_params]\n+                rhs = rhs % tuple(func)\n+        \n+        return rhs, rhs_params\n+\n+\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\n@@ -494,6 +531,7 @@ KeyTransform.register_lookup(KeyTransformLt)\n KeyTransform.register_lookup(KeyTransformLte)\n KeyTransform.register_lookup(KeyTransformGt)\n KeyTransform.register_lookup(KeyTransformGte)\n+KeyTransform.register_lookup(KeyTransformIn)\n \n \n class KeyTransformFactory:\ndiff --git a/test_final_verification.py b/test_final_verification.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_json_in_different_dbs.py b/test_json_in_different_dbs.py\nnew file mode 100644\nindex 0000000000..471f35b261\n--- /dev/null\n+++ b/test_json_in_different_dbs.py\n@@ -0,0 +1,93 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+\n+# Test with different database backends\n+test_configs = [\n+    {\n+        'name': 'SQLite',\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    },\n+    # We can't easily test MySQL and Oracle without actual database servers\n+]\n+\n+for config in test_configs:\n+    print(f\"\\n{'='*50}\")\n+    print(f\"Testing with {config['name']}\")\n+    print('='*50)\n+    \n+    if settings.configured:\n+        # Reset settings\n+        settings._wrapped = None\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': config\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=False,\n+    )\n+    django.setup()\n+    \n+    # Define test model\n+    class TestModel(models.Model):\n+        data = models.JSONField()\n+        \n+        class Meta:\n+            app_label = 'test'\n+    \n+    # Create the table\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(TestModel)\n+    \n+    # Create test data\n+    TestModel.objects.create(data={'key': 0})\n+    TestModel.objects.create(data={'key': 1}) \n+    TestModel.objects.create(data={'key': 2})\n+    TestModel.objects.create(data={'other_key': 3})\n+    TestModel.objects.create(data={'key': 'string_value'})\n+    TestModel.objects.create(data={'key': [1, 2, 3]})  # Array value\n+    TestModel.objects.create(data={'key': {'nested': 'object'}})  # Object value\n+    \n+    # Test various scenarios\n+    tests = [\n+        ('data__key__in', [0], \"Single numeric value\"),\n+        ('data__key__in', [0, 1], \"Multiple numeric values\"),\n+        ('data__key__in', ['string_value'], \"String value\"),\n+        ('data__key__in', [0, 'string_value'], \"Mixed types\"),\n+        ('data__key__in', [[1, 2, 3]], \"Array value (should match the array)\"),\n+        ('data__key__in', [{'nested': 'object'}], \"Object value\"),\n+    ]\n+    \n+    for lookup, values, description in tests:\n+        filter_dict = {lookup: values}\n+        items = TestModel.objects.filter(**filter_dict)\n+        print(f\"\\n{description}: {lookup}={values}\")\n+        print(f\"  Count: {items.count()}\")\n+        \n+        # Also test exact match for comparison\n+        if len(values) == 1:\n+            exact_filter = {'data__key': values[0]}\n+            exact_items = TestModel.objects.filter(**exact_filter)\n+            print(f\"  Exact match count: {exact_items.count()}\")\n+    \n+    # Test edge cases\n+    print(\"\\n\\nEdge cases:\")\n+    \n+    # Empty list\n+    empty_list = TestModel.objects.filter(data__key__in=[])\n+    print(f\"Empty list: {empty_list.count()} (should be 0)\")\n+    \n+    # None in list (should be ignored like regular In lookup)\n+    none_list = TestModel.objects.filter(data__key__in=[0, None, 1])\n+    print(f\"List with None: {none_list.count()} (should be 2, None is ignored)\")\n+    \n+    # Cleanup\n+    TestModel.objects.all().delete()\ndiff --git a/test_json_in_lookup.py b/test_json_in_lookup.py\nnew file mode 100644\nindex 0000000000..69fbe0abd8\n--- /dev/null\n+++ b/test_json_in_lookup.py\n@@ -0,0 +1,60 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=False,\n+    )\n+    django.setup()\n+\n+# Define test model\n+class TestModel(models.Model):\n+    data = models.JSONField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(TestModel)\n+\n+# Create test data\n+TestModel.objects.create(data={'key': 0})\n+TestModel.objects.create(data={'key': 1})\n+TestModel.objects.create(data={'key': 2})\n+TestModel.objects.create(data={'other_key': 3})\n+\n+# Test the issue\n+print(\"Testing __in lookup on JSON field key transform...\")\n+first_filter = {'data__key__in': [0]}\n+first_items = TestModel.objects.filter(**first_filter)\n+print(f\"Items with data__key__in=[0]: {first_items.count()}\")\n+\n+second_filter = {'data__key': 0}\n+second_items = TestModel.objects.filter(**second_filter)\n+print(f\"Items with data__key=0: {second_items.count()}\")\n+\n+# Let's also test with multiple values\n+third_filter = {'data__key__in': [0, 1]}\n+third_items = TestModel.objects.filter(**third_filter)\n+print(f\"Items with data__key__in=[0, 1]: {third_items.count()}\")\n+\n+# Check what SQL is generated\n+print(\"\\nSQL queries:\")\n+print(\"For __in lookup:\", first_items.query)\n+print(\"For exact lookup:\", second_items.query)\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex a7648711ac..a7c8b07d9e 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -531,6 +531,77 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n+    def test_key_in(self):\n+        # Test __in lookup on key transforms\n+        objs = [\n+            NullableJSONModel.objects.create(value={'x': 0}),\n+            NullableJSONModel.objects.create(value={'x': 1}),\n+            NullableJSONModel.objects.create(value={'x': 2}),\n+            NullableJSONModel.objects.create(value={'x': 'foo'}),\n+            NullableJSONModel.objects.create(value={'y': 0}),\n+            NullableJSONModel.objects.create(value={'x': [1, 2]}),\n+            NullableJSONModel.objects.create(value={'x': {'y': 'z'}}),\n+        ]\n+        \n+        # Test with single value\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[0]),\n+            [objs[0]],\n+        )\n+        \n+        # Test with multiple numeric values\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[0, 1]).order_by('id'),\n+            [objs[0], objs[1]],\n+        )\n+        \n+        # Test with string value\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=['foo']),\n+            [objs[3]],\n+        )\n+        \n+        # Test with mixed types\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[0, 'foo']).order_by('id'),\n+            [objs[0], objs[3]],\n+        )\n+        \n+        # Test with empty list\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[]),\n+            [],\n+        )\n+        \n+        # Test with None in the list (should be ignored)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[0, None, 1]).order_by('id'),\n+            [objs[0], objs[1]],\n+        )\n+        \n+        # Test with array value\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[[1, 2]]),\n+            [objs[5]],\n+        )\n+        \n+        # Test with object value\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__x__in=[{'y': 'z'}]),\n+            [objs[6]],\n+        )\n+        \n+        # Test nested key transform with __in\n+        nested_objs = [\n+            NullableJSONModel.objects.create(value={'a': {'b': 1}}),\n+            NullableJSONModel.objects.create(value={'a': {'b': 2}}),\n+            NullableJSONModel.objects.create(value={'a': {'b': 3}}),\n+        ]\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__a__b__in=[1, 3]).order_by('id'),\n+            [nested_objs[0], nested_objs[2]],\n+        )\n+\n     def test_none_key_exclude(self):\n         obj = NullableJSONModel.objects.create(value={'j': 1})\n         if connection.vendor == 'oracle':\n", "gold_standard_diff": "From 04bbacb9b5dbe00b355d272b7d0267d771e553fe Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Mon, 24 Aug 2020 14:31:18 +0200\nSubject: [PATCH] Fixed #31936 -- Fixed __in lookup on key transforms for\n JSONField.\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThis resolves an issue on databases without a native JSONField\n(MariaDB, MySQL, SQLite, Oracle), where values must be wrapped.\n\nThanks S\u00e9bastien Pattyn for the report.\n---\n django/db/models/fields/json.py      | 25 +++++++++++++++++++++++++\n docs/releases/3.1.1.txt              |  4 ++++\n tests/model_fields/test_jsonfield.py | 19 +++++++++++++++++++\n 3 files changed, 48 insertions(+)\n\ndiff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py\nindex fafc1beee8a8..00df1ae20637 100644\n--- a/django/db/models/fields/json.py\n+++ b/django/db/models/fields/json.py\n@@ -378,6 +378,30 @@ def as_sqlite(self, compiler, connection):\n         return super().as_sql(compiler, connection)\n \n \n+class KeyTransformIn(lookups.In):\n+    def process_rhs(self, compiler, connection):\n+        rhs, rhs_params = super().process_rhs(compiler, connection)\n+        if not connection.features.has_native_json_field:\n+            func = ()\n+            if connection.vendor == 'oracle':\n+                func = []\n+                for value in rhs_params:\n+                    value = json.loads(value)\n+                    function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n+                    func.append(\"%s('%s', '$.value')\" % (\n+                        function,\n+                        json.dumps({'value': value}),\n+                    ))\n+                func = tuple(func)\n+                rhs_params = ()\n+            elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n+                func = (\"JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))\",) * len(rhs_params)\n+            elif connection.vendor in {'sqlite', 'mysql'}:\n+                func = (\"JSON_EXTRACT(%s, '$')\",) * len(rhs_params)\n+            rhs = rhs % func\n+        return rhs, rhs_params\n+\n+\n class KeyTransformExact(JSONExact):\n     def process_lhs(self, compiler, connection):\n         lhs, lhs_params = super().process_lhs(compiler, connection)\n@@ -479,6 +503,7 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual\n     pass\n \n \n+KeyTransform.register_lookup(KeyTransformIn)\n KeyTransform.register_lookup(KeyTransformExact)\n KeyTransform.register_lookup(KeyTransformIExact)\n KeyTransform.register_lookup(KeyTransformIsNull)\ndiff --git a/docs/releases/3.1.1.txt b/docs/releases/3.1.1.txt\nindex 6359f181fa39..83ff2b07d22f 100644\n--- a/docs/releases/3.1.1.txt\n+++ b/docs/releases/3.1.1.txt\n@@ -39,3 +39,7 @@ Bugfixes\n * Enforced thread sensitivity of the :class:`MiddlewareMixin.process_request()\n   <django.utils.deprecation.MiddlewareMixin>` and ``process_response()`` hooks\n   when in an async context (:ticket:`31905`).\n+\n+* Fixed ``__in`` lookup on key transforms for\n+  :class:`~django.db.models.JSONField` with MariaDB, MySQL, Oracle, and SQLite\n+  (:ticket:`31936`).\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex a7648711acda..a250827635be 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -627,6 +627,25 @@ def test_key_iexact(self):\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='BaR').exists(), True)\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists(), False)\n \n+    def test_key_in(self):\n+        tests = [\n+            ('value__c__in', [14], self.objs[3:5]),\n+            ('value__c__in', [14, 15], self.objs[3:5]),\n+            ('value__0__in', [1], [self.objs[5]]),\n+            ('value__0__in', [1, 3], [self.objs[5]]),\n+            ('value__foo__in', ['bar'], [self.objs[7]]),\n+            ('value__foo__in', ['bar', 'baz'], [self.objs[7]]),\n+            ('value__bar__in', [['foo', 'bar']], [self.objs[7]]),\n+            ('value__bar__in', [['foo', 'bar'], ['a']], [self.objs[7]]),\n+            ('value__bax__in', [{'foo': 'bar'}, {'a': 'b'}], [self.objs[7]]),\n+        ]\n+        for lookup, value, expected in tests:\n+            with self.subTest(lookup=lookup, value=value):\n+                self.assertSequenceEqual(\n+                    NullableJSONModel.objects.filter(**{lookup: value}),\n+                    expected,\n+                )\n+\n     @skipUnlessDBFeature('supports_json_field_contains')\n     def test_key_contains(self):\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__contains='ar').exists(), False)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13346"}