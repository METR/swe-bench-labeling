{"instance_id": "astropy__astropy-13977", "score": "I", "diff": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..2f8660551a 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -640,7 +640,13 @@ class Quantity(np.ndarray):\n         # input to that expected (e.g., radian for np.sin), or to get\n         # consistent units between two inputs (e.g., in np.add) --\n         # and the unit of the result (or tuple of units for nout > 1).\n-        converters, unit = converters_and_unit(function, method, *inputs)\n+        try:\n+            converters, unit = converters_and_unit(function, method, *inputs)\n+        except (TypeError, ValueError):\n+            # If there's an error in determining converters, it's likely because\n+            # we're dealing with an incompatible duck type. Return NotImplemented\n+            # to allow the other operand to handle the operation.\n+            return NotImplemented\n \n         out = kwargs.get(\"out\", None)\n         # Avoid loop back by turning any Quantity output into array views.\n@@ -667,7 +673,15 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            try:\n+                arrays.append(converter(input_) if converter else input_)\n+            except (TypeError, ValueError):\n+                # _condition_arg failed: arg could not be converted to a\n+                # form compatible with quantities. This can happen when\n+                # there is an attempt to use a duck-typed quantity which\n+                # has different units. Return NotImplemented to allow the\n+                # other argument to handle the operation.\n+                return NotImplemented\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 486d6b9b3b..1c5f74f3a1 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,5 +1,5 @@\n [build-system]\n-requires = [\"setuptools\",\n+requires = [\"setuptools==68.0.0\",\n             \"setuptools_scm>=6.2\",\n             \"wheel\",\n             \"cython==0.29.30\",\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..b3746e1576\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,85 @@\n+import numpy as np\n+import astropy.units as u\n+import dataclasses\n+\n+# First, let's test standard Quantity operations to ensure we didn't break them\n+print(\"Testing standard Quantity operations...\")\n+\n+# Test basic arithmetic\n+q1 = 1 * u.m\n+q2 = 2 * u.m\n+print(f\"Addition: {q1} + {q2} = {q1 + q2}\")\n+print(f\"Subtraction: {q2} - {q1} = {q2 - q1}\")\n+print(f\"Multiplication: {q1} * 3 = {q1 * 3}\")\n+print(f\"Division: {q2} / 2 = {q2 / 2}\")\n+\n+# Test unit conversion in arithmetic\n+q3 = 1000 * u.mm\n+print(f\"Unit conversion: {q1} + {q3} = {q1 + q3}\")\n+\n+# Test with arrays\n+arr1 = [1, 2, 3] * u.m\n+arr2 = [4, 5, 6] * u.m\n+print(f\"Array addition: {arr1} + {arr2} = {arr1 + arr2}\")\n+\n+# Test with incompatible units (should still raise error)\n+try:\n+    result = (1 * u.m) + (1 * u.s)\n+except Exception as e:\n+    print(f\"Incompatible units error (expected): {type(e).__name__}: {e}\")\n+\n+# Test with regular numpy arrays\n+arr3 = np.array([1, 2, 3])\n+q4 = 2 * u.dimensionless_unscaled\n+print(f\"Quantity with numpy array: {q4} * {arr3} = {q4 * arr3}\")\n+\n+print(\"\\n\" + \"=\"*50 + \"\\n\")\n+\n+# Now test the duck type\n+@dataclasses.dataclass\n+class DuckArray(np.lib.mixins.NDArrayOperatorsMixin):\n+    ndarray: u.Quantity\n+\n+    @property\n+    def unit(self) -> u.UnitBase:\n+        return self.ndarray.unit\n+\n+    def __array_ufunc__(self, function, method, *inputs, **kwargs):\n+        inputs = [inp.ndarray if isinstance(inp, DuckArray) else inp for inp in inputs]\n+\n+        for inp in inputs:\n+            if isinstance(inp, np.ndarray):\n+                result = inp.__array_ufunc__(function, method, *inputs, **kwargs)\n+                if result is not NotImplemented:\n+                    return DuckArray(result)\n+\n+        return NotImplemented\n+    \n+    def __repr__(self):\n+        return f\"DuckArray({self.ndarray})\"\n+\n+\n+print(\"Testing DuckArray operations...\")\n+\n+# Test all combinations\n+d1 = DuckArray(1 * u.mm)\n+q5 = 1 * u.m\n+\n+print(f\"DuckArray + Quantity (same units): {d1} + {1 * u.mm} = {d1 + (1 * u.mm)}\")\n+print(f\"Quantity + DuckArray (same units): {1 * u.mm} + {d1} = {(1 * u.mm) + d1}\")\n+print(f\"DuckArray + Quantity (different units): {d1} + {q5} = {d1 + q5}\")\n+print(f\"Quantity + DuckArray (different units): {q5} + {d1} = {q5 + d1}\")\n+\n+# Test other operations\n+print(f\"Multiplication: {d1} * 2 = {d1 * 2}\")\n+print(f\"Multiplication (reversed): 2 * {d1} = {2 * d1}\")\n+\n+# Test with arrays\n+d2 = DuckArray([1, 2, 3] * u.mm)\n+print(f\"Array DuckArray: {d2}\")\n+print(f\"Array operations: {d2} + {[1, 1, 1] * u.m} = {d2 + ([1, 1, 1] * u.m)}\")\n+\n+# Test comparison operations (these should return plain arrays, not DuckArrays)\n+print(f\"Comparison: {d1} > {0.5 * u.mm} = {d1 > (0.5 * u.mm)}\")\n+\n+print(\"\\nAll tests passed!\")\ndiff --git a/test_duck_type.py b/test_duck_type.py\nnew file mode 100644\nindex 0000000000..98d292341a\n--- /dev/null\n+++ b/test_duck_type.py\n@@ -0,0 +1,43 @@\n+import dataclasses\n+import numpy as np\n+import astropy.units as u\n+\n+\n+@dataclasses.dataclass\n+class DuckArray(np.lib.mixins.NDArrayOperatorsMixin):\n+    ndarray: u.Quantity\n+\n+    @property\n+    def unit(self) -> u.UnitBase:\n+        return self.ndarray.unit\n+\n+    def __array_ufunc__(self, function, method, *inputs, **kwargs):\n+\n+        inputs = [inp.ndarray if isinstance(inp, DuckArray) else inp for inp in inputs]\n+\n+        for inp in inputs:\n+            if isinstance(inp, np.ndarray):\n+                result = inp.__array_ufunc__(function, method, *inputs, **kwargs)\n+                if result is not NotImplemented:\n+                    return DuckArray(result)\n+\n+        return NotImplemented\n+\n+\n+# Test cases\n+print(\"Test 1: DuckArray(1 * u.mm) + (1 * u.m)\")\n+result1 = DuckArray(1 * u.mm) + (1 * u.m)\n+print(f\"Success: {result1}\")\n+print()\n+\n+print(\"Test 2: (1 * u.mm) + DuckArray(1 * u.mm)\")\n+result2 = (1 * u.mm) + DuckArray(1 * u.mm)\n+print(f\"Success: {result2}\")\n+print()\n+\n+print(\"Test 3: (1 * u.m) + DuckArray(1 * u.mm)\")\n+try:\n+    result3 = (1 * u.m) + DuckArray(1 * u.mm)\n+    print(f\"Success: {result3}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\ndiff --git a/test_notimplemented.py b/test_notimplemented.py\nnew file mode 100644\nindex 0000000000..4abe614280\n--- /dev/null\n+++ b/test_notimplemented.py\n@@ -0,0 +1,67 @@\n+import numpy as np\n+import astropy.units as u\n+import dataclasses\n+\n+# Create a duck type that simulates incompatibility\n+class IncompatibleDuck:\n+    \"\"\"A duck type that will cause _condition_arg to fail\"\"\"\n+    def __init__(self, value):\n+        self._value = value\n+    \n+    def __array__(self):\n+        # Purposely return something that _condition_arg won't like\n+        return self\n+    \n+    def __repr__(self):\n+        return f\"IncompatibleDuck({self._value})\"\n+\n+\n+# Test that Quantity.__array_ufunc__ returns NotImplemented for incompatible inputs\n+print(\"Testing NotImplemented return...\")\n+\n+# Create a Quantity\n+q = 1 * u.m\n+\n+# Test with our incompatible duck type\n+duck = IncompatibleDuck(5)\n+\n+# This should trigger the ValueError in _condition_arg and return NotImplemented\n+result = q.__array_ufunc__(np.add, \"__call__\", q, duck)\n+print(f\"q.__array_ufunc__(np.add, '__call__', q, duck) = {result}\")\n+assert result is NotImplemented, f\"Expected NotImplemented, got {result}\"\n+\n+print(\"\u2713 Correctly returned NotImplemented for incompatible input\")\n+\n+# Test with another scenario\n+print(\"\\nTesting with converter that fails...\")\n+\n+# Create a scenario where converter fails\n+q1 = 1 * u.m\n+# Create an object that has a 'value' attribute but still fails _condition_arg\n+\n+class DuckWithValue:\n+    def __init__(self, val):\n+        self.value = IncompatibleDuck(val)  # value attribute returns IncompatibleDuck\n+    \n+    def __repr__(self):\n+        return f\"DuckWithValue({self.value._value})\"\n+\n+duck2 = DuckWithValue(10)\n+result2 = q1.__array_ufunc__(np.add, \"__call__\", q1, duck2)\n+print(f\"q1.__array_ufunc__(np.add, '__call__', q1, duck2) = {result2}\")\n+assert result2 is NotImplemented, f\"Expected NotImplemented, got {result2}\"\n+\n+print(\"\u2713 Correctly returned NotImplemented when converter fails\")\n+\n+# Test that normal operations still work\n+print(\"\\nTesting normal operations still work...\")\n+q2 = 2 * u.m\n+result3 = q1.__array_ufunc__(np.add, \"__call__\", q1, q2)\n+print(f\"q1.__array_ufunc__(np.add, '__call__', q1, q2) = {result3}\")\n+assert isinstance(result3, u.Quantity), f\"Expected Quantity, got {type(result3)}\"\n+assert result3.value == 3.0, f\"Expected 3.0, got {result3.value}\"\n+assert result3.unit == u.m, f\"Expected meter unit, got {result3.unit}\"\n+\n+print(\"\u2713 Normal operations still work correctly\")\n+\n+print(\"\\nAll tests passed!\")\n", "gold_standard_diff": "diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb09c..21134c0fb5c2 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -633,53 +633,70 @@ def __array_ufunc__(self, function, method, *inputs, **kwargs):\n \n         Returns\n         -------\n-        result : `~astropy.units.Quantity`\n+        result : `~astropy.units.Quantity` or `NotImplemented`\n             Results of the ufunc, with the unit set properly.\n         \"\"\"\n         # Determine required conversion functions -- to bring the unit of the\n         # input to that expected (e.g., radian for np.sin), or to get\n         # consistent units between two inputs (e.g., in np.add) --\n         # and the unit of the result (or tuple of units for nout > 1).\n-        converters, unit = converters_and_unit(function, method, *inputs)\n+        try:\n+            converters, unit = converters_and_unit(function, method, *inputs)\n+\n+            out = kwargs.get(\"out\", None)\n+            # Avoid loop back by turning any Quantity output into array views.\n+            if out is not None:\n+                # If pre-allocated output is used, check it is suitable.\n+                # This also returns array view, to ensure we don't loop back.\n+                if function.nout == 1:\n+                    out = out[0]\n+                out_array = check_output(out, unit, inputs, function=function)\n+                # Ensure output argument remains a tuple.\n+                kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\n+\n+            if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\n+                # Special-case for initial argument for reductions like\n+                # np.add.reduce.  This should be converted to the output unit as\n+                # well, which is typically the same as the input unit (but can\n+                # in principle be different: unitless for np.equal, radian\n+                # for np.arctan2, though those are not necessarily useful!)\n+                kwargs[\"initial\"] = self._to_own_unit(\n+                    kwargs[\"initial\"], check_precision=False, unit=unit\n+                )\n \n-        out = kwargs.get(\"out\", None)\n-        # Avoid loop back by turning any Quantity output into array views.\n-        if out is not None:\n-            # If pre-allocated output is used, check it is suitable.\n-            # This also returns array view, to ensure we don't loop back.\n-            if function.nout == 1:\n-                out = out[0]\n-            out_array = check_output(out, unit, inputs, function=function)\n-            # Ensure output argument remains a tuple.\n-            kwargs[\"out\"] = (out_array,) if function.nout == 1 else out_array\n-\n-        if method == \"reduce\" and \"initial\" in kwargs and unit is not None:\n-            # Special-case for initial argument for reductions like\n-            # np.add.reduce.  This should be converted to the output unit as\n-            # well, which is typically the same as the input unit (but can\n-            # in principle be different: unitless for np.equal, radian\n-            # for np.arctan2, though those are not necessarily useful!)\n-            kwargs[\"initial\"] = self._to_own_unit(\n-                kwargs[\"initial\"], check_precision=False, unit=unit\n+            # Same for inputs, but here also convert if necessary.\n+            arrays = []\n+            for input_, converter in zip(inputs, converters):\n+                input_ = getattr(input_, \"value\", input_)\n+                arrays.append(converter(input_) if converter else input_)\n+\n+            # Call our superclass's __array_ufunc__\n+            result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n+            # If unit is None, a plain array is expected (e.g., comparisons), which\n+            # means we're done.\n+            # We're also done if the result was None (for method 'at') or\n+            # NotImplemented, which can happen if other inputs/outputs override\n+            # __array_ufunc__; hopefully, they can then deal with us.\n+            if unit is None or result is None or result is NotImplemented:\n+                return result\n+\n+            return self._result_as_quantity(result, unit, out)\n+\n+        except (TypeError, ValueError) as e:\n+            out_normalized = kwargs.get(\"out\", tuple())\n+            inputs_and_outputs = inputs + out_normalized\n+            ignored_ufunc = (\n+                None,\n+                np.ndarray.__array_ufunc__,\n+                type(self).__array_ufunc__,\n             )\n-\n-        # Same for inputs, but here also convert if necessary.\n-        arrays = []\n-        for input_, converter in zip(inputs, converters):\n-            input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n-\n-        # Call our superclass's __array_ufunc__\n-        result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n-        # If unit is None, a plain array is expected (e.g., comparisons), which\n-        # means we're done.\n-        # We're also done if the result was None (for method 'at') or\n-        # NotImplemented, which can happen if other inputs/outputs override\n-        # __array_ufunc__; hopefully, they can then deal with us.\n-        if unit is None or result is None or result is NotImplemented:\n-            return result\n-\n-        return self._result_as_quantity(result, unit, out)\n+            if not all(\n+                getattr(type(io), \"__array_ufunc__\", None) in ignored_ufunc\n+                for io in inputs_and_outputs\n+            ):\n+                return NotImplemented\n+            else:\n+                raise e\n \n     def _result_as_quantity(self, result, unit, out):\n         \"\"\"Turn result into a quantity with the given unit.\ndiff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py\nindex b07d4de1d69b..a2d0d7927bcd 100644\n--- a/astropy/units/tests/test_quantity.py\n+++ b/astropy/units/tests/test_quantity.py\n@@ -505,11 +505,10 @@ def test_incompatible_units(self):\n \n     def test_non_number_type(self):\n         q1 = u.Quantity(11.412, unit=u.meter)\n-        with pytest.raises(TypeError) as exc:\n+        with pytest.raises(\n+            TypeError, match=r\"Unsupported operand type\\(s\\) for ufunc .*\"\n+        ):\n             q1 + {\"a\": 1}\n-        assert exc.value.args[0].startswith(\n-            \"Unsupported operand type(s) for ufunc add:\"\n-        )\n \n         with pytest.raises(TypeError):\n             q1 + u.meter\ndiff --git a/astropy/units/tests/test_quantity_ufuncs.py b/astropy/units/tests/test_quantity_ufuncs.py\nindex 5f8c3ab3eb41..7625e670b1c1 100644\n--- a/astropy/units/tests/test_quantity_ufuncs.py\n+++ b/astropy/units/tests/test_quantity_ufuncs.py\n@@ -2,6 +2,7 @@\n # returns quantities with the right units, or raises exceptions.\n \n import concurrent.futures\n+import dataclasses\n import warnings\n from collections import namedtuple\n \n@@ -1294,6 +1295,125 @@ def test_two_argument_ufunc_outer(self):\n         assert np.all(s13_greater_outer == check13_greater_outer)\n \n \n+@dataclasses.dataclass\n+class DuckQuantity1:\n+    data: u.Quantity\n+\n+\n+@dataclasses.dataclass\n+class DuckQuantity2(DuckQuantity1):\n+    @property\n+    def unit(self) -> u.UnitBase:\n+        return self.data.unit\n+\n+\n+@dataclasses.dataclass(eq=False)\n+class DuckQuantity3(DuckQuantity2):\n+    def __array_ufunc__(self, function, method, *inputs, **kwargs):\n+\n+        inputs = [inp.data if isinstance(inp, type(self)) else inp for inp in inputs]\n+\n+        if \"out\" in kwargs:\n+            out = kwargs[\"out\"]\n+        else:\n+            out = None\n+\n+        kwargs_copy = {}\n+        for k in kwargs:\n+            kwarg = kwargs[k]\n+            if isinstance(kwarg, type(self)):\n+                kwargs_copy[k] = kwarg.data\n+            elif isinstance(kwarg, (list, tuple)):\n+                kwargs_copy[k] = type(kwarg)(\n+                    item.data if isinstance(item, type(self)) else item\n+                    for item in kwarg\n+                )\n+            else:\n+                kwargs_copy[k] = kwarg\n+        kwargs = kwargs_copy\n+\n+        for inp in inputs:\n+            if isinstance(inp, np.ndarray):\n+                result = inp.__array_ufunc__(function, method, *inputs, **kwargs)\n+                if result is not NotImplemented:\n+                    if out is None:\n+                        return type(self)(result)\n+                    else:\n+                        if function.nout == 1:\n+                            return out[0]\n+                        else:\n+                            return out\n+\n+        return NotImplemented\n+\n+\n+class TestUfuncReturnsNotImplemented:\n+    @pytest.mark.parametrize(\"ufunc\", (np.negative, np.abs))\n+    class TestUnaryUfuncs:\n+        @pytest.mark.parametrize(\n+            \"duck_quantity\",\n+            [DuckQuantity1(1 * u.mm), DuckQuantity2(1 * u.mm)],\n+        )\n+        def test_basic(self, ufunc, duck_quantity):\n+            with pytest.raises(TypeError, match=\"bad operand type for .*\"):\n+                ufunc(duck_quantity)\n+\n+        @pytest.mark.parametrize(\n+            \"duck_quantity\", [DuckQuantity3(1 * u.mm), DuckQuantity3([1, 2] * u.mm)]\n+        )\n+        @pytest.mark.parametrize(\"out\", [None, \"empty\"])\n+        def test_full(self, ufunc, duck_quantity, out):\n+            out_expected = out\n+            if out == \"empty\":\n+                out = type(duck_quantity)(np.empty_like(ufunc(duck_quantity.data)))\n+                out_expected = np.empty_like(ufunc(duck_quantity.data))\n+\n+            result = ufunc(duck_quantity, out=out)\n+            if out is not None:\n+                assert result is out\n+\n+            result_expected = ufunc(duck_quantity.data, out=out_expected)\n+            assert np.all(result.data == result_expected)\n+\n+    @pytest.mark.parametrize(\"ufunc\", (np.add, np.multiply, np.less))\n+    @pytest.mark.parametrize(\"quantity\", (1 * u.m, [1, 2] * u.m))\n+    class TestBinaryUfuncs:\n+        @pytest.mark.parametrize(\n+            \"duck_quantity\",\n+            [DuckQuantity1(1 * u.mm), DuckQuantity2(1 * u.mm)],\n+        )\n+        def test_basic(self, ufunc, quantity, duck_quantity):\n+            with pytest.raises(\n+                (TypeError, ValueError),\n+                match=(\n+                    r\"(Unsupported operand type\\(s\\) for ufunc .*)|\"\n+                    r\"(unsupported operand type\\(s\\) for .*)|\"\n+                    r\"(Value not scalar compatible or convertible to an int, float, or complex array)\"\n+                ),\n+            ):\n+                ufunc(quantity, duck_quantity)\n+\n+        @pytest.mark.parametrize(\n+            \"duck_quantity\",\n+            [DuckQuantity3(1 * u.mm), DuckQuantity3([1, 2] * u.mm)],\n+        )\n+        @pytest.mark.parametrize(\"out\", [None, \"empty\"])\n+        def test_full(self, ufunc, quantity, duck_quantity, out):\n+            out_expected = out\n+            if out == \"empty\":\n+                out = type(duck_quantity)(\n+                    np.empty_like(ufunc(quantity, duck_quantity.data))\n+                )\n+                out_expected = np.empty_like(ufunc(quantity, duck_quantity.data))\n+\n+            result = ufunc(quantity, duck_quantity, out=out)\n+            if out is not None:\n+                assert result is out\n+\n+            result_expected = ufunc(quantity, duck_quantity.data, out=out_expected)\n+            assert np.all(result.data == result_expected)\n+\n+\n if HAS_SCIPY:\n     from scipy import special as sps\n \ndiff --git a/docs/changes/units/13977.bugfix.rst b/docs/changes/units/13977.bugfix.rst\nnew file mode 100644\nindex 000000000000..7e7d4a348e56\n--- /dev/null\n+++ b/docs/changes/units/13977.bugfix.rst\n@@ -0,0 +1 @@\n+Modified ``astropy.units.Quantity.__array_ufunc__()`` to return ``NotImplemented`` instead of raising a ``ValueError`` if the inputs are incompatible.\n", "gold_standard_pr_link": "https://github.com/astropy/astropy/pull/13977"}