{"instance_id": "django__django-13410", "score": "C", "diff": "diff --git a/django/core/files/locks.py b/django/core/files/locks.py\nindex c46b00b905..4938347ea7 100644\n--- a/django/core/files/locks.py\n+++ b/django/core/files/locks.py\n@@ -107,9 +107,15 @@ else:\n             return True\n     else:\n         def lock(f, flags):\n-            ret = fcntl.flock(_fd(f), flags)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except OSError:\n+                return False\n \n         def unlock(f):\n-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+                return True\n+            except OSError:\n+                return False\ndiff --git a/django/core/files/locks.py.backup b/django/core/files/locks.py.backup\nnew file mode 100644\nindex 0000000000..8a45509106\n--- /dev/null\n+++ b/django/core/files/locks.py.backup\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Portable file locking utilities.\n+\n+Based partially on an example by Jonathan Feignberg in the Python\n+Cookbook [1] (licensed under the Python Software License) and a ctypes port by\n+Anatoly Techtonik for Roundup [2] (license [3]).\n+\n+[1] http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/65203\n+[2] https://sourceforge.net/p/roundup/code/ci/default/tree/roundup/backends/portalocker.py\n+[3] https://sourceforge.net/p/roundup/code/ci/default/tree/COPYING.txt\n+\n+Example Usage::\n+\n+    >>> from django.core.files import locks\n+    >>> with open('./file', 'wb') as f:\n+    ...     locks.lock(f, locks.LOCK_EX)\n+    ...     f.write('Django')\n+\"\"\"\n+import os\n+\n+__all__ = ('LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock', 'unlock')\n+\n+\n+def _fd(f):\n+    \"\"\"Get a filedescriptor from something which could be a file or an fd.\"\"\"\n+    return f.fileno() if hasattr(f, 'fileno') else f\n+\n+\n+if os.name == 'nt':\n+    import msvcrt\n+    from ctypes import (\n+        POINTER, Structure, Union, byref, c_int64, c_ulong, c_void_p, sizeof,\n+        windll,\n+    )\n+    from ctypes.wintypes import BOOL, DWORD, HANDLE\n+\n+    LOCK_SH = 0  # the default\n+    LOCK_NB = 0x1  # LOCKFILE_FAIL_IMMEDIATELY\n+    LOCK_EX = 0x2  # LOCKFILE_EXCLUSIVE_LOCK\n+\n+    # --- Adapted from the pyserial project ---\n+    # detect size of ULONG_PTR\n+    if sizeof(c_ulong) != sizeof(c_void_p):\n+        ULONG_PTR = c_int64\n+    else:\n+        ULONG_PTR = c_ulong\n+    PVOID = c_void_p\n+\n+    # --- Union inside Structure by stackoverflow:3480240 ---\n+    class _OFFSET(Structure):\n+        _fields_ = [\n+            ('Offset', DWORD),\n+            ('OffsetHigh', DWORD)]\n+\n+    class _OFFSET_UNION(Union):\n+        _anonymous_ = ['_offset']\n+        _fields_ = [\n+            ('_offset', _OFFSET),\n+            ('Pointer', PVOID)]\n+\n+    class OVERLAPPED(Structure):\n+        _anonymous_ = ['_offset_union']\n+        _fields_ = [\n+            ('Internal', ULONG_PTR),\n+            ('InternalHigh', ULONG_PTR),\n+            ('_offset_union', _OFFSET_UNION),\n+            ('hEvent', HANDLE)]\n+\n+    LPOVERLAPPED = POINTER(OVERLAPPED)\n+\n+    # --- Define function prototypes for extra safety ---\n+    LockFileEx = windll.kernel32.LockFileEx\n+    LockFileEx.restype = BOOL\n+    LockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, DWORD, LPOVERLAPPED]\n+    UnlockFileEx = windll.kernel32.UnlockFileEx\n+    UnlockFileEx.restype = BOOL\n+    UnlockFileEx.argtypes = [HANDLE, DWORD, DWORD, DWORD, LPOVERLAPPED]\n+\n+    def lock(f, flags):\n+        hfile = msvcrt.get_osfhandle(_fd(f))\n+        overlapped = OVERLAPPED()\n+        ret = LockFileEx(hfile, flags, 0, 0, 0xFFFF0000, byref(overlapped))\n+        return bool(ret)\n+\n+    def unlock(f):\n+        hfile = msvcrt.get_osfhandle(_fd(f))\n+        overlapped = OVERLAPPED()\n+        ret = UnlockFileEx(hfile, 0, 0, 0xFFFF0000, byref(overlapped))\n+        return bool(ret)\n+else:\n+    try:\n+        import fcntl\n+        LOCK_SH = fcntl.LOCK_SH  # shared lock\n+        LOCK_NB = fcntl.LOCK_NB  # non-blocking\n+        LOCK_EX = fcntl.LOCK_EX\n+    except (ImportError, AttributeError):\n+        # File locking is not supported.\n+        LOCK_EX = LOCK_SH = LOCK_NB = 0\n+\n+        # Dummy functions that don't do anything.\n+        def lock(f, flags):\n+            # File is not locked\n+            return False\n+\n+        def unlock(f):\n+            # File is unlocked\n+            return True\n+    else:\n+        def lock(f, flags):\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except OSError:\n+                return False\n+\n+        def unlock(f):\n+            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+            return ret == 0\ndiff --git a/fix_locks.py b/fix_locks.py\nnew file mode 100644\nindex 0000000000..24129d1db4\n--- /dev/null\n+++ b/fix_locks.py\n@@ -0,0 +1,40 @@\n+#!/usr/bin/env python\n+\"\"\"Script to fix the locks.py file\"\"\"\n+\n+# Read the file\n+with open('/testbed/django/core/files/locks.py', 'r') as f:\n+    content = f.read()\n+\n+# Replace the problematic lock function\n+old_lock = \"\"\"        def lock(f, flags):\n+            ret = fcntl.flock(_fd(f), flags)\n+            return ret == 0\"\"\"\n+\n+new_lock = \"\"\"        def lock(f, flags):\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except OSError:\n+                return False\"\"\"\n+\n+content = content.replace(old_lock, new_lock)\n+\n+# Replace the problematic unlock function\n+old_unlock = \"\"\"        def unlock(f):\n+            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+            return ret == 0\"\"\"\n+\n+new_unlock = \"\"\"        def unlock(f):\n+            try:\n+                fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+                return True\n+            except OSError:\n+                return False\"\"\"\n+\n+content = content.replace(old_unlock, new_unlock)\n+\n+# Write the fixed content back\n+with open('/testbed/django/core/files/locks.py', 'w') as f:\n+    f.write(content)\n+\n+print(\"File fixed successfully!\")\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_locks.py b/test_locks.py\nnew file mode 100644\nindex 0000000000..14dfb56d41\n--- /dev/null\n+++ b/test_locks.py\n@@ -0,0 +1,40 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to verify the lock behavior\"\"\"\n+\n+import os\n+import tempfile\n+from django.core.files import locks\n+\n+# Create a temporary file for testing\n+with tempfile.NamedTemporaryFile(delete=False) as f:\n+    test_file_path = f.name\n+    f.write(b\"test content\")\n+\n+try:\n+    # Test the lock function\n+    with open(test_file_path, 'rb') as f:\n+        print(\"Testing lock with LOCK_EX...\")\n+        result = locks.lock(f, locks.LOCK_EX)\n+        print(f\"Lock result: {result}, type: {type(result)}\")\n+        print(f\"Expected: True (lock should succeed)\")\n+        \n+        # Try to lock again with non-blocking to test failure case\n+        with open(test_file_path, 'rb') as f2:\n+            print(\"\\nTesting lock with LOCK_EX | LOCK_NB on already locked file...\")\n+            try:\n+                result2 = locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB)\n+                print(f\"Second lock result: {result2}, type: {type(result2)}\")\n+                print(f\"Expected: False (lock should fail since file is already locked)\")\n+            except Exception as e:\n+                print(f\"Exception raised: {type(e).__name__}: {e}\")\n+                print(\"This shows the current implementation is broken - it raises exception instead of returning False\")\n+        \n+        # Unlock the file\n+        print(\"\\nTesting unlock...\")\n+        unlock_result = locks.unlock(f)\n+        print(f\"Unlock result: {unlock_result}, type: {type(unlock_result)}\")\n+        print(f\"Expected: True (unlock should succeed)\")\n+        \n+finally:\n+    # Clean up\n+    os.unlink(test_file_path)\ndiff --git a/test_locks_comprehensive.py b/test_locks_comprehensive.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\n", "gold_standard_diff": "diff --git a/django/core/files/locks.py b/django/core/files/locks.py\nindex c46b00b90576..b02faaa181e5 100644\n--- a/django/core/files/locks.py\n+++ b/django/core/files/locks.py\n@@ -107,9 +107,12 @@ def unlock(f):\n             return True\n     else:\n         def lock(f, flags):\n-            ret = fcntl.flock(_fd(f), flags)\n-            return ret == 0\n+            try:\n+                fcntl.flock(_fd(f), flags)\n+                return True\n+            except BlockingIOError:\n+                return False\n \n         def unlock(f):\n-            ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n-            return ret == 0\n+            fcntl.flock(_fd(f), fcntl.LOCK_UN)\n+            return True\ndiff --git a/docs/releases/3.2.txt b/docs/releases/3.2.txt\nindex 30cc6a401ae2..e77785f8e2a8 100644\n--- a/docs/releases/3.2.txt\n+++ b/docs/releases/3.2.txt\n@@ -504,6 +504,10 @@ Miscellaneous\n   distinguishes inherited field instances across models. Additionally, the\n   ordering of such fields is now defined.\n \n+* The undocumented ``django.core.files.locks.lock()`` function now returns\n+  ``False`` if the file cannot be locked, instead of raising\n+  :exc:`BlockingIOError`.\n+\n .. _deprecated-features-3.2:\n \n Features deprecated in 3.2\ndiff --git a/tests/files/tests.py b/tests/files/tests.py\nindex 047c8935b827..dfb007f2fcd5 100644\n--- a/tests/files/tests.py\n+++ b/tests/files/tests.py\n@@ -8,7 +8,7 @@\n from pathlib import Path\n from unittest import mock\n \n-from django.core.files import File\n+from django.core.files import File, locks\n from django.core.files.base import ContentFile\n from django.core.files.move import file_move_safe\n from django.core.files.temp import NamedTemporaryFile\n@@ -169,6 +169,22 @@ def test_io_wrapper(self):\n             test_file.seek(0)\n             self.assertEqual(test_file.read(), (content * 2).encode())\n \n+    def test_exclusive_lock(self):\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path) as f1, open(file_path) as f2:\n+            self.assertIs(locks.lock(f1, locks.LOCK_EX), True)\n+            self.assertIs(locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB), False)\n+            self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), False)\n+            self.assertIs(locks.unlock(f1), True)\n+\n+    def test_shared_lock(self):\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path) as f1, open(file_path) as f2:\n+            self.assertIs(locks.lock(f1, locks.LOCK_SH), True)\n+            self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), True)\n+            self.assertIs(locks.unlock(f1), True)\n+            self.assertIs(locks.unlock(f2), True)\n+\n \n class NoNameFileTestCase(unittest.TestCase):\n     \"\"\"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13410"}