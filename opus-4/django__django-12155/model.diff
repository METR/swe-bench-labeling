diff --git a/django/contrib/admindocs/utils.py b/django/contrib/admindocs/utils.py
index 4c0e7e2a56..9bcb1d371d 100644
--- a/django/contrib/admindocs/utils.py
+++ b/django/contrib/admindocs/utils.py
@@ -34,7 +34,10 @@ def trim_docstring(docstring):
         return ''
     # Convert tabs to spaces and split into lines
     lines = docstring.expandtabs().splitlines()
-    indent = min(len(line) - len(line.lstrip()) for line in lines if line.lstrip())
+    # Calculate minimum indentation (ignoring first line)
+    indents = [len(line) - len(line.lstrip()) for line in lines[1:] if line.lstrip()]
+    # If there are no non-empty lines after the first, use 0 as the indent
+    indent = min(indents) if indents else 0
     trimmed = [lines[0].lstrip()] + [line[indent:].rstrip() for line in lines[1:]]
     return "\n".join(trimmed).strip()
 
diff --git a/test_docstring_issue.py b/test_docstring_issue.py
new file mode 100644
index 0000000000..9bca3ad6bc
--- /dev/null
+++ b/test_docstring_issue.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+"""Test script to reproduce the docstring issue."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')
+django.setup()
+
+from django.contrib.admindocs.utils import trim_docstring, parse_rst, parse_docstring
+
+
+def test_function_with_first_line_docstring():
+    """This is a test function.
+    
+    It has a docstring that starts on the first line.
+    """
+    pass
+
+
+def test_function_with_empty_first_line():
+    """
+    This is a test function.
+    
+    It has a docstring with an empty first line.
+    """
+    pass
+
+
+if __name__ == "__main__":
+    # Test the current implementation
+    print("Testing function with docstring on first line:")
+    docstring1 = test_function_with_first_line_docstring.__doc__
+    print("Original docstring:")
+    print(repr(docstring1))
+    
+    try:
+        trimmed1 = trim_docstring(docstring1)
+        print("\nTrimmed docstring:")
+        print(repr(trimmed1))
+        
+        # Try to parse it with rst
+        title, body, metadata = parse_docstring(docstring1)
+        print("\nParsed title:")
+        print(repr(title))
+        print("\nParsed body:")
+        print(repr(body))
+        
+        # Try to render it as RST
+        print("\nTrying to render as RST...")
+        rendered = parse_rst(trimmed1, 'test')
+        print("Success!")
+    except Exception as e:
+        print(f"\nError: {type(e).__name__}: {e}")
+    
+    print("\n" + "="*50 + "\n")
+    
+    print("Testing function with empty first line:")
+    docstring2 = test_function_with_empty_first_line.__doc__
+    print("Original docstring:")
+    print(repr(docstring2))
+    
+    try:
+        trimmed2 = trim_docstring(docstring2)
+        print("\nTrimmed docstring:")
+        print(repr(trimmed2))
+        
+        # Try to parse it with rst
+        title, body, metadata = parse_docstring(docstring2)
+        print("\nParsed title:")
+        print(repr(title))
+        print("\nParsed body:")
+        print(repr(body))
+        
+        # Try to render it as RST
+        print("\nTrying to render as RST...")
+        rendered = parse_rst(trimmed2, 'test')
+        print("Success!")
+    except Exception as e:
+        print(f"\nError: {type(e).__name__}: {e}")
diff --git a/test_docstring_rst_error.py b/test_docstring_rst_error.py
new file mode 100644
index 0000000000..eaf5425c38
--- /dev/null
+++ b/test_docstring_rst_error.py
@@ -0,0 +1,73 @@
+#!/usr/bin/env python
+"""Test that the RST parsing error is fixed."""
+
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')
+
+# Configure URLs
+from django.urls import path
+
+urlpatterns = [
+    path('admindocs/', lambda request: None, name='django-admindocs-docroot'),
+]
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        'django.contrib.admin',
+        'django.contrib.admindocs',
+    ],
+    ROOT_URLCONF=__name__,
+)
+
+django.setup()
+
+from django.contrib.admindocs.utils import trim_docstring, parse_rst, parse_docstring
+
+
+def test_view():
+    """test tests something.
+    
+    This is the body of the docstring.
+    It contains multiple lines.
+    """
+    pass
+
+
+if __name__ == "__main__":
+    print("Testing docstring that starts on first line...")
+    
+    docstring = test_view.__doc__
+    print(f"\nOriginal docstring:\n{repr(docstring)}")
+    
+    # Test trim_docstring
+    trimmed = trim_docstring(docstring)
+    print(f"\nTrimmed docstring:\n{repr(trimmed)}")
+    
+    # Test parse_docstring
+    title, body, metadata = parse_docstring(docstring)
+    print(f"\nParsed title: {repr(title)}")
+    print(f"Parsed body: {repr(body)}")
+    
+    # The crucial test - parse as RST (this should not raise an error)
+    print("\nTrying to render trimmed docstring as RST...")
+    try:
+        rendered = parse_rst(trimmed, 'test')
+        print("SUCCESS! No error when rendering RST.")
+        print(f"\nRendered HTML:\n{rendered}")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        import traceback
+        traceback.print_exc()
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..da425d1720
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python
+"""Test edge cases for trim_docstring."""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from django.contrib.admindocs.utils import trim_docstring
+
+
+# Edge case 1: Single line docstring
+single_line = """This is a single line docstring."""
+
+# Edge case 2: Docstring with empty subsequent lines
+empty_subsequent = """First line
+    
+
+
+    """
+
+# Edge case 3: Only whitespace on subsequent lines
+whitespace_only = """First line
+        
+    """
+
+
+if __name__ == "__main__":
+    print("Testing edge cases:")
+    
+    print("\n1. Single line docstring:")
+    print(f"Original: {repr(single_line)}")
+    try:
+        trimmed = trim_docstring(single_line)
+        print(f"Trimmed: {repr(trimmed)}")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+    
+    print("\n2. Docstring with empty subsequent lines:")
+    print(f"Original: {repr(empty_subsequent)}")
+    try:
+        trimmed = trim_docstring(empty_subsequent)
+        print(f"Trimmed: {repr(trimmed)}")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+    
+    print("\n3. Only whitespace on subsequent lines:")
+    print(f"Original: {repr(whitespace_only)}")
+    try:
+        trimmed = trim_docstring(whitespace_only)
+        print(f"Trimmed: {repr(trimmed)}")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
diff --git a/test_issue_scenario.py b/test_issue_scenario.py
new file mode 100644
index 0000000000..919961b27a
--- /dev/null
+++ b/test_issue_scenario.py
@@ -0,0 +1,61 @@
+#!/usr/bin/env python
+"""Test the exact scenario mentioned in the issue."""
+
+import os
+import django
+from django.conf import settings
+from django.urls import path
+
+# Configure Django settings
+urlpatterns = [
+    path('admindocs/', lambda request: None, name='django-admindocs-docroot'),
+]
+
+settings.configure(
+    DEBUG=True,
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+        'django.contrib.admin',
+        'django.contrib.admindocs',
+    ],
+    ROOT_URLCONF=__name__,
+)
+
+django.setup()
+
+from django.contrib.admindocs.utils import trim_docstring, parse_rst
+
+
+def test():
+    """test tests something.
+    """
+    pass
+
+
+if __name__ == "__main__":
+    print("Testing exact scenario from issue...")
+    print(f"Function docstring: {repr(test.__doc__)}")
+    
+    # Trim the docstring
+    trimmed = trim_docstring(test.__doc__)
+    print(f"Trimmed docstring: {repr(trimmed)}")
+    
+    # Try to parse as RST - this was causing the error before
+    print("\nTrying to render as RST...")
+    try:
+        rendered = parse_rst(trimmed, 'test')
+        print("SUCCESS! No error when rendering RST.")
+        print(f"Rendered HTML: {rendered}")
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        if "Error in \"default-role\" directive" in str(e):
+            print("\nThis is the exact error mentioned in the issue!")
+        import traceback
+        traceback.print_exc()
diff --git a/test_trim_docstring.py b/test_trim_docstring.py
new file mode 100644
index 0000000000..738a319e62
--- /dev/null
+++ b/test_trim_docstring.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python
+"""Test script to reproduce the trim_docstring issue."""
+
+import sys
+sys.path.insert(0, '/testbed')
+
+from django.contrib.admindocs.utils import trim_docstring
+
+
+def test_function_with_first_line_docstring():
+    """This is a test function.
+    
+    It has a docstring that starts on the first line.
+    """
+    pass
+
+
+def test_function_with_empty_first_line():
+    """
+    This is a test function.
+    
+    It has a docstring with an empty first line.
+    """
+    pass
+
+
+# Simpler docstring case that shows the issue more clearly
+simple_docstring = """Test docstring starts on first line.
+    Second line is indented.
+    Third line is also indented."""
+
+
+if __name__ == "__main__":
+    # Test the current implementation
+    print("Testing simple docstring:")
+    print("Original:")
+    print(repr(simple_docstring))
+    
+    # Current implementation
+    lines = simple_docstring.expandtabs().splitlines()
+    print(f"\nLines: {lines}")
+    
+    # The problem: when we calculate indent, the first line has 0 indentation
+    indents = [len(line) - len(line.lstrip()) for line in lines if line.lstrip()]
+    print(f"Indents for non-empty lines: {indents}")
+    indent = min(indents)
+    print(f"Minimum indent: {indent}")
+    
+    # This causes the issue - we're using indent=0 because first line has no indent
+    trimmed_current = trim_docstring(simple_docstring)
+    print("\nCurrent trim_docstring result:")
+    print(repr(trimmed_current))
+    print("\nNotice the issue: The second and third lines still have leading spaces!")
+    
+    print("\n" + "="*50 + "\n")
+    
+    # Test with function docstrings
+    print("Testing function with docstring on first line:")
+    docstring1 = test_function_with_first_line_docstring.__doc__
+    print("Original docstring:")
+    print(repr(docstring1))
+    
+    trimmed1 = trim_docstring(docstring1)
+    print("\nTrimmed docstring:")
+    print(repr(trimmed1))
+    print("\nNotice: Body line still has extra indentation!")
+    
+    print("\n" + "="*50 + "\n")
+    
+    print("Testing function with empty first line:")
+    docstring2 = test_function_with_empty_first_line.__doc__
+    print("Original docstring:")
+    print(repr(docstring2))
+    
+    trimmed2 = trim_docstring(docstring2)
+    print("\nTrimmed docstring:")
+    print(repr(trimmed2))
+    print("\nThis one works correctly!")
diff --git a/tests/admin_docs/test_utils.py b/tests/admin_docs/test_utils.py
index 17ea912015..0fb80eb999 100644
--- a/tests/admin_docs/test_utils.py
+++ b/tests/admin_docs/test_utils.py
@@ -118,3 +118,33 @@ class TestUtils(AdminDocsSimpleTestCase):
         markup = '<p>reST, <cite>interpreted text</cite>, default role.</p>\n'
         parts = docutils.core.publish_parts(source=source, writer_name="html4css1")
         self.assertEqual(parts['fragment'], markup)
+    
+    def test_trim_docstring_first_line(self):
+        """
+        Test trim_docstring() with docstrings that start on the first line.
+        """
+        # Docstring that starts on the first line (issue case)
+        docstring_first_line = """test tests something.
+    
+    This is the body of the docstring.
+    It has multiple lines."""
+        
+        expected = "test tests something.\n\nThis is the body of the docstring.\nIt has multiple lines."
+        self.assertEqual(trim_docstring(docstring_first_line), expected)
+        
+        # Ensure parse_rst doesn't throw an error
+        trimmed = trim_docstring(docstring_first_line)
+        # This should not raise an exception
+        output = parse_rst(trimmed, 'test')
+        self.assertIn('test tests something.', output)
+        self.assertIn('This is the body of the docstring.', output)
+        
+        # Edge case: single line docstring
+        single_line = """This is a single line docstring."""
+        self.assertEqual(trim_docstring(single_line), "This is a single line docstring.")
+        
+        # Edge case: docstring with only whitespace in subsequent lines
+        whitespace_only = """First line
+        
+    """
+        self.assertEqual(trim_docstring(whitespace_only), "First line")
