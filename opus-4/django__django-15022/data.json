{"instance_id": "django__django-15022", "score": "C", "diff": "diff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 66f3396a6b..96d0ffde30 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1031,6 +1031,7 @@ class ModelAdmin(BaseModelAdmin):\n         if search_fields and search_term:\n             orm_lookups = [construct_search(str(search_field))\n                            for search_field in search_fields]\n+            search_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n@@ -1038,7 +1039,10 @@ class ModelAdmin(BaseModelAdmin):\n                     *((orm_lookup, bit) for orm_lookup in orm_lookups),\n                     _connector=models.Q.OR,\n                 )\n-                queryset = queryset.filter(or_queries)\n+                search_queries.append(or_queries)\n+            # Apply all search queries in a single filter to avoid multiple JOINs\n+            if search_queries:\n+                queryset = queryset.filter(*search_queries)\n             may_have_duplicates |= any(\n                 lookup_spawns_duplicates(self.opts, search_spec)\n                 for search_spec in orm_lookups\ndiff --git a/show_original_problem.py b/show_original_problem.py\nnew file mode 100644\nindex 0000000000..a214b29f6f\n--- /dev/null\n+++ b/show_original_problem.py\n@@ -0,0 +1,59 @@\n+\"\"\"\n+This script shows the original problem behavior before the fix.\n+\"\"\"\n+\n+def show_original_problem():\n+    \"\"\"Demonstrate the original problem with multiple JOINs\"\"\"\n+    \n+    print(\"Original Problem: Multiple JOINs in Admin Search\")\n+    print(\"=\" * 60)\n+    print()\n+    print(\"Issue: When searching with multiple words in Django admin,\")\n+    print(\"each word creates a separate filter() call, leading to\")\n+    print(\"multiple JOINs when searching through related fields.\")\n+    print()\n+    print(\"Example:\")\n+    print(\"-\" * 60)\n+    print(\"Admin configuration:\")\n+    print(\"  search_fields = ('name', 'clientoffice__name')\")\n+    print()\n+    print(\"Search query: 'word1 word2 word3'\")\n+    print()\n+    print(\"Original code pattern (simplified):\")\n+    print(\"  for word in ['word1', 'word2', 'word3']:\")\n+    print(\"      queryset = queryset.filter(\")\n+    print(\"          Q(name__icontains=word) |\")  \n+    print(\"          Q(clientoffice__name__icontains=word)\")\n+    print(\"      )\")\n+    print()\n+    print(\"This creates SQL like:\")\n+    print(\"  SELECT ... FROM client\")\n+    print(\"  LEFT JOIN clientoffice T1 ON ... -- for word1\")\n+    print(\"  LEFT JOIN clientoffice T2 ON ... -- for word2\") \n+    print(\"  LEFT JOIN clientoffice T3 ON ... -- for word3\")\n+    print(\"  WHERE ...\")\n+    print()\n+    print(\"Problem: 3 JOINs for the same table!\")\n+    print()\n+    print(\"-\" * 60)\n+    print(\"Our Fix:\")\n+    print(\"-\" * 60)\n+    print()\n+    print(\"Collect all Q objects first, then apply in single filter:\")\n+    print(\"  queries = []\")\n+    print(\"  for word in ['word1', 'word2', 'word3']:\")\n+    print(\"      queries.append(\")\n+    print(\"          Q(name__icontains=word) |\")\n+    print(\"          Q(clientoffice__name__icontains=word)\")\n+    print(\"      )\")\n+    print(\"  queryset = queryset.filter(*queries)\")\n+    print()\n+    print(\"This creates SQL like:\")\n+    print(\"  SELECT ... FROM client\")\n+    print(\"  LEFT JOIN clientoffice T1 ON ... -- only ONE join!\")\n+    print(\"  WHERE ...\")\n+    print()\n+    print(\"Result: Only 1 JOIN, much better performance!\")\n+\n+if __name__ == '__main__':\n+    show_original_problem()\ndiff --git a/test_admin_search_joins.py b/test_admin_search_joins.py\nnew file mode 100644\nindex 0000000000..85d928d079\n--- /dev/null\n+++ b/test_admin_search_joins.py\n@@ -0,0 +1,111 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models, connection\n+from django.contrib import admin\n+from django.test import TestCase, RequestFactory\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.test_sqlite')\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+        ],\n+        MIDDLEWARE=[],\n+        ROOT_URLCONF='',\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+\n+# Define test models\n+class Client(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    contact_person = models.CharField('contact person', max_length=256, blank=True, null=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class ClientOffice(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    client = models.ForeignKey(Client, verbose_name='client', on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+# Define admin\n+class ClientAdmin(admin.ModelAdmin):\n+    search_fields = ('name', 'name2', 'contact_person', 'clientoffice__name', 'clientoffice__name2')\n+\n+\n+def test_search_joins():\n+    \"\"\"Test that searching with multiple words doesn't create multiple JOINs\"\"\"\n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Client)\n+        schema_editor.create_model(ClientOffice)\n+    \n+    # Create some test data\n+    client = Client.objects.create(name=\"Test Client\", name2=\"Alt Name\", contact_person=\"John Doe\")\n+    ClientOffice.objects.create(name=\"Main Office\", name2=\"HQ\", client=client)\n+    \n+    # Create admin instance\n+    site = AdminSite()\n+    client_admin = ClientAdmin(Client, site)\n+    \n+    # Create a mock request\n+    factory = RequestFactory()\n+    request = factory.get('/', {'q': 'test office main'})  # Multiple words\n+    request.user = User(username='test', is_superuser=True)\n+    \n+    # Reset queries\n+    from django.db import reset_queries\n+    from django.conf import settings\n+    settings.DEBUG = True\n+    reset_queries()\n+    \n+    # Get search results\n+    queryset = Client.objects.all()\n+    qs, may_have_duplicates = client_admin.get_search_results(request, queryset, 'test office main')\n+    \n+    # Force query execution\n+    list(qs)\n+    \n+    # Check the generated SQL\n+    queries = connection.queries\n+    print(\"\\nGenerated SQL queries:\")\n+    for i, query in enumerate(queries):\n+        print(f\"\\nQuery {i+1}:\")\n+        print(query['sql'])\n+    \n+    # Count JOINs in the query\n+    sql = queries[-1]['sql'] if queries else ''\n+    join_count = sql.upper().count('JOIN')\n+    print(f\"\\nNumber of JOINs: {join_count}\")\n+    \n+    # With the bug, we would see multiple JOINs for each search word\n+    # After fix, we should see fewer JOINs\n+    return join_count\n+\n+\n+if __name__ == '__main__':\n+    join_count = test_search_joins()\n+    print(f\"\\nTotal JOINs in search query: {join_count}\")\ndiff --git a/test_admin_search_joins_fix.py b/test_admin_search_joins_fix.py\nnew file mode 100644\nindex 0000000000..8b13789179\n--- /dev/null\n+++ b/test_admin_search_joins_fix.py\n@@ -0,0 +1 @@\n+\ndiff --git a/test_fix_verification.py b/test_fix_verification.py\nnew file mode 100644\nindex 0000000000..61a422e751\n--- /dev/null\n+++ b/test_fix_verification.py\n@@ -0,0 +1,90 @@\n+\"\"\"\n+Test to verify that the fix for multiple JOINs in admin search works correctly.\n+\"\"\"\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+            'tests.admin_changelist',\n+        ],\n+        MIDDLEWARE=[],\n+        ROOT_URLCONF='',\n+        SECRET_KEY='test',\n+    )\n+django.setup()\n+\n+def test_get_search_results():\n+    \"\"\"Test the fixed get_search_results method\"\"\"\n+    from django.db import models\n+    from django.contrib.admin import ModelAdmin\n+    from django.utils.text import smart_split, unescape_string_literal\n+    \n+    # Create a mock admin class with the fixed method\n+    class TestAdmin(ModelAdmin):\n+        search_fields = ['name', 'related__field']\n+    \n+    # Create a simple test\n+    admin = TestAdmin(models.Model, None)\n+    \n+    # Verify the fix by checking the implementation\n+    import inspect\n+    source = inspect.getsource(admin.get_search_results)\n+    \n+    # Check if search_queries list is being used (our fix)\n+    has_search_queries = 'search_queries = []' in source\n+    has_append = 'search_queries.append(or_queries)' in source\n+    has_single_filter = 'queryset.filter(*search_queries)' in source\n+    \n+    print(\"Verification of the fix:\")\n+    print(\"=\" * 60)\n+    print(f\"\u2713 Uses search_queries list: {has_search_queries}\")\n+    print(f\"\u2713 Appends Q objects to list: {has_append}\")\n+    print(f\"\u2713 Applies all filters at once: {has_single_filter}\")\n+    print()\n+    \n+    if has_search_queries and has_append and has_single_filter:\n+        print(\"SUCCESS: The fix has been properly applied!\")\n+        print(\"Multiple search words will now use a single filter() call,\")\n+        print(\"avoiding the creation of multiple JOINs for related fields.\")\n+    else:\n+        print(\"FAILED: The fix was not properly applied.\")\n+    \n+    # Test with actual Q objects to ensure functionality works\n+    print(\"\\n\\nFunctional Test:\")\n+    print(\"-\" * 60)\n+    \n+    # Simulate the fixed logic\n+    search_term = \"word1 word2 word3\"\n+    orm_lookups = ['name__icontains', 'related__field__icontains']\n+    search_queries = []\n+    \n+    for bit in smart_split(search_term):\n+        if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n+            bit = unescape_string_literal(bit)\n+        or_queries = models.Q(\n+            *((orm_lookup, bit) for orm_lookup in orm_lookups),\n+            _connector=models.Q.OR,\n+        )\n+        search_queries.append(or_queries)\n+    \n+    print(f\"Search term: '{search_term}'\")\n+    print(f\"Number of Q objects created: {len(search_queries)}\")\n+    print(f\"Q objects will be applied in a single filter(*search_queries) call\")\n+    print(\"\\nThis avoids creating multiple JOINs when searching related fields!\")\n+\n+if __name__ == '__main__':\n+    test_get_search_results()\ndiff --git a/test_join_issue.py b/test_join_issue.py\nnew file mode 100644\nindex 0000000000..60dc4c1f8c\n--- /dev/null\n+++ b/test_join_issue.py\n@@ -0,0 +1,74 @@\n+\"\"\"\n+This script demonstrates the issue with multiple JOINs in admin search.\n+When searching with multiple words, each word creates a separate filter()\n+call, which leads to multiple JOINs when searching through related fields.\n+\"\"\"\n+\n+def demonstrate_issue():\n+    \"\"\"Show the problematic code pattern in get_search_results\"\"\"\n+    \n+    print(\"Current implementation in get_search_results (lines 1034-1041):\")\n+    print(\"=\" * 60)\n+    print(\"\"\"\n+    for bit in smart_split(search_term):\n+        if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n+            bit = unescape_string_literal(bit)\n+        or_queries = models.Q(\n+            *((orm_lookup, bit) for orm_lookup in orm_lookups),\n+            _connector=models.Q.OR,\n+        )\n+        queryset = queryset.filter(or_queries)  # <-- This creates a new JOIN each time!\n+    \"\"\")\n+    \n+    print(\"\\n\\nProblem:\")\n+    print(\"-\" * 60)\n+    print(\"For search_term = 'word1 word2 word3' and search_fields including related fields,\")\n+    print(\"this creates:\")\n+    print(\"  queryset.filter(Q(...word1...)).filter(Q(...word2...)).filter(Q(...word3...))\")\n+    print(\"\\nEach filter() call creates a new JOIN for related fields!\")\n+    \n+    print(\"\\n\\nSQL Pattern (simplified):\")\n+    print(\"-\" * 60)\n+    print(\"\"\"\n+    SELECT ... FROM client\n+    LEFT JOIN clientoffice T1 ON ...  -- JOIN for word1\n+    LEFT JOIN clientoffice T2 ON ...  -- JOIN for word2  \n+    LEFT JOIN clientoffice T3 ON ...  -- JOIN for word3\n+    WHERE (... OR T1.name LIKE '%word1%' OR ...)\n+      AND (... OR T2.name LIKE '%word2%' OR ...)\n+      AND (... OR T3.name LIKE '%word3%' OR ...)\n+    \"\"\")\n+    \n+    print(\"\\n\\nSolution:\")\n+    print(\"-\" * 60)\n+    print(\"Combine all search conditions into a single filter() call:\")\n+    print(\"\"\"\n+    # Build all Q objects first\n+    search_queries = []\n+    for bit in smart_split(search_term):\n+        if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n+            bit = unescape_string_literal(bit)\n+        or_queries = models.Q(\n+            *((orm_lookup, bit) for orm_lookup in orm_lookups),\n+            _connector=models.Q.OR,\n+        )\n+        search_queries.append(or_queries)\n+    \n+    # Apply all filters at once\n+    if search_queries:\n+        queryset = queryset.filter(*search_queries)\n+    \"\"\")\n+    \n+    print(\"\\n\\nThis produces SQL like:\")\n+    print(\"-\" * 60)\n+    print(\"\"\"\n+    SELECT ... FROM client\n+    LEFT JOIN clientoffice T1 ON ...  -- Only ONE JOIN needed!\n+    WHERE (... OR T1.name LIKE '%word1%' OR ...)\n+      AND (... OR T1.name LIKE '%word2%' OR ...)\n+      AND (... OR T1.name LIKE '%word3%' OR ...)\n+    \"\"\")\n+\n+\n+if __name__ == '__main__':\n+    demonstrate_issue()\ndiff --git a/test_search_join_fix.py b/test_search_join_fix.py\nnew file mode 100644\nindex 0000000000..f666133a27\n--- /dev/null\n+++ b/test_search_join_fix.py\n@@ -0,0 +1,160 @@\n+#!/usr/bin/env python\n+\"\"\"Test that verifies the fix for multiple JOINs in admin changelist search.\"\"\"\n+\n+import os\n+import sys\n+sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n+\n+import django\n+from django.conf import settings\n+from django.test import TestCase\n+from django.test.utils import CaptureQueriesContext, override_settings\n+from django.db import connection\n+from django.contrib.admin import ModelAdmin, site\n+from django.contrib.auth.models import User\n+from django.test import RequestFactory\n+\n+# Configure Django if needed\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+            'django.contrib.sessions',\n+            'django.contrib.messages',\n+            'test_app',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+            'django.contrib.messages.middleware.MessageMiddleware',\n+        ],\n+        ROOT_URLCONF='',\n+        SECRET_KEY='test',\n+        TEMPLATES=[{\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+            'APP_DIRS': True,\n+            'OPTIONS': {\n+                'context_processors': [\n+                    'django.template.context_processors.debug',\n+                    'django.template.context_processors.request',\n+                    'django.contrib.auth.context_processors.auth',\n+                    'django.contrib.messages.context_processors.messages',\n+                ],\n+            },\n+        }],\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+\n+# Define test models\n+class Client(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    contact_person = models.CharField('contact person', max_length=256, blank=True, null=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class ClientOffice(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    client = models.ForeignKey(Client, verbose_name='client', on_delete=models.CASCADE, related_name='offices')\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+# Admin class with search fields that include related fields\n+class ClientAdmin(ModelAdmin):\n+    search_fields = ('name', 'name2', 'contact_person', 'offices__name', 'offices__name2')\n+\n+\n+class TestSearchJoinFix(TestCase):\n+    \"\"\"Test that searching with multiple words doesn't create unnecessary JOINs.\"\"\"\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(\n+            username='admin', \n+            email='admin@example.com', \n+            password='admin'\n+        )\n+    \n+    def setUp(self):\n+        # Create test data\n+        self.client1 = Client.objects.create(\n+            name=\"Test Client\", \n+            name2=\"Alternative Name\",\n+            contact_person=\"John Doe\"\n+        )\n+        self.office1 = ClientOffice.objects.create(\n+            name=\"Main Office\",\n+            name2=\"Head Office\", \n+            client=self.client1\n+        )\n+        \n+        self.factory = RequestFactory()\n+    \n+    def test_search_with_multiple_words_uses_single_join(self):\n+        \"\"\"Test that searching with multiple words uses a single JOIN, not multiple.\"\"\"\n+        # Create admin instance\n+        admin = ClientAdmin(Client, site)\n+        \n+        # Create request\n+        request = self.factory.get('/', {'q': 'test main office'})  # 3 search words\n+        request.user = self.superuser\n+        \n+        # Get base queryset\n+        queryset = Client.objects.all()\n+        \n+        # Capture queries\n+        with CaptureQueriesContext(connection) as queries:\n+            qs, may_have_duplicates = admin.get_search_results(\n+                request, queryset, 'test main office'\n+            )\n+            # Force evaluation\n+            list(qs)\n+        \n+        # Check the SQL query\n+        self.assertEqual(len(queries), 1, \"Should execute exactly one query\")\n+        sql = queries[0]['sql']\n+        \n+        # Count JOINs\n+        join_count = sql.upper().count(' JOIN ')\n+        \n+        # With the fix, we should see only one JOIN for the related table\n+        # Without the fix, we would see 3 JOINs (one for each search word)\n+        self.assertLessEqual(\n+            join_count, \n+            1, \n+            f\"Query should have at most 1 JOIN, but has {join_count}. SQL: {sql}\"\n+        )\n+        \n+        print(f\"\\n\u2713 SUCCESS: Query uses {join_count} JOIN(s) for 3 search words\")\n+        print(f\"SQL: {sql}\")\n+\n+\n+if __name__ == '__main__':\n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Client)\n+        schema_editor.create_model(ClientOffice)\n+    \n+    # Run the test\n+    import unittest\n+    suite = unittest.TestLoader().loadTestsFromTestCase(TestSearchJoinFix)\n+    runner = unittest.TextTestRunner(verbosity=2)\n+    result = runner.run(suite)\ndiff --git a/test_search_joins.py b/test_search_joins.py\nnew file mode 100644\nindex 0000000000..14ef656060\n--- /dev/null\n+++ b/test_search_joins.py\n@@ -0,0 +1,129 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings first\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'django.contrib.admin',\n+            'django.contrib.sessions',\n+            'django.contrib.messages',\n+        ],\n+        MIDDLEWARE=[\n+            'django.contrib.sessions.middleware.SessionMiddleware',\n+            'django.contrib.auth.middleware.AuthenticationMiddleware',\n+            'django.contrib.messages.middleware.MessageMiddleware',\n+        ],\n+        ROOT_URLCONF='',\n+        SECRET_KEY='test-secret-key',\n+        TEMPLATES=[{\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+            'DIRS': [],\n+            'APP_DIRS': True,\n+            'OPTIONS': {\n+                'context_processors': [\n+                    'django.template.context_processors.debug',\n+                    'django.template.context_processors.request',\n+                    'django.contrib.auth.context_processors.auth',\n+                    'django.contrib.messages.context_processors.messages',\n+                ],\n+            },\n+        }],\n+    )\n+\n+django.setup()\n+\n+# Now import Django modules\n+from django.db import models, connection, reset_queries\n+from django.contrib import admin\n+from django.test import RequestFactory\n+from django.contrib.admin.sites import AdminSite\n+from django.contrib.auth.models import User\n+\n+\n+# Define test models\n+class Client(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    contact_person = models.CharField('contact person', max_length=256, blank=True, null=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class ClientOffice(models.Model):\n+    name = models.CharField('name', max_length=256)\n+    name2 = models.CharField('unofficial or obsolete name', max_length=256, blank=True, null=True)\n+    client = models.ForeignKey(Client, verbose_name='client', on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+# Define admin\n+class ClientAdmin(admin.ModelAdmin):\n+    search_fields = ('name', 'name2', 'contact_person', 'clientoffice__name', 'clientoffice__name2')\n+\n+\n+def test_search_joins():\n+    \"\"\"Test that searching with multiple words creates multiple JOINs\"\"\"\n+    # Create tables\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Client)\n+        schema_editor.create_model(ClientOffice)\n+    \n+    # Create some test data\n+    client = Client.objects.create(name=\"Test Client\", name2=\"Alt Name\", contact_person=\"John Doe\")\n+    ClientOffice.objects.create(name=\"Main Office\", name2=\"HQ\", client=client)\n+    \n+    # Create admin instance\n+    site = AdminSite()\n+    client_admin = ClientAdmin(Client, site)\n+    \n+    # Create a mock request\n+    factory = RequestFactory()\n+    request = factory.get('/', {'q': 'test office main'})  # Multiple words\n+    request.user = User(username='test', is_superuser=True)\n+    \n+    # Reset queries\n+    reset_queries()\n+    \n+    # Get search results\n+    queryset = Client.objects.all()\n+    qs, may_have_duplicates = client_admin.get_search_results(request, queryset, 'test office main')\n+    \n+    # Force query execution\n+    list(qs)\n+    \n+    # Check the generated SQL\n+    queries = connection.queries\n+    print(\"\\nGenerated SQL queries:\")\n+    for i, query in enumerate(queries):\n+        print(f\"\\nQuery {i+1}:\")\n+        print(query['sql'])\n+    \n+    # Count JOINs in the query\n+    sql = queries[-1]['sql'] if queries else ''\n+    join_count = sql.upper().count('JOIN')\n+    print(f\"\\nNumber of JOINs: {join_count}\")\n+    \n+    # With the bug, we would see multiple JOINs for each search word\n+    # After fix, we should see fewer JOINs\n+    return join_count\n+\n+\n+if __name__ == '__main__':\n+    join_count = test_search_joins()\n+    print(f\"\\nTotal JOINs in search query: {join_count}\")\n+    print(\"\\nNote: With the bug, we expect to see multiple JOINs (one per search word)\")\n+    print(\"After the fix, we should see fewer JOINs\")\n", "gold_standard_diff": "From 76ccce64cc3d66cfec075651c3d2239fda747dc2 Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Tue, 5 Oct 2021 21:38:15 -0400\nSubject: [PATCH] Fixed #16063 -- Adjusted admin changelist searches spanning\n multi-valued relationships.\n\nThis reduces the likelihood of admin searches issuing queries with\nexcessive joins.\n---\n django/contrib/admin/options.py  |  4 ++-\n docs/ref/contrib/admin/index.txt | 32 ++++++++++++++++++++++++\n docs/releases/4.1.txt            | 20 +++++++++++++++\n docs/topics/db/queries.txt       |  2 ++\n tests/admin_changelist/admin.py  |  6 +++++\n tests/admin_changelist/tests.py  | 42 +++++++++++++++++++++++++++++---\n 6 files changed, 102 insertions(+), 4 deletions(-)\n\ndiff --git a/django/contrib/admin/options.py b/django/contrib/admin/options.py\nindex 66f3396a6b31..c5968a79ed90 100644\n--- a/django/contrib/admin/options.py\n+++ b/django/contrib/admin/options.py\n@@ -1031,6 +1031,7 @@ def construct_search(field_name):\n         if search_fields and search_term:\n             orm_lookups = [construct_search(str(search_field))\n                            for search_field in search_fields]\n+            term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n@@ -1038,7 +1039,8 @@ def construct_search(field_name):\n                     *((orm_lookup, bit) for orm_lookup in orm_lookups),\n                     _connector=models.Q.OR,\n                 )\n-                queryset = queryset.filter(or_queries)\n+                term_queries.append(or_queries)\n+            queryset = queryset.filter(models.Q(*term_queries))\n             may_have_duplicates |= any(\n                 lookup_spawns_duplicates(self.opts, search_spec)\n                 for search_spec in orm_lookups\ndiff --git a/docs/ref/contrib/admin/index.txt b/docs/ref/contrib/admin/index.txt\nindex 5caea603c1ae..ac8f44b76560 100644\n--- a/docs/ref/contrib/admin/index.txt\n+++ b/docs/ref/contrib/admin/index.txt\n@@ -1185,6 +1185,22 @@ subclass::\n     :meth:`ModelAdmin.get_search_results` to provide additional or alternate\n     search behavior.\n \n+    .. versionchanged:: 4.1\n+\n+        Searches using multiple search terms are now applied in a single call\n+        to ``filter()``, rather than in sequential ``filter()`` calls.\n+\n+        For multi-valued relationships, this means that rows from the related\n+        model must match all terms rather than any term. For example, if\n+        ``search_fields`` is set to ``['child__name', 'child__age']``, and a\n+        user searches for ``'Jamal 17'``, parent rows will be returned only if\n+        there is a relationship to some 17-year-old child named Jamal, rather\n+        than also returning parents who merely have a younger or older child\n+        named Jamal in addition to some other 17-year-old.\n+\n+        See the :ref:`spanning-multi-valued-relationships` topic for more\n+        discussion of this difference.\n+\n .. attribute:: ModelAdmin.search_help_text\n \n     .. versionadded:: 4.0\n@@ -1403,6 +1419,22 @@ templates used by the :class:`ModelAdmin` views:\n     field, for example ``... OR UPPER(\"polls_choice\".\"votes\"::text) = UPPER('4')``\n     on PostgreSQL.\n \n+    .. versionchanged:: 4.1\n+\n+        Searches using multiple search terms are now applied in a single call\n+        to ``filter()``, rather than in sequential ``filter()`` calls.\n+\n+        For multi-valued relationships, this means that rows from the related\n+        model must match all terms rather than any term. For example, if\n+        ``search_fields`` is set to ``['child__name', 'child__age']``, and a\n+        user searches for ``'Jamal 17'``, parent rows will be returned only if\n+        there is a relationship to some 17-year-old child named Jamal, rather\n+        than also returning parents who merely have a younger or older child\n+        named Jamal in addition to some other 17-year-old.\n+\n+        See the :ref:`spanning-multi-valued-relationships` topic for more\n+        discussion of this difference.\n+\n .. method:: ModelAdmin.save_related(request, form, formsets, change)\n \n     The ``save_related`` method is given the ``HttpRequest``, the parent\ndiff --git a/docs/releases/4.1.txt b/docs/releases/4.1.txt\nindex 3fdd7f53c6fb..5f184d234904 100644\n--- a/docs/releases/4.1.txt\n+++ b/docs/releases/4.1.txt\n@@ -290,6 +290,26 @@ Dropped support for MariaDB 10.2\n Upstream support for MariaDB 10.2 ends in May 2022. Django 4.1 supports MariaDB\n 10.3 and higher.\n \n+Admin changelist searches spanning multi-valued relationships changes\n+---------------------------------------------------------------------\n+\n+Admin changelist searches using multiple search terms are now applied in a\n+single call to ``filter()``, rather than in sequential ``filter()`` calls.\n+\n+For multi-valued relationships, this means that rows from the related model\n+must match all terms rather than any term. For example, if ``search_fields``\n+is set to ``['child__name', 'child__age']``, and a user searches for\n+``'Jamal 17'``, parent rows will be returned only if there is a relationship to\n+some 17-year-old child named Jamal, rather than also returning parents who\n+merely have a younger or older child named Jamal in addition to some other\n+17-year-old.\n+\n+See the :ref:`spanning-multi-valued-relationships` topic for more discussion of\n+this difference. In Django 4.0 and earlier,\n+:meth:`~django.contrib.admin.ModelAdmin.get_search_results` followed the\n+second example query, but this undocumented behavior led to queries with\n+excessive joins.\n+\n Miscellaneous\n -------------\n \ndiff --git a/docs/topics/db/queries.txt b/docs/topics/db/queries.txt\nindex c24c06da686b..eb68c7b4dade 100644\n--- a/docs/topics/db/queries.txt\n+++ b/docs/topics/db/queries.txt\n@@ -525,6 +525,8 @@ those latter objects, you could write::\n \n     Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)\n \n+.. _spanning-multi-valued-relationships:\n+\n Spanning multi-valued relationships\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \ndiff --git a/tests/admin_changelist/admin.py b/tests/admin_changelist/admin.py\nindex f8051f64fa07..929539ea88bc 100644\n--- a/tests/admin_changelist/admin.py\n+++ b/tests/admin_changelist/admin.py\n@@ -36,6 +36,12 @@ class ParentAdmin(admin.ModelAdmin):\n     list_select_related = ['child']\n \n \n+class ParentAdminTwoSearchFields(admin.ModelAdmin):\n+    list_filter = ['child__name']\n+    search_fields = ['child__name', 'child__age']\n+    list_select_related = ['child']\n+\n+\n class ChildAdmin(admin.ModelAdmin):\n     list_display = ['name', 'parent']\n     list_per_page = 10\ndiff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 92ea0dd71874..86fcab531a93 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -30,8 +30,8 @@\n     DynamicListDisplayLinksChildAdmin, DynamicListFilterChildAdmin,\n     DynamicSearchFieldsChildAdmin, EmptyValueChildAdmin, EventAdmin,\n     FilteredChildAdmin, GroupAdmin, InvitationAdmin,\n-    NoListDisplayLinksParentAdmin, ParentAdmin, QuartetAdmin, SwallowAdmin,\n-    site as custom_site,\n+    NoListDisplayLinksParentAdmin, ParentAdmin, ParentAdminTwoSearchFields,\n+    QuartetAdmin, SwallowAdmin, site as custom_site,\n )\n from .models import (\n     Band, CharPK, Child, ChordsBand, ChordsMusician, Concert, CustomIdUser,\n@@ -153,6 +153,42 @@ def get_list_select_related(self, request):\n         cl = ia.get_changelist_instance(request)\n         self.assertEqual(cl.queryset.query.select_related, {'player': {}, 'band': {}})\n \n+    def test_many_search_terms(self):\n+        parent = Parent.objects.create(name='Mary')\n+        Child.objects.create(parent=parent, name='Danielle')\n+        Child.objects.create(parent=parent, name='Daniel')\n+\n+        m = ParentAdmin(Parent, custom_site)\n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'daniel ' * 80})\n+        request.user = self.superuser\n+\n+        cl = m.get_changelist_instance(request)\n+        with CaptureQueriesContext(connection) as context:\n+            object_count = cl.queryset.count()\n+        self.assertEqual(object_count, 1)\n+        self.assertEqual(context.captured_queries[0]['sql'].count('JOIN'), 1)\n+\n+    def test_related_field_multiple_search_terms(self):\n+        \"\"\"\n+        Searches over multi-valued relationships return rows from related\n+        models only when all searched fields match that row.\n+        \"\"\"\n+        parent = Parent.objects.create(name='Mary')\n+        Child.objects.create(parent=parent, name='Danielle', age=18)\n+        Child.objects.create(parent=parent, name='Daniel', age=19)\n+\n+        m = ParentAdminTwoSearchFields(Parent, custom_site)\n+\n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'danielle 19'})\n+        request.user = self.superuser\n+        cl = m.get_changelist_instance(request)\n+        self.assertEqual(cl.queryset.count(), 0)\n+\n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'daniel 19'})\n+        request.user = self.superuser\n+        cl = m.get_changelist_instance(request)\n+        self.assertEqual(cl.queryset.count(), 1)\n+\n     def test_result_list_empty_changelist_value(self):\n         \"\"\"\n         Regression test for #14982: EMPTY_CHANGELIST_VALUE should be honored\n@@ -555,7 +591,7 @@ def test_multiple_search_fields(self):\n             ('Finlayson', 1),\n             ('Finlayson Hype', 0),\n             ('Jonathan Finlayson Duo', 1),\n-            ('Mary Jonathan Duo', 1),\n+            ('Mary Jonathan Duo', 0),\n             ('Oscar Finlayson Duo', 0),\n         ):\n             with self.subTest(search_string=search_string):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15022"}