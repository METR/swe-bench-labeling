diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index d65141b834..74c1afd7a1 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1894,8 +1894,12 @@ class Query(BaseExpression):
         expressions.
 
         If 'ordering' is empty, clear all ordering from the query.
+
+        For self-referencing foreign keys, this method appends '__id' to the
+        field name to ensure correct ordering.
         """
         errors = []
+        new_ordering = []
         for item in ordering:
             if isinstance(item, str):
                 if '.' in item:
@@ -1908,18 +1912,37 @@ class Query(BaseExpression):
                     )
                     continue
                 if item == '?':
+                    new_ordering.append(item)
                     continue
-                if item.startswith('-'):
+                desc = item.startswith('-')
+                if desc:
                     item = item[1:]
                 if item in self.annotations:
+                    new_ordering.append(item if not desc else '-' + item)
                     continue
                 if self.extra and item in self.extra:
+                    new_ordering.append(item if not desc else '-' + item)
                     continue
+                # Handle self-referencing foreign key
+                parts = item.split(LOOKUP_SEP)
+                if len(parts) > 1:
+                    field_name = parts[-1]
+                    try:
+                        field = self.model._meta.get_field(field_name)
+                        if field.remote_field and field.remote_field.model == self.model:
+                            new_item = f"{item}__id"
+                            new_ordering.append(new_item if not desc else '-' + new_item)
+                            continue
+                    except FieldDoesNotExist:
+                        pass
                 # names_to_path() validates the lookup. A descriptive
-                # FieldError will be raise if it's not.
-                self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)
+                # FieldError will be raised if it's not.
+                self.names_to_path(parts, self.model._meta)
+                new_ordering.append(item if not desc else '-' + item)
             elif not hasattr(item, 'resolve_expression'):
                 errors.append(item)
+            else:
+                new_ordering.append(item)
             if getattr(item, 'contains_aggregate', False):
                 raise FieldError(
                     'Using an aggregate in order_by() without also including '
@@ -1927,8 +1950,8 @@ class Query(BaseExpression):
                 )
         if errors:
             raise FieldError('Invalid order_by arguments: %s' % errors)
-        if ordering:
-            self.order_by += ordering
+        if new_ordering:
+            self.order_by += tuple(new_ordering)
         else:
             self.default_ordering = False
 
