{"instance_id": "django__django-7530", "score": "C", "diff": "diff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py\nindex 0b39536f5b..e648880ef0 100644\n--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -105,7 +105,7 @@ class Command(BaseCommand):\n                     # At least one model must be migrated to the database.\n                     router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n                     for app_label in consistency_check_labels\n-                    for model in apps.get_models(app_label)\n+                    for model in apps.get_app_config(app_label).get_models()\n             )):\n                 loader.check_consistent_history(connection)\n \ndiff --git a/django/core/management/commands/makemigrations.py.backup b/django/core/management/commands/makemigrations.py.backup\nnew file mode 100644\nindex 0000000000..0b39536f5b\n--- /dev/null\n+++ b/django/core/management/commands/makemigrations.py.backup\n@@ -0,0 +1,322 @@\n+import io\n+import os\n+import sys\n+import warnings\n+from itertools import takewhile\n+\n+from django.apps import apps\n+from django.conf import settings\n+from django.core.management.base import BaseCommand, CommandError\n+from django.db import DEFAULT_DB_ALIAS, connections, router\n+from django.db.migrations import Migration\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.loader import MigrationLoader\n+from django.db.migrations.questioner import (\n+    InteractiveMigrationQuestioner, MigrationQuestioner,\n+    NonInteractiveMigrationQuestioner,\n+)\n+from django.db.migrations.state import ProjectState\n+from django.db.migrations.utils import get_migration_name_timestamp\n+from django.db.migrations.writer import MigrationWriter\n+from django.utils.deprecation import RemovedInDjango20Warning\n+from django.utils.six import iteritems\n+from django.utils.six.moves import zip\n+\n+\n+class Command(BaseCommand):\n+    help = \"Creates new migration(s) for apps.\"\n+\n+    def add_arguments(self, parser):\n+        parser.add_argument(\n+            'args', metavar='app_label', nargs='*',\n+            help='Specify the app label(s) to create migrations for.',\n+        )\n+        parser.add_argument(\n+            '--dry-run', action='store_true', dest='dry_run', default=False,\n+            help=\"Just show what migrations would be made; don't actually write them.\",\n+        )\n+        parser.add_argument(\n+            '--merge', action='store_true', dest='merge', default=False,\n+            help=\"Enable fixing of migration conflicts.\",\n+        )\n+        parser.add_argument(\n+            '--empty', action='store_true', dest='empty', default=False,\n+            help=\"Create an empty migration.\",\n+        )\n+        parser.add_argument(\n+            '--noinput', '--no-input',\n+            action='store_false', dest='interactive', default=True,\n+            help='Tells Django to NOT prompt the user for input of any kind.',\n+        )\n+        parser.add_argument(\n+            '-n', '--name', action='store', dest='name', default=None,\n+            help=\"Use this name for migration file(s).\",\n+        )\n+        parser.add_argument(\n+            '-e', '--exit', action='store_true', dest='exit_code', default=False,\n+            help='Exit with error code 1 if no changes needing migrations are found. '\n+                 'Deprecated, use the --check option instead.',\n+        )\n+        parser.add_argument(\n+            '--check', action='store_true', dest='check_changes',\n+            help='Exit with a non-zero status if model changes are missing migrations.',\n+        )\n+\n+    def handle(self, *app_labels, **options):\n+        self.verbosity = options['verbosity']\n+        self.interactive = options['interactive']\n+        self.dry_run = options['dry_run']\n+        self.merge = options['merge']\n+        self.empty = options['empty']\n+        self.migration_name = options['name']\n+        self.exit_code = options['exit_code']\n+        check_changes = options['check_changes']\n+\n+        if self.exit_code:\n+            warnings.warn(\n+                \"The --exit option is deprecated in favor of the --check option.\",\n+                RemovedInDjango20Warning\n+            )\n+\n+        # Make sure the app they asked for exists\n+        app_labels = set(app_labels)\n+        bad_app_labels = set()\n+        for app_label in app_labels:\n+            try:\n+                apps.get_app_config(app_label)\n+            except LookupError:\n+                bad_app_labels.add(app_label)\n+        if bad_app_labels:\n+            for app_label in bad_app_labels:\n+                self.stderr.write(\"App '%s' could not be found. Is it in INSTALLED_APPS?\" % app_label)\n+            sys.exit(2)\n+\n+        # Load the current graph state. Pass in None for the connection so\n+        # the loader doesn't try to resolve replaced migrations from DB.\n+        loader = MigrationLoader(None, ignore_no_migrations=True)\n+\n+        # Raise an error if any migrations are applied before their dependencies.\n+        consistency_check_labels = set(config.label for config in apps.get_app_configs())\n+        # Non-default databases are only checked if database routers used.\n+        aliases_to_check = connections if settings.DATABASE_ROUTERS else [DEFAULT_DB_ALIAS]\n+        for alias in sorted(aliases_to_check):\n+            connection = connections[alias]\n+            if (connection.settings_dict['ENGINE'] != 'django.db.backends.dummy' and any(\n+                    # At least one model must be migrated to the database.\n+                    router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n+                    for app_label in consistency_check_labels\n+                    for model in apps.get_models(app_label)\n+            )):\n+                loader.check_consistent_history(connection)\n+\n+        # Before anything else, see if there's conflicting apps and drop out\n+        # hard if there are any and they don't want to merge\n+        conflicts = loader.detect_conflicts()\n+\n+        # If app_labels is specified, filter out conflicting migrations for unspecified apps\n+        if app_labels:\n+            conflicts = {\n+                app_label: conflict for app_label, conflict in iteritems(conflicts)\n+                if app_label in app_labels\n+            }\n+\n+        if conflicts and not self.merge:\n+            name_str = \"; \".join(\n+                \"%s in %s\" % (\", \".join(names), app)\n+                for app, names in conflicts.items()\n+            )\n+            raise CommandError(\n+                \"Conflicting migrations detected; multiple leaf nodes in the \"\n+                \"migration graph: (%s).\\nTo fix them run \"\n+                \"'python manage.py makemigrations --merge'\" % name_str\n+            )\n+\n+        # If they want to merge and there's nothing to merge, then politely exit\n+        if self.merge and not conflicts:\n+            self.stdout.write(\"No conflicts detected to merge.\")\n+            return\n+\n+        # If they want to merge and there is something to merge, then\n+        # divert into the merge code\n+        if self.merge and conflicts:\n+            return self.handle_merge(loader, conflicts)\n+\n+        if self.interactive:\n+            questioner = InteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)\n+        else:\n+            questioner = NonInteractiveMigrationQuestioner(specified_apps=app_labels, dry_run=self.dry_run)\n+        # Set up autodetector\n+        autodetector = MigrationAutodetector(\n+            loader.project_state(),\n+            ProjectState.from_apps(apps),\n+            questioner,\n+        )\n+\n+        # If they want to make an empty migration, make one for each app\n+        if self.empty:\n+            if not app_labels:\n+                raise CommandError(\"You must supply at least one app label when using --empty.\")\n+            # Make a fake changes() result we can pass to arrange_for_graph\n+            changes = {\n+                app: [Migration(\"custom\", app)]\n+                for app in app_labels\n+            }\n+            changes = autodetector.arrange_for_graph(\n+                changes=changes,\n+                graph=loader.graph,\n+                migration_name=self.migration_name,\n+            )\n+            self.write_migration_files(changes)\n+            return\n+\n+        # Detect changes\n+        changes = autodetector.changes(\n+            graph=loader.graph,\n+            trim_to_apps=app_labels or None,\n+            convert_apps=app_labels or None,\n+            migration_name=self.migration_name,\n+        )\n+\n+        if not changes:\n+            # No changes? Tell them.\n+            if self.verbosity >= 1:\n+                if len(app_labels) == 1:\n+                    self.stdout.write(\"No changes detected in app '%s'\" % app_labels.pop())\n+                elif len(app_labels) > 1:\n+                    self.stdout.write(\"No changes detected in apps '%s'\" % (\"', '\".join(app_labels)))\n+                else:\n+                    self.stdout.write(\"No changes detected\")\n+\n+            if self.exit_code:\n+                sys.exit(1)\n+        else:\n+            self.write_migration_files(changes)\n+            if check_changes:\n+                sys.exit(1)\n+\n+    def write_migration_files(self, changes):\n+        \"\"\"\n+        Takes a changes dict and writes them out as migration files.\n+        \"\"\"\n+        directory_created = {}\n+        for app_label, app_migrations in changes.items():\n+            if self.verbosity >= 1:\n+                self.stdout.write(self.style.MIGRATE_HEADING(\"Migrations for '%s':\" % app_label) + \"\\n\")\n+            for migration in app_migrations:\n+                # Describe the migration\n+                writer = MigrationWriter(migration)\n+                if self.verbosity >= 1:\n+                    # Display a relative path if it's below the current working\n+                    # directory, or an absolute path otherwise.\n+                    try:\n+                        migration_string = os.path.relpath(writer.path)\n+                    except ValueError:\n+                        migration_string = writer.path\n+                    if migration_string.startswith('..'):\n+                        migration_string = writer.path\n+                    self.stdout.write(\"  %s:\\n\" % (self.style.MIGRATE_LABEL(migration_string),))\n+                    for operation in migration.operations:\n+                        self.stdout.write(\"    - %s\\n\" % operation.describe())\n+                if not self.dry_run:\n+                    # Write the migrations file to the disk.\n+                    migrations_directory = os.path.dirname(writer.path)\n+                    if not directory_created.get(app_label):\n+                        if not os.path.isdir(migrations_directory):\n+                            os.mkdir(migrations_directory)\n+                        init_path = os.path.join(migrations_directory, \"__init__.py\")\n+                        if not os.path.isfile(init_path):\n+                            open(init_path, \"w\").close()\n+                        # We just do this once per app\n+                        directory_created[app_label] = True\n+                    migration_string = writer.as_string()\n+                    with io.open(writer.path, \"w\", encoding='utf-8') as fh:\n+                        fh.write(migration_string)\n+                elif self.verbosity == 3:\n+                    # Alternatively, makemigrations --dry-run --verbosity 3\n+                    # will output the migrations to stdout rather than saving\n+                    # the file to the disk.\n+                    self.stdout.write(self.style.MIGRATE_HEADING(\n+                        \"Full migrations file '%s':\" % writer.filename) + \"\\n\"\n+                    )\n+                    self.stdout.write(\"%s\\n\" % writer.as_string())\n+\n+    def handle_merge(self, loader, conflicts):\n+        \"\"\"\n+        Handles merging together conflicted migrations interactively,\n+        if it's safe; otherwise, advises on how to fix it.\n+        \"\"\"\n+        if self.interactive:\n+            questioner = InteractiveMigrationQuestioner()\n+        else:\n+            questioner = MigrationQuestioner(defaults={'ask_merge': True})\n+\n+        for app_label, migration_names in conflicts.items():\n+            # Grab out the migrations in question, and work out their\n+            # common ancestor.\n+            merge_migrations = []\n+            for migration_name in migration_names:\n+                migration = loader.get_migration(app_label, migration_name)\n+                migration.ancestry = [\n+                    mig for mig in loader.graph.forwards_plan((app_label, migration_name))\n+                    if mig[0] == migration.app_label\n+                ]\n+                merge_migrations.append(migration)\n+\n+            def all_items_equal(seq):\n+                return all(item == seq[0] for item in seq[1:])\n+\n+            merge_migrations_generations = zip(*[m.ancestry for m in merge_migrations])\n+            common_ancestor_count = sum(1 for common_ancestor_generation\n+                                        in takewhile(all_items_equal, merge_migrations_generations))\n+            if not common_ancestor_count:\n+                raise ValueError(\"Could not find common ancestor of %s\" % migration_names)\n+            # Now work out the operations along each divergent branch\n+            for migration in merge_migrations:\n+                migration.branch = migration.ancestry[common_ancestor_count:]\n+                migrations_ops = (loader.get_migration(node_app, node_name).operations\n+                                  for node_app, node_name in migration.branch)\n+                migration.merged_operations = sum(migrations_ops, [])\n+            # In future, this could use some of the Optimizer code\n+            # (can_optimize_through) to automatically see if they're\n+            # mergeable. For now, we always just prompt the user.\n+            if self.verbosity > 0:\n+                self.stdout.write(self.style.MIGRATE_HEADING(\"Merging %s\" % app_label))\n+                for migration in merge_migrations:\n+                    self.stdout.write(self.style.MIGRATE_LABEL(\"  Branch %s\" % migration.name))\n+                    for operation in migration.merged_operations:\n+                        self.stdout.write(\"    - %s\\n\" % operation.describe())\n+            if questioner.ask_merge(app_label):\n+                # If they still want to merge it, then write out an empty\n+                # file depending on the migrations needing merging.\n+                numbers = [\n+                    MigrationAutodetector.parse_number(migration.name)\n+                    for migration in merge_migrations\n+                ]\n+                try:\n+                    biggest_number = max(x for x in numbers if x is not None)\n+                except ValueError:\n+                    biggest_number = 1\n+                subclass = type(\"Migration\", (Migration, ), {\n+                    \"dependencies\": [(app_label, migration.name) for migration in merge_migrations],\n+                })\n+                migration_name = \"%04i_%s\" % (\n+                    biggest_number + 1,\n+                    self.migration_name or (\"merge_%s\" % get_migration_name_timestamp())\n+                )\n+                new_migration = subclass(migration_name, app_label)\n+                writer = MigrationWriter(new_migration)\n+\n+                if not self.dry_run:\n+                    # Write the merge migrations file to the disk\n+                    with io.open(writer.path, \"w\", encoding='utf-8') as fh:\n+                        fh.write(writer.as_string())\n+                    if self.verbosity > 0:\n+                        self.stdout.write(\"\\nCreated new merge migration %s\" % writer.path)\n+                elif self.verbosity == 3:\n+                    # Alternatively, makemigrations --merge --dry-run --verbosity 3\n+                    # will output the merge migrations to stdout rather than saving\n+                    # the file to the disk.\n+                    self.stdout.write(self.style.MIGRATE_HEADING(\n+                        \"Full merge migrations file '%s':\" % writer.filename) + \"\\n\"\n+                    )\n+                    self.stdout.write(\"%s\\n\" % writer.as_string())\n", "gold_standard_diff": "From 65072ced02cbdb3e631d0d88fb6706d472c95957 Mon Sep 17 00:00:00 2001\nFrom: Joseph Kahn <josephbkahn@gmail.com>\nDate: Tue, 8 Nov 2016 12:26:34 -0500\nSubject: [PATCH] Fixed #27461 -- Fixed incorrect allow_migrate() arguments in\n makemigrations.\n\n---\n django/core/management/commands/makemigrations.py |  2 +-\n docs/releases/1.10.4.txt                          |  4 ++++\n tests/migrations/test_commands.py                 | 11 ++++++++++-\n 3 files changed, 15 insertions(+), 2 deletions(-)\n\ndiff --git a/django/core/management/commands/makemigrations.py b/django/core/management/commands/makemigrations.py\nindex 0b39536f5b7f..e648880ef006 100644\n--- a/django/core/management/commands/makemigrations.py\n+++ b/django/core/management/commands/makemigrations.py\n@@ -105,7 +105,7 @@ def handle(self, *app_labels, **options):\n                     # At least one model must be migrated to the database.\n                     router.allow_migrate(connection.alias, app_label, model_name=model._meta.object_name)\n                     for app_label in consistency_check_labels\n-                    for model in apps.get_models(app_label)\n+                    for model in apps.get_app_config(app_label).get_models()\n             )):\n                 loader.check_consistent_history(connection)\n \ndiff --git a/docs/releases/1.10.4.txt b/docs/releases/1.10.4.txt\nindex c9c6181beb19..3304df907135 100644\n--- a/docs/releases/1.10.4.txt\n+++ b/docs/releases/1.10.4.txt\n@@ -12,3 +12,7 @@ Bugfixes\n * Quoted the Oracle test user's password in queries to fix the \"ORA-00922:\n   missing or invalid option\" error when the password starts with a number or\n   special character (:ticket:`27420`).\n+\n+* Fixed incorrect ``app_label`` / ``model_name`` arguments for\n+  ``allow_migrate()`` in ``makemigrations`` migration consistency checks\n+  (:ticket:`27461`).\ndiff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex fb2b0fb87762..e138ef40bfd5 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -598,6 +598,7 @@ def test_makemigrations_empty_connections(self):\n                 init_file = os.path.join(migration_dir, '__init__.py')\n                 self.assertTrue(os.path.exists(init_file))\n \n+    @override_settings(INSTALLED_APPS=['migrations', 'migrations2'])\n     def test_makemigrations_consistency_checks_respect_routers(self):\n         \"\"\"\n         The history consistency checks in makemigrations respect\n@@ -638,7 +639,15 @@ def patched_ensure_schema(migration_recorder):\n                 with self.settings(DATABASE_ROUTERS=['migrations.routers.TestRouter']):\n                     with mock.patch.object(TestRouter, 'allow_migrate', return_value=False) as allow_migrate:\n                         call_command('makemigrations', 'migrations', verbosity=0)\n-                allow_migrate.assert_called_with('other', 'migrations', model_name='UnicodeModel')\n+                allow_migrate.assert_any_call('other', 'migrations', model_name='UnicodeModel')\n+                # allow_migrate() is called with the correct arguments.\n+                self.assertGreater(len(allow_migrate.mock_calls), 0)\n+                for mock_call in allow_migrate.mock_calls:\n+                    _, call_args, call_kwargs = mock_call\n+                    connection_alias, app_name = call_args\n+                    self.assertIn(connection_alias, ['default', 'other'])\n+                    # Raises an error if invalid app_name/model_name occurs.\n+                    apps.get_app_config(app_name).get_model(call_kwargs['model_name'])\n                 self.assertEqual(ensure_schema.call_count, 4)\n \n     def test_failing_migration(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/7530"}