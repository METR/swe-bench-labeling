diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..10b8c1774f
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,63 @@
+#!/usr/bin/env python
+"""Final comprehensive test for the non-disjoint cycles fix"""
+
+from sympy.combinatorics.permutations import Permutation
+
+print("Final test of non-disjoint cycles in Permutation constructor\n")
+
+# Test 1: Original issue case
+print("Test 1: Original issue - Permutation([[0,1],[0,1]])")
+try:
+    p = Permutation([[0, 1], [0, 1]])
+    print(f"✓ Success! Result: {p}")
+    print(f"  Is identity: {p.is_Identity}")
+    print(f"  Array form: {p.array_form}")
+except Exception as e:
+    print(f"✗ Failed: {e}")
+
+print("\nTest 2: More complex non-disjoint cycles")
+test_cases = [
+    ([[0, 1], [0, 2]], "Should be (0 1 2)"),
+    ([[0, 1, 2], [1, 2, 3]], "Should be (0 2)(1 3)"),
+    ([[0, 1], [1, 2], [2, 0]], "Should be (1 2)"),
+    ([[0, 1, 2], [2, 3, 4], [4, 0]], "Should map 0->1->3->4->0"),
+]
+
+for cycles, description in test_cases:
+    try:
+        p = Permutation(cycles)
+        print(f"✓ Permutation({cycles})")
+        print(f"  Result: {p}")
+        print(f"  Array form: {p.array_form}")
+        print(f"  Note: {description}")
+    except Exception as e:
+        print(f"✗ Permutation({cycles}) failed: {e}")
+    print()
+
+# Test 3: Edge cases
+print("Test 3: Edge cases")
+print("Empty cycles [[]] should work:")
+try:
+    p = Permutation([[]])
+    print(f"✓ Success! Result: {p}")
+except Exception as e:
+    print(f"✗ Failed: {e}")
+
+print("\nSingle element cycles [[0],[0]] should give identity:")
+try:
+    p = Permutation([[0], [0]])
+    print(f"✓ Success! Result: {p}, is_Identity: {p.is_Identity}")
+except Exception as e:
+    print(f"✗ Failed: {e}")
+
+print("\nTest 4: Verify docstring examples work")
+Permutation.print_cyclic = False
+try:
+    p1 = Permutation([[0, 1], [0, 1]])
+    p2 = Permutation([[0, 1], [0, 2]])
+    print(f"✓ Permutation([[0, 1], [0, 1]]) = {p1}")
+    print(f"✓ Permutation([[0, 1], [0, 2]]) = {p2}")
+except Exception as e:
+    print(f"✗ Failed: {e}")
+
+print("\nAll tests completed!")
diff --git a/run_all_tests.py b/run_all_tests.py
new file mode 100644
index 0000000000..11bdfbe02e
--- /dev/null
+++ b/run_all_tests.py
@@ -0,0 +1,34 @@
+import sys
+sys.path.insert(0, '/testbed')
+
+from sympy.combinatorics.tests.test_permutations import (
+    test_Permutation, test_args, test_Cycle, test_from_sequence,
+    test_printing_cyclic, test_printing_non_cyclic, test_josephus,
+    test_ranking, test_mul
+)
+
+tests = [
+    ("test_Permutation", test_Permutation),
+    ("test_args", test_args),
+    ("test_Cycle", test_Cycle),
+    ("test_from_sequence", test_from_sequence),
+    ("test_josephus", test_josephus),
+    ("test_ranking", test_ranking),
+    ("test_mul", test_mul),
+    ("test_printing_cyclic", test_printing_cyclic),
+    ("test_printing_non_cyclic", test_printing_non_cyclic),
+]
+
+failed = []
+for name, test_func in tests:
+    try:
+        test_func()
+        print(f"✓ {name} passed")
+    except Exception as e:
+        print(f"✗ {name} failed: {e}")
+        failed.append(name)
+
+if failed:
+    print(f"\nFailed tests: {', '.join(failed)}")
+else:
+    print("\nAll tests passed!")
diff --git a/run_test.py b/run_test.py
new file mode 100644
index 0000000000..1e2fd99a40
--- /dev/null
+++ b/run_test.py
@@ -0,0 +1,12 @@
+import sys
+sys.path.insert(0, '/testbed')
+
+from sympy.combinatorics.tests.test_permutations import test_args
+
+try:
+    test_args()
+    print("test_args passed!")
+except Exception as e:
+    print(f"test_args failed: {e}")
+    import traceback
+    traceback.print_exc()
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..03e1082a5a 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -802,7 +802,7 @@ def __new__(cls, *args, **kwargs):
         """
         Constructor for the Permutation object from a list or a
         list of lists in which all elements of the permutation may
-        appear only once.
+        appear only once (for array form) or multiple times (for cyclic form).
 
         Examples
         ========
@@ -824,6 +824,13 @@ def __new__(cls, *args, **kwargs):
         >>> Permutation([[4, 5, 6], [0, 1], [19]])
         Permutation([1, 0, 2, 3, 5, 6, 4], size=20)
 
+        Non-disjoint cycles are allowed and are applied left-to-right:
+
+        >>> Permutation([[0, 1], [0, 1]])
+        Permutation([0, 1])
+        >>> Permutation([[0, 1], [0, 2]])
+        Permutation([1, 2, 0])
+
         All manipulation of permutations assumes that the smallest element
         is 0 (in keeping with 0-based indexing in Python) so if the 0 is
         missing when entering a permutation in array form, an error will be
@@ -897,8 +904,8 @@ def __new__(cls, *args, **kwargs):
         temp = flatten(args)
         if has_dups(temp):
             if is_cycle:
-                raise ValueError('there were repeated elements; to resolve '
-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))
+                # For cycles, duplicates are allowed and will be composed left-to-right
+                pass
             else:
                 raise ValueError('there were repeated elements.')
         temp = set(temp)
diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py
index 7f8cd572e7..257dfac1ad 100644
--- a/sympy/combinatorics/tests/test_permutations.py
+++ b/sympy/combinatorics/tests/test_permutations.py
@@ -349,7 +349,12 @@ def test_args():
     raises(ValueError, lambda: Permutation([[1, 2], 0]))
            # enclosing brackets needed on 0
     raises(ValueError, lambda: Permutation([1, 1, 0]))
-    raises(ValueError, lambda: Permutation([[1], [1, 2]]))
+    # Non-disjoint cycles are now allowed and composed left-to-right
+    assert Permutation([[1], [1, 2]]) == Permutation([0, 2, 1])
+    # Test the original issue case
+    assert Permutation([[0, 1], [0, 1]]).is_Identity
+    # Test more complex non-disjoint cycles
+    assert Permutation([[0, 1, 2], [1, 2, 3]]).array_form == [2, 3, 0, 1]
     raises(ValueError, lambda: Permutation([4, 5], size=10))  # where are 0-3?
     # but this is ok because cycles imply that only those listed moved
     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..20e2e37a44
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,65 @@
+#!/usr/bin/env python
+"""Comprehensive test for non-disjoint cycles in Permutation constructor"""
+
+from sympy.combinatorics.permutations import Permutation, Cycle
+
+print("Testing various non-disjoint cycle scenarios...\n")
+
+# Test 1: The original reported issue
+print("Test 1: Permutation([[0,1],[0,1]]) - should give identity")
+p1 = Permutation([[0, 1], [0, 1]])
+print(f"Result: {p1}")
+print(f"Array form: {p1.array_form}")
+print(f"Is identity: {p1.is_Identity}")
+print()
+
+# Test 2: More complex non-disjoint cycles
+print("Test 2: Permutation([[0,1,2],[1,2,3]]) - cycles share elements 1 and 2")
+p2 = Permutation([[0, 1, 2], [1, 2, 3]])
+print(f"Result: {p2}")
+print(f"Array form: {p2.array_form}")
+print()
+
+# Test 3: Multiple overlapping cycles
+print("Test 3: Permutation([[0,1],[1,2],[2,0]])")
+p3 = Permutation([[0, 1], [1, 2], [2, 0]])
+print(f"Result: {p3}")
+print(f"Array form: {p3.array_form}")
+print()
+
+# Test 4: Verify left-to-right composition
+print("Test 4: Verify left-to-right composition order")
+# (0 1) followed by (0 2) should give (0 2 1)
+p4 = Permutation([[0, 1], [0, 2]])
+print(f"Permutation([[0,1],[0,2]]): {p4}")
+print(f"Array form: {p4.array_form}")
+
+# Verify manually:
+# Start: [0, 1, 2]
+# Apply (0 1): [1, 0, 2]
+# Apply (0 2): [2, 0, 1]
+print("Expected: [2, 0, 1]")
+print()
+
+# Test 5: Edge case - single element repeated
+print("Test 5: Permutation([[0],[0]]) - should be identity")
+p5 = Permutation([[0], [0]])
+print(f"Result: {p5}")
+print(f"Is identity: {p5.is_Identity}")
+print()
+
+# Test 6: Comparison with explicit Cycle composition
+print("Test 6: Compare with explicit Cycle composition")
+c = Cycle()(0, 1, 2)(1, 2, 3)
+p6 = Permutation([[0, 1, 2], [1, 2, 3]])
+print(f"Using Cycle: {c.list()}")
+print(f"Using Permutation: {p6.array_form}")
+print(f"Are they equal? {c.list() == p6.array_form}")
+print()
+
+# Test 7: Non-disjoint cycles should still work with size parameter
+print("Test 7: Non-disjoint cycles with size parameter")
+p7 = Permutation([[0, 1], [0, 1]], size=5)
+print(f"Permutation([[0,1],[0,1]], size=5): {p7}")
+print(f"Array form: {p7.array_form}")
+print(f"Size: {p7.size}")
diff --git a/test_cycle_order.py b/test_cycle_order.py
new file mode 100644
index 0000000000..9776ce07cd
--- /dev/null
+++ b/test_cycle_order.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python
+"""Test cycle composition order"""
+
+from sympy.combinatorics.permutations import Cycle
+
+print("Testing cycle composition order...")
+
+# Manual step-by-step
+print("\nManual composition of (0 1) then (0 2):")
+print("Start with identity: [0, 1, 2]")
+
+# Apply (0 1)
+c1 = Cycle(0, 1)
+print(f"After (0 1): {c1.list()}")
+
+# Apply (0 2) to the result
+c2 = c1(0, 2)
+print(f"After (0 2): {c2.list()}")
+
+# Direct composition
+print("\nDirect composition:")
+c3 = Cycle()(0, 1)(0, 2)
+print(f"Cycle()(0, 1)(0, 2): {c3.list()}")
+
+# Let's understand the composition
+print("\nDetailed analysis:")
+print("In cycle notation, composition is right-to-left for functions")
+print("But Cycle class applies them left-to-right as transformations")
+print()
+
+# Let's trace what happens to each element
+print("Tracing elements through (0 1) then (0 2):")
+for i in range(3):
+    # Where does i go after (0 1)?
+    temp = c1[i]
+    # Where does that go after (0 2)?
+    final = Cycle(0, 2)[temp]
+    print(f"{i} -> {temp} -> {final}")
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..6c6c0e1342
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,28 @@
+#!/usr/bin/env python
+"""Test script to verify the issue with non-disjoint cycles"""
+
+from sympy.combinatorics.permutations import Permutation, Cycle
+
+print("Testing the reported issue...")
+try:
+    # This should create the identity permutation
+    p = Permutation([[0, 1], [0, 1]])
+    print("Success! Created permutation:", p)
+except ValueError as e:
+    print("Error:", e)
+    
+print("\nTesting how Cycle handles non-disjoint cycles...")
+# Test how individual cycles work
+c1 = Cycle(0, 1)
+print("c1 = Cycle(0, 1):", c1)
+print("c1.list():", c1.list())
+
+# Test composition
+c2 = Cycle()(0, 1)(0, 1)
+print("\nc2 = Cycle()(0, 1)(0, 1):", c2)
+print("c2.list():", c2.list())
+
+# This should give identity
+print("\nComposing (0 1) with (0 1) should give identity...")
+print("Expected: [0, 1] (identity)")
+print("Actual:", c2.list())
