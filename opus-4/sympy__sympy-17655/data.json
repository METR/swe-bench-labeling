{"instance_id": "sympy__sympy-17655", "score": "C", "diff": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c978c47be..39bf3971cf 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -104,6 +104,7 @@ class Point(GeometryEntity):\n     \"\"\"\n \n     is_Point = True\n+    _op_priority = 11.0  # higher than Expr's priority (10.0) to handle multiplication\n \n     def __new__(cls, *args, **kwargs):\n         evaluate = kwargs.get('evaluate', global_evaluate[0])\n@@ -278,6 +279,19 @@ def __mul__(self, factor):\n         coords = [simplify(x*factor) for x in self.args]\n         return Point(coords, evaluate=False)\n \n+    def __rmul__(self, factor):\n+        \"\"\"Right multiplication for factor * point.\n+        \n+        This method is called when a non-Point object is multiplied by a Point\n+        from the left side (e.g., 2 * Point(1, 1)).\n+        \n+        See Also\n+        ========\n+        \n+        sympy.geometry.point.Point.__mul__\n+        \"\"\"\n+        return self.__mul__(factor)\n+\n     def __neg__(self):\n         \"\"\"Negate the point.\"\"\"\n         coords = [-x for x in self.args]\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..34c3f17615\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,65 @@\n+from sympy import geometry as ge\n+import sympy\n+from sympy import S, Symbol\n+\n+# Test different types of multiplication\n+point = ge.Point(1, 2, 3)\n+point2d = ge.Point(1, 2)\n+\n+# Test with different numeric types\n+print(\"=== Testing multiplication with different numeric types ===\")\n+print(f\"point * 2 = {point * 2}\")\n+print(f\"2 * point = {2 * point}\")\n+print(f\"point * 2.0 = {point * 2.0}\")\n+print(f\"2.0 * point = {2.0 * point}\")\n+print(f\"point * sympy.S(2) = {point * sympy.S(2)}\")\n+print(f\"sympy.S(2) * point = {sympy.S(2) * point}\")\n+print(f\"point * sympy.Float(2.5) = {point * sympy.Float(2.5)}\")\n+print(f\"sympy.Float(2.5) * point = {sympy.Float(2.5) * point}\")\n+print(f\"point * sympy.Rational(3, 2) = {point * sympy.Rational(3, 2)}\")\n+print(f\"sympy.Rational(3, 2) * point = {sympy.Rational(3, 2) * point}\")\n+\n+# Test with symbols\n+x = Symbol('x')\n+print(f\"\\npoint * x = {point * x}\")\n+print(f\"x * point = {x * point}\")\n+\n+# Test division (should work via __mul__ and Pow)\n+print(f\"\\n=== Testing division ===\")\n+print(f\"point / 2 = {point / 2}\")\n+\n+# Test __rmul__ is still called correctly for non-Point objects\n+class CustomClass:\n+    def __mul__(self, other):\n+        return f\"CustomClass.__mul__ called with {other}\"\n+    \n+    def __rmul__(self, other):\n+        return f\"CustomClass.__rmul__ called with {other}\"\n+\n+custom = CustomClass()\n+print(f\"\\n=== Testing with custom class ===\")\n+print(f\"point * custom = {point * custom}\")\n+\n+# Test the original issue case\n+print(f\"\\n=== Testing original issue ===\")\n+point1 = ge.Point(0,0)\n+point2 = ge.Point(1,1)\n+result1 = point1 + point2 * sympy.sympify(2.0)\n+result2 = point1 + sympy.sympify(2.0) * point2\n+print(f\"point1 + point2 * sympy.sympify(2.0) = {result1}\")\n+print(f\"point1 + sympy.sympify(2.0) * point2 = {result2}\")\n+print(f\"Results are equal: {result1 == result2}\")\n+\n+# Test that Point methods still work\n+print(f\"\\n=== Testing Point methods ===\")\n+p1 = ge.Point(0, 0)\n+p2 = ge.Point(3, 4)\n+print(f\"p1.distance(p2) = {p1.distance(p2)}\")\n+print(f\"p1.midpoint(p2) = {p1.midpoint(p2)}\")\n+\n+# Test Point2D and Point3D specific behavior\n+print(f\"\\n=== Testing Point2D and Point3D ===\")\n+p2d = ge.Point2D(1, 2)\n+p3d = ge.Point3D(1, 2, 3)\n+print(f\"2 * Point2D(1, 2) = {2 * p2d}, type: {type(2 * p2d)}\")\n+print(f\"2 * Point3D(1, 2, 3) = {2 * p3d}, type: {type(2 * p3d)}\")\ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..abbe552732\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,23 @@\n+from sympy import geometry as ge\n+import sympy\n+\n+point2 = ge.Point(1, 1)\n+factor = sympy.sympify(2.0)\n+\n+# Check types\n+print(f\"Type of factor: {type(factor)}\")\n+print(f\"Type of point2: {type(point2)}\")\n+\n+# Try multiplication\n+result = factor * point2\n+print(f\"\\nResult of {factor} * {point2} = {result}\")\n+print(f\"Type of result: {type(result)}\")\n+\n+# Check if our __rmul__ is being called\n+print(f\"\\nHas __rmul__: {hasattr(point2, '__rmul__')}\")\n+\n+# Check what happens when we explicitly call __rmul__\n+if hasattr(point2, '__rmul__'):\n+    explicit_result = point2.__rmul__(factor)\n+    print(f\"Explicit __rmul__ result: {explicit_result}\")\n+    print(f\"Type: {type(explicit_result)}\")\ndiff --git a/test_final.py b/test_final.py\nnew file mode 100644\nindex 0000000000..06cb32fb2a\n--- /dev/null\n+++ b/test_final.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Test script to verify the fix for the issue:\n+\"Unexpected exception when multiplying geometry.Point and number\"\n+\n+The issue was that point1 + sympy.sympify(2.0) * point2 raised an exception\n+while point1 + point2 * sympy.sympify(2.0) worked fine.\n+\"\"\"\n+\n+from sympy import geometry as ge\n+import sympy\n+\n+def test_point_multiplication_fix():\n+    \"\"\"Test that both orderings of multiplication work correctly.\"\"\"\n+    point1 = ge.Point(0, 0)\n+    point2 = ge.Point(1, 1)\n+    \n+    # These should both work and give the same result\n+    result1 = point1 + point2 * sympy.sympify(2.0)\n+    result2 = point1 + sympy.sympify(2.0) * point2\n+    \n+    assert result1 == result2 == ge.Point(2.0, 2.0)\n+    assert isinstance(result1, ge.Point2D)\n+    assert isinstance(result2, ge.Point2D)\n+    \n+    # Test with different numeric types\n+    for factor in [2, 2.0, sympy.S(2), sympy.Float(2.0), sympy.Rational(2, 1)]:\n+        r1 = point2 * factor\n+        r2 = factor * point2\n+        assert r1 == r2 == ge.Point(2, 2)\n+        assert isinstance(r1, ge.Point)\n+        assert isinstance(r2, ge.Point)\n+    \n+    # Test with 3D points\n+    p3d = ge.Point(1, 2, 3)\n+    assert 2 * p3d == p3d * 2 == ge.Point(2, 4, 6)\n+    \n+    # Test with symbols  \n+    x = sympy.Symbol('x')\n+    assert x * point2 == point2 * x == ge.Point(x, x)\n+    \n+    print(\"All tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_point_multiplication_fix()\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..6771d10051\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,34 @@\n+from sympy import geometry as ge\n+import sympy\n+\n+# Test case from the issue\n+point1 = ge.Point(0, 0)\n+point2 = ge.Point(1, 1)\n+\n+print(\"Test 1: point1 + point2 * sympy.sympify(2.0)\")\n+try:\n+    result1 = point1 + point2 * sympy.sympify(2.0)\n+    print(f\"Result: {result1}\")\n+    print(f\"Type: {type(result1)}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+print(\"\\nTest 2: point1 + sympy.sympify(2.0) * point2\")\n+try:\n+    result2 = point1 + sympy.sympify(2.0) * point2\n+    print(f\"Result: {result2}\")\n+    print(f\"Type: {type(result2)}\")\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+print(\"\\nTest 3: Direct multiplication\")\n+print(f\"point2 * 2.0 = {point2 * 2.0}\")\n+print(f\"Type: {type(point2 * 2.0)}\")\n+try:\n+    result = 2.0 * point2\n+    print(f\"2.0 * point2 = {result}\")\n+    print(f\"Type: {type(result)}\")\n+except TypeError as e:\n+    print(f\"2.0 * point2 raises TypeError: {e}\")\n+    print(f\"sympy.sympify(2.0) * point2 = {sympy.sympify(2.0) * point2}\")\n+    print(f\"Type: {type(sympy.sympify(2.0) * point2)}\")\n", "gold_standard_diff": "diff --git a/sympy/geometry/point.py b/sympy/geometry/point.py\nindex 7c978c47be75..ee679a556b91 100644\n--- a/sympy/geometry/point.py\n+++ b/sympy/geometry/point.py\n@@ -278,6 +278,10 @@ def __mul__(self, factor):\n         coords = [simplify(x*factor) for x in self.args]\n         return Point(coords, evaluate=False)\n \n+    def __rmul__(self, factor):\n+        \"\"\"Multiply a factor by point's coordinates.\"\"\"\n+        return self.__mul__(factor)\n+\n     def __neg__(self):\n         \"\"\"Negate the point.\"\"\"\n         coords = [-x for x in self.args]\ndiff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 475d1d403ff9..7d6ea9a1ca95 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -26,7 +26,6 @@ def test_point():\n     assert p2.y == y2\n     assert (p3 + p4) == p4\n     assert (p2 - p1) == Point(y1 - x1, y2 - x2)\n-    assert p4*5 == Point(5, 5)\n     assert -p2 == Point(-y1, -y2)\n     raises(ValueError, lambda: Point(3, I))\n     raises(ValueError, lambda: Point(2*I, I))\n@@ -92,6 +91,7 @@ def test_point():\n \n     assert p4 * 5 == Point(5, 5)\n     assert p4 / 5 == Point(0.2, 0.2)\n+    assert 5 * p4 == Point(5, 5)\n \n     raises(ValueError, lambda: Point(0, 0) + 10)\n \n@@ -140,7 +140,6 @@ def test_point3D():\n     assert p2.y == y2\n     assert (p3 + p4) == p4\n     assert (p2 - p1) == Point3D(y1 - x1, y2 - x2, y3 - x3)\n-    assert p4*5 == Point3D(5, 5, 5)\n     assert -p2 == Point3D(-y1, -y2, -y3)\n \n     assert Point(34.05, sqrt(3)) == Point(Rational(681, 20), sqrt(3))\n@@ -169,6 +168,7 @@ def test_point3D():\n \n     assert p4 * 5 == Point3D(5, 5, 5)\n     assert p4 / 5 == Point3D(0.2, 0.2, 0.2)\n+    assert 5 * p4 == Point3D(5, 5, 5)\n \n     raises(ValueError, lambda: Point3D(0, 0, 0) + 10)\n \n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/17655"}