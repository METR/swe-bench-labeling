{"instance_id": "django__django-16315", "score": "C", "diff": "diff --git a/django/db/backends/mysql/operations.py b/django/db/backends/mysql/operations.py\nindex 76ca815765..fe58588d86 100644\n--- a/django/db/backends/mysql/operations.py\n+++ b/django/db/backends/mysql/operations.py\n@@ -449,10 +449,22 @@ class DatabaseOperations(BaseDatabaseOperations):\n             else:\n                 field_sql = \"%(field)s = VALUE(%(field)s)\"\n \n+            # Create a mapping from field names to field objects\n+            field_map = {f.name: f for f in fields}\n+            \n+            # Map field names to database column names\n+            update_columns = []\n+            for field_name in update_fields:\n+                field = field_map.get(field_name)\n+                if field:\n+                    update_columns.append(field.column)\n+                else:\n+                    update_columns.append(field_name)\n+            \n             fields = \", \".join(\n                 [\n-                    field_sql % {\"field\": field}\n-                    for field in map(self.quote_name, update_fields)\n+                    field_sql % {\"field\": self.quote_name(column)}\n+                    for column in update_columns\n                 ]\n             )\n             return conflict_suffix_sql % {\"fields\": fields}\ndiff --git a/django/db/backends/postgresql/operations.py b/django/db/backends/postgresql/operations.py\nindex 62273fc43c..4e2fa670f1 100644\n--- a/django/db/backends/postgresql/operations.py\n+++ b/django/db/backends/postgresql/operations.py\n@@ -353,12 +353,32 @@ class DatabaseOperations(BaseDatabaseOperations):\n         if on_conflict == OnConflict.IGNORE:\n             return \"ON CONFLICT DO NOTHING\"\n         if on_conflict == OnConflict.UPDATE:\n+            # Create a mapping from field names to field objects\n+            field_map = {f.name: f for f in fields}\n+            \n+            # Map field names to database column names\n+            unique_columns = []\n+            for field_name in unique_fields:\n+                field = field_map.get(field_name)\n+                if field:\n+                    unique_columns.append(field.column)\n+                else:\n+                    unique_columns.append(field_name)\n+            \n+            update_columns = []\n+            for field_name in update_fields:\n+                field = field_map.get(field_name)\n+                if field:\n+                    update_columns.append(field.column)\n+                else:\n+                    update_columns.append(field_name)\n+            \n             return \"ON CONFLICT(%s) DO UPDATE SET %s\" % (\n-                \", \".join(map(self.quote_name, unique_fields)),\n+                \", \".join(map(self.quote_name, unique_columns)),\n                 \", \".join(\n                     [\n-                        f\"{field} = EXCLUDED.{field}\"\n-                        for field in map(self.quote_name, update_fields)\n+                        f\"{self.quote_name(column)} = EXCLUDED.{self.quote_name(column)}\"\n+                        for column in update_columns\n                     ]\n                 ),\n             )\ndiff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py\nindex bb84d52071..ca1cd5adea 100644\n--- a/django/db/backends/sqlite3/operations.py\n+++ b/django/db/backends/sqlite3/operations.py\n@@ -417,12 +417,32 @@ class DatabaseOperations(BaseDatabaseOperations):\n             on_conflict == OnConflict.UPDATE\n             and self.connection.features.supports_update_conflicts_with_target\n         ):\n+            # Create a mapping from field names to field objects\n+            field_map = {f.name: f for f in fields}\n+            \n+            # Map field names to database column names\n+            unique_columns = []\n+            for field_name in unique_fields:\n+                field = field_map.get(field_name)\n+                if field:\n+                    unique_columns.append(field.column)\n+                else:\n+                    unique_columns.append(field_name)\n+            \n+            update_columns = []\n+            for field_name in update_fields:\n+                field = field_map.get(field_name)\n+                if field:\n+                    update_columns.append(field.column)\n+                else:\n+                    update_columns.append(field_name)\n+            \n             return \"ON CONFLICT(%s) DO UPDATE SET %s\" % (\n-                \", \".join(map(self.quote_name, unique_fields)),\n+                \", \".join(map(self.quote_name, unique_columns)),\n                 \", \".join(\n                     [\n-                        f\"{field} = EXCLUDED.{field}\"\n-                        for field in map(self.quote_name, update_fields)\n+                        f\"{self.quote_name(column)} = EXCLUDED.{self.quote_name(column)}\"\n+                        for column in update_columns\n                     ]\n                 ),\n             )\ndiff --git a/test_bulk_create_db_column.py b/test_bulk_create_db_column.py\nnew file mode 100644\nindex 0000000000..1a501cc272\n--- /dev/null\n+++ b/test_bulk_create_db_column.py\n@@ -0,0 +1,72 @@\n+import os\n+import django\n+from django.db import models, connection\n+from django.db.models import IntegerField\n+\n+# Configure Django settings\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"django.conf.global_settings\")\n+from django.conf import settings\n+\n+# Configure the database to use SQLite\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Define the model with db_column\n+class ActivityBlackListed(models.Model):\n+    class Meta:\n+        db_table = \"Activity_BlackListed\"\n+        app_label = 'test_app'\n+    \n+    blacklistid = models.IntegerField(primary_key=True, db_column=\"BlacklistID\")\n+    sectorid = models.IntegerField(null=True, blank=True, db_column=\"SectorID\")\n+    \n+    def __str__(self):\n+        return f\"ActivityBlackListed(blacklistid={self.blacklistid}, sectorid={self.sectorid})\"\n+\n+# Create the table\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(ActivityBlackListed)\n+\n+# Test bulk_create with update_conflicts\n+instances = [\n+    ActivityBlackListed(blacklistid=1, sectorid=10),\n+    ActivityBlackListed(blacklistid=2, sectorid=20),\n+]\n+\n+# This should work - initial creation\n+ActivityBlackListed.objects.bulk_create(instances)\n+print(\"Initial bulk_create successful\")\n+\n+# Now test with conflicts - update existing records\n+instances = [\n+    ActivityBlackListed(blacklistid=1, sectorid=100),  # Changed sectorid\n+    ActivityBlackListed(blacklistid=2, sectorid=200),  # Changed sectorid\n+]\n+\n+try:\n+    # This should fail with the bug\n+    ActivityBlackListed.objects.bulk_create(\n+        instances, \n+        update_conflicts=True, \n+        update_fields=[\"sectorid\"], \n+        unique_fields=[\"blacklistid\"]\n+    )\n+    print(\"bulk_create with update_conflicts successful\")\n+except Exception as e:\n+    print(f\"Error occurred: {e}\")\n+    print(f\"Error type: {type(e)}\")\ndiff --git a/test_postgres_bulk_create.py b/test_postgres_bulk_create.py\nnew file mode 100644\nindex 0000000000..83165931f9\n--- /dev/null\n+++ b/test_postgres_bulk_create.py\n@@ -0,0 +1,113 @@\n+# Test the fix without needing actual database connection\n+from django.db.models.enums import OnConflict\n+from django.db.models import Model, IntegerField\n+\n+# Create a mock model with db_column set\n+class ActivityBlackListed(Model):\n+    class Meta:\n+        db_table = \"Activity_BlackListed\"\n+        app_label = 'test_app'\n+    \n+    blacklistid = IntegerField(primary_key=True, db_column=\"BlacklistID\")\n+    sectorid = IntegerField(null=True, blank=True, db_column=\"SectorID\")\n+    \n+# Create mock field objects\n+blacklistid_field = type('Field', (), {'name': 'blacklistid', 'column': 'BlacklistID'})()\n+sectorid_field = type('Field', (), {'name': 'sectorid', 'column': 'SectorID'})()\n+\n+fields = [blacklistid_field, sectorid_field]\n+update_fields = ['sectorid']\n+unique_fields = ['blacklistid']\n+\n+# Test PostgreSQL implementation\n+print(\"Testing PostgreSQL implementation...\")\n+from django.db.backends.postgresql.operations import DatabaseOperations\n+\n+# Create a mock connection with quote_name method\n+class MockConnection:\n+    class ops:\n+        @staticmethod\n+        def quote_name(name):\n+            return f'\"{name}\"'\n+\n+ops = DatabaseOperations(MockConnection())\n+\n+sql = ops.on_conflict_suffix_sql(\n+    fields,\n+    OnConflict.UPDATE,\n+    update_fields,\n+    unique_fields\n+)\n+\n+print(\"Generated SQL:\", sql)\n+\n+# Check if the SQL uses the correct column names\n+if '\"BlacklistID\"' in sql and '\"SectorID\"' in sql:\n+    print(\"\u2713 SUCCESS: PostgreSQL correctly uses the db_column names!\")\n+else:\n+    print(\"\u2717 FAILURE: PostgreSQL is still using field names instead of db_column names\")\n+    print(\"Expected to see 'BlacklistID' and 'SectorID' in the SQL\")\n+\n+# Test SQLite implementation\n+print(\"\\nTesting SQLite implementation...\")\n+from django.db.backends.sqlite3.operations import DatabaseOperations as SQLiteOperations\n+\n+# Create a mock connection with features\n+class MockSQLiteConnection:\n+    class ops:\n+        @staticmethod\n+        def quote_name(name):\n+            return f'\"{name}\"'\n+    \n+    class features:\n+        supports_update_conflicts_with_target = True\n+\n+sqlite_ops = SQLiteOperations(MockSQLiteConnection())\n+\n+sql = sqlite_ops.on_conflict_suffix_sql(\n+    fields,\n+    OnConflict.UPDATE,\n+    update_fields,\n+    unique_fields\n+)\n+\n+print(\"Generated SQL:\", sql)\n+\n+# Check if the SQL uses the correct column names\n+if '\"BlacklistID\"' in sql and '\"SectorID\"' in sql:\n+    print(\"\u2713 SUCCESS: SQLite correctly uses the db_column names!\")\n+else:\n+    print(\"\u2717 FAILURE: SQLite is still using field names instead of db_column names\")\n+    print(\"Expected to see 'BlacklistID' and 'SectorID' in the SQL\")\n+\n+# Test MySQL implementation\n+print(\"\\nTesting MySQL implementation...\")\n+from django.db.backends.mysql.operations import DatabaseOperations as MySQLOperations\n+\n+# Create a mock connection with features\n+class MockMySQLConnection:\n+    mysql_is_mariadb = False\n+    mysql_version = (8, 0, 19)\n+    \n+    class ops:\n+        @staticmethod\n+        def quote_name(name):\n+            return f'`{name}`'\n+\n+mysql_ops = MySQLOperations(MockMySQLConnection())\n+\n+sql = mysql_ops.on_conflict_suffix_sql(\n+    fields,\n+    OnConflict.UPDATE,\n+    update_fields,\n+    unique_fields\n+)\n+\n+print(\"Generated SQL:\", sql)\n+\n+# Check if the SQL uses the correct column names\n+if '`SectorID`' in sql:\n+    print(\"\u2713 SUCCESS: MySQL correctly uses the db_column names!\")\n+else:\n+    print(\"\u2717 FAILURE: MySQL is still using field names instead of db_column names\")\n+    print(\"Expected to see 'SectorID' in the SQL\")\n", "gold_standard_diff": "diff --git a/django/db/models/query.py b/django/db/models/query.py\nindex be8580f2c446..cf419cb8cf7f 100644\n--- a/django/db/models/query.py\n+++ b/django/db/models/query.py\n@@ -720,7 +720,6 @@ def _check_bulk_create_options(\n                     \"Unique fields that can trigger the upsert must be provided.\"\n                 )\n             # Updating primary keys and non-concrete fields is forbidden.\n-            update_fields = [self.model._meta.get_field(name) for name in update_fields]\n             if any(not f.concrete or f.many_to_many for f in update_fields):\n                 raise ValueError(\n                     \"bulk_create() can only be used with concrete fields in \"\n@@ -732,9 +731,6 @@ def _check_bulk_create_options(\n                     \"update_fields.\"\n                 )\n             if unique_fields:\n-                unique_fields = [\n-                    self.model._meta.get_field(name) for name in unique_fields\n-                ]\n                 if any(not f.concrete or f.many_to_many for f in unique_fields):\n                     raise ValueError(\n                         \"bulk_create() can only be used with concrete fields \"\n@@ -786,8 +782,11 @@ def bulk_create(\n         if unique_fields:\n             # Primary key is allowed in unique_fields.\n             unique_fields = [\n-                opts.pk.name if name == \"pk\" else name for name in unique_fields\n+                self.model._meta.get_field(opts.pk.name if name == \"pk\" else name)\n+                for name in unique_fields\n             ]\n+        if update_fields:\n+            update_fields = [self.model._meta.get_field(name) for name in update_fields]\n         on_conflict = self._check_bulk_create_options(\n             ignore_conflicts,\n             update_conflicts,\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 0562a71dd118..caf36382b545 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -1725,8 +1725,8 @@ def as_sql(self):\n         on_conflict_suffix_sql = self.connection.ops.on_conflict_suffix_sql(\n             fields,\n             self.query.on_conflict,\n-            self.query.update_fields,\n-            self.query.unique_fields,\n+            (f.column for f in self.query.update_fields),\n+            (f.column for f in self.query.unique_fields),\n         )\n         if (\n             self.returning_fields\ndiff --git a/docs/releases/4.1.4.txt b/docs/releases/4.1.4.txt\nindex 7cdd2521ea16..509135f3b2b0 100644\n--- a/docs/releases/4.1.4.txt\n+++ b/docs/releases/4.1.4.txt\n@@ -23,3 +23,6 @@ Bugfixes\n \n * Fixed a bug in Django 4.1 that caused a crash of ``QuerySet.bulk_create()``\n   with ``\"pk\"`` in ``unique_fields`` (:ticket:`34177`).\n+\n+* Fixed a bug in Django 4.1 that caused a crash of ``QuerySet.bulk_create()``\n+  on fields with ``db_column`` (:ticket:`34171`).\ndiff --git a/tests/bulk_create/models.py b/tests/bulk_create/models.py\nindex 27abc416bd24..8a21c7dfa144 100644\n--- a/tests/bulk_create/models.py\n+++ b/tests/bulk_create/models.py\n@@ -69,6 +69,11 @@ class TwoFields(models.Model):\n     name = models.CharField(max_length=15, null=True)\n \n \n+class FieldsWithDbColumns(models.Model):\n+    rank = models.IntegerField(unique=True, db_column=\"rAnK\")\n+    name = models.CharField(max_length=15, null=True, db_column=\"oTheRNaMe\")\n+\n+\n class UpsertConflict(models.Model):\n     number = models.IntegerField(unique=True)\n     rank = models.IntegerField()\ndiff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex 6c490d1235aa..a5050c9b0bf3 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -21,6 +21,7 @@\n from .models import (\n     BigAutoFieldModel,\n     Country,\n+    FieldsWithDbColumns,\n     NoFields,\n     NullableFields,\n     Pizzeria,\n@@ -772,3 +773,34 @@ def test_update_conflicts_unique_fields(self):\n     @skipIfDBFeature(\"supports_update_conflicts_with_target\")\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n+\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n+    )\n+    def test_update_conflicts_unique_fields_update_fields_db_column(self):\n+        FieldsWithDbColumns.objects.bulk_create(\n+            [\n+                FieldsWithDbColumns(rank=1, name=\"a\"),\n+                FieldsWithDbColumns(rank=2, name=\"b\"),\n+            ]\n+        )\n+        self.assertEqual(FieldsWithDbColumns.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            FieldsWithDbColumns(rank=1, name=\"c\"),\n+            FieldsWithDbColumns(rank=2, name=\"d\"),\n+        ]\n+        FieldsWithDbColumns.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"rank\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(FieldsWithDbColumns.objects.count(), 2)\n+        self.assertCountEqual(\n+            FieldsWithDbColumns.objects.values(\"rank\", \"name\"),\n+            [\n+                {\"rank\": 1, \"name\": \"c\"},\n+                {\"rank\": 2, \"name\": \"d\"},\n+            ],\n+        )\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16315"}