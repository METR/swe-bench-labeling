{"instance_id": "pylint-dev__pylint-8898", "score": "I", "diff": "diff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd175..51d83f597 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -111,10 +111,77 @@ def _regex_transformer(value: str) -> Pattern[str]:\n         raise argparse.ArgumentTypeError(msg) from e\n \n \n+def _smart_split_regex_csv(value: str) -> list[str]:\n+    \"\"\"Split a comma-separated string while respecting regex syntax.\n+    \n+    This function splits on commas, but only those that are not inside:\n+    - Parentheses ()\n+    - Square brackets []\n+    - Curly braces {}\n+    \n+    This allows regex patterns with commas to be preserved.\n+    \"\"\"\n+    patterns = []\n+    current_pattern = []\n+    depth = {\n+        '(': 0,\n+        '[': 0,\n+        '{': 0\n+    }\n+    escape_next = False\n+    in_char_class = False  # Track if we're inside []\n+    \n+    for char in value:\n+        if escape_next:\n+            current_pattern.append(char)\n+            escape_next = False\n+            continue\n+            \n+        if char == '\\\\':\n+            escape_next = True\n+            current_pattern.append(char)\n+            continue\n+        \n+        # Track character classes separately (they have special rules)\n+        if char == '[' and not in_char_class:\n+            in_char_class = True\n+            depth['['] += 1\n+        elif char == ']' and in_char_class:\n+            in_char_class = False\n+            depth['['] -= 1\n+        # Only track other brackets if not in character class\n+        elif not in_char_class:\n+            if char == '(':\n+                depth['('] += 1\n+            elif char == ')':\n+                depth['('] -= 1\n+            elif char == '{':\n+                depth['{'] += 1\n+            elif char == '}':\n+                depth['{'] -= 1\n+        \n+        # Check if we're at a top-level comma\n+        if char == ',' and all(d == 0 for d in depth.values()) and not in_char_class:\n+            # Found a separator comma\n+            pattern = ''.join(current_pattern).strip()\n+            if pattern:  # Don't add empty patterns\n+                patterns.append(pattern)\n+            current_pattern = []\n+        else:\n+            current_pattern.append(char)\n+    \n+    # Don't forget the last pattern\n+    pattern = ''.join(current_pattern).strip()\n+    if pattern:\n+        patterns.append(pattern)\n+    \n+    return patterns\n+\n+\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _smart_split_regex_csv(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \n@@ -122,7 +189,7 @@ def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n def _regexp_paths_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions paths.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in _smart_split_regex_csv(value):\n         patterns.append(\n             re.compile(\n                 str(pathlib.PureWindowsPath(pattern)).replace(\"\\\\\", \"\\\\\\\\\")\ndiff --git a/test_bad_names_rgxs.py b/test_bad_names_rgxs.py\nnew file mode 100644\nindex 000000000..f5481e467\n--- /dev/null\n+++ b/test_bad_names_rgxs.py\n@@ -0,0 +1,77 @@\n+#!/usr/bin/env python3\n+\"\"\"Test script to verify the fix for bad-names-rgxs with commas in regex\"\"\"\n+\n+import tempfile\n+import os\n+import subprocess\n+\n+# Create a test Python file\n+test_code = \"\"\"\n+# Test file for pylint\n+foo = 1\n+fooo = 2\n+foooo = 3\n+bar = 4\n+\"\"\"\n+\n+# Create a config file with regex containing commas\n+pyproject_toml = \"\"\"\n+[tool.pylint.basic]\n+# capture group ensures that the part after the comma is valid\n+bad-name-rgxs = \"(foo{1,3})\"\n+\"\"\"\n+\n+# Create temporary directory and files\n+with tempfile.TemporaryDirectory() as tmpdir:\n+    # Write test Python file\n+    test_file = os.path.join(tmpdir, \"test.py\")\n+    with open(test_file, \"w\") as f:\n+        f.write(test_code)\n+    \n+    # Write config file\n+    config_file = os.path.join(tmpdir, \"pyproject.toml\")\n+    with open(config_file, \"w\") as f:\n+        f.write(pyproject_toml)\n+    \n+    # Run pylint\n+    print(\"Running pylint with bad-name-rgxs containing commas...\")\n+    print(f\"Config: bad-name-rgxs = \\\"(foo{{1,3}})\\\"\")\n+    print()\n+    \n+    try:\n+        result = subprocess.run(\n+            [\"python\", \"-m\", \"pylint\", test_file, \"--rcfile\", config_file],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        print(\"Exit code:\", result.returncode)\n+        print(\"\\nSTDOUT:\")\n+        print(result.stdout)\n+        if result.stderr:\n+            print(\"\\nSTDERR:\")\n+            print(result.stderr)\n+            \n+    except Exception as e:\n+        print(f\"Error running pylint: {e}\")\n+\n+# Test the transformation directly\n+print(\"\\n\" + \"=\"*60 + \"\\n\")\n+print(\"Testing the transformation directly:\")\n+from pylint.config.argument import _regexp_csv_transfomer\n+\n+test_patterns = [\n+    \"(foo{1,3})\",\n+    \"foo{1,3},bar{2,}\",\n+    \"[a,b,c]+,test\",\n+    \"(?:foo|bar){1,3}\"\n+]\n+\n+for pattern in test_patterns:\n+    print(f\"\\nInput: {pattern}\")\n+    try:\n+        result = _regexp_csv_transfomer(pattern)\n+        print(f\"Success! Compiled patterns: {[p.pattern for p in result]}\")\n+    except Exception as e:\n+        print(f\"Error: {type(e).__name__}: {e}\")\ndiff --git a/test_regex_comma_issue.py b/test_regex_comma_issue.py\nnew file mode 100644\nindex 000000000..d7c2bca42\n--- /dev/null\n+++ b/test_regex_comma_issue.py\n@@ -0,0 +1,46 @@\n+#!/usr/bin/env python3\n+\"\"\"Test script to reproduce the issue with regex containing commas\"\"\"\n+\n+import re\n+from pylint.utils.utils import _splitstrip\n+from pylint.config.argument import _regexp_csv_transfomer\n+\n+# Test the issue\n+test_regex = \"(foo{1,3})\"\n+print(f\"Original regex: {test_regex}\")\n+print(f\"Split result: {_splitstrip(test_regex)}\")\n+\n+# This should fail\n+try:\n+    result = _regexp_csv_transfomer(test_regex)\n+    print(f\"Transformed: {result}\")\n+except Exception as e:\n+    print(f\"Error: {type(e).__name__}: {e}\")\n+\n+# Test with other regex patterns that have commas\n+test_cases = [\n+    \"foo{1,3}\",\n+    \"(foo{1,3})\",\n+    \"bar{2,}\",\n+    \"baz{,5}\",\n+    \"test{3,4}|other{1,2}\",\n+    \"[a,b,c]+\",\n+    \"(?:foo|bar){1,3}\"\n+]\n+\n+print(\"\\nTesting various regex patterns with commas:\")\n+for pattern in test_cases:\n+    print(f\"\\nPattern: {pattern}\")\n+    print(f\"Split result: {_splitstrip(pattern)}\")\n+    try:\n+        re.compile(pattern)\n+        print(\"Valid regex: YES\")\n+    except:\n+        print(\"Valid regex: NO\")\n+    \n+    # Test if _regexp_csv_transfomer can handle it\n+    try:\n+        result = _regexp_csv_transfomer(pattern)\n+        print(f\"Transform successful: {result}\")\n+    except Exception as e:\n+        print(f\"Transform failed: {type(e).__name__}: {e}\")\ndiff --git a/test_regex_csv_parser.py b/test_regex_csv_parser.py\nnew file mode 100644\nindex 000000000..0aa515e64\n--- /dev/null\n+++ b/test_regex_csv_parser.py\n@@ -0,0 +1,123 @@\n+#!/usr/bin/env python3\n+\"\"\"Test implementation for a regex-aware CSV parser\"\"\"\n+\n+import re\n+from typing import List, Sequence\n+\n+\n+def _smart_split_regex_csv(value: str) -> List[str]:\n+    \"\"\"Split a comma-separated string while respecting regex syntax.\n+    \n+    This function splits on commas, but only those that are not inside:\n+    - Parentheses ()\n+    - Square brackets []\n+    - Curly braces {}\n+    \n+    This allows regex patterns with commas to be preserved.\n+    \"\"\"\n+    patterns = []\n+    current_pattern = []\n+    depth = {\n+        '(': 0,\n+        '[': 0,\n+        '{': 0\n+    }\n+    escape_next = False\n+    in_char_class = False  # Track if we're inside []\n+    \n+    for i, char in enumerate(value):\n+        if escape_next:\n+            current_pattern.append(char)\n+            escape_next = False\n+            continue\n+            \n+        if char == '\\\\':\n+            escape_next = True\n+            current_pattern.append(char)\n+            continue\n+        \n+        # Track character classes separately (they have special rules)\n+        if char == '[' and not in_char_class:\n+            in_char_class = True\n+            depth['['] += 1\n+        elif char == ']' and in_char_class:\n+            in_char_class = False\n+            depth['['] -= 1\n+        # Only track other brackets if not in character class\n+        elif not in_char_class:\n+            if char == '(':\n+                depth['('] += 1\n+            elif char == ')':\n+                depth['('] -= 1\n+            elif char == '{':\n+                depth['{'] += 1\n+            elif char == '}':\n+                depth['{'] -= 1\n+        \n+        # Check if we're at a top-level comma\n+        if char == ',' and all(d == 0 for d in depth.values()) and not in_char_class:\n+            # Found a separator comma\n+            pattern = ''.join(current_pattern).strip()\n+            if pattern:  # Don't add empty patterns\n+                patterns.append(pattern)\n+            current_pattern = []\n+        else:\n+            current_pattern.append(char)\n+    \n+    # Don't forget the last pattern\n+    pattern = ''.join(current_pattern).strip()\n+    if pattern:\n+        patterns.append(pattern)\n+    \n+    return patterns\n+\n+\n+# Test cases\n+test_cases = [\n+    # Single patterns with commas\n+    (\"foo{1,3}\", [\"foo{1,3}\"]),\n+    (\"(foo{1,3})\", [\"(foo{1,3})\"]),\n+    (\"bar{2,}\", [\"bar{2,}\"]),\n+    (\"baz{,5}\", [\"baz{,5}\"]),\n+    (\"[a,b,c]+\", [\"[a,b,c]+\"]),\n+    (\"(?:foo|bar){1,3}\", [\"(?:foo|bar){1,3}\"]),\n+    \n+    # Multiple patterns\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo{1,3},bar{2,}\", [\"foo{1,3}\", \"bar{2,}\"]),\n+    (\"(foo{1,3}),bar\", [\"(foo{1,3})\", \"bar\"]),\n+    (\"[a,b],foo{1,2}\", [\"[a,b]\", \"foo{1,2}\"]),\n+    \n+    # Edge cases\n+    (\"\", []),\n+    (\"   \", []),\n+    (\"foo,\", [\"foo\"]),\n+    (\",foo\", [\"foo\"]),\n+    (\"foo,,bar\", [\"foo\", \"bar\"]),\n+    \n+    # Complex patterns\n+    (\"test{3,4}|other{1,2},simple\", [\"test{3,4}|other{1,2}\", \"simple\"]),\n+    (\"(?:a{1,3}|b{2,}),c{,5}\", [\"(?:a{1,3}|b{2,})\", \"c{,5}\"]),\n+    \n+    # Escaped characters  \n+    (r\"foo\\,,bar\", [r\"foo\\,\", \"bar\"]),\n+    # Note: foo\\{1,3\\} has literal braces, not regex quantifier, so comma would split\n+]\n+\n+print(\"Testing smart regex CSV parser:\")\n+for input_str, expected in test_cases:\n+    result = _smart_split_regex_csv(input_str)\n+    status = \"\u2713\" if result == expected else \"\u2717\"\n+    print(f\"{status} Input: {repr(input_str)}\")\n+    print(f\"  Expected: {expected}\")\n+    print(f\"  Got:      {result}\")\n+    if result != expected:\n+        print(\"  MISMATCH!\")\n+    \n+    # Also verify each pattern is valid regex\n+    for pattern in result:\n+        try:\n+            re.compile(pattern)\n+        except re.error as e:\n+            print(f\"  WARNING: Invalid regex pattern '{pattern}': {e}\")\n+    print()\n", "gold_standard_diff": "diff --git a/doc/whatsnew/fragments/7229.bugfix b/doc/whatsnew/fragments/7229.bugfix\nnew file mode 100644\nindex 0000000000..c39e130192\n--- /dev/null\n+++ b/doc/whatsnew/fragments/7229.bugfix\n@@ -0,0 +1,5 @@\n+When parsing comma-separated lists of regular expressions in the config, ignore\n+commas that are inside braces since those indicate quantifiers, not delineation\n+between expressions.\n+\n+Closes #7229\ndiff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd1753..2d2a46a3fd 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -114,7 +114,7 @@ def _regex_transformer(value: str) -> Pattern[str]:\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in pylint_utils._check_regexp_csv(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \ndiff --git a/pylint/utils/__init__.py b/pylint/utils/__init__.py\nindex 61833a5987..eecb3cbe37 100644\n--- a/pylint/utils/__init__.py\n+++ b/pylint/utils/__init__.py\n@@ -14,6 +14,7 @@\n     HAS_ISORT_5,\n     IsortDriver,\n     _check_csv,\n+    _check_regexp_csv,\n     _splitstrip,\n     _unquote,\n     decoding_stream,\n@@ -32,6 +33,7 @@\n     \"HAS_ISORT_5\",\n     \"IsortDriver\",\n     \"_check_csv\",\n+    \"_check_regexp_csv\",\n     \"_splitstrip\",\n     \"_unquote\",\n     \"decoding_stream\",\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92ff..8f16d2f1f4 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -22,7 +22,8 @@\n import textwrap\n import tokenize\n import warnings\n-from collections.abc import Sequence\n+from collections import deque\n+from collections.abc import Iterable, Sequence\n from io import BufferedReader, BytesIO\n from typing import (\n     TYPE_CHECKING,\n@@ -253,6 +254,31 @@ def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n     return _splitstrip(value)\n \n \n+def _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n+    r\"\"\"Split a comma-separated list of regexps, taking care to avoid splitting\n+    a regex employing a comma as quantifier, as in `\\d{1,2}`.\"\"\"\n+    if isinstance(value, (list, tuple)):\n+        yield from value\n+    else:\n+        # None is a sentinel value here\n+        regexps: deque[deque[str] | None] = deque([None])\n+        open_braces = False\n+        for char in value:\n+            if char == \"{\":\n+                open_braces = True\n+            elif char == \"}\" and open_braces:\n+                open_braces = False\n+\n+            if char == \",\" and not open_braces:\n+                regexps.append(None)\n+            elif regexps[-1] is None:\n+                regexps.pop()\n+                regexps.append(deque([char]))\n+            else:\n+                regexps[-1].append(char)\n+        yield from (\"\".join(regexp).strip() for regexp in regexps if regexp is not None)\n+\n+\n def _comment(string: str) -> str:\n     \"\"\"Return string as a comment.\"\"\"\n     lines = [line.strip() for line in string.splitlines()]\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 83c8b072e5..872b568a61 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -5,8 +5,10 @@\n from __future__ import annotations\n \n import os\n+import re\n from pathlib import Path\n from tempfile import TemporaryDirectory\n+from typing import Any\n \n import pytest\n from pytest import CaptureFixture\n@@ -115,6 +117,31 @@ def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     assert \"the-newest has an invalid format, should be a version string.\" in output.err\n \n \n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+]\n+\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_in_quantifier(in_string: str, expected: list[str]) -> None:\n+    \"\"\"Check that we correctly parse a comma-separated regex when there are one\n+    or more commas within quantifier expressions.\n+    \"\"\"\n+\n+    def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+\n+\n def test_regex_error(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error when an an option is passed whose value is an invalid regular expression.\"\"\"\n     with pytest.raises(SystemExit):\n@@ -137,12 +164,12 @@ def test_csv_regex_error(capsys: CaptureFixture) -> None:\n     \"\"\"\n     with pytest.raises(SystemExit):\n         Run(\n-            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,3})\"],\n+            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,}, foo{1,3}})\"],\n             exit=False,\n         )\n     output = capsys.readouterr()\n     assert (\n-        r\"Error in provided regular expression: (foo{1 beginning at index 0: missing ), unterminated subpattern\"\n+        r\"Error in provided regular expression: (foo{1,} beginning at index 0: missing ), unterminated subpattern\"\n         in output.err\n     )\n \n", "gold_standard_pr_link": "https://github.com/pylint-dev/pylint/pull/8898"}