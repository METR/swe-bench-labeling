{"instance_id": "pylint-dev__pylint-4551", "score": "I", "diff": "diff --git a/pylint/pyreverse/diadefslib.py b/pylint/pyreverse/diadefslib.py\nindex 5d803c929..eb627dcef 100644\n--- a/pylint/pyreverse/diadefslib.py\n+++ b/pylint/pyreverse/diadefslib.py\n@@ -83,7 +83,27 @@ class DiaDefGenerator:\n     def add_class(self, node):\n         \"\"\"visit one class and add it to diagram\"\"\"\n         self.linker.visit(node)\n-        self.classdiagram.add_object(self.get_title(node), node)\n+        attributes = self.get_attributes_with_type_hints(node)\n+        self.classdiagram.add_object(self.get_title(node), node, attributes=attributes)\n+\n+    def get_attributes_with_type_hints(self, node):\n+        \"\"\"Get class attributes with their type hints\"\"\"\n+        attributes = []\n+        for attr_name, attr_node in node.instance_attrs.items():\n+            type_hint = self.get_type_hint(attr_node)\n+            if type_hint:\n+                attributes.append(f\"{attr_name}: {type_hint}\")\n+            else:\n+                attributes.append(attr_name)\n+        return attributes\n+\n+    def get_type_hint(self, attr_node):\n+        \"\"\"Get the type hint for an attribute\"\"\"\n+        if isinstance(attr_node, astroid.AssignAttr):\n+            assigned = attr_node.assigned_stmts()\n+            if assigned and isinstance(assigned[0], astroid.AnnAssign):\n+                return assigned[0].annotation.as_string()\n+        return None\n \n     def get_ancestors(self, node, level):\n         \"\"\"return ancestor nodes of a class node\"\"\"\ndiff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af6..2aefc4257 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -108,10 +108,15 @@ class ClassDiagram(Figure, FilterMixIn):\n         ]\n         return sorted(methods, key=lambda n: n.name)\n \n-    def add_object(self, title, node):\n+    def add_object(self, title, node, attributes=None):\n         \"\"\"create a diagram object\"\"\"\n         assert node not in self._nodes\n         ent = DiagramEntity(title, node)\n+        if attributes:\n+            ent.attrs = attributes\n+        else:\n+            ent.attrs = self.get_attrs(node)\n+        ent.methods = self.get_methods(node)\n         self._nodes[node] = ent\n         self.objects.append(ent)\n \ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca..b54b63789 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -132,14 +132,15 @@ class DotWriter(DiagramWriter):\n         if obj.shape == \"interface\":\n             label = \"\u00abinterface\u00bb\\\\n%s\" % label\n         if not self.config.only_classnames:\n-            label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n+            attrs = r\"\\l\".join(obj.attrs)\n+            methods = \"\"\n             for func in obj.methods:\n                 if func.args.args:\n                     args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n                 else:\n                     args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n-            label = \"{%s}\" % label\n+                methods += r\"{}({})\\l\".format(func.name, \", \".join(args))\n+            label = \"{%s|%s|%s}\" % (label, attrs, methods)\n         if is_exception(obj.node):\n             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n         return dict(label=label, shape=\"record\")\n", "gold_standard_diff": "From 4b35586e1e5a94cd8dd5876597559d13ec5e25c6 Mon Sep 17 00:00:00 2001\nFrom: Mark Byrne <mbyrnepr2@gmail.com>\nDate: Sat, 15 May 2021 19:15:06 +0200\nSubject: [PATCH 1/3] Add type annotations to pyreverse dot files\n\nCloses #1548\n---\n ChangeLog                     |  4 ++++\n doc/whatsnew/2.9.rst          |  2 ++\n pylint/pyreverse/diagrams.py  |  2 +-\n pylint/pyreverse/inspector.py | 14 ++++++++++++--\n pylint/pyreverse/writer.py    | 11 ++++++++++-\n 5 files changed, 29 insertions(+), 4 deletions(-)\n\ndiff --git a/ChangeLog b/ChangeLog\nindex 9f4bd8462d..0b3046c640 100644\n--- a/ChangeLog\n+++ b/ChangeLog\n@@ -9,6 +9,10 @@ Release date: TBA\n ..\n   Put new features and bugfixes here and also in 'doc/whatsnew/2.9.rst'\n \n+* Add type annotations to pyreverse dot files\n+\n+  Closes #1548\n+\n * Added ``deprecated-decorator``: Emitted when deprecated decorator is used.\n \n   Closes #4429\ndiff --git a/doc/whatsnew/2.9.rst b/doc/whatsnew/2.9.rst\nindex 59ad255c07..bbdd90769b 100644\n--- a/doc/whatsnew/2.9.rst\n+++ b/doc/whatsnew/2.9.rst\n@@ -40,6 +40,8 @@ New checkers\n Other Changes\n =============\n \n+* Add type annotations to pyreverse dot files\n+\n * Pylint's tags are now the standard form ``vX.Y.Z`` and not ``pylint-X.Y.Z`` anymore.\n \n * Fix false-positive ``too-many-ancestors`` when inheriting from builtin classes,\ndiff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex bf9f67af66..f111bfe0ed 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -122,7 +122,7 @@ def class_names(self, nodes):\n             if isinstance(node, astroid.Instance):\n                 node = node._proxied\n             if (\n-                isinstance(node, astroid.ClassDef)\n+                isinstance(node, (astroid.ClassDef, astroid.Name))\n                 and hasattr(node, \"name\")\n                 and not self.has_node(node)\n             ):\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 8fa1220224..a301b4defc 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -218,7 +218,8 @@ def visit_assignname(self, node):\n                     self.visit_module(frame)\n \n             current = frame.locals_type[node.name]\n-            values = set(node.infer())\n+            ann = getattr(node.parent, \"annotation\", None)\n+            values = {ann} if ann else set(node.infer())\n             frame.locals_type[node.name] = list(set(current) | values)\n         except astroid.InferenceError:\n             pass\n@@ -229,8 +230,17 @@ def handle_assignattr_type(node, parent):\n \n         handle instance_attrs_type\n         \"\"\"\n+        ann = None\n+        if isinstance(node.parent.value, astroid.Name):\n+            try:\n+                idx = list(node.parent.parent.locals).index(node.parent.value.name)\n+                ann = node.parent.parent.args.annotations[idx]\n+            except (IndexError, ValueError):\n+                pass\n+        elif hasattr(node.parent, \"annotation\"):\n+            ann = node.parent.annotation\n         try:\n-            values = set(node.infer())\n+            values = {ann} if ann else set(node.infer())\n             current = set(parent.instance_attrs_type[node.attrname])\n             parent.instance_attrs_type[node.attrname] = list(current | values)\n         except astroid.InferenceError:\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex 0d80bb9ca6..d68fcd56e0 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -134,11 +134,20 @@ def get_values(self, obj):\n         if not self.config.only_classnames:\n             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n             for func in obj.methods:\n+                return_type = f\": {func.returns.name}\" if func.returns else \"\"\n+\n                 if func.args.args:\n                     args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n                 else:\n                     args = []\n-                label = r\"{}{}({})\\l\".format(label, func.name, \", \".join(args))\n+\n+                annotations = [a.name if a else None for a in func.args.annotations[1:]]\n+                args = \", \".join(\n+                    f\"{arg}: {ann}\" if ann else f\"{arg}\"\n+                    for arg, ann in zip(args, annotations)\n+                )\n+\n+                label = fr\"{label}{func.name}({args}){return_type}\\l\"\n             label = \"{%s}\" % label\n         if is_exception(obj.node):\n             return dict(fontcolor=\"red\", label=label, shape=\"record\")\n\nFrom 4534b72c1325fafb990828044b57729ca93f1757 Mon Sep 17 00:00:00 2001\nFrom: Mark Byrne <mbyrnepr2@gmail.com>\nDate: Mon, 14 Jun 2021 07:56:45 +0200\nSubject: [PATCH 2/3] Add type annotations to pyreverse dot files\n\n- Indicate the attribute is optional in the dot files by\n  inspecting the default value.\n- Handle the Subscript type annotations\n- Refactor & move the logic to obtain annotations to utils.py as\n  re-usable functions\n- Add unittests for the added functions\n---\n pylint/pyreverse/diagrams.py       |  2 +-\n pylint/pyreverse/inspector.py      | 12 ++------\n pylint/pyreverse/utils.py          | 43 ++++++++++++++++++++++++++++\n pylint/pyreverse/writer.py         | 21 ++++++++++----\n tests/unittest_pyreverse_writer.py | 46 +++++++++++++++++++++++++++++-\n 5 files changed, 106 insertions(+), 18 deletions(-)\n\ndiff --git a/pylint/pyreverse/diagrams.py b/pylint/pyreverse/diagrams.py\nindex f111bfe0ed..4c391c7fa8 100644\n--- a/pylint/pyreverse/diagrams.py\n+++ b/pylint/pyreverse/diagrams.py\n@@ -122,7 +122,7 @@ def class_names(self, nodes):\n             if isinstance(node, astroid.Instance):\n                 node = node._proxied\n             if (\n-                isinstance(node, (astroid.ClassDef, astroid.Name))\n+                isinstance(node, (astroid.ClassDef, astroid.Name, astroid.Subscript))\n                 and hasattr(node, \"name\")\n                 and not self.has_node(node)\n             ):\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex a301b4defc..1923f0252a 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -218,7 +218,7 @@ def visit_assignname(self, node):\n                     self.visit_module(frame)\n \n             current = frame.locals_type[node.name]\n-            ann = getattr(node.parent, \"annotation\", None)\n+            ann = utils.get_annotation(node)\n             values = {ann} if ann else set(node.infer())\n             frame.locals_type[node.name] = list(set(current) | values)\n         except astroid.InferenceError:\n@@ -230,15 +230,7 @@ def handle_assignattr_type(node, parent):\n \n         handle instance_attrs_type\n         \"\"\"\n-        ann = None\n-        if isinstance(node.parent.value, astroid.Name):\n-            try:\n-                idx = list(node.parent.parent.locals).index(node.parent.value.name)\n-                ann = node.parent.parent.args.annotations[idx]\n-            except (IndexError, ValueError):\n-                pass\n-        elif hasattr(node.parent, \"annotation\"):\n-            ann = node.parent.annotation\n+        ann = utils.get_annotation(node)\n         try:\n             values = {ann} if ann else set(node.infer())\n             current = set(parent.instance_attrs_type[node.attrname])\ndiff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py\nindex 34558aac1b..2d7231ee13 100644\n--- a/pylint/pyreverse/utils.py\n+++ b/pylint/pyreverse/utils.py\n@@ -18,6 +18,9 @@\n import os\n import re\n import sys\n+from typing import Optional, Union\n+\n+import astroid\n \n RCFILE = \".pyreverserc\"\n \n@@ -212,3 +215,43 @@ def visit(self, node):\n         if methods[1] is not None:\n             return methods[1](node)\n         return None\n+\n+\n+def get_annotation_label(ann: Union[astroid.Name, astroid.Subscript]) -> str:\n+    label = \"\"\n+    if isinstance(ann, astroid.Subscript):\n+        label = ann.as_string()\n+    elif isinstance(ann, astroid.Name):\n+        label = ann.name\n+    return label\n+\n+\n+def get_annotation(\n+    node: Union[astroid.AnnAssign, astroid.AssignAttr]\n+) -> Optional[Union[astroid.Name, astroid.Subscript]]:\n+    \"\"\"return the annotation for `node`\"\"\"\n+    ann = None\n+    if isinstance(node.parent, astroid.AnnAssign):\n+        ann = node.parent.annotation\n+    elif isinstance(node, astroid.AssignAttr):\n+        init_method = node.parent.parent\n+        try:\n+            annotations = dict(zip(init_method.locals, init_method.args.annotations))\n+            ann = annotations.get(node.parent.value.name)\n+        except AttributeError:\n+            pass\n+    else:\n+        return ann\n+\n+    default, *_ = node.infer()\n+    label = get_annotation_label(ann)\n+    if ann:\n+        label = (\n+            rf\"Optional[{label}]\"\n+            if getattr(default, \"value\", \"value\") is None\n+            and not label.startswith(\"Optional\")\n+            else label\n+        )\n+    if label:\n+        ann.name = label\n+    return ann\ndiff --git a/pylint/pyreverse/writer.py b/pylint/pyreverse/writer.py\nindex d68fcd56e0..baafc6904f 100644\n--- a/pylint/pyreverse/writer.py\n+++ b/pylint/pyreverse/writer.py\n@@ -19,7 +19,7 @@\n import os\n \n from pylint.graph import DotBackend\n-from pylint.pyreverse.utils import is_exception\n+from pylint.pyreverse.utils import get_annotation_label, is_exception\n from pylint.pyreverse.vcgutils import VCGPrinter\n \n \n@@ -134,17 +134,26 @@ def get_values(self, obj):\n         if not self.config.only_classnames:\n             label = r\"{}|{}\\l|\".format(label, r\"\\l\".join(obj.attrs))\n             for func in obj.methods:\n-                return_type = f\": {func.returns.name}\" if func.returns else \"\"\n+                return_type = (\n+                    f\": {get_annotation_label(func.returns)}\" if func.returns else \"\"\n+                )\n \n                 if func.args.args:\n-                    args = [arg.name for arg in func.args.args if arg.name != \"self\"]\n+                    args = [arg for arg in func.args.args if arg.name != \"self\"]\n                 else:\n                     args = []\n \n-                annotations = [a.name if a else None for a in func.args.annotations[1:]]\n+                annotations = dict(zip(args, func.args.annotations[1:]))\n+                for arg in args:\n+                    annotation_label = \"\"\n+                    ann = annotations.get(arg)\n+                    if ann:\n+                        annotation_label = get_annotation_label(ann)\n+                    annotations[arg] = annotation_label\n+\n                 args = \", \".join(\n-                    f\"{arg}: {ann}\" if ann else f\"{arg}\"\n-                    for arg, ann in zip(args, annotations)\n+                    f\"{arg.name}: {ann}\" if ann else f\"{arg.name}\"\n+                    for arg, ann in annotations.items()\n                 )\n \n                 label = fr\"{label}{func.name}({args}){return_type}\\l\"\ndiff --git a/tests/unittest_pyreverse_writer.py b/tests/unittest_pyreverse_writer.py\nindex 98bb014881..8ffdbafda9 100644\n--- a/tests/unittest_pyreverse_writer.py\n+++ b/tests/unittest_pyreverse_writer.py\n@@ -23,11 +23,12 @@\n import os\n from difflib import unified_diff\n \n+import astroid\n import pytest\n \n from pylint.pyreverse.diadefslib import DefaultDiadefGenerator, DiadefsHandler\n from pylint.pyreverse.inspector import Linker, project_from_files\n-from pylint.pyreverse.utils import get_visibility\n+from pylint.pyreverse.utils import get_annotation, get_visibility\n from pylint.pyreverse.writer import DotWriter\n \n _DEFAULTS = {\n@@ -132,3 +133,46 @@ def test_get_visibility(names, expected):\n     for name in names:\n         got = get_visibility(name)\n         assert got == expected, f\"got {got} instead of {expected} for value {name}\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"assign, label\",\n+    [\n+        (\"a: str = None\", \"Optional[str]\"),\n+        (\"a: str = 'mystr'\", \"str\"),\n+        (\"a: Optional[str] = 'str'\", \"Optional[str]\"),\n+        (\"a: Optional[str] = None\", \"Optional[str]\"),\n+    ],\n+)\n+def test_get_annotation_annassign(assign, label):\n+    \"\"\"AnnAssign\"\"\"\n+    node = astroid.extract_node(assign)\n+    got = get_annotation(node.value).name\n+    assert isinstance(node, astroid.AnnAssign)\n+    assert got == label, f\"got {got} instead of {label} for value {node}\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"init_method, label\",\n+    [\n+        (\"def __init__(self, x: str):                   self.x = x\", \"str\"),\n+        (\"def __init__(self, x: str = 'str'):           self.x = x\", \"str\"),\n+        (\"def __init__(self, x: str = None):            self.x = x\", \"Optional[str]\"),\n+        (\"def __init__(self, x: Optional[str]):         self.x = x\", \"Optional[str]\"),\n+        (\"def __init__(self, x: Optional[str] = None):  self.x = x\", \"Optional[str]\"),\n+        (\"def __init__(self, x: Optional[str] = 'str'): self.x = x\", \"Optional[str]\"),\n+    ],\n+)\n+def test_get_annotation_assignattr(init_method, label):\n+    \"\"\"AssignAttr\"\"\"\n+    assign = rf\"\"\"\n+        class A:\n+            {init_method}\n+    \"\"\"\n+    node = astroid.extract_node(assign)\n+    instance_attrs = node.instance_attrs\n+    for _, assign_attrs in instance_attrs.items():\n+        for assign_attr in assign_attrs:\n+            got = get_annotation(assign_attr).name\n+            assert isinstance(assign_attr, astroid.AssignAttr)\n+            assert got == label, f\"got {got} instead of {label} for value {node}\"\n\nFrom 194e6d35d40f15828bae97dccd4871d49537bdbc Mon Sep 17 00:00:00 2001\nFrom: Mark Byrne <mbyrnepr2@gmail.com>\nDate: Sat, 26 Jun 2021 17:55:02 +0200\nSubject: [PATCH 3/3] Add type annotations to pyreverse dot files\n\n- Add a try/except to deal with a possible InferenceError when using\nNodeNG.infer method\n- Create a function in utils and so remove repeated logic in inspector.py\n- Add unittests to check the InferenceError logic\n- Adjust the types in function input\n---\n pylint/pyreverse/inspector.py      | 42 ++++++++++++------------------\n pylint/pyreverse/utils.py          | 21 +++++++++++++--\n tests/unittest_pyreverse_writer.py | 29 ++++++++++++++++++++-\n 3 files changed, 64 insertions(+), 28 deletions(-)\n\ndiff --git a/pylint/pyreverse/inspector.py b/pylint/pyreverse/inspector.py\nindex 1923f0252a..d6c0bb9c6a 100644\n--- a/pylint/pyreverse/inspector.py\n+++ b/pylint/pyreverse/inspector.py\n@@ -205,24 +205,19 @@ def visit_assignname(self, node):\n             # the name has been defined as 'global' in the frame and belongs\n             # there.\n             frame = node.root()\n-        try:\n-            if not hasattr(frame, \"locals_type\"):\n-                # If the frame doesn't have a locals_type yet,\n-                # it means it wasn't yet visited. Visit it now\n-                # to add what's missing from it.\n-                if isinstance(frame, astroid.ClassDef):\n-                    self.visit_classdef(frame)\n-                elif isinstance(frame, astroid.FunctionDef):\n-                    self.visit_functiondef(frame)\n-                else:\n-                    self.visit_module(frame)\n-\n-            current = frame.locals_type[node.name]\n-            ann = utils.get_annotation(node)\n-            values = {ann} if ann else set(node.infer())\n-            frame.locals_type[node.name] = list(set(current) | values)\n-        except astroid.InferenceError:\n-            pass\n+        if not hasattr(frame, \"locals_type\"):\n+            # If the frame doesn't have a locals_type yet,\n+            # it means it wasn't yet visited. Visit it now\n+            # to add what's missing from it.\n+            if isinstance(frame, astroid.ClassDef):\n+                self.visit_classdef(frame)\n+            elif isinstance(frame, astroid.FunctionDef):\n+                self.visit_functiondef(frame)\n+            else:\n+                self.visit_module(frame)\n+\n+        current = frame.locals_type[node.name]\n+        frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))\n \n     @staticmethod\n     def handle_assignattr_type(node, parent):\n@@ -230,13 +225,10 @@ def handle_assignattr_type(node, parent):\n \n         handle instance_attrs_type\n         \"\"\"\n-        ann = utils.get_annotation(node)\n-        try:\n-            values = {ann} if ann else set(node.infer())\n-            current = set(parent.instance_attrs_type[node.attrname])\n-            parent.instance_attrs_type[node.attrname] = list(current | values)\n-        except astroid.InferenceError:\n-            pass\n+        current = set(parent.instance_attrs_type[node.attrname])\n+        parent.instance_attrs_type[node.attrname] = list(\n+            current | utils.infer_node(node)\n+        )\n \n     def visit_import(self, node):\n         \"\"\"visit an astroid.Import node\ndiff --git a/pylint/pyreverse/utils.py b/pylint/pyreverse/utils.py\nindex 18d2e96a6d..1f4a65e5be 100644\n--- a/pylint/pyreverse/utils.py\n+++ b/pylint/pyreverse/utils.py\n@@ -228,7 +228,7 @@ def get_annotation_label(ann: Union[astroid.Name, astroid.Subscript]) -> str:\n \n \n def get_annotation(\n-    node: Union[astroid.AnnAssign, astroid.AssignAttr]\n+    node: Union[astroid.AssignAttr, astroid.AssignName]\n ) -> Optional[Union[astroid.Name, astroid.Subscript]]:\n     \"\"\"return the annotation for `node`\"\"\"\n     ann = None\n@@ -244,7 +244,11 @@ def get_annotation(\n     else:\n         return ann\n \n-    default, *_ = node.infer()\n+    try:\n+        default, *_ = node.infer()\n+    except astroid.InferenceError:\n+        default = \"\"\n+\n     label = get_annotation_label(ann)\n     if ann:\n         label = (\n@@ -256,3 +260,16 @@ def get_annotation(\n     if label:\n         ann.name = label\n     return ann\n+\n+\n+def infer_node(node: Union[astroid.AssignAttr, astroid.AssignName]) -> set:\n+    \"\"\"Return a set containing the node annotation if it exists\n+    otherwise return a set of the inferred types using the NodeNG.infer method\"\"\"\n+\n+    ann = get_annotation(node)\n+    if ann:\n+        return {ann}\n+    try:\n+        return set(node.infer())\n+    except astroid.InferenceError:\n+        return set()\ndiff --git a/tests/unittest_pyreverse_writer.py b/tests/unittest_pyreverse_writer.py\nindex 8ffdbafda9..95b1b20e05 100644\n--- a/tests/unittest_pyreverse_writer.py\n+++ b/tests/unittest_pyreverse_writer.py\n@@ -22,13 +22,14 @@\n import codecs\n import os\n from difflib import unified_diff\n+from unittest.mock import patch\n \n import astroid\n import pytest\n \n from pylint.pyreverse.diadefslib import DefaultDiadefGenerator, DiadefsHandler\n from pylint.pyreverse.inspector import Linker, project_from_files\n-from pylint.pyreverse.utils import get_annotation, get_visibility\n+from pylint.pyreverse.utils import get_annotation, get_visibility, infer_node\n from pylint.pyreverse.writer import DotWriter\n \n _DEFAULTS = {\n@@ -176,3 +177,29 @@ class A:\n             got = get_annotation(assign_attr).name\n             assert isinstance(assign_attr, astroid.AssignAttr)\n             assert got == label, f\"got {got} instead of {label} for value {node}\"\n+\n+\n+@patch(\"pylint.pyreverse.utils.get_annotation\")\n+@patch(\"astroid.node_classes.NodeNG.infer\", side_effect=astroid.InferenceError)\n+def test_infer_node_1(mock_infer, mock_get_annotation):\n+    \"\"\"Return set() when astroid.InferenceError is raised and an annotation has\n+    not been returned\n+    \"\"\"\n+    mock_get_annotation.return_value = None\n+    node = astroid.extract_node(\"a: str = 'mystr'\")\n+    mock_infer.return_value = \"x\"\n+    assert infer_node(node) == set()\n+    assert mock_infer.called\n+\n+\n+@patch(\"pylint.pyreverse.utils.get_annotation\")\n+@patch(\"astroid.node_classes.NodeNG.infer\")\n+def test_infer_node_2(mock_infer, mock_get_annotation):\n+    \"\"\"Return set(node.infer()) when InferenceError is not raised and an\n+    annotation has not been returned\n+    \"\"\"\n+    mock_get_annotation.return_value = None\n+    node = astroid.extract_node(\"a: str = 'mystr'\")\n+    mock_infer.return_value = \"x\"\n+    assert infer_node(node) == set(\"x\")\n+    assert mock_infer.called\n", "gold_standard_pr_link": "https://github.com/pylint-dev/pylint/pull/4551"}