{"instance_id": "pytest-dev__pytest-6197", "score": "I", "diff": "diff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 306e5f217..c91810d42 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -177,9 +177,11 @@ def pytest_collect_file(path, parent):\n     ext = path.ext\n     if ext == \".py\":\n         if not parent.session.isinitpath(path):\n-            if not path_matches_patterns(\n-                path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n-            ):\n+            # For __init__.py files, only collect them if they explicitly match python_files\n+            # (don't add __init__.py to patterns automatically)\n+            # For other files, check against patterns as usual\n+            patterns = parent.config.getini(\"python_files\")\n+            if not path_matches_patterns(path, patterns):\n                 return\n         ihook = parent.session.gethookproxy(path)\n         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n@@ -642,8 +644,9 @@ class Package(Module):\n         self._mount_obj_if_needed()\n         this_path = self.fspath.dirpath()\n         init_module = this_path.join(\"__init__.py\")\n-        if init_module.check(file=1) and path_matches_patterns(\n-            init_module, self.config.getini(\"python_files\")\n+        if init_module.check(file=1) and (\n+            self.isinitpath(init_module) or \n+            path_matches_patterns(init_module, self.config.getini(\"python_files\"))\n         ):\n             yield Module(init_module, self)\n         pkg_prefixes = set()\ndiff --git a/test_init_collection.py b/test_init_collection.py\nnew file mode 100644\nindex 000000000..f9dbacc9e\n--- /dev/null\n+++ b/test_init_collection.py\n@@ -0,0 +1,128 @@\n+\"\"\"Test cases for __init__.py file collection behavior\"\"\"\n+import subprocess\n+import sys\n+import os\n+import tempfile\n+\n+def test_init_files_not_collected_by_default():\n+    \"\"\"Test that random __init__.py files are not collected by default\"\"\"\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create a subdirectory with an __init__.py that has assert False\n+        subdir = os.path.join(tmpdir, \"foobar\")\n+        os.makedirs(subdir)\n+        \n+        init_file = os.path.join(subdir, \"__init__.py\")\n+        with open(init_file, \"w\") as f:\n+            f.write(\"assert False\\n\")\n+        \n+        # Create a simple test file\n+        test_file = os.path.join(tmpdir, \"test_foo.py\")\n+        with open(test_file, \"w\") as f:\n+            f.write(\"def test_something():\\n    pass\\n\")\n+        \n+        # Run pytest in the directory\n+        result = subprocess.run(\n+            [sys.executable, \"-m\", \"pytest\", \"-v\"],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        # Check that the test passed and __init__.py was not collected\n+        assert result.returncode == 0, f\"pytest failed with return code {result.returncode}\\nSTDOUT: {result.stdout}\\nSTDERR: {result.stderr}\"\n+        assert \"foobar/__init__.py\" not in result.stdout, \"__init__.py should not be collected\"\n+        assert \"test_foo.py\" in result.stdout, \"test_foo.py should be collected\"\n+        assert \"1 passed\" in result.stdout, \"One test should pass\"\n+        print(\"\u2713 Test passed: __init__.py files are not collected by default\")\n+\n+def test_init_file_collected_when_explicit():\n+    \"\"\"Test that __init__.py is collected when explicitly specified\"\"\"\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create a subdirectory with an __init__.py that has a test\n+        subdir = os.path.join(tmpdir, \"foobar\")\n+        os.makedirs(subdir)\n+        \n+        init_file = os.path.join(subdir, \"__init__.py\")\n+        with open(init_file, \"w\") as f:\n+            f.write(\"def test_in_init():\\n    assert True\\n\")\n+        \n+        # Run pytest explicitly on the __init__.py file\n+        result = subprocess.run(\n+            [sys.executable, \"-m\", \"pytest\", \"-v\", os.path.join(\"foobar\", \"__init__.py\")],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        # Check that the test in __init__.py was collected and passed\n+        assert result.returncode == 0, f\"pytest failed with return code {result.returncode}\\nSTDOUT: {result.stdout}\\nSTDERR: {result.stderr}\"\n+        assert \"test_in_init\" in result.stdout, \"test_in_init should be collected\"\n+        assert \"1 passed\" in result.stdout, \"One test should pass\"\n+        print(\"\u2713 Test passed: __init__.py is collected when explicitly specified\")\n+\n+def test_init_file_collected_with_python_files_pattern():\n+    \"\"\"Test that __init__.py is collected when it matches python_files pattern\"\"\"\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create a subdirectory with an __init__.py that has a test\n+        subdir = os.path.join(tmpdir, \"foobar\")\n+        os.makedirs(subdir)\n+        \n+        init_file = os.path.join(subdir, \"__init__.py\")\n+        with open(init_file, \"w\") as f:\n+            f.write(\"def test_in_init():\\n    assert True\\n\")\n+        \n+        # Create pytest.ini with python_files including __init__.py\n+        ini_file = os.path.join(tmpdir, \"pytest.ini\")\n+        with open(ini_file, \"w\") as f:\n+            f.write(\"[pytest]\\npython_files = test_*.py __init__.py\\n\")\n+        \n+        # Run pytest in the directory\n+        result = subprocess.run(\n+            [sys.executable, \"-m\", \"pytest\", \"-v\"],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        # Check that the test in __init__.py was collected and passed\n+        assert result.returncode == 0, f\"pytest failed with return code {result.returncode}\\nSTDOUT: {result.stdout}\\nSTDERR: {result.stderr}\"\n+        assert \"test_in_init\" in result.stdout, \"test_in_init should be collected\"\n+        assert \"1 passed\" in result.stdout, \"One test should pass\"\n+        print(\"\u2713 Test passed: __init__.py is collected when matching python_files pattern\")\n+\n+def test_package_collection():\n+    \"\"\"Test that packages are properly collected\"\"\"\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create a package with tests\n+        pkg_dir = os.path.join(tmpdir, \"mypkg\")\n+        os.makedirs(pkg_dir)\n+        \n+        # Create __init__.py in package\n+        init_file = os.path.join(pkg_dir, \"__init__.py\")\n+        with open(init_file, \"w\") as f:\n+            f.write(\"# Package init\\n\")\n+        \n+        # Create a test file in the package\n+        test_file = os.path.join(pkg_dir, \"test_module.py\")\n+        with open(test_file, \"w\") as f:\n+            f.write(\"def test_in_package():\\n    assert True\\n\")\n+        \n+        # Run pytest on the package\n+        result = subprocess.run(\n+            [sys.executable, \"-m\", \"pytest\", \"-v\", \"mypkg\"],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        # Check that the test in the package was collected and passed\n+        assert result.returncode == 0, f\"pytest failed with return code {result.returncode}\\nSTDOUT: {result.stdout}\\nSTDERR: {result.stderr}\"\n+        assert \"test_in_package\" in result.stdout, \"test_in_package should be collected\"\n+        assert \"1 passed\" in result.stdout, \"One test should pass\"\n+        print(\"\u2713 Test passed: package collection works correctly\")\n+\n+if __name__ == \"__main__\":\n+    test_init_files_not_collected_by_default()\n+    test_init_file_collected_when_explicit()\n+    test_init_file_collected_with_python_files_pattern()\n+    test_package_collection()\ndiff --git a/test_regression.py b/test_regression.py\nnew file mode 100644\nindex 000000000..ee636125a\n--- /dev/null\n+++ b/test_regression.py\n@@ -0,0 +1,45 @@\n+\"\"\"Test for regression where pytest tries to collect random __init__.py files\"\"\"\n+import subprocess\n+import sys\n+import os\n+import tempfile\n+import shutil\n+\n+def test_init_files_not_collected():\n+    \"\"\"Test that random __init__.py files are not collected\"\"\"\n+    # Create a temporary directory\n+    with tempfile.TemporaryDirectory() as tmpdir:\n+        # Create a subdirectory with an __init__.py that has assert False\n+        subdir = os.path.join(tmpdir, \"foobar\")\n+        os.makedirs(subdir)\n+        \n+        init_file = os.path.join(subdir, \"__init__.py\")\n+        with open(init_file, \"w\") as f:\n+            f.write(\"assert False\\n\")\n+        \n+        # Create a simple test file\n+        test_file = os.path.join(tmpdir, \"test_foo.py\")\n+        with open(test_file, \"w\") as f:\n+            f.write(\"def test_something():\\n    pass\\n\")\n+        \n+        # Run pytest in the directory\n+        result = subprocess.run(\n+            [sys.executable, \"-m\", \"pytest\", \"-v\"],\n+            cwd=tmpdir,\n+            capture_output=True,\n+            text=True\n+        )\n+        \n+        # The test should pass - the __init__.py file should not be collected\n+        print(\"STDOUT:\", result.stdout)\n+        print(\"STDERR:\", result.stderr)\n+        print(\"Return code:\", result.returncode)\n+        \n+        # Check that the test passed and __init__.py was not collected\n+        assert result.returncode == 0, f\"pytest failed with return code {result.returncode}\"\n+        assert \"foobar/__init__.py\" not in result.stdout, \"__init__.py should not be collected\"\n+        assert \"test_foo.py\" in result.stdout, \"test_foo.py should be collected\"\n+        assert \"1 passed\" in result.stdout, \"One test should pass\"\n+\n+if __name__ == \"__main__\":\n+    test_init_files_not_collected()\n", "gold_standard_diff": "From 176c7771fb4f3bd703bb6c9650cc32e31d548a2b Mon Sep 17 00:00:00 2001\nFrom: Anthony Sottile <asottile@umich.edu>\nDate: Fri, 15 Nov 2019 08:29:52 -0800\nSubject: [PATCH 1/2] Revert \"fix bug with nonskipped first test in package\n (#5831)\"\n\nThis reverts commit 85288b53218d4e0037dce9c34bd37f86fa9e212d, reversing\nchanges made to 5f9db8a01721e10162769b96b82794dd069bbaeb.\n---\n AUTHORS                  |  1 -\n src/_pytest/python.py    | 24 ++++++------------------\n testing/test_skipping.py | 23 -----------------------\n 3 files changed, 6 insertions(+), 42 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex d0e584f6367..e11400c1fa0 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -70,7 +70,6 @@ Daniel Hahler\n Daniel Nuri\n Daniel Wandschneider\n Danielle Jenkins\n-Daniil Galiev\n Dave Hunt\n David D\u00edaz-Barquero\n David Mohr\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 306e5f217ce..b8b365ad34d 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -251,21 +251,18 @@ class PyobjMixin(PyobjContext):\n     @property\n     def obj(self):\n         \"\"\"Underlying Python object.\"\"\"\n-        self._mount_obj_if_needed()\n-        return self._obj\n-\n-    @obj.setter\n-    def obj(self, value):\n-        self._obj = value\n-\n-    def _mount_obj_if_needed(self):\n         obj = getattr(self, \"_obj\", None)\n         if obj is None:\n             self._obj = obj = self._getobj()\n             # XXX evil hack\n             # used to avoid Instance collector marker duplication\n             if self._ALLOW_MARKERS:\n-                self.own_markers.extend(get_unpacked_marks(obj))\n+                self.own_markers.extend(get_unpacked_marks(self.obj))\n+        return obj\n+\n+    @obj.setter\n+    def obj(self, value):\n+        self._obj = value\n \n     def _getobj(self):\n         \"\"\"Gets the underlying Python object. May be overwritten by subclasses.\"\"\"\n@@ -432,14 +429,6 @@ def _genfunctions(self, name, funcobj):\n class Module(nodes.File, PyCollector):\n     \"\"\" Collector for test classes and functions. \"\"\"\n \n-    def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n-        if fspath.basename == \"__init__.py\":\n-            self._ALLOW_MARKERS = False\n-\n-        nodes.FSCollector.__init__(\n-            self, fspath, parent=parent, config=config, session=session, nodeid=nodeid\n-        )\n-\n     def _getobj(self):\n         return self._importtestmodule()\n \n@@ -639,7 +628,6 @@ def isinitpath(self, path):\n         return path in self.session._initialpaths\n \n     def collect(self):\n-        self._mount_obj_if_needed()\n         this_path = self.fspath.dirpath()\n         init_module = this_path.join(\"__init__.py\")\n         if init_module.check(file=1) and path_matches_patterns(\ndiff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 371c3a4dbce..8bba479f1b0 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1162,26 +1162,3 @@ def test_importorskip():\n         match=\"^could not import 'doesnotexist': No module named .*\",\n     ):\n         pytest.importorskip(\"doesnotexist\")\n-\n-\n-def test_skip_package(testdir):\n-    testdir.makepyfile(\n-        __init__=\"\"\"\n-        import pytest\n-        pytestmark = pytest.mark.skip\n-    \"\"\"\n-    )\n-\n-    testdir.makepyfile(\n-        \"\"\"\n-        import pytest\n-        def test_skip1():\n-            assert 0\n-        def test_skip2():\n-            assert 0\n-    \"\"\"\n-    )\n-\n-    result = testdir.inline_run()\n-    _, skipped, _ = result.listoutcomes()\n-    assert len(skipped) == 2\n\nFrom 4e0f99260d438d750b55a0881110658b8bba5a4a Mon Sep 17 00:00:00 2001\nFrom: Anthony Sottile <asottile@umich.edu>\nDate: Fri, 15 Nov 2019 08:31:53 -0800\nSubject: [PATCH 2/2] Add regression tests for __init__.py breakage\n\n---\n AUTHORS                    |  1 +\n changelog/6194.bugfix.rst  |  1 +\n changelog/6197.bugfix.rst  |  1 +\n testing/test_collection.py | 21 +++++++++++++++++++++\n 4 files changed, 24 insertions(+)\n create mode 100644 changelog/6194.bugfix.rst\n create mode 100644 changelog/6197.bugfix.rst\n\ndiff --git a/AUTHORS b/AUTHORS\nindex e11400c1fa0..d0e584f6367 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -70,6 +70,7 @@ Daniel Hahler\n Daniel Nuri\n Daniel Wandschneider\n Danielle Jenkins\n+Daniil Galiev\n Dave Hunt\n David D\u00edaz-Barquero\n David Mohr\ndiff --git a/changelog/6194.bugfix.rst b/changelog/6194.bugfix.rst\nnew file mode 100644\nindex 00000000000..92e6aec7828\n--- /dev/null\n+++ b/changelog/6194.bugfix.rst\n@@ -0,0 +1 @@\n+Fix incorrect discovery of non-test ``__init__.py`` files.\ndiff --git a/changelog/6197.bugfix.rst b/changelog/6197.bugfix.rst\nnew file mode 100644\nindex 00000000000..9bd0a5a6510\n--- /dev/null\n+++ b/changelog/6197.bugfix.rst\n@@ -0,0 +1 @@\n+Revert \"The first test in a package (``__init__.py``) marked with ``@pytest.mark.skip`` is now correctly skipped.\".\ndiff --git a/testing/test_collection.py b/testing/test_collection.py\nindex dee07d5c715..8050e80f989 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1257,3 +1257,24 @@ def test_collector_respects_tbstyle(testdir):\n             \"*= 1 error in *\",\n         ]\n     )\n+\n+\n+def test_does_not_eagerly_collect_packages(testdir):\n+    testdir.makepyfile(\"def test(): pass\")\n+    pydir = testdir.mkpydir(\"foopkg\")\n+    pydir.join(\"__init__.py\").write(\"assert False\")\n+    result = testdir.runpytest()\n+    assert result.ret == ExitCode.OK\n+\n+\n+def test_does_not_put_src_on_path(testdir):\n+    # `src` is not on sys.path so it should not be importable\n+    testdir.tmpdir.join(\"src/nope/__init__.py\").ensure()\n+    testdir.makepyfile(\n+        \"import pytest\\n\"\n+        \"def test():\\n\"\n+        \"    with pytest.raises(ImportError):\\n\"\n+        \"        import nope\\n\"\n+    )\n+    result = testdir.runpytest()\n+    assert result.ret == ExitCode.OK\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/6197"}