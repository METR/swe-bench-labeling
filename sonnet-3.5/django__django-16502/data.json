{"instance_id": "django__django-16502", "score": "I", "diff": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..458eed3946 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -198,8 +198,30 @@ class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n         return super().get_environ()\n \n     def handle(self):\n+        \"\"\"Handle a single HTTP request\"\"\"\n+        self.raw_requestline = self.rfile.readline(65537)\n+        if len(self.raw_requestline) > 65536:\n+            self.requestline = ''\n+            self.request_version = ''\n+            self.command = ''\n+            self.send_error(414)\n+            return\n+\n+        if not self.parse_request():\n+            return\n+\n+        handler = ServerHandler(\n+            self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n+        )\n+        handler.request_handler = self  # backpointer for logging\n+        handler.run(self.server.get_app())\n+\n+        if self.command == 'HEAD':\n+            # For HEAD requests, remove the response body\n+            self.wfile.truncate(0)\n+            self.wfile.seek(0)\n+\n         self.close_connection = True\n-        self.handle_one_request()\n         while not self.close_connection:\n             self.handle_one_request()\n         try:\n", "gold_standard_diff": "From f37b07f6648450d2346c84a2eb59ab9abae762c3 Mon Sep 17 00:00:00 2001\nFrom: sarahboyce <sarahvboyce95@gmail.com>\nDate: Thu, 26 Jan 2023 10:06:05 +0100\nSubject: [PATCH] Fixed #28054 -- Made runserver not return response body for\n HEAD requests.\n\nCo-authored-by: jannschu <jannik.schuerg@posteo.de>\n---\n django/core/servers/basehttp.py | 27 ++++++++++++-\n tests/servers/test_basehttp.py  | 69 +++++++++++++++++++++++++++++----\n 2 files changed, 88 insertions(+), 8 deletions(-)\n\ndiff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e5856..d08fb77a475a 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -11,6 +11,7 @@\n import socket\n import socketserver\n import sys\n+from collections import deque\n from wsgiref import simple_server\n \n from django.core.exceptions import ImproperlyConfigured\n@@ -130,10 +131,18 @@ def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n \n     def cleanup_headers(self):\n         super().cleanup_headers()\n+        if (\n+            self.environ[\"REQUEST_METHOD\"] == \"HEAD\"\n+            and \"Content-Length\" in self.headers\n+        ):\n+            del self.headers[\"Content-Length\"]\n         # HTTP/1.1 requires support for persistent connections. Send 'close' if\n         # the content length is unknown to prevent clients from reusing the\n         # connection.\n-        if \"Content-Length\" not in self.headers:\n+        if (\n+            self.environ[\"REQUEST_METHOD\"] != \"HEAD\"\n+            and \"Content-Length\" not in self.headers\n+        ):\n             self.headers[\"Connection\"] = \"close\"\n         # Persistent connections require threading server.\n         elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n@@ -147,6 +156,22 @@ def close(self):\n         self.get_stdin().read()\n         super().close()\n \n+    def finish_response(self):\n+        if self.environ[\"REQUEST_METHOD\"] == \"HEAD\":\n+            try:\n+                deque(self.result, maxlen=0)  # Consume iterator.\n+                # Don't call self.finish_content() as, if the headers have not\n+                # been sent and Content-Length isn't set, it'll default to \"0\"\n+                # which will prevent omission of the Content-Length header with\n+                # HEAD requests as permitted by RFC 9110 Section 9.3.2.\n+                # Instead, send the headers, if not sent yet.\n+                if not self.headers_sent:\n+                    self.send_headers()\n+            finally:\n+                self.close()\n+        else:\n+            super().finish_response()\n+\n \n class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n     protocol_version = \"HTTP/1.1\"\ndiff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py\nindex a837505feb7a..1e535e933e24 100644\n--- a/tests/servers/test_basehttp.py\n+++ b/tests/servers/test_basehttp.py\n@@ -1,4 +1,5 @@\n from io import BytesIO\n+from socketserver import ThreadingMixIn\n \n from django.core.handlers.wsgi import WSGIRequest\n from django.core.servers.basehttp import WSGIRequestHandler, WSGIServer\n@@ -7,7 +8,7 @@\n from django.test.utils import captured_stderr\n \n \n-class Stub:\n+class Stub(ThreadingMixIn):\n     def __init__(self, **kwargs):\n         self.__dict__.update(kwargs)\n \n@@ -15,6 +16,13 @@ def sendall(self, data):\n         self.makefile(\"wb\").write(data)\n \n \n+class UnclosableBytesIO(BytesIO):\n+    def close(self):\n+        # WSGIRequestHandler closes the output file; we need to make this a\n+        # no-op so we can still read its contents.\n+        pass\n+\n+\n class WSGIRequestHandlerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n \n@@ -79,12 +87,6 @@ def test_app(environ, start_response):\n         rfile.write(b\"Other_Header: bad\\r\\n\")\n         rfile.seek(0)\n \n-        # WSGIRequestHandler closes the output file; we need to make this a\n-        # no-op so we can still read its contents.\n-        class UnclosableBytesIO(BytesIO):\n-            def close(self):\n-                pass\n-\n         wfile = UnclosableBytesIO()\n \n         def makefile(mode, *a, **kw):\n@@ -106,6 +108,59 @@ def makefile(mode, *a, **kw):\n \n         self.assertEqual(body, b\"HTTP_SOME_HEADER:good\")\n \n+    def test_no_body_returned_for_head_requests(self):\n+        hello_world_body = b\"<!DOCTYPE html><html><body>Hello World</body></html>\"\n+        content_length = len(hello_world_body)\n+\n+        def test_app(environ, start_response):\n+            \"\"\"A WSGI app that returns a hello world.\"\"\"\n+            start_response(\"200 OK\", [])\n+            return [hello_world_body]\n+\n+        rfile = BytesIO(b\"GET / HTTP/1.0\\r\\n\")\n+        rfile.seek(0)\n+\n+        wfile = UnclosableBytesIO()\n+\n+        def makefile(mode, *a, **kw):\n+            if mode == \"rb\":\n+                return rfile\n+            elif mode == \"wb\":\n+                return wfile\n+\n+        request = Stub(makefile=makefile)\n+        server = Stub(base_environ={}, get_app=lambda: test_app)\n+\n+        # Prevent logging from appearing in test output.\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            # Instantiating a handler runs the request as side effect.\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        lines = list(wfile.readlines())\n+        body = lines[-1]\n+        # The body is returned in a GET response.\n+        self.assertEqual(body, hello_world_body)\n+        self.assertIn(f\"Content-Length: {content_length}\\r\\n\".encode(), lines)\n+        self.assertNotIn(b\"Connection: close\\r\\n\", lines)\n+\n+        rfile = BytesIO(b\"HEAD / HTTP/1.0\\r\\n\")\n+        rfile.seek(0)\n+        wfile = UnclosableBytesIO()\n+\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        lines = list(wfile.readlines())\n+        body = lines[-1]\n+        # The body is not returned in a HEAD response.\n+        self.assertEqual(body, b\"\\r\\n\")\n+        self.assertIs(\n+            any([line.startswith(b\"Content-Length:\") for line in lines]), False\n+        )\n+        self.assertNotIn(b\"Connection: close\\r\\n\", lines)\n+\n \n class WSGIServerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16502"}