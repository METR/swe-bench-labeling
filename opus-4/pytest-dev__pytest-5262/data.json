{"instance_id": "pytest-dev__pytest-5262", "score": "C", "diff": "diff --git a/src/_pytest/capture.py b/src/_pytest/capture.py\nindex 25eab7fdf..ca33d7a9d 100644\n--- a/src/_pytest/capture.py\n+++ b/src/_pytest/capture.py\n@@ -447,6 +447,13 @@ class EncodedFile(object):\n         \"\"\"Ensure that file.name is a string.\"\"\"\n         return repr(self.buffer)\n \n+    @property\n+    def mode(self):\n+        \"\"\"Return the mode without 'b' since EncodedFile only accepts text.\"\"\"\n+        mode = getattr(self.buffer, \"mode\", \"r\")\n+        # Remove 'b' from mode string to reflect that we only accept text\n+        return mode.replace(\"b\", \"\")\n+\n     def __getattr__(self, name):\n         return getattr(object.__getattribute__(self, \"buffer\"), name)\n \ndiff --git a/test_encodedfile_mode_fix.py b/test_encodedfile_mode_fix.py\nnew file mode 100644\nindex 000000000..3b64de122\n--- /dev/null\n+++ b/test_encodedfile_mode_fix.py\n@@ -0,0 +1,113 @@\n+import io\n+import pytest\n+from _pytest.capture import EncodedFile\n+\n+\n+def test_encodedfile_mode_removes_binary_flag():\n+    \"\"\"Test that EncodedFile.mode removes 'b' flag from underlying buffer mode.\"\"\"\n+    # Test various binary modes\n+    test_cases = [\n+        (\"rb\", \"r\"),\n+        (\"rb+\", \"r+\"),\n+        (\"wb\", \"w\"),\n+        (\"wb+\", \"w+\"),\n+        (\"ab\", \"a\"),\n+        (\"ab+\", \"a+\"),\n+        (\"r+b\", \"r+\"),  # 'b' can be at the end\n+        (\"w+b\", \"w+\"),\n+        (\"a+b\", \"a+\"),\n+    ]\n+    \n+    for buffer_mode, expected_mode in test_cases:\n+        buffer = io.BytesIO()\n+        buffer.mode = buffer_mode\n+        ef = EncodedFile(buffer, \"utf-8\")\n+        assert ef.mode == expected_mode, f\"Expected {expected_mode} for buffer mode {buffer_mode}, got {ef.mode}\"\n+        assert 'b' not in ef.mode, f\"Binary flag 'b' should not be in mode: {ef.mode}\"\n+\n+\n+def test_encodedfile_mode_preserves_text_mode():\n+    \"\"\"Test that EncodedFile.mode preserves text mode from buffer.\"\"\"\n+    # Test text modes (no 'b')\n+    test_cases = [\"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\"]\n+    \n+    for mode in test_cases:\n+        buffer = io.StringIO()\n+        buffer.mode = mode\n+        ef = EncodedFile(buffer, \"utf-8\")\n+        assert ef.mode == mode, f\"Text mode should be preserved: expected {mode}, got {ef.mode}\"\n+\n+\n+def test_encodedfile_mode_default():\n+    \"\"\"Test that EncodedFile.mode defaults to 'r' when buffer has no mode.\"\"\"\n+    buffer = object()  # Object with no mode attribute\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    assert ef.mode == \"r\", f\"Expected default mode 'r', got {ef.mode}\"\n+\n+\n+def test_encodedfile_write_accepts_only_text():\n+    \"\"\"Test that EncodedFile.write() only accepts text strings.\"\"\"\n+    buffer = io.BytesIO()\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    # Should accept strings\n+    ef.write(\"Hello\")\n+    \n+    # Should reject bytes\n+    with pytest.raises(TypeError, match=\"write\\\\(\\\\) argument must be str\"):\n+        ef.write(b\"Hello\")\n+\n+\n+def test_youtube_dl_compatibility():\n+    \"\"\"Test that the fix solves the youtube-dl compatibility issue.\"\"\"\n+    buffer = io.BytesIO()\n+    buffer.mode = \"rb+\"\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    # Simulate youtube-dl's behavior\n+    if 'b' in ef.mode:\n+        # This branch should not be taken anymore\n+        pytest.fail(\"EncodedFile.mode should not contain 'b'\")\n+    else:\n+        # This is the correct branch - write text\n+        ef.write(\"Hello from youtube-dl\")\n+        # Should work without error\n+\n+\n+def test_other_attributes_still_forwarded():\n+    \"\"\"Test that other attributes are still forwarded via __getattr__.\"\"\"\n+    buffer = io.BytesIO()\n+    buffer.custom_attr = \"test_value\"\n+    buffer.another_attr = 42\n+    \n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    # These should still be forwarded\n+    assert ef.custom_attr == \"test_value\"\n+    assert ef.another_attr == 42\n+    \n+    # But mode should be overridden\n+    buffer.mode = \"rb+\"\n+    assert ef.mode == \"r+\"\n+\n+\n+if __name__ == \"__main__\":\n+    test_encodedfile_mode_removes_binary_flag()\n+    print(\"\u2713 Binary flag removal test passed\")\n+    \n+    test_encodedfile_mode_preserves_text_mode()\n+    print(\"\u2713 Text mode preservation test passed\")\n+    \n+    test_encodedfile_mode_default()\n+    print(\"\u2713 Default mode test passed\")\n+    \n+    test_encodedfile_write_accepts_only_text()\n+    print(\"\u2713 Write type checking test passed\")\n+    \n+    test_youtube_dl_compatibility()\n+    print(\"\u2713 YouTube-dl compatibility test passed\")\n+    \n+    test_other_attributes_still_forwarded()\n+    print(\"\u2713 Attribute forwarding test passed\")\n+    \n+    print(\"\\nAll tests passed!\")\ndiff --git a/test_issue_mock.py b/test_issue_mock.py\nnew file mode 100644\nindex 000000000..e0b42b5cd\n--- /dev/null\n+++ b/test_issue_mock.py\n@@ -0,0 +1,43 @@\n+\"\"\"\n+Mock test that simulates the issue from the bug report.\n+\"\"\"\n+\n+import sys\n+\n+\n+class MockYoutubeDL:\n+    \"\"\"Mock YoutubeDL that simulates the behavior that causes the issue.\"\"\"\n+    \n+    def _write_string(self, s, out=None):\n+        \"\"\"Simplified version of youtube-dl's _write_string method.\"\"\"\n+        if out is None:\n+            out = sys.stdout\n+            \n+        # This is the key check that youtube-dl does\n+        if 'b' in getattr(out, 'mode', ''):\n+            # Binary mode - write bytes\n+            byt = s.encode('utf-8')\n+            out.write(byt)\n+        else:\n+            # Text mode - write string\n+            out.write(s)\n+    \n+    def to_stdout(self, message):\n+        \"\"\"Simulate youtube-dl writing to stdout.\"\"\"\n+        self._write_string(message + '\\n', sys.stdout)\n+    \n+    def extract_info(self, url):\n+        \"\"\"Simulate extraction that writes to stdout.\"\"\"\n+        self.to_stdout(f'[generic] example: Requesting header')\n+        return {'title': 'Example'}\n+\n+\n+def test_foo():\n+    \"\"\"The test from the issue description.\"\"\"\n+    ydl = MockYoutubeDL()\n+    ydl.extract_info('http://example.com/')\n+    print(\"Test passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_foo()\ndiff --git a/test_issue_reproduction.py b/test_issue_reproduction.py\nnew file mode 100644\nindex 000000000..8f50ab174\n--- /dev/null\n+++ b/test_issue_reproduction.py\n@@ -0,0 +1,55 @@\n+import io\n+import sys\n+from _pytest.capture import EncodedFile\n+\n+\n+def test_encodedfile_mode():\n+    \"\"\"Test that EncodedFile doesn't expose binary mode from underlying buffer.\"\"\"\n+    # Create a binary buffer  \n+    buffer = io.BytesIO()\n+    buffer.mode = \"rb+\"  # Set binary mode on buffer\n+    \n+    # Create EncodedFile wrapper\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    # The issue: ef.mode shows 'rb+' from the buffer, but ef.write() only accepts strings\n+    print(f\"Buffer mode: {buffer.mode}\")\n+    print(f\"EncodedFile mode (via __getattr__): {ef.mode}\")\n+    \n+    # This is what youtube-dl does - checks for 'b' in mode\n+    if 'b' in ef.mode:\n+        print(\"youtube-dl thinks this accepts bytes\")\n+        try:\n+            ef.write(b\"test bytes\")\n+            print(\"SUCCESS: Bytes written\")\n+        except TypeError as e:\n+            print(f\"ERROR: {e}\")\n+    else:\n+        print(\"youtube-dl thinks this accepts strings\")\n+        ef.write(\"test string\")\n+        print(\"SUCCESS: String written\")\n+\n+\n+def test_direct_usage():\n+    \"\"\"Test the direct use case that fails.\"\"\"\n+    # Simulate what pytest does\n+    buffer = io.BytesIO() \n+    buffer.mode = \"rb+\"\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    # What youtube-dl does\n+    mode = ef.mode\n+    print(f\"Mode detected: {mode}\")\n+    \n+    # This fails because 'b' is in mode but write() doesn't accept bytes\n+    if 'b' in mode:\n+        try:\n+            ef.write(b\"Hello bytes\")\n+        except TypeError as e:\n+            print(f\"Failed as expected: {e}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_encodedfile_mode()\n+    print(\"\\n\" + \"=\"*50 + \"\\n\")\n+    test_direct_usage()\ndiff --git a/test_youtube_dl_issue.py b/test_youtube_dl_issue.py\nnew file mode 100644\nindex 000000000..edc68a594\n--- /dev/null\n+++ b/test_youtube_dl_issue.py\n@@ -0,0 +1,4 @@\n+import youtube_dl\n+\n+def test_foo():\n+    youtube_dl.YoutubeDL().extract_info('http://example.com/')\ndiff --git a/test_youtube_dl_simulation.py b/test_youtube_dl_simulation.py\nnew file mode 100644\nindex 000000000..0fcccff94\n--- /dev/null\n+++ b/test_youtube_dl_simulation.py\n@@ -0,0 +1,73 @@\n+\"\"\"\n+This simulates what youtube-dl does with output streams.\n+\"\"\"\n+\n+import sys\n+import io\n+from _pytest.capture import EncodedFile\n+\n+\n+def youtube_dl_write_string(s, out):\n+    \"\"\"Simulate youtube-dl's write_string function.\"\"\"\n+    # This is what youtube-dl does - checks for 'b' in mode\n+    if 'b' in out.mode:\n+        # If binary mode, encode to bytes\n+        print(f\"youtube-dl detected binary mode: {out.mode}\")\n+        byt = s.encode('utf-8')\n+        out.write(byt)\n+    else:\n+        # If text mode, write string directly\n+        print(f\"youtube-dl detected text mode: {out.mode}\")\n+        out.write(s)\n+\n+\n+def test_before_fix():\n+    \"\"\"Show what happens without the fix (when mode has 'b').\"\"\"\n+    print(\"=== BEFORE FIX (simulated) ===\")\n+    buffer = io.BytesIO()\n+    buffer.mode = \"rb+\"\n+    \n+    # Simulate an EncodedFile that doesn't override mode\n+    class OldEncodedFile:\n+        def __init__(self, buffer, encoding):\n+            self.buffer = buffer\n+            self.encoding = encoding\n+            \n+        def write(self, obj):\n+            if isinstance(obj, str):\n+                obj = obj.encode(self.encoding, \"replace\")\n+            elif isinstance(obj, bytes):\n+                raise TypeError(f\"write() argument must be str, not {type(obj).__name__}\")\n+            self.buffer.write(obj)\n+            \n+        def __getattr__(self, name):\n+            return getattr(self.buffer, name)\n+    \n+    ef = OldEncodedFile(buffer, \"utf-8\")\n+    \n+    try:\n+        youtube_dl_write_string(\"Hello from youtube-dl\\n\", ef)\n+        print(\"SUCCESS: No exception raised\")\n+    except TypeError as e:\n+        print(f\"ERROR: {e}\")\n+\n+\n+def test_after_fix():\n+    \"\"\"Show what happens with the fix (mode has no 'b').\"\"\"\n+    print(\"\\n=== AFTER FIX ===\")\n+    buffer = io.BytesIO()\n+    buffer.mode = \"rb+\"\n+    \n+    # Use the fixed EncodedFile\n+    ef = EncodedFile(buffer, \"utf-8\")\n+    \n+    try:\n+        youtube_dl_write_string(\"Hello from youtube-dl\\n\", ef)\n+        print(\"SUCCESS: No exception raised\")\n+    except TypeError as e:\n+        print(f\"ERROR: {e}\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_before_fix()\n+    test_after_fix()\ndiff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 5d80eb63d..3c5e150fe 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -1461,6 +1461,25 @@ def test_pickling_and_unpickling_encoded_file():\n     pickle.loads(ef_as_str)\n \n \n+def test_encodedfile_mode_no_binary():\n+    \"\"\"Test that EncodedFile.mode removes binary flag.\"\"\"\n+    import io\n+    # Create a buffer with binary mode\n+    buffer = io.BytesIO()\n+    buffer.mode = \"rb+\"\n+    \n+    ef = capture.EncodedFile(buffer, \"utf-8\")\n+    \n+    # EncodedFile should report text mode (no 'b')\n+    assert ef.mode == \"r+\"\n+    assert \"b\" not in ef.mode\n+    \n+    # Test that write still only accepts strings\n+    ef.write(\"test string\")  # Should work\n+    with pytest.raises(TypeError, match=\"write\\\\(\\\\) argument must be str\"):\n+        ef.write(b\"test bytes\")  # Should fail\n+\n+\n def test_global_capture_with_live_logging(testdir):\n     # Issue 3819\n     # capture should work with live cli logging\n", "gold_standard_diff": "diff --git a/changelog/5257.bugfix.rst b/changelog/5257.bugfix.rst\nnew file mode 100644\nindex 00000000000..5205190882d\n--- /dev/null\n+++ b/changelog/5257.bugfix.rst\n@@ -0,0 +1 @@\n+Ensure that ``sys.stdout.mode`` does not include ``'b'`` as it is a text stream.\ndiff --git a/src/_pytest/capture.py b/src/_pytest/capture.py\nindex 25eab7fdf14..56017113429 100644\n--- a/src/_pytest/capture.py\n+++ b/src/_pytest/capture.py\n@@ -447,6 +447,10 @@ def name(self):\n         \"\"\"Ensure that file.name is a string.\"\"\"\n         return repr(self.buffer)\n \n+    @property\n+    def mode(self):\n+        return self.buffer.mode.replace(\"b\", \"\")\n+\n     def __getattr__(self, name):\n         return getattr(object.__getattribute__(self, \"buffer\"), name)\n \ndiff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 5d80eb63da0..f1802cc16dc 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -1051,6 +1051,9 @@ def test_simple_resume_suspend(self, tmpfile):\n             cap.done()\n             pytest.raises(AttributeError, cap.suspend)\n \n+    def test_capfd_sys_stdout_mode(self, capfd):\n+        assert \"b\" not in sys.stdout.mode\n+\n \n @contextlib.contextmanager\n def saved_fd(fd):\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/5262"}