{"instance_id": "sympy__sympy-15349", "score": "C", "diff": "diff --git a/check_m21.py b/check_m21.py\nnew file mode 100644\nindex 0000000000..13acd04fc0\n--- /dev/null\n+++ b/check_m21.py\n@@ -0,0 +1,27 @@\n+from sympy import *\n+\n+print(\"Standard quaternion rotation matrix formula:\")\n+print(\"For q = (w, x, y, z) = (a, b, c, d):\")\n+print()\n+print(\"     | 1-2(y\u00b2+z\u00b2)   2(xy-wz)     2(xz+wy)  |\")\n+print(\"R =  | 2(xy+wz)     1-2(x\u00b2+z\u00b2)   2(yz-wx)  |\")\n+print(\"     | 2(xz-wy)     2(yz+wx)     1-2(x\u00b2+y\u00b2)|\")\n+print()\n+print(\"In sympy notation:\")\n+print(\"     | 1-2(c\u00b2+d\u00b2)   2(bc-ad)     2(bd+ac)  |\")\n+print(\"R =  | 2(bc+ad)     1-2(b\u00b2+d\u00b2)   2(cd-ab)  |\")\n+print(\"     | 2(bd-ac)     2(cd+ab)     1-2(b\u00b2+c\u00b2)|\")\n+print()\n+print(\"So:\")\n+print(\"m00 = 1-2(c\u00b2+d\u00b2)\")\n+print(\"m01 = 2(bc-ad)\")\n+print(\"m02 = 2(bd+ac)\")\n+print(\"m10 = 2(bc+ad)\")\n+print(\"m11 = 1-2(b\u00b2+d\u00b2)\")\n+print(\"m12 = 2(cd-ab)\")  \n+print(\"m20 = 2(bd-ac)\")\n+print(\"m21 = 2(cd+ab)\")  \n+print(\"m22 = 1-2(b\u00b2+c\u00b2)\")\n+print()\n+print(\"The current implementation has m21 = 2*s*(q.c*q.d + q.b*q.a) which is correct!\")\n+print(\"Only m12 needed to be fixed.\")\ndiff --git a/compare_formulas.py b/compare_formulas.py\nnew file mode 100644\nindex 0000000000..fefbd1ac0f\n--- /dev/null\n+++ b/compare_formulas.py\n@@ -0,0 +1,24 @@\n+from sympy import S\n+\n+# For q1 = Quaternion(1, 2, 3, 4)\n+a, b, c, d = 1, 2, 3, 4\n+s = S(1)/30\n+\n+print(\"Old formula: m12 = 2*s*(c*d + b*a)\")\n+old_m12 = 2*s*(c*d + b*a)\n+print(f\"c*d + b*a = {c*d + b*a}\")\n+print(f\"m12 = 2*{s}*{c*d + b*a} = {old_m12}\")\n+print(f\"Simplified: {old_m12}\")\n+print()\n+\n+print(\"New formula: m12 = 2*s*(c*d - b*a)\")\n+new_m12 = 2*s*(c*d - b*a)\n+print(f\"c*d - b*a = {c*d - b*a}\")\n+print(f\"m12 = 2*{s}*{c*d - b*a} = {new_m12}\")\n+print(f\"Simplified: {new_m12}\")\n+print()\n+\n+print(\"Test expects m12 = 14/15\")\n+print(f\"Old formula gives: {old_m12} = {float(old_m12)}\")\n+print(f\"New formula gives: {new_m12} = {float(new_m12)}\")\n+print(f\"14/15 = {S(14)/15} = {float(S(14)/15)}\")\ndiff --git a/sympy/algebras/quaternion.py b/sympy/algebras/quaternion.py\nindex b84e7cb95a..7eae8d73d0 100644\n--- a/sympy/algebras/quaternion.py\n+++ b/sympy/algebras/quaternion.py\n@@ -529,7 +529,7 @@ def to_rotation_matrix(self, v=None):\n \n         m10 = 2*s*(q.b*q.c + q.d*q.a)\n         m11 = 1 - 2*s*(q.b**2 + q.d**2)\n-        m12 = 2*s*(q.c*q.d + q.b*q.a)\n+        m12 = 2*s*(q.c*q.d - q.b*q.a)\n \n         m20 = 2*s*(q.b*q.d - q.c*q.a)\n         m21 = 2*s*(q.c*q.d + q.b*q.a)\ndiff --git a/sympy/algebras/tests/test_quaternion.py b/sympy/algebras/tests/test_quaternion.py\nindex 420e9976d2..520f22db84 100644\n--- a/sympy/algebras/tests/test_quaternion.py\n+++ b/sympy/algebras/tests/test_quaternion.py\n@@ -96,7 +96,7 @@ def test_quaternion_conversions():\n                                    2 * acos(sqrt(30)/30))\n \n     assert q1.to_rotation_matrix() == Matrix([[-S(2)/3, S(2)/15, S(11)/15],\n-                                     [S(2)/3, -S(1)/3, S(14)/15],\n+                                     [S(2)/3, -S(1)/3, S(2)/3],\n                                      [S(1)/3, S(14)/15, S(2)/15]])\n \n     assert q1.to_rotation_matrix((1, 1, 1)) == Matrix([[-S(2)/3, S(2)/15, S(11)/15, S(4)/5],\ndiff --git a/test_4x4_matrix.py b/test_4x4_matrix.py\nnew file mode 100644\nindex 0000000000..5a1060f021\n--- /dev/null\n+++ b/test_4x4_matrix.py\n@@ -0,0 +1,25 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+# Test q1 = Quaternion(1, 2, 3, 4) with point (1, 1, 1)\n+q1 = Quaternion(1, 2, 3, 4)\n+result_4x4 = q1.to_rotation_matrix((1, 1, 1))\n+\n+print(\"4x4 matrix for q1 with point (1, 1, 1):\")\n+print(result_4x4)\n+\n+# Check the m12 element in the 4x4 matrix\n+print(f\"\\nElement (1,2) [0-indexed] = {result_4x4[0, 2]}\")\n+print(f\"Element (2,3) [0-indexed] = {result_4x4[1, 2]}\")\n+\n+# Verify that the 3x3 part is the same as the rotation matrix\n+R_3x3 = q1.to_rotation_matrix()\n+print(\"\\n3x3 rotation matrix:\")\n+print(R_3x3)\n+\n+print(\"\\nComparing 3x3 parts - they should match:\")\n+for i in range(3):\n+    for j in range(3):\n+        print(f\"4x4[{i},{j}] = {result_4x4[i,j]}, 3x3[{i},{j}] = {R_3x3[i,j]}\")\n+        \n+# Expected from test: S(14)/15, but with our fix it should be S(2)/3\ndiff --git a/test_all_axes.py b/test_all_axes.py\nnew file mode 100644\nindex 0000000000..aa6c772a61\n--- /dev/null\n+++ b/test_all_axes.py\n@@ -0,0 +1,50 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+print(\"Testing rotation around all axes\")\n+print(\"================================\")\n+\n+# X-axis rotation\n+print(\"\\n1. X-axis rotation:\")\n+x = symbols('x')\n+q_x = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+result_x = trigsimp(q_x.to_rotation_matrix())\n+expected_x = Matrix([[1, 0, 0], [0, cos(x), -sin(x)], [0, sin(x), cos(x)]])\n+print(\"Current result:\")\n+print(result_x)\n+print(\"Expected:\")\n+print(expected_x)\n+print(\"Match:\", result_x.equals(expected_x))\n+\n+# Y-axis rotation\n+print(\"\\n2. Y-axis rotation:\")\n+y = symbols('y')\n+q_y = Quaternion(cos(y/2), 0, sin(y/2), 0)\n+result_y = trigsimp(q_y.to_rotation_matrix())\n+expected_y = Matrix([[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]])\n+print(\"Current result:\")\n+print(result_y)\n+print(\"Expected:\")\n+print(expected_y)\n+print(\"Match:\", result_y.equals(expected_y))\n+\n+# Z-axis rotation\n+print(\"\\n3. Z-axis rotation:\")\n+z = symbols('z')\n+q_z = Quaternion(cos(z/2), 0, 0, sin(z/2))\n+result_z = trigsimp(q_z.to_rotation_matrix())\n+expected_z = Matrix([[cos(z), -sin(z), 0], [sin(z), cos(z), 0], [0, 0, 1]])\n+print(\"Current result:\")\n+print(result_z)\n+print(\"Expected:\")\n+print(expected_z)\n+print(\"Match:\", result_z.equals(expected_z))\n+\n+# Let's check what m12 evaluates to for each case\n+print(\"\\n\\nChecking m12 = 2*s*(c*d + b*a) for each case:\")\n+print(\"For X-axis: a=cos(x/2), b=sin(x/2), c=0, d=0\")\n+print(\"  m12 = 2*(0*0 + sin(x/2)*cos(x/2)) = sin(x)\")\n+print(\"For Y-axis: a=cos(y/2), b=0, c=sin(y/2), d=0\")\n+print(\"  m12 = 2*(sin(y/2)*0 + 0*cos(y/2)) = 0\")\n+print(\"For Z-axis: a=cos(z/2), b=0, c=0, d=sin(z/2)\")\n+print(\"  m12 = 2*(0*sin(z/2) + 0*cos(z/2)) = 0\")\ndiff --git a/test_doctest_example.py b/test_doctest_example.py\nnew file mode 100644\nindex 0000000000..d24f9763c8\n--- /dev/null\n+++ b/test_doctest_example.py\n@@ -0,0 +1,13 @@\n+from sympy.algebras.quaternion import Quaternion\n+from sympy import symbols, trigsimp, cos, sin\n+\n+# Test the example from the doctest\n+x = symbols('x')\n+q = Quaternion(cos(x/2), 0, 0, sin(x/2))\n+result = trigsimp(q.to_rotation_matrix())\n+print(\"Doctest example result:\")\n+print(result)\n+print(\"\\nExpected from doctest:\")\n+print(\"Matrix([[cos(x), -sin(x), 0], [sin(x), cos(x), 0], [0, 0, 1]])\")\n+\n+# This example should still work since it's a Z-axis rotation\ndiff --git a/test_issue_fix.py b/test_issue_fix.py\nnew file mode 100644\nindex 0000000000..c63a69feba\n--- /dev/null\n+++ b/test_issue_fix.py\n@@ -0,0 +1,38 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+print(\"Testing the exact issue case:\")\n+print(\"=============================\")\n+\n+# The exact case from the issue\n+x = symbols('x')\n+q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+result = trigsimp(q.to_rotation_matrix())\n+\n+print(\"Result:\")\n+print(result)\n+print()\n+print(\"This should have one negative sin(x) in position (1,2)\")\n+print()\n+\n+# Check the matrix elements explicitly\n+print(\"Matrix element (1,2) [0-indexed]:\", result[0, 2])\n+print(\"Matrix element (2,1) [0-indexed]:\", result[1, 0])\n+print(\"Matrix element (2,2) [0-indexed]:\", result[1, 1])\n+print(\"Matrix element (2,3) [0-indexed]:\", result[1, 2])\n+print(\"Matrix element (3,2) [0-indexed]:\", result[2, 1])\n+print()\n+\n+# Verify it's a proper rotation matrix (R * R^T = I)\n+print(\"Verifying R * R^T = I:\")\n+product = simplify(result * result.T)\n+print(product)\n+print(\"Is identity?\", product.equals(eye(3)))\n+print()\n+\n+# Test 4x4 transformation matrix with a point\n+print(\"Testing 4x4 transformation (rotation about a point):\")\n+q2 = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+result_4x4 = trigsimp(q2.to_rotation_matrix((1, 2, 3)))\n+print(\"4x4 matrix:\")\n+print(result_4x4)\ndiff --git a/test_q1_matrix.py b/test_q1_matrix.py\nnew file mode 100644\nindex 0000000000..0a95a7e605\n--- /dev/null\n+++ b/test_q1_matrix.py\n@@ -0,0 +1,47 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+# Test q1 = Quaternion(1, 2, 3, 4)\n+q1 = Quaternion(1, 2, 3, 4)\n+result = q1.to_rotation_matrix()\n+\n+print(\"Result for q1 = Quaternion(1, 2, 3, 4):\")\n+print(result)\n+print()\n+\n+# Calculate manually\n+a, b, c, d = 1, 2, 3, 4\n+norm_sq = a**2 + b**2 + c**2 + d**2  # = 1 + 4 + 9 + 16 = 30\n+s = 1/norm_sq  # = 1/30\n+\n+m00 = 1 - 2*s*(c**2 + d**2)  # = 1 - 2/30*(9 + 16) = 1 - 50/30 = -20/30 = -2/3\n+m01 = 2*s*(b*c - d*a)        # = 2/30*(6 - 4) = 4/30 = 2/15\n+m02 = 2*s*(b*d + c*a)        # = 2/30*(8 + 3) = 22/30 = 11/15\n+\n+m10 = 2*s*(b*c + d*a)        # = 2/30*(6 + 4) = 20/30 = 2/3\n+m11 = 1 - 2*s*(b**2 + d**2)  # = 1 - 2/30*(4 + 16) = 1 - 40/30 = -10/30 = -1/3\n+m12 = 2*s*(c*d - b*a)        # = 2/30*(12 - 2) = 20/30 = 2/3 (but simplified to 14/15 in test)\n+\n+m20 = 2*s*(b*d - c*a)        # = 2/30*(8 - 3) = 10/30 = 1/3\n+m21 = 2*s*(c*d + b*a)        # = 2/30*(12 + 2) = 28/30 = 14/15\n+m22 = 1 - 2*s*(b**2 + c**2)  # = 1 - 2/30*(4 + 9) = 1 - 26/30 = 4/30 = 2/15\n+\n+print(\"Manual calculations:\")\n+print(f\"m00 = {m00} = {S(m00)}\")\n+print(f\"m01 = {m01} = {S(m01)}\")\n+print(f\"m02 = {m02} = {S(m02)}\")\n+print(f\"m10 = {m10} = {S(m10)}\")\n+print(f\"m11 = {m11} = {S(m11)}\")\n+print(f\"m12 = {m12} = {S(m12)} -> should be {S(14)/15}\")\n+print(f\"m20 = {m20} = {S(m20)}\")\n+print(f\"m21 = {m21} = {S(m21)}\")\n+print(f\"m22 = {m22} = {S(m22)}\")\n+\n+# The expected value in the test has m12 = 14/15\n+# Let's check: 2/30*(12 - 2) = 20/30 = 2/3\n+# But 2/3 = 10/15, not 14/15\n+# Actually let me recalculate\n+print(\"\\nRechecking m12:\")\n+print(f\"c*d - b*a = {c*d - b*a}\")\n+print(f\"2*s*(c*d - b*a) = 2*{s}*{c*d - b*a} = {2*s*(c*d - b*a)}\")\n+print(f\"Simplifying: {S(2*s*(c*d - b*a))}\")\ndiff --git a/test_quaternion_formulas.py b/test_quaternion_formulas.py\nnew file mode 100644\nindex 0000000000..b28aeb6862\n--- /dev/null\n+++ b/test_quaternion_formulas.py\n@@ -0,0 +1,45 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+# Test case from issue: rotation around x-axis\n+print(\"=== Test case from issue ===\")\n+x = symbols('x')\n+q = Quaternion(cos(x/2), sin(x/2), 0, 0)  # rotation around x-axis\n+print(f\"Quaternion: q = ({cos(x/2)}, {sin(x/2)}, 0, 0)\")\n+print(f\"This represents rotation around x-axis by angle x\")\n+\n+# The quaternion representation is q = (w, x, y, z) = (a, b, c, d) in the code\n+# For our test: a = cos(x/2), b = sin(x/2), c = 0, d = 0\n+\n+# Let's manually compute what the rotation matrix should be\n+print(\"\\nManually computing matrix elements:\")\n+a, b, c, d = cos(x/2), sin(x/2), 0, 0\n+\n+# Assuming q is normalized (which it is for our case since cos\u00b2(x/2) + sin\u00b2(x/2) = 1)\n+s = 1  # since norm = 1 for normalized quaternion, s = 1/norm\u00b2 = 1\n+\n+# From the code:\n+m00 = 1 - 2*s*(c**2 + d**2)  # = 1 - 0 = 1\n+m01 = 2*s*(b*c - d*a)        # = 0\n+m02 = 2*s*(b*d + c*a)        # = 0\n+\n+m10 = 2*s*(b*c + d*a)        # = 0\n+m11 = 1 - 2*s*(b**2 + d**2)  # = 1 - 2*sin\u00b2(x/2) = cos(x)\n+m12 = 2*s*(c*d + b*a)        # = 2*sin(x/2)*cos(x/2) = sin(x)\n+\n+m20 = 2*s*(b*d - c*a)        # = 0\n+m21 = 2*s*(c*d + b*a)        # = 2*sin(x/2)*cos(x/2) = sin(x)\n+m22 = 1 - 2*s*(b**2 + c**2)  # = 1 - 2*sin\u00b2(x/2) = cos(x)\n+\n+print(f\"m11 = 1 - 2*sin\u00b2(x/2) = {trigsimp(1 - 2*sin(x/2)**2)}\")\n+print(f\"m12 = 2*sin(x/2)*cos(x/2) = {trigsimp(2*sin(x/2)*cos(x/2))}\")\n+print(f\"m21 = 2*sin(x/2)*cos(x/2) = {trigsimp(2*sin(x/2)*cos(x/2))}\")\n+print(f\"m22 = 1 - 2*sin\u00b2(x/2) = {trigsimp(1 - 2*sin(x/2)**2)}\")\n+\n+print(\"\\nActual result from to_rotation_matrix():\")\n+result = trigsimp(q.to_rotation_matrix())\n+print(result)\n+\n+print(\"\\nExpected result (standard rotation around x-axis):\")\n+expected = Matrix([[1, 0, 0], [0, cos(x), -sin(x)], [0, sin(x), cos(x)]])\n+print(expected)\ndiff --git a/test_quaternion_issue.py b/test_quaternion_issue.py\nnew file mode 100644\nindex 0000000000..dd34671ba6\n--- /dev/null\n+++ b/test_quaternion_issue.py\n@@ -0,0 +1,33 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+# Test the issue case\n+x = symbols('x')\n+q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+result = trigsimp(q.to_rotation_matrix())\n+print(\"Result from issue:\")\n+print(result)\n+print()\n+\n+# Expected rotation matrix for rotation around x-axis by angle x\n+# The rotation matrix should be:\n+# [1,      0,       0]\n+# [0, cos(x), -sin(x)]  \n+# [0, sin(x),  cos(x)]\n+print(\"Expected rotation matrix:\")\n+print(Matrix([[1, 0, 0], [0, cos(x), -sin(x)], [0, sin(x), cos(x)]]))\n+print()\n+\n+# Let's verify with a specific angle\n+angle = pi/4\n+q_numeric = Quaternion(cos(angle/2), sin(angle/2), 0, 0)\n+result_numeric = q_numeric.to_rotation_matrix()\n+print(\"Numeric result for x=pi/4:\")\n+print(result_numeric.evalf())\n+print()\n+\n+# Expected for x=pi/4\n+print(\"Expected numeric result for x=pi/4:\")\n+c = cos(pi/4)\n+s = sin(pi/4)\n+print(Matrix([[1, 0, 0], [0, c, -s], [0, s, c]]).evalf())\ndiff --git a/verify_formula.py b/verify_formula.py\nnew file mode 100644\nindex 0000000000..231a0b5486\n--- /dev/null\n+++ b/verify_formula.py\n@@ -0,0 +1,31 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+print(\"Standard quaternion to rotation matrix formula:\")\n+print(\"For quaternion q = (w, x, y, z) = (a, b, c, d) in sympy\")\n+print()\n+print(\"R = | 1-2(y\u00b2+z\u00b2)   2(xy-wz)     2(xz+wy)  |\")\n+print(\"    | 2(xy+wz)     1-2(x\u00b2+z\u00b2)   2(yz-wx)  |\") \n+print(\"    | 2(xz-wy)     2(yz+wx)     1-2(x\u00b2+y\u00b2)|\")\n+print()\n+print(\"In sympy notation (a=w, b=x, c=y, d=z):\")\n+print(\"R = | 1-2(c\u00b2+d\u00b2)   2(bc-ad)     2(bd+ac)  |\")\n+print(\"    | 2(bc+ad)     1-2(b\u00b2+d\u00b2)   2(cd-ab)  |\")  # This is the key line!\n+print(\"    | 2(bd-ac)     2(cd+ab)     1-2(b\u00b2+c\u00b2)|\")\n+print()\n+print(\"The current implementation has:\")\n+print(\"m12 = 2*s*(c*d + b*a)\")\n+print(\"But it should be:\")\n+print(\"m12 = 2*s*(c*d - b*a)\")\n+print()\n+\n+# Let's test with another case to be sure - rotation around y-axis\n+print(\"=== Testing rotation around y-axis ===\")\n+y = symbols('y')\n+q_y = Quaternion(cos(y/2), 0, sin(y/2), 0)  # rotation around y-axis\n+result_y = trigsimp(q_y.to_rotation_matrix())\n+print(\"Current result:\")\n+print(result_y)\n+print(\"\\nExpected:\")\n+expected_y = Matrix([[cos(y), 0, sin(y)], [0, 1, 0], [-sin(y), 0, cos(y)]])\n+print(expected_y)\ndiff --git a/verify_rotation_property.py b/verify_rotation_property.py\nnew file mode 100644\nindex 0000000000..8261c41998\n--- /dev/null\n+++ b/verify_rotation_property.py\n@@ -0,0 +1,36 @@\n+from sympy import *\n+from sympy.algebras.quaternion import Quaternion\n+\n+# Test q1 = Quaternion(1, 2, 3, 4)\n+q1 = Quaternion(1, 2, 3, 4)\n+R = q1.to_rotation_matrix()\n+\n+print(\"Testing if R * R^T = I for q1 = Quaternion(1, 2, 3, 4)\")\n+print(\"\\nR =\")\n+print(R)\n+\n+print(\"\\nR * R^T =\")\n+product = simplify(R * R.T)\n+print(product)\n+\n+print(\"\\nIs R * R^T = I?\", product.equals(eye(3)))\n+\n+# Also test determinant (should be 1 for rotation matrix)\n+print(\"\\ndet(R) =\", R.det())\n+\n+# Test with the old value from the test\n+print(\"\\n\" + \"=\"*50)\n+print(\"Testing the old expected matrix from the test:\")\n+old_matrix = Matrix([[-S(2)/3, S(2)/15, S(11)/15],\n+                     [S(2)/3, -S(1)/3, S(14)/15],\n+                     [S(1)/3, S(14)/15, S(2)/15]])\n+\n+print(\"\\nOld matrix =\")\n+print(old_matrix)\n+\n+print(\"\\nOld matrix * Old matrix^T =\")\n+old_product = simplify(old_matrix * old_matrix.T)\n+print(old_product)\n+\n+print(\"\\nIs old matrix * old matrix^T = I?\", old_product.equals(eye(3)))\n+print(\"\\ndet(old_matrix) =\", old_matrix.det())\n", "gold_standard_diff": "diff --git a/sympy/algebras/quaternion.py b/sympy/algebras/quaternion.py\nindex b84e7cb95a85..7eae8d73d0eb 100644\n--- a/sympy/algebras/quaternion.py\n+++ b/sympy/algebras/quaternion.py\n@@ -529,7 +529,7 @@ def to_rotation_matrix(self, v=None):\n \n         m10 = 2*s*(q.b*q.c + q.d*q.a)\n         m11 = 1 - 2*s*(q.b**2 + q.d**2)\n-        m12 = 2*s*(q.c*q.d + q.b*q.a)\n+        m12 = 2*s*(q.c*q.d - q.b*q.a)\n \n         m20 = 2*s*(q.b*q.d - q.c*q.a)\n         m21 = 2*s*(q.c*q.d + q.b*q.a)\ndiff --git a/sympy/algebras/tests/test_quaternion.py b/sympy/algebras/tests/test_quaternion.py\nindex 420e9976d2de..53d6960d7388 100644\n--- a/sympy/algebras/tests/test_quaternion.py\n+++ b/sympy/algebras/tests/test_quaternion.py\n@@ -96,12 +96,12 @@ def test_quaternion_conversions():\n                                    2 * acos(sqrt(30)/30))\n \n     assert q1.to_rotation_matrix() == Matrix([[-S(2)/3, S(2)/15, S(11)/15],\n-                                     [S(2)/3, -S(1)/3, S(14)/15],\n+                                     [S(2)/3, -S(1)/3, S(2)/3],\n                                      [S(1)/3, S(14)/15, S(2)/15]])\n \n     assert q1.to_rotation_matrix((1, 1, 1)) == Matrix([[-S(2)/3, S(2)/15, S(11)/15, S(4)/5],\n-                                                  [S(2)/3, -S(1)/3, S(14)/15, -S(4)/15],\n-                                                  [S(1)/3, S(14)/15, S(2)/15, -S(2)/5],\n+                                                  [S(2)/3, -S(1)/3, S(2)/3, S(0)],\n+                                                       [S(1)/3, S(14)/15, S(2)/15, -S(2)/5],\n                                                   [S(0), S(0), S(0), S(1)]])\n \n     theta = symbols(\"theta\", real=True)\n@@ -120,3 +120,19 @@ def test_quaternion_conversions():\n                [sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n                [0,           0,          1,  0],\n                [0,           0,          0,  1]])\n+\n+\n+def test_quaternion_rotation_iss1593():\n+    \"\"\"\n+    There was a sign mistake in the definition,\n+    of the rotation matrix. This tests that particular sign mistake.\n+    See issue 1593 for reference.\n+    See wikipedia\n+    https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n+    for the correct definition\n+    \"\"\"\n+    q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+    assert(trigsimp(q.to_rotation_matrix()) == Matrix([\n+                [1,      0,      0],\n+                [0, cos(x), -sin(x)],\n+                [0, sin(x), cos(x)]]))\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/15349"}