{"instance_id": "django__django-13343", "score": "C", "diff": "diff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex e10a5bb6d9..e1fe727450 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -227,10 +227,12 @@ class FileField(Field):\n     def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **kwargs):\n         self._primary_key_set_explicitly = 'primary_key' in kwargs\n \n-        self.storage = storage or default_storage\n-        if callable(self.storage):\n-            self.storage = self.storage()\n-            if not isinstance(self.storage, Storage):\n+        self._storage = storage or default_storage\n+        self._storage_callable = callable(self._storage)\n+        if self._storage_callable:\n+            # Evaluate the callable to check if it returns a valid Storage\n+            storage_instance = self._storage()\n+            if not isinstance(storage_instance, Storage):\n                 raise TypeError(\n                     \"%s.storage must be a subclass/instance of %s.%s\"\n                     % (self.__class__.__qualname__, Storage.__module__, Storage.__qualname__)\n@@ -240,6 +242,12 @@ class FileField(Field):\n         kwargs.setdefault('max_length', 100)\n         super().__init__(verbose_name, name, **kwargs)\n \n+    @property\n+    def storage(self):\n+        if self._storage_callable:\n+            return self._storage()\n+        return self._storage\n+\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n@@ -278,8 +286,9 @@ class FileField(Field):\n         if kwargs.get(\"max_length\") == 100:\n             del kwargs[\"max_length\"]\n         kwargs['upload_to'] = self.upload_to\n-        if self.storage is not default_storage:\n-            kwargs['storage'] = self.storage\n+        # Use the original storage value (callable or instance) for deconstruction\n+        if self._storage is not default_storage:\n+            kwargs['storage'] = self._storage\n         return name, path, args, kwargs\n \n     def get_internal_type(self):\ndiff --git a/test_callable_storage.py b/test_callable_storage.py\nnew file mode 100644\nindex 0000000000..57b1fa7646\n--- /dev/null\n+++ b/test_callable_storage.py\n@@ -0,0 +1,69 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+from django.db import models\n+from django.core.files.storage import default_storage\n+\n+\n+def get_custom_storage():\n+    \"\"\"A callable that returns a storage instance.\"\"\"\n+    return default_storage\n+\n+\n+class TestModel(models.Model):\n+    # Test with callable storage\n+    file_field = models.FileField(storage=get_custom_storage)\n+    # Test with callable upload_to for comparison\n+    file_field_upload = models.FileField(upload_to=lambda instance, filename: f\"test/{filename}\")\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+# Test the deconstruction\n+field = TestModel._meta.get_field('file_field')\n+name, path, args, kwargs = field.deconstruct()\n+\n+print(\"Deconstructed FileField with callable storage:\")\n+print(f\"  name: {name}\")\n+print(f\"  path: {path}\")\n+print(f\"  args: {args}\")\n+print(f\"  kwargs: {kwargs}\")\n+print(f\"  storage in kwargs: {'storage' in kwargs}\")\n+if 'storage' in kwargs:\n+    print(f\"  storage value: {kwargs['storage']}\")\n+    print(f\"  storage is callable: {callable(kwargs['storage'])}\")\n+    print(f\"  storage is the original function: {kwargs['storage'] is get_custom_storage}\")\n+\n+print(\"\\n\" + \"=\"*50 + \"\\n\")\n+\n+# Compare with upload_to\n+field_upload = TestModel._meta.get_field('file_field_upload')\n+name, path, args, kwargs = field_upload.deconstruct()\n+\n+print(\"Deconstructed FileField with callable upload_to:\")\n+print(f\"  name: {name}\")\n+print(f\"  path: {path}\")\n+print(f\"  args: {args}\")\n+print(f\"  kwargs: {kwargs}\")\n+print(f\"  upload_to in kwargs: {'upload_to' in kwargs}\")\n+if 'upload_to' in kwargs:\n+    print(f\"  upload_to value: {kwargs['upload_to']}\")\n+    print(f\"  upload_to is callable: {callable(kwargs['upload_to'])}\")\ndiff --git a/test_callable_storage_deconstruct.py b/test_callable_storage_deconstruct.py\nnew file mode 100644\nindex 0000000000..fc0d9deaff\n--- /dev/null\n+++ b/test_callable_storage_deconstruct.py\n@@ -0,0 +1,122 @@\n+import django\n+from django.conf import settings\n+from django.test import TestCase\n+from django.db import models\n+from django.core.files.storage import default_storage, Storage\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+\n+def get_test_storage():\n+    \"\"\"A callable that returns a storage instance.\"\"\"\n+    return default_storage\n+\n+\n+def get_test_storage_2():\n+    \"\"\"Another callable that returns a different storage instance.\"\"\"\n+    from django.core.files.storage import FileSystemStorage\n+    return FileSystemStorage(location='/tmp/test')\n+\n+\n+class FileFieldCallableStorageTests(TestCase):\n+    \"\"\"Test that FileField correctly handles callable storage during deconstruction.\"\"\"\n+    \n+    def test_callable_storage_deconstruct(self):\n+        \"\"\"Test that a callable storage is preserved in deconstruction.\"\"\"\n+        # Create a field with callable storage\n+        field = models.FileField(storage=get_test_storage)\n+        \n+        # Deconstruct it\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        # The storage should be in kwargs and should be the original callable\n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], get_test_storage)\n+        self.assertTrue(callable(kwargs['storage']))\n+        \n+    def test_callable_storage_different_than_default(self):\n+        \"\"\"Test that a callable storage different from default is preserved.\"\"\"\n+        # Create a field with a different callable storage\n+        field = models.FileField(storage=get_test_storage_2)\n+        \n+        # Deconstruct it\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        # The storage should be in kwargs\n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], get_test_storage_2)\n+        self.assertTrue(callable(kwargs['storage']))\n+        \n+    def test_non_callable_storage_deconstruct(self):\n+        \"\"\"Test that a non-callable storage is also handled correctly.\"\"\"\n+        from django.core.files.storage import FileSystemStorage\n+        custom_storage = FileSystemStorage(location='/tmp/custom')\n+        \n+        # Create a field with non-callable storage\n+        field = models.FileField(storage=custom_storage)\n+        \n+        # Deconstruct it\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        # The storage should be in kwargs and should be the instance\n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], custom_storage)\n+        self.assertFalse(callable(kwargs['storage']))\n+        \n+    def test_callable_storage_evaluated_on_access(self):\n+        \"\"\"Test that callable storage is evaluated when accessed.\"\"\"\n+        # Create a field with callable storage\n+        field = models.FileField(storage=get_test_storage)\n+        \n+        # Access the storage property\n+        storage = field.storage\n+        \n+        # It should be a Storage instance\n+        self.assertIsInstance(storage, Storage)\n+        \n+        # But the original should still be callable\n+        self.assertTrue(callable(field._storage))\n+        \n+    def test_default_storage_omitted_from_deconstruct(self):\n+        \"\"\"Test that default_storage is omitted from deconstruction.\"\"\"\n+        # Create a field with default storage  \n+        field = models.FileField()\n+        \n+        # Deconstruct it\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        # Storage should not be in kwargs\n+        self.assertNotIn('storage', kwargs)\n+\n+\n+# Run the tests\n+if __name__ == '__main__':\n+    import unittest\n+    \n+    # Create test suite\n+    suite = unittest.TestLoader().loadTestsFromTestCase(FileFieldCallableStorageTests)\n+    \n+    # Run tests\n+    runner = unittest.TextTestRunner(verbosity=2)\n+    result = runner.run(suite)\n+    \n+    # Print summary\n+    if result.wasSuccessful():\n+        print(\"\\nAll tests passed!\")\n+    else:\n+        print(f\"\\n{len(result.failures)} failures, {len(result.errors)} errors\")\ndiff --git a/test_field_deconstruction.py b/test_field_deconstruction.py\nnew file mode 100644\nindex 0000000000..14b7ff668c\n--- /dev/null\n+++ b/test_field_deconstruction.py\n@@ -0,0 +1,104 @@\n+\"\"\"\n+Test for FileField deconstruction with callable storage.\n+This test should be added to Django's test suite.\n+\"\"\"\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-secret-key',\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+from django.test import TestCase\n+from django.db import models\n+from django.core.files.storage import default_storage, FileSystemStorage\n+\n+\n+def callable_storage():\n+    return default_storage\n+\n+\n+def custom_callable_storage():\n+    return FileSystemStorage(location='/tmp/custom')\n+\n+\n+class FileFieldCallableStorageDeconstructionTests(TestCase):\n+    \"\"\"\n+    Test that FileField with callable storage deconstructs properly.\n+    Regression test for https://code.djangoproject.com/ticket/XXXXX\n+    \"\"\"\n+\n+    def test_callable_storage_preserved_in_deconstruct(self):\n+        \"\"\"A callable storage should be preserved as-is during deconstruction.\"\"\"\n+        field = models.FileField(storage=callable_storage)\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], callable_storage)\n+        self.assertTrue(callable(kwargs['storage']))\n+\n+    def test_different_callable_storage_in_deconstruct(self):\n+        \"\"\"A different callable storage should be included in deconstruction.\"\"\"\n+        field = models.FileField(storage=custom_callable_storage)\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], custom_callable_storage)\n+        self.assertTrue(callable(kwargs['storage']))\n+\n+    def test_non_callable_storage_in_deconstruct(self):\n+        \"\"\"A non-callable storage instance should also work correctly.\"\"\"\n+        storage_instance = FileSystemStorage(location='/tmp/test')\n+        field = models.FileField(storage=storage_instance)\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], storage_instance)\n+        self.assertIsInstance(kwargs['storage'], FileSystemStorage)\n+\n+    def test_default_storage_omitted_from_deconstruct(self):\n+        \"\"\"Fields with default storage should not include storage in deconstruction.\"\"\"\n+        field = models.FileField()\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        self.assertNotIn('storage', kwargs)\n+\n+    def test_callable_storage_evaluated_on_property_access(self):\n+        \"\"\"Callable storage should be evaluated when the storage property is accessed.\"\"\"\n+        field = models.FileField(storage=callable_storage)\n+        \n+        # The storage property should return the evaluated storage\n+        self.assertEqual(field.storage, default_storage)\n+        # But the original callable should be preserved\n+        self.assertEqual(field._storage, callable_storage)\n+\n+    def test_imagefield_inherits_callable_storage_behavior(self):\n+        \"\"\"ImageField should inherit the callable storage behavior from FileField.\"\"\"\n+        field = models.ImageField(storage=callable_storage)\n+        name, path, args, kwargs = field.deconstruct()\n+        \n+        self.assertIn('storage', kwargs)\n+        self.assertEqual(kwargs['storage'], callable_storage)\n+        self.assertTrue(callable(kwargs['storage']))\n+\n+\n+if __name__ == '__main__':\n+    import unittest\n+    suite = unittest.TestLoader().loadTestsFromTestCase(FileFieldCallableStorageDeconstructionTests)\n+    runner = unittest.TextTestRunner(verbosity=2)\n+    result = runner.run(suite)\n+    print(f\"\\nTests run: {result.testsRun}\")\n+    print(f\"Failures: {len(result.failures)}\")\n+    print(f\"Errors: {len(result.errors)}\")\ndiff --git a/test_migration_writer.py b/test_migration_writer.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\n", "gold_standard_diff": "From 8711fec8a8c2ee83da9fc1d5b6efc8869ddd3323 Mon Sep 17 00:00:00 2001\nFrom: Brian Helba <brian.helba@kitware.com>\nDate: Mon, 24 Aug 2020 15:27:22 -0400\nSubject: [PATCH] Fixed #31941 -- Corrected FileField.deconstruct() with a\n callable storage.\n\n---\n AUTHORS                          |  1 +\n django/db/models/fields/files.py |  4 +++-\n docs/releases/3.1.2.txt          |  3 ++-\n tests/file_storage/tests.py      | 13 ++++++++++++-\n 4 files changed, 18 insertions(+), 3 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex 5c50598ddc95..386837aee66a 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -146,6 +146,7 @@ answer newbie questions, and generally made Django that much better:\n     Brian Beck <http://blog.brianbeck.com/>\n     Brian Fabian Crain <http://www.bfc.do/>\n     Brian Harring <ferringb@gmail.com>\n+    Brian Helba <brian.helba@kitware.com>\n     Brian Ray <http://brianray.chipy.org/>\n     Brian Rosner <brosner@gmail.com>\n     Bruce Kroeze <https://coderseye.com/>\ndiff --git a/django/db/models/fields/files.py b/django/db/models/fields/files.py\nindex e10a5bb6d96a..db2450a738bb 100644\n--- a/django/db/models/fields/files.py\n+++ b/django/db/models/fields/files.py\n@@ -229,6 +229,8 @@ def __init__(self, verbose_name=None, name=None, upload_to='', storage=None, **k\n \n         self.storage = storage or default_storage\n         if callable(self.storage):\n+            # Hold a reference to the callable for deconstruct().\n+            self._storage_callable = self.storage\n             self.storage = self.storage()\n             if not isinstance(self.storage, Storage):\n                 raise TypeError(\n@@ -279,7 +281,7 @@ def deconstruct(self):\n             del kwargs[\"max_length\"]\n         kwargs['upload_to'] = self.upload_to\n         if self.storage is not default_storage:\n-            kwargs['storage'] = self.storage\n+            kwargs['storage'] = getattr(self, '_storage_callable', self.storage)\n         return name, path, args, kwargs\n \n     def get_internal_type(self):\ndiff --git a/docs/releases/3.1.2.txt b/docs/releases/3.1.2.txt\nindex 64c64f7e7841..1243654bfb64 100644\n--- a/docs/releases/3.1.2.txt\n+++ b/docs/releases/3.1.2.txt\n@@ -9,4 +9,5 @@ Django 3.1.2 fixes several bugs in 3.1.1.\n Bugfixes\n ========\n \n-* ...\n+* Fixed a bug in Django 3.1 where ``FileField`` instances with a callable\n+  storage were not correctly deconstructed (:ticket:`31941`).\ndiff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 4bac3ca11da8..6d17a7118b4e 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -29,7 +29,9 @@\n from django.urls import NoReverseMatch, reverse_lazy\n from django.utils import timezone\n \n-from .models import Storage, temp_storage, temp_storage_location\n+from .models import (\n+    Storage, callable_storage, temp_storage, temp_storage_location,\n+)\n \n FILE_SUFFIX_REGEX = '[A-Za-z0-9]{7}'\n \n@@ -912,6 +914,15 @@ def test_callable_storage_file_field_in_model(self):\n         self.assertEqual(obj.storage_callable.storage.location, temp_storage_location)\n         self.assertIsInstance(obj.storage_callable_class.storage, BaseStorage)\n \n+    def test_deconstruction(self):\n+        \"\"\"\n+        Deconstructing gives the original callable, not the evaluated value.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field('storage_callable').deconstruct()\n+        storage = kwargs['storage']\n+        self.assertIs(storage, callable_storage)\n+\n \n # Tests for a race condition on file saving (#4948).\n # This is written in such a way that it'll always pass on platforms\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13343"}