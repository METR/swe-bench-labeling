{"instance_id": "pydata__xarray-2905", "score": "C", "diff": "diff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 00000000..0fce5c1e\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,21 @@\n+import xarray as xr\n+import numpy as np\n+\n+good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])\n+\n+class HasValues(object):\n+    values = 5\n+    \n+good_indexed.loc[{'dim_0': 0}] = set()\n+bad_indexed.loc[{'dim_0': 0}] = HasValues()\n+\n+print(\"good_indexed.values =>\", good_indexed.values)\n+print(\"bad_indexed.values =>\", bad_indexed.values)\n+\n+# Test with another object that has values attribute\n+class AnotherHasValues(object):\n+    values = [1, 2, 3]\n+\n+test_indexed = xr.DataArray([None])\n+test_indexed.loc[{'dim_0': 0}] = AnotherHasValues()\n+print(\"test_indexed.values =>\", test_indexed.values)\ndiff --git a/test_pandas_compat.py b/test_pandas_compat.py\nnew file mode 100644\nindex 00000000..07ca92fb\n--- /dev/null\n+++ b/test_pandas_compat.py\n@@ -0,0 +1,31 @@\n+import xarray as xr\n+import pandas as pd\n+import numpy as np\n+\n+# Test that pandas objects still work correctly\n+arr = xr.DataArray([1, 2, 3])\n+\n+# Test with pandas Series\n+s = pd.Series([10, 20, 30])\n+arr.loc[{'dim_0': 0}] = s[0]\n+print(\"After assigning pandas Series element:\", arr.values)\n+\n+# Test with pandas DataFrame  \n+df = pd.DataFrame({'a': [100, 200, 300]})\n+arr2 = xr.DataArray([[1, 2], [3, 4]])\n+try:\n+    # This should work if dimensions match\n+    arr2.loc[{'dim_0': 0}] = df.iloc[0].values\n+    print(\"After assigning DataFrame row values:\", arr2.values)\n+except Exception as e:\n+    print(\"Error with DataFrame:\", e)\n+\n+# Test direct pandas Series assignment\n+arr3 = xr.DataArray([None, None, None])\n+arr3[:] = pd.Series([1, 2, 3])\n+print(\"After assigning full pandas Series:\", arr3.values)\n+\n+# Test that the fix doesn't affect numpy arrays\n+arr4 = xr.DataArray([None])\n+arr4.loc[{'dim_0': 0}] = np.array(42)\n+print(\"After assigning numpy scalar:\", arr4.values)\ndiff --git a/test_values_attribute_fix.py b/test_values_attribute_fix.py\nnew file mode 100644\nindex 00000000..d19ae7b0\n--- /dev/null\n+++ b/test_values_attribute_fix.py\n@@ -0,0 +1,52 @@\n+import xarray as xr\n+import numpy as np\n+import pandas as pd\n+\n+\n+def test_setitem_object_with_values_attribute():\n+    \"\"\"Test that objects with .values attribute are not coerced when assigned to DataArray\"\"\"\n+    \n+    # Test case 1: Object with scalar .values attribute\n+    class HasScalarValues:\n+        values = 5\n+    \n+    arr = xr.DataArray([None])\n+    obj = HasScalarValues()\n+    arr.loc[{'dim_0': 0}] = obj\n+    \n+    # Should store the object itself, not extract .values\n+    assert isinstance(arr.values[0], HasScalarValues)\n+    assert arr.values[0] is obj\n+    \n+    # Test case 2: Object with array .values attribute\n+    class HasArrayValues:\n+        values = [1, 2, 3]\n+    \n+    arr2 = xr.DataArray([None])\n+    obj2 = HasArrayValues()\n+    arr2.loc[{'dim_0': 0}] = obj2\n+    \n+    # Should store the object itself\n+    assert isinstance(arr2.values[0], HasArrayValues)\n+    assert arr2.values[0] is obj2\n+    \n+    # Test case 3: Ensure pandas objects still work correctly\n+    arr3 = xr.DataArray([1, 2, 3])\n+    series = pd.Series([10, 20, 30])\n+    arr3[:] = series\n+    np.testing.assert_array_equal(arr3.values, [10, 20, 30])\n+    \n+    # Test case 4: Multiple objects with values\n+    arr4 = xr.DataArray([None, None])\n+    obj3 = HasScalarValues()\n+    obj4 = HasScalarValues()\n+    arr4[0] = obj3\n+    arr4[1] = obj4\n+    \n+    assert isinstance(arr4.values[0], HasScalarValues)\n+    assert isinstance(arr4.values[1], HasScalarValues)\n+    \n+\n+if __name__ == \"__main__\":\n+    test_setitem_object_with_values_attribute()\n+    print(\"All tests passed!\")\ndiff --git a/test_values_extraction.py b/test_values_extraction.py\nnew file mode 100644\nindex 00000000..94377faa\n--- /dev/null\n+++ b/test_values_extraction.py\n@@ -0,0 +1,19 @@\n+import pandas as pd\n+import numpy as np\n+\n+# Test what types have .values that should be extracted\n+df = pd.DataFrame([[1, 2], [3, 4]])\n+series = pd.Series([1, 2, 3])\n+\n+print(\"DataFrame type:\", type(df))\n+print(\"Series type:\", type(series))\n+print(\"DataFrame.values type:\", type(df.values))\n+print(\"Series.values type:\", type(series.values))\n+\n+# Check inheritance\n+print(\"\\nDataFrame bases:\", pd.DataFrame.__bases__)\n+print(\"Series bases:\", pd.Series.__bases__)\n+\n+# Check if they have a common base that we can use\n+print(\"\\nIs DataFrame a pd.core.generic.NDFrame?\", isinstance(df, pd.core.generic.NDFrame))\n+print(\"Is Series a pd.core.generic.NDFrame?\", isinstance(series, pd.core.generic.NDFrame))\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 45553eb9..8e9df1aa 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -218,7 +218,14 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    # only extract .values from pandas objects (DataFrame/Series)\n+    # this check uses pandas' internal structure to avoid extracting .values\n+    # from arbitrary objects that happen to have a .values attribute\n+    if hasattr(pd.core.generic, 'NDFrame') and isinstance(data, pd.core.generic.NDFrame):\n+        data = data.values\n+    elif isinstance(data, (pd.DataFrame, pd.Series)):\n+        # fallback for older pandas versions or if internal structure changes\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1ae3e1f..50526d1c 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -1872,6 +1872,51 @@ class TestVariable(VariableSubclassobjects):\n         expected = Variable([\"x\", \"y\"], [[2, 3], [3, 4], [4, 5]])\n         assert_identical(v, expected)\n \n+    def test_setitem_object_with_values_attribute(self):\n+        \"\"\"Test that objects with .values attribute are not coerced when assigned\"\"\"\n+        # Regression test for GH issue - objects with .values should be stored as-is\n+        # and not have their .values attribute extracted\n+        \n+        # Test with scalar .values attribute\n+        class HasScalarValues:\n+            values = 5\n+        \n+        v = Variable([\"x\"], [None])\n+        obj = HasScalarValues()\n+        v[0] = obj\n+        \n+        # Should store the object itself, not extract .values\n+        assert isinstance(v.values[0], HasScalarValues)\n+        assert v.values[0] is obj\n+        \n+        # Test with array .values attribute\n+        class HasArrayValues:\n+            values = [1, 2, 3]\n+        \n+        v2 = Variable([\"x\"], [None])\n+        obj2 = HasArrayValues()\n+        v2[0] = obj2\n+        \n+        # Should store the object itself\n+        assert isinstance(v2.values[0], HasArrayValues)\n+        assert v2.values[0] is obj2\n+        \n+        # Test with multiple objects\n+        v3 = Variable([\"x\"], [None, None])\n+        obj3 = HasScalarValues()\n+        obj4 = HasScalarValues()\n+        v3[0] = obj3\n+        v3[1] = obj4\n+        \n+        assert isinstance(v3.values[0], HasScalarValues)\n+        assert isinstance(v3.values[1], HasScalarValues)\n+        \n+        # Ensure pandas objects still work correctly (extract .values)\n+        v4 = Variable([\"x\"], [1, 2, 3])\n+        series = pd.Series([10, 20, 30])\n+        v4[:] = series\n+        assert_array_equal(v4.values, [10, 20, 30])\n+\n     def test_coarsen(self):\n         v = self.cls([\"x\"], [0, 1, 2, 3, 4])\n         actual = v.coarsen({\"x\": 2}, boundary=\"pad\", func=\"mean\")\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex 277c32b1016..1e0873c628d 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -90,6 +90,10 @@ New Features\n \n Bug fixes\n ~~~~~~~~~\n+- Use specific type checks in\n+  :py:func:`~xarray.core.variable.as_compatible_data` instead of blanket\n+  access to ``values`` attribute (:issue:`2097`)\n+  By `Yunus Sevinchan <https://github.com/blsqr>`_.\n - :py:meth:`DataArray.resample` and :py:meth:`Dataset.resample` do not trigger computations anymore if :py:meth:`Dataset.weighted` or :py:meth:`DataArray.weighted` are applied (:issue:`4625`, :pull:`4668`). By `Julius Busecke <https://github.com/jbusecke>`_.\n - :py:func:`merge` with ``combine_attrs='override'`` makes a copy of the attrs (:issue:`4627`).\n - By default, when possible, xarray will now always use values of type ``int64`` when encoding\ndiff --git a/xarray/core/variable.py b/xarray/core/variable.py\nindex 45553eb9b1e..7ca90d6b3c7 100644\n--- a/xarray/core/variable.py\n+++ b/xarray/core/variable.py\n@@ -218,7 +218,8 @@ def as_compatible_data(data, fastpath=False):\n         data = np.timedelta64(getattr(data, \"value\", data), \"ns\")\n \n     # we don't want nested self-described arrays\n-    data = getattr(data, \"values\", data)\n+    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n+        data = data.values\n \n     if isinstance(data, np.ma.MaskedArray):\n         mask = np.ma.getmaskarray(data)\ndiff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1ae3e1f258..0d4c8662d21 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2300,6 +2300,11 @@ def __init__(self, array):\n         class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n             pass\n \n+        # Type with data stored in values attribute\n+        class CustomWithValuesAttr:\n+            def __init__(self, array):\n+                self.values = array\n+\n         array = CustomArray(np.arange(3))\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, np.ndarray)  # should not be CustomArray\n@@ -2308,6 +2313,10 @@ class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, CustomIndexable)\n \n+        array = CustomWithValuesAttr(np.arange(3))\n+        orig = Variable(dims=(), data=array)\n+        assert isinstance(orig._data.item(), CustomWithValuesAttr)\n+\n \n def test_raise_no_warning_for_nan_in_binary_ops():\n     with pytest.warns(None) as record:\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/2905"}