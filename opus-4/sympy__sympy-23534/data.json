{"instance_id": "sympy__sympy-23534", "score": "C", "diff": "diff --git a/run_tests.py b/run_tests.py\nnew file mode 100644\nindex 0000000000..d322d1b0c7\n--- /dev/null\n+++ b/run_tests.py\n@@ -0,0 +1,20 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from sympy.core.tests.test_symbol import test_symbols, test_symbols_with_cls_and_tuple_input\n+\n+print(\"Running test_symbols...\")\n+try:\n+    test_symbols()\n+    print(\"\u2713 test_symbols passed\")\n+except Exception as e:\n+    print(f\"\u2717 test_symbols failed: {e}\")\n+    \n+print(\"\\nRunning test_symbols_with_cls_and_tuple_input...\")\n+try:\n+    test_symbols_with_cls_and_tuple_input()\n+    print(\"\u2713 test_symbols_with_cls_and_tuple_input passed\")\n+except Exception as e:\n+    print(f\"\u2717 test_symbols_with_cls_and_tuple_input failed: {e}\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/sympy/core/symbol.py b/sympy/core/symbol.py\nindex f4a555c13f..2aca8bab27 100644\n--- a/sympy/core/symbol.py\n+++ b/sympy/core/symbol.py\n@@ -791,7 +791,7 @@ def literal(s):\n         return tuple(result)\n     else:\n         for name in names:\n-            result.append(symbols(name, **args))\n+            result.append(symbols(name, cls=cls, **args))\n \n         return type(names)(result)\n \ndiff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex 19494c2083..eb722d97c9 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -327,6 +327,31 @@ def sym(s):\n     raises(ValueError, lambda: symbols('::a'))\n \n \n+def test_symbols_with_cls_and_tuple_input():\n+    \"\"\"Test that cls parameter is propagated when using tuple input.\"\"\"\n+    from sympy import Function, Wild\n+    from sympy.core.function import UndefinedFunction\n+    \n+    # Test with Function class\n+    q, u = symbols(('q:2', 'u:2'), cls=Function)\n+    assert all(isinstance(item, UndefinedFunction) for item in q)\n+    assert all(isinstance(item, UndefinedFunction) for item in u)\n+    \n+    # Test with Wild class\n+    w1, w2 = symbols(('w1', 'w2'), cls=Wild)\n+    assert isinstance(w1, Wild)\n+    assert isinstance(w2, Wild)\n+    \n+    # Test with list input\n+    result = symbols(['f:2', 'g:2'], cls=Function)\n+    assert all(isinstance(item, UndefinedFunction) for sublist in result for item in sublist)\n+    \n+    # Test that assumptions are preserved with tuple input\n+    a, b = symbols(('a', 'b'), real=True, positive=True, cls=Symbol)\n+    assert a.is_real and a.is_positive\n+    assert b.is_real and b.is_positive\n+\n+\n def test_symbols_become_functions_issue_3539():\n     from sympy.abc import alpha, phi, beta, t\n     raises(TypeError, lambda: beta(2))\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..b34a381989\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,60 @@\n+import sympy as smp\n+from sympy import Wild, Function\n+\n+print(\"=== Testing various cases for symbols function ===\")\n+\n+# Test 1: Original issue with Function class\n+print(\"\\n1. Testing with Function class and tuple input:\")\n+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)\n+print(f\"q: {q}, type of q[0]: {type(q[0])}\")\n+print(f\"u: {u}, type of u[0]: {type(u[0])}\")\n+assert all(isinstance(item, smp.core.function.UndefinedFunction) for item in q)\n+assert all(isinstance(item, smp.core.function.UndefinedFunction) for item in u)\n+print(\"\u2713 All are UndefinedFunction\")\n+\n+# Test 2: Test with Wild class\n+print(\"\\n2. Testing with Wild class and tuple input:\")\n+w1, w2 = smp.symbols(('w1', 'w2'), cls=Wild)\n+print(f\"w1: {w1}, type: {type(w1)}\")\n+print(f\"w2: {w2}, type: {type(w2)}\")\n+assert isinstance(w1, Wild)\n+assert isinstance(w2, Wild)\n+print(\"\u2713 All are Wild\")\n+\n+# Test 3: Test with default Symbol class\n+print(\"\\n3. Testing with default Symbol class and tuple input:\")\n+x, y = smp.symbols(('x', 'y'))\n+print(f\"x: {x}, type: {type(x)}\")\n+print(f\"y: {y}, type: {type(y)}\")\n+assert isinstance(x, smp.Symbol)\n+assert isinstance(y, smp.Symbol)\n+print(\"\u2713 All are Symbol\")\n+\n+# Test 4: Test with list input\n+print(\"\\n4. Testing with Function class and list input:\")\n+result = smp.symbols(['f:2', 'g:2'], cls=Function)\n+print(f\"Result: {result}\")\n+for i, item in enumerate(result):\n+    print(f\"  Item {i}: {item}, all are Functions: {all(isinstance(sub, smp.core.function.UndefinedFunction) for sub in item)}\")\n+assert all(isinstance(sub, smp.core.function.UndefinedFunction) for item in result for sub in item)\n+print(\"\u2713 All are UndefinedFunction\")\n+\n+# Test 5: Test with assumptions\n+print(\"\\n5. Testing with assumptions and tuple input:\")\n+a, b = smp.symbols(('a', 'b'), real=True, positive=True)\n+print(f\"a: {a}, is_real: {a.is_real}, is_positive: {a.is_positive}\")\n+print(f\"b: {b}, is_real: {b.is_real}, is_positive: {b.is_positive}\")\n+assert a.is_real and a.is_positive\n+assert b.is_real and b.is_positive\n+print(\"\u2713 Assumptions preserved\")\n+\n+# Test 6: Test edge case with nested tuples\n+print(\"\\n6. Testing with nested structures:\")\n+try:\n+    result = smp.symbols((('x', 'y'), ('z', 'w')), cls=Function)\n+    print(f\"Result: {result}\")\n+    print(f\"Type: {type(result)}\")\n+except Exception as e:\n+    print(f\"Expected behavior - Error: {type(e).__name__}: {e}\")\n+\n+print(\"\\n=== All tests passed! ===\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..948c9c75e7\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,17 @@\n+import sympy as smp\n+\n+# Testing the issue\n+print(\"Testing with extra parentheses:\")\n+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)\n+print(f\"Type of q[0]: {type(q[0])}\")\n+print(f\"Type of q[1]: {type(q[1])}\")\n+print(f\"Type of u[0]: {type(u[0])}\")\n+print(f\"Type of u[1]: {type(u[1])}\")\n+\n+print(\"\\nTesting without extra parentheses:\")\n+result = smp.symbols('q:2 u:2', cls=smp.Function)\n+print(f\"Result type: {type(result)}\")\n+print(f\"Result: {result}\")\n+if isinstance(result, tuple):\n+    for i, item in enumerate(result):\n+        print(f\"Item {i}: {item}, type: {type(item)}\")\ndiff --git a/test_issue2.py b/test_issue2.py\nnew file mode 100644\nindex 0000000000..a346636716\n--- /dev/null\n+++ b/test_issue2.py\n@@ -0,0 +1,27 @@\n+import sympy as smp\n+\n+# Testing the issue\n+print(\"Testing with extra parentheses (tuple input):\")\n+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)\n+print(f\"Type of q[0]: {type(q[0])}\")\n+print(f\"Type of q[1]: {type(q[1])}\")\n+print(f\"Type of u[0]: {type(u[0])}\")\n+print(f\"Type of u[1]: {type(u[1])}\")\n+\n+print(\"\\nTesting without extra parentheses (string input):\")\n+result = smp.symbols('q:2 u:2', cls=smp.Function)\n+print(f\"Result type: {type(result)}\")\n+print(f\"Result: {result}\")\n+if isinstance(result, tuple):\n+    for i, item in enumerate(result):\n+        print(f\"Item {i}: {item}, type: {type(item)}\")\n+\n+print(\"\\nTesting with list input:\")\n+result2 = smp.symbols(['q:2', 'u:2'], cls=smp.Function)\n+print(f\"Result2 type: {type(result2)}\")\n+print(f\"Result2: {result2}\")\n+for i, item in enumerate(result2):\n+    print(f\"Item {i}: {item}, type: {type(item)}\")\n+    if isinstance(item, tuple):\n+        for j, subitem in enumerate(item):\n+            print(f\"  Subitem {j}: {subitem}, type: {type(subitem)}\")\ndiff --git a/verify_issue.py b/verify_issue.py\nnew file mode 100644\nindex 0000000000..ec451886bd\n--- /dev/null\n+++ b/verify_issue.py\n@@ -0,0 +1,13 @@\n+import sympy as smp\n+\n+print(\"Reproducing the issue from the problem statement:\")\n+q, u = smp.symbols(('q:2', 'u:2'), cls=smp.Function)\n+print(f\"Type of q[0]: {type(q[0])}\")\n+\n+print(\"\\nExpected result: <class 'sympy.core.function.UndefinedFunction'>\")\n+print(f\"Actual result: {type(q[0])}\")\n+\n+if str(type(q[0])) == \"<class 'sympy.core.function.UndefinedFunction'>\":\n+    print(\"\\n\u2713 Issue fixed!\")\n+else:\n+    print(\"\\n\u2717 Issue not fixed\")\n", "gold_standard_diff": "diff --git a/sympy/core/symbol.py b/sympy/core/symbol.py\nindex f4a555c13fe4..2aca8bab2736 100644\n--- a/sympy/core/symbol.py\n+++ b/sympy/core/symbol.py\n@@ -791,7 +791,7 @@ def literal(s):\n         return tuple(result)\n     else:\n         for name in names:\n-            result.append(symbols(name, **args))\n+            result.append(symbols(name, cls=cls, **args))\n \n         return type(names)(result)\n \ndiff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex 19494c208383..2b7bca85dc01 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -1,3 +1,4 @@\n+from sympy.core.function import Function, UndefinedFunction\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.relational import (GreaterThan, LessThan, StrictGreaterThan, StrictLessThan)\n from sympy.core.symbol import (Dummy, Symbol, Wild, symbols)\n@@ -294,6 +295,7 @@ def test_symbols():\n     assert symbols('aa:d,x:z') == (aa, ab, ac, ad, x, y, z)\n     assert symbols(('aa:d','x:z')) == ((aa, ab, ac, ad), (x, y, z))\n \n+    assert type(symbols(('q:2', 'u:2'), cls=Function)[0][0]) == UndefinedFunction  # issue 23532\n \n     # issue 6675\n     def sym(s):\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/23534"}