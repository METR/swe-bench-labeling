{"instance_id": "django__django-10097", "score": "I", "diff": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 92394a7eae..6a2788b9b0 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -92,9 +92,21 @@ class URLValidator(RegexValidator):\n     )\n     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n \n+    # Characters allowed in userinfo (username and password) according to RFC 1738\n+    # user = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n+    # password = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n+    # uchar = unreserved | escape\n+    # unreserved = alpha | digit | safe | extra\n+    # safe = \"$\" | \"-\" | \"_\" | \".\" | \"+\"\n+    # extra = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\n+    # escape = \"%\" hex hex\n+    # Within the user and password field, any \":\", \"@\", or \"/\" must be encoded.\n+    userinfo_chars = r\"[a-zA-Z0-9$\\-_.+!*'(),;?&=]|%[0-9a-fA-F]{2}\"\n+    userinfo_re = r'(?:(?:' + userinfo_chars + r')+(?::(?:' + userinfo_chars + r')*)?@)?'\n+\n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n-        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n+        userinfo_re +  # user:pass authentication\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\ndiff --git a/django/core/validators.py.backup b/django/core/validators.py.backup\nnew file mode 100644\nindex 0000000000..92394a7eae\n--- /dev/null\n+++ b/django/core/validators.py.backup\n@@ -0,0 +1,538 @@\n+import ipaddress\n+import re\n+from pathlib import Path\n+from urllib.parse import urlsplit, urlunsplit\n+\n+from django.core.exceptions import ValidationError\n+from django.utils.deconstruct import deconstructible\n+from django.utils.functional import SimpleLazyObject\n+from django.utils.ipv6 import is_valid_ipv6_address\n+from django.utils.translation import gettext_lazy as _, ngettext_lazy\n+\n+# These values, if given to validate(), will trigger the self.required check.\n+EMPTY_VALUES = (None, '', [], (), {})\n+\n+\n+def _lazy_re_compile(regex, flags=0):\n+    \"\"\"Lazily compile a regex with flags.\"\"\"\n+    def _compile():\n+        # Compile the regex if it was not passed pre-compiled.\n+        if isinstance(regex, str):\n+            return re.compile(regex, flags)\n+        else:\n+            assert not flags, \"flags must be empty if regex is passed pre-compiled\"\n+            return regex\n+    return SimpleLazyObject(_compile)\n+\n+\n+@deconstructible\n+class RegexValidator:\n+    regex = ''\n+    message = _('Enter a valid value.')\n+    code = 'invalid'\n+    inverse_match = False\n+    flags = 0\n+\n+    def __init__(self, regex=None, message=None, code=None, inverse_match=None, flags=None):\n+        if regex is not None:\n+            self.regex = regex\n+        if message is not None:\n+            self.message = message\n+        if code is not None:\n+            self.code = code\n+        if inverse_match is not None:\n+            self.inverse_match = inverse_match\n+        if flags is not None:\n+            self.flags = flags\n+        if self.flags and not isinstance(self.regex, str):\n+            raise TypeError(\"If the flags are set, regex must be a regular expression string.\")\n+\n+        self.regex = _lazy_re_compile(self.regex, self.flags)\n+\n+    def __call__(self, value):\n+        \"\"\"\n+        Validate that the input contains (or does *not* contain, if\n+        inverse_match is True) a match for the regular expression.\n+        \"\"\"\n+        regex_matches = self.regex.search(str(value))\n+        invalid_input = regex_matches if self.inverse_match else not regex_matches\n+        if invalid_input:\n+            raise ValidationError(self.message, code=self.code)\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, RegexValidator) and\n+            self.regex.pattern == other.regex.pattern and\n+            self.regex.flags == other.regex.flags and\n+            (self.message == other.message) and\n+            (self.code == other.code) and\n+            (self.inverse_match == other.inverse_match)\n+        )\n+\n+\n+@deconstructible\n+class URLValidator(RegexValidator):\n+    ul = '\\u00a1-\\uffff'  # unicode letters range (must not be a raw string)\n+\n+    # IP patterns\n+    ipv4_re = r'(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}'\n+    ipv6_re = r'\\[[0-9a-f:\\.]+\\]'  # (simple regex, validated later)\n+\n+    # Host patterns\n+    hostname_re = r'[a-z' + ul + r'0-9](?:[a-z' + ul + r'0-9-]{0,61}[a-z' + ul + r'0-9])?'\n+    # Max length for domain name labels is 63 characters per RFC 1034 sec. 3.1\n+    domain_re = r'(?:\\.(?!-)[a-z' + ul + r'0-9-]{1,63}(?<!-))*'\n+    tld_re = (\n+        r'\\.'                                # dot\n+        r'(?!-)'                             # can't start with a dash\n+        r'(?:[a-z' + ul + '-]{2,63}'         # domain label\n+        r'|xn--[a-z0-9]{1,59})'              # or punycode label\n+        r'(?<!-)'                            # can't end with a dash\n+        r'\\.?'                               # may have a trailing dot\n+    )\n+    host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n+\n+    regex = _lazy_re_compile(\n+        r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n+        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n+        r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n+        r'(?::\\d{2,5})?'  # port\n+        r'(?:[/?#][^\\s]*)?'  # resource path\n+        r'\\Z', re.IGNORECASE)\n+    message = _('Enter a valid URL.')\n+    schemes = ['http', 'https', 'ftp', 'ftps']\n+\n+    def __init__(self, schemes=None, **kwargs):\n+        super().__init__(**kwargs)\n+        if schemes is not None:\n+            self.schemes = schemes\n+\n+    def __call__(self, value):\n+        # Check first if the scheme is valid\n+        scheme = value.split('://')[0].lower()\n+        if scheme not in self.schemes:\n+            raise ValidationError(self.message, code=self.code)\n+\n+        # Then check full URL\n+        try:\n+            super().__call__(value)\n+        except ValidationError as e:\n+            # Trivial case failed. Try for possible IDN domain\n+            if value:\n+                try:\n+                    scheme, netloc, path, query, fragment = urlsplit(value)\n+                except ValueError:  # for example, \"Invalid IPv6 URL\"\n+                    raise ValidationError(self.message, code=self.code)\n+                try:\n+                    netloc = netloc.encode('idna').decode('ascii')  # IDN -> ACE\n+                except UnicodeError:  # invalid domain part\n+                    raise e\n+                url = urlunsplit((scheme, netloc, path, query, fragment))\n+                super().__call__(url)\n+            else:\n+                raise\n+        else:\n+            # Now verify IPv6 in the netloc part\n+            host_match = re.search(r'^\\[(.+)\\](?::\\d{2,5})?$', urlsplit(value).netloc)\n+            if host_match:\n+                potential_ip = host_match.groups()[0]\n+                try:\n+                    validate_ipv6_address(potential_ip)\n+                except ValidationError:\n+                    raise ValidationError(self.message, code=self.code)\n+\n+        # The maximum length of a full host name is 253 characters per RFC 1034\n+        # section 3.1. It's defined to be 255 bytes or less, but this includes\n+        # one byte for the length of the name and one byte for the trailing dot\n+        # that's used to indicate absolute names in DNS.\n+        if len(urlsplit(value).netloc) > 253:\n+            raise ValidationError(self.message, code=self.code)\n+\n+\n+integer_validator = RegexValidator(\n+    _lazy_re_compile(r'^-?\\d+\\Z'),\n+    message=_('Enter a valid integer.'),\n+    code='invalid',\n+)\n+\n+\n+def validate_integer(value):\n+    return integer_validator(value)\n+\n+\n+@deconstructible\n+class EmailValidator:\n+    message = _('Enter a valid email address.')\n+    code = 'invalid'\n+    user_regex = _lazy_re_compile(\n+        r\"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\\Z\"  # dot-atom\n+        r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"\\Z)',  # quoted-string\n+        re.IGNORECASE)\n+    domain_regex = _lazy_re_compile(\n+        # max length for domain name labels is 63 characters per RFC 1034\n+        r'((?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+)(?:[A-Z0-9-]{2,63}(?<!-))\\Z',\n+        re.IGNORECASE)\n+    literal_regex = _lazy_re_compile(\n+        # literal form, ipv4 or ipv6 address (SMTP 4.1.3)\n+        r'\\[([A-f0-9:\\.]+)\\]\\Z',\n+        re.IGNORECASE)\n+    domain_whitelist = ['localhost']\n+\n+    def __init__(self, message=None, code=None, whitelist=None):\n+        if message is not None:\n+            self.message = message\n+        if code is not None:\n+            self.code = code\n+        if whitelist is not None:\n+            self.domain_whitelist = whitelist\n+\n+    def __call__(self, value):\n+        if not value or '@' not in value:\n+            raise ValidationError(self.message, code=self.code)\n+\n+        user_part, domain_part = value.rsplit('@', 1)\n+\n+        if not self.user_regex.match(user_part):\n+            raise ValidationError(self.message, code=self.code)\n+\n+        if (domain_part not in self.domain_whitelist and\n+                not self.validate_domain_part(domain_part)):\n+            # Try for possible IDN domain-part\n+            try:\n+                domain_part = domain_part.encode('idna').decode('ascii')\n+            except UnicodeError:\n+                pass\n+            else:\n+                if self.validate_domain_part(domain_part):\n+                    return\n+            raise ValidationError(self.message, code=self.code)\n+\n+    def validate_domain_part(self, domain_part):\n+        if self.domain_regex.match(domain_part):\n+            return True\n+\n+        literal_match = self.literal_regex.match(domain_part)\n+        if literal_match:\n+            ip_address = literal_match.group(1)\n+            try:\n+                validate_ipv46_address(ip_address)\n+                return True\n+            except ValidationError:\n+                pass\n+        return False\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, EmailValidator) and\n+            (self.domain_whitelist == other.domain_whitelist) and\n+            (self.message == other.message) and\n+            (self.code == other.code)\n+        )\n+\n+\n+validate_email = EmailValidator()\n+\n+slug_re = _lazy_re_compile(r'^[-a-zA-Z0-9_]+\\Z')\n+validate_slug = RegexValidator(\n+    slug_re,\n+    # Translators: \"letters\" means latin letters: a-z and A-Z.\n+    _(\"Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens.\"),\n+    'invalid'\n+)\n+\n+slug_unicode_re = _lazy_re_compile(r'^[-\\w]+\\Z')\n+validate_unicode_slug = RegexValidator(\n+    slug_unicode_re,\n+    _(\"Enter a valid 'slug' consisting of Unicode letters, numbers, underscores, or hyphens.\"),\n+    'invalid'\n+)\n+\n+\n+def validate_ipv4_address(value):\n+    try:\n+        ipaddress.IPv4Address(value)\n+    except ValueError:\n+        raise ValidationError(_('Enter a valid IPv4 address.'), code='invalid')\n+\n+\n+def validate_ipv6_address(value):\n+    if not is_valid_ipv6_address(value):\n+        raise ValidationError(_('Enter a valid IPv6 address.'), code='invalid')\n+\n+\n+def validate_ipv46_address(value):\n+    try:\n+        validate_ipv4_address(value)\n+    except ValidationError:\n+        try:\n+            validate_ipv6_address(value)\n+        except ValidationError:\n+            raise ValidationError(_('Enter a valid IPv4 or IPv6 address.'), code='invalid')\n+\n+\n+ip_address_validator_map = {\n+    'both': ([validate_ipv46_address], _('Enter a valid IPv4 or IPv6 address.')),\n+    'ipv4': ([validate_ipv4_address], _('Enter a valid IPv4 address.')),\n+    'ipv6': ([validate_ipv6_address], _('Enter a valid IPv6 address.')),\n+}\n+\n+\n+def ip_address_validators(protocol, unpack_ipv4):\n+    \"\"\"\n+    Depending on the given parameters, return the appropriate validators for\n+    the GenericIPAddressField.\n+    \"\"\"\n+    if protocol != 'both' and unpack_ipv4:\n+        raise ValueError(\n+            \"You can only use `unpack_ipv4` if `protocol` is set to 'both'\")\n+    try:\n+        return ip_address_validator_map[protocol.lower()]\n+    except KeyError:\n+        raise ValueError(\"The protocol '%s' is unknown. Supported: %s\"\n+                         % (protocol, list(ip_address_validator_map)))\n+\n+\n+def int_list_validator(sep=',', message=None, code='invalid', allow_negative=False):\n+    regexp = _lazy_re_compile(r'^%(neg)s\\d+(?:%(sep)s%(neg)s\\d+)*\\Z' % {\n+        'neg': '(-)?' if allow_negative else '',\n+        'sep': re.escape(sep),\n+    })\n+    return RegexValidator(regexp, message=message, code=code)\n+\n+\n+validate_comma_separated_integer_list = int_list_validator(\n+    message=_('Enter only digits separated by commas.'),\n+)\n+\n+\n+@deconstructible\n+class BaseValidator:\n+    message = _('Ensure this value is %(limit_value)s (it is %(show_value)s).')\n+    code = 'limit_value'\n+\n+    def __init__(self, limit_value, message=None):\n+        self.limit_value = limit_value\n+        if message:\n+            self.message = message\n+\n+    def __call__(self, value):\n+        cleaned = self.clean(value)\n+        params = {'limit_value': self.limit_value, 'show_value': cleaned, 'value': value}\n+        if self.compare(cleaned, self.limit_value):\n+            raise ValidationError(self.message, code=self.code, params=params)\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, self.__class__) and\n+            self.limit_value == other.limit_value and\n+            self.message == other.message and\n+            self.code == other.code\n+        )\n+\n+    def compare(self, a, b):\n+        return a is not b\n+\n+    def clean(self, x):\n+        return x\n+\n+\n+@deconstructible\n+class MaxValueValidator(BaseValidator):\n+    message = _('Ensure this value is less than or equal to %(limit_value)s.')\n+    code = 'max_value'\n+\n+    def compare(self, a, b):\n+        return a > b\n+\n+\n+@deconstructible\n+class MinValueValidator(BaseValidator):\n+    message = _('Ensure this value is greater than or equal to %(limit_value)s.')\n+    code = 'min_value'\n+\n+    def compare(self, a, b):\n+        return a < b\n+\n+\n+@deconstructible\n+class MinLengthValidator(BaseValidator):\n+    message = ngettext_lazy(\n+        'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).',\n+        'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).',\n+        'limit_value')\n+    code = 'min_length'\n+\n+    def compare(self, a, b):\n+        return a < b\n+\n+    def clean(self, x):\n+        return len(x)\n+\n+\n+@deconstructible\n+class MaxLengthValidator(BaseValidator):\n+    message = ngettext_lazy(\n+        'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).',\n+        'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).',\n+        'limit_value')\n+    code = 'max_length'\n+\n+    def compare(self, a, b):\n+        return a > b\n+\n+    def clean(self, x):\n+        return len(x)\n+\n+\n+@deconstructible\n+class DecimalValidator:\n+    \"\"\"\n+    Validate that the input does not exceed the maximum number of digits\n+    expected, otherwise raise ValidationError.\n+    \"\"\"\n+    messages = {\n+        'invalid': _('Enter a number.'),\n+        'max_digits': ngettext_lazy(\n+            'Ensure that there are no more than %(max)s digit in total.',\n+            'Ensure that there are no more than %(max)s digits in total.',\n+            'max'\n+        ),\n+        'max_decimal_places': ngettext_lazy(\n+            'Ensure that there are no more than %(max)s decimal place.',\n+            'Ensure that there are no more than %(max)s decimal places.',\n+            'max'\n+        ),\n+        'max_whole_digits': ngettext_lazy(\n+            'Ensure that there are no more than %(max)s digit before the decimal point.',\n+            'Ensure that there are no more than %(max)s digits before the decimal point.',\n+            'max'\n+        ),\n+    }\n+\n+    def __init__(self, max_digits, decimal_places):\n+        self.max_digits = max_digits\n+        self.decimal_places = decimal_places\n+\n+    def __call__(self, value):\n+        digit_tuple, exponent = value.as_tuple()[1:]\n+        if exponent in {'F', 'n', 'N'}:\n+            raise ValidationError(self.messages['invalid'])\n+        if exponent >= 0:\n+            # A positive exponent adds that many trailing zeros.\n+            digits = len(digit_tuple) + exponent\n+            decimals = 0\n+        else:\n+            # If the absolute value of the negative exponent is larger than the\n+            # number of digits, then it's the same as the number of digits,\n+            # because it'll consume all of the digits in digit_tuple and then\n+            # add abs(exponent) - len(digit_tuple) leading zeros after the\n+            # decimal point.\n+            if abs(exponent) > len(digit_tuple):\n+                digits = decimals = abs(exponent)\n+            else:\n+                digits = len(digit_tuple)\n+                decimals = abs(exponent)\n+        whole_digits = digits - decimals\n+\n+        if self.max_digits is not None and digits > self.max_digits:\n+            raise ValidationError(\n+                self.messages['max_digits'],\n+                code='max_digits',\n+                params={'max': self.max_digits},\n+            )\n+        if self.decimal_places is not None and decimals > self.decimal_places:\n+            raise ValidationError(\n+                self.messages['max_decimal_places'],\n+                code='max_decimal_places',\n+                params={'max': self.decimal_places},\n+            )\n+        if (self.max_digits is not None and self.decimal_places is not None and\n+                whole_digits > (self.max_digits - self.decimal_places)):\n+            raise ValidationError(\n+                self.messages['max_whole_digits'],\n+                code='max_whole_digits',\n+                params={'max': (self.max_digits - self.decimal_places)},\n+            )\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, self.__class__) and\n+            self.max_digits == other.max_digits and\n+            self.decimal_places == other.decimal_places\n+        )\n+\n+\n+@deconstructible\n+class FileExtensionValidator:\n+    message = _(\n+        \"File extension '%(extension)s' is not allowed. \"\n+        \"Allowed extensions are: '%(allowed_extensions)s'.\"\n+    )\n+    code = 'invalid_extension'\n+\n+    def __init__(self, allowed_extensions=None, message=None, code=None):\n+        if allowed_extensions is not None:\n+            allowed_extensions = [allowed_extension.lower() for allowed_extension in allowed_extensions]\n+        self.allowed_extensions = allowed_extensions\n+        if message is not None:\n+            self.message = message\n+        if code is not None:\n+            self.code = code\n+\n+    def __call__(self, value):\n+        extension = Path(value.name).suffix[1:].lower()\n+        if self.allowed_extensions is not None and extension not in self.allowed_extensions:\n+            raise ValidationError(\n+                self.message,\n+                code=self.code,\n+                params={\n+                    'extension': extension,\n+                    'allowed_extensions': ', '.join(self.allowed_extensions)\n+                }\n+            )\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, self.__class__) and\n+            self.allowed_extensions == other.allowed_extensions and\n+            self.message == other.message and\n+            self.code == other.code\n+        )\n+\n+\n+def get_available_image_extensions():\n+    try:\n+        from PIL import Image\n+    except ImportError:\n+        return []\n+    else:\n+        Image.init()\n+        return [ext.lower()[1:] for ext in Image.EXTENSION]\n+\n+\n+def validate_image_file_extension(value):\n+    return FileExtensionValidator(allowed_extensions=get_available_image_extensions())(value)\n+\n+\n+@deconstructible\n+class ProhibitNullCharactersValidator:\n+    \"\"\"Validate that the string doesn't contain the null character.\"\"\"\n+    message = _('Null characters are not allowed.')\n+    code = 'null_characters_not_allowed'\n+\n+    def __init__(self, message=None, code=None):\n+        if message is not None:\n+            self.message = message\n+        if code is not None:\n+            self.code = code\n+\n+    def __call__(self, value):\n+        if '\\x00' in str(value):\n+            raise ValidationError(self.message, code=self.code)\n+\n+    def __eq__(self, other):\n+        return (\n+            isinstance(other, self.__class__) and\n+            self.message == other.message and\n+            self.code == other.code\n+        )\ndiff --git a/test_rfc1738.py b/test_rfc1738.py\nnew file mode 100644\nindex 0000000000..59b21beb15\n--- /dev/null\n+++ b/test_rfc1738.py\n@@ -0,0 +1,50 @@\n+# According to RFC 1738:\n+# user = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n+# password = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n+# uchar = unreserved | escape\n+# unreserved = alpha | digit | safe | extra\n+# alpha = lowalpha | hialpha\n+# digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n+# safe = \"$\" | \"-\" | \"_\" | \".\" | \"+\"\n+# extra = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\n+\n+# Characters that MUST be encoded: \":\", \"@\", \"/\"\n+# These are not allowed in userinfo without encoding\n+\n+import re\n+\n+# Build the allowed character set for username and password\n+unreserved = r'[a-zA-Z0-9$\\-_.+!*\\'(),]'\n+allowed_in_userinfo = unreserved + r'|[;?&=]|%[0-9a-fA-F]{2}'  # includes escaped chars\n+\n+# The pattern should be:\n+# - username: one or more allowed chars\n+# - optional: \":\" followed by password (zero or more allowed chars)\n+# - required: \"@\"\n+\n+userinfo_pattern = r'(?:(?:' + allowed_in_userinfo + r')+(?::(?:' + allowed_in_userinfo + r')*)?@)?'\n+\n+print(\"Proposed userinfo pattern:\")\n+print(userinfo_pattern)\n+\n+# Test it\n+test_cases = [\n+    ('user:pass@', True),\n+    ('user@', True),\n+    ('user:@', True),\n+    (':pass@', True),\n+    ('user%40name:pass@', True),  # @ encoded as %40\n+    ('user:pass%2Fword@', True),  # / encoded as %2F\n+    ('user/name:pass@', False),   # / not encoded\n+    ('user@name:pass@', False),   # @ not encoded in username\n+    ('user:pass:word@', False),   # : not encoded in password\n+    ('user:pass/word@', False),   # / not encoded in password\n+]\n+\n+pattern = re.compile('^' + userinfo_pattern + '$')\n+print(\"\\nTesting pattern:\")\n+for test, expected in test_cases:\n+    match = pattern.match(test)\n+    result = bool(match)\n+    status = \"PASS\" if result == expected else \"FAIL\"\n+    print(\"%s: '%s' -> %s (expected %s)\" % (status, test, result, expected))\ndiff --git a/test_rfc1738_v2.py b/test_rfc1738_v2.py\nnew file mode 100644\nindex 0000000000..5bd17dd5c8\n--- /dev/null\n+++ b/test_rfc1738_v2.py\n@@ -0,0 +1,63 @@\n+import re\n+\n+# Build the allowed character set for username and password\n+unreserved = r'[a-zA-Z0-9$\\-_.+!*\\'(),]'\n+allowed_in_userinfo = unreserved + r'|[;?&=]|%[0-9a-fA-F]{2}'  # includes escaped chars\n+\n+# The pattern should be:\n+# - optional username: zero or more allowed chars\n+# - optional: \":\" followed by password (zero or more allowed chars)\n+# - required: \"@\"\n+# Note: At least username OR password must be present\n+\n+userinfo_pattern = r'(?:(?:' + allowed_in_userinfo + r')*(?::(?:' + allowed_in_userinfo + r')*)?@)'\n+\n+print(\"Proposed userinfo pattern:\")\n+print(userinfo_pattern)\n+\n+# Test it\n+test_cases = [\n+    ('user:pass@', True),\n+    ('user@', True),\n+    ('user:@', True),\n+    (':pass@', True),\n+    ('@', True),  # Edge case - empty userinfo\n+    ('user%40name:pass@', True),  # @ encoded as %40\n+    ('user:pass%2Fword@', True),  # / encoded as %2F\n+    ('user/name:pass@', False),   # / not encoded\n+    ('user@name:pass@', False),   # @ not encoded in username\n+    ('user:pass:word@', False),   # : not encoded in password\n+    ('user:pass/word@', False),   # / not encoded in password\n+]\n+\n+pattern = re.compile('^' + userinfo_pattern + '$')\n+print(\"\\nTesting pattern:\")\n+for test, expected in test_cases:\n+    match = pattern.match(test)\n+    result = bool(match)\n+    status = \"PASS\" if result == expected else \"FAIL\"\n+    print(\"%s: '%s' -> %s (expected %s)\" % (status, test, result, expected))\n+    \n+# Now test with full URLs\n+print(\"\\n\\nTesting with full URLs:\")\n+full_urls = [\n+    ('http://user:pass@example.com', True),\n+    ('http://user@example.com', True),\n+    ('http://foo/bar@example.com', False),\n+    ('http://user@pass@example.com', False),\n+    ('http://user:pass:word@example.com', False),\n+    ('http://user:pass/word@example.com', False),\n+    ('http://user%3Apass@example.com', True),\n+    ('http://user%40pass@example.com', True),\n+    ('http://user:pass%2Fword@example.com', True),\n+]\n+\n+# Build full URL pattern (simplified)\n+url_pattern = r'^(?:[a-z0-9\\.\\-\\+]*)://' + r'(?:' + userinfo_pattern + r')?' + r'([^/?#]+)(?:[/?#].*)?$'\n+url_re = re.compile(url_pattern, re.IGNORECASE)\n+\n+for url, expected in full_urls:\n+    match = url_re.match(url)\n+    result = bool(match)\n+    status = \"PASS\" if result == expected else \"FAIL\"\n+    print(\"%s: '%s' -> %s (expected %s)\" % (status, url, result, expected))\ndiff --git a/test_url_comprehensive.py b/test_url_comprehensive.py\nnew file mode 100644\nindex 0000000000..02e0037b92\n--- /dev/null\n+++ b/test_url_comprehensive.py\n@@ -0,0 +1,87 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+from django.core.validators import URLValidator\n+from django.core.exceptions import ValidationError\n+\n+# Test cases\n+test_cases = [\n+    # (URL, should_be_valid, description)\n+    ('http://foo/bar@example.com', True, 'Path with @ - Currently parsed as host=foo, path=/bar@example.com'),\n+    ('http://foo:bar@example.com', True, 'Valid userinfo'),\n+    ('http://user:pass/word@example.com', False, '/ in password must be encoded'),\n+    ('http://user@pass@example.com', False, '@ in username must be encoded'),\n+    ('http://user:pass:word@example.com', False, ': in password must be encoded'),\n+    ('http://user:pass@example.com', True, 'Valid userinfo'),\n+    ('http://user%3Apass@example.com', True, ': encoded as %3A in username'),\n+    ('http://user%40pass@example.com', True, '@ encoded as %40 in username'),\n+    ('http://user:pass%2Fword@example.com', True, '/ encoded as %2F in password'),\n+    ('http://user:p%40ss@example.com', True, '@ encoded as %40 in password'),\n+    ('http://user:p%3Ass@example.com', True, ': encoded as %3A in password'),\n+    # Edge cases\n+    ('http://:pass@example.com', True, 'Empty username'),\n+    ('http://user:@example.com', True, 'Empty password'),\n+    ('http://@example.com', True, 'Empty userinfo with @'),\n+    # Query string edge case mentioned in issue\n+    ('http://example.com?m=foo@example.com', True, '@ in query string is valid'),\n+    ('http://example.com?m=foo/bar@example.com', True, '@ and / in query string are valid'),\n+]\n+\n+validator = URLValidator()\n+\n+print(\"Testing URLs with URLValidator:\")\n+print(\"-\" * 80)\n+print(\"%-50s %-10s %-10s %s\" % (\"URL\", \"Expected\", \"Actual\", \"Status\"))\n+print(\"-\" * 80)\n+\n+passed = 0\n+failed = 0\n+\n+for url, expected, desc in test_cases:\n+    try:\n+        validator(url)\n+        actual = True\n+    except ValidationError:\n+        actual = False\n+    \n+    status = \"PASS\" if actual == expected else \"FAIL\"\n+    if status == \"PASS\":\n+        passed += 1\n+    else:\n+        failed += 1\n+        \n+    print(\"%-50s %-10s %-10s %s\" % (url[:50], expected, actual, status))\n+    if status == \"FAIL\":\n+        print(\"  Description: %s\" % desc)\n+\n+print(\"-\" * 80)\n+print(\"Passed: %d, Failed: %d\" % (passed, failed))\n+\n+# Let's also check what the regex actually captures\n+print(\"\\n\\nRegex analysis:\")\n+print(\"-\" * 80)\n+import re\n+print(\"Current userinfo pattern in URLValidator:\")\n+print(validator.regex.pattern)\ndiff --git a/test_url_issue.py b/test_url_issue.py\nnew file mode 100644\nindex 0000000000..51e61f9802\n--- /dev/null\n+++ b/test_url_issue.py\n@@ -0,0 +1,86 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+    django.setup()\n+\n+from django.core.validators import URLValidator\n+from django.core.exceptions import ValidationError\n+\n+# Test cases mentioned in the issue\n+test_urls = [\n+    # Should be invalid according to RFC 1738\n+    'http://foo/bar@example.com',\n+    'http://foo:bar@example.com',  # This is currently valid but should check if : in password is encoded\n+    'http://user:pass/word@example.com',  # / in password should be encoded\n+    'http://user@pass@example.com',  # @ in username should be encoded\n+    'http://user:pass:word@example.com',  # : in password should be encoded\n+    \n+    # Valid cases (for comparison)\n+    'http://user:pass@example.com',\n+    'http://user%3Apass@example.com',  # : encoded as %3A\n+    'http://user%40pass@example.com',  # @ encoded as %40\n+    'http://user:pass%2Fword@example.com',  # / encoded as %2F\n+]\n+\n+validator = URLValidator()\n+\n+print(\"Testing URLs with URLValidator:\")\n+print(\"-\" * 60)\n+for url in test_urls:\n+    try:\n+        validator(url)\n+        print(\"VALID: %s\" % url)\n+    except ValidationError:\n+        print(\"INVALID: %s\" % url)\n+        \n+print(\"\\n\" + \"-\" * 60)\n+print(\"\\nTesting regex pattern directly:\")\n+print(\"-\" * 60)\n+\n+import re\n+# Let's extract and test the user:pass pattern specifically\n+user_pass_pattern = r'(?:\\S+(?::\\S*)?@)?'\n+for url in test_urls:\n+    # Extract the part between scheme and host\n+    match = re.match(r'^(https?://)([^/]+)', url)\n+    if match:\n+        scheme = match.group(1)\n+        rest = match.group(2)\n+        if '@' in rest:\n+            userinfo_host = rest.split('@')\n+            userinfo = userinfo_host[0]\n+            print(\"URL: %s\" % url)\n+            print(\"  User info: %s\" % userinfo)\n+            print(\"  Contains invalid chars: \"),\n+            invalid_chars = []\n+            if ':' in userinfo and userinfo.count(':') > 1:\n+                invalid_chars.append(': (multiple colons)')\n+            if '/' in userinfo:\n+                invalid_chars.append('/')\n+            if '@' in userinfo:\n+                invalid_chars.append('@')\n+            if invalid_chars:\n+                print(\", \".join(invalid_chars))\n+            else:\n+                print(\"None\")\n+        print(\"\")\ndiff --git a/test_url_parsing.py b/test_url_parsing.py\nnew file mode 100644\nindex 0000000000..c68daaa528\n--- /dev/null\n+++ b/test_url_parsing.py\n@@ -0,0 +1,20 @@\n+from urllib.parse import urlsplit\n+\n+test_urls = [\n+    'http://foo/bar@example.com',\n+    'http://user@pass@example.com',\n+    'http://user:pass:word@example.com',\n+    'http://user:pass/word@example.com',\n+]\n+\n+print(\"URL parsing analysis:\")\n+print(\"-\" * 60)\n+for url in test_urls:\n+    parts = urlsplit(url)\n+    print(\"\\nURL: %s\" % url)\n+    print(\"  scheme: %s\" % parts.scheme)\n+    print(\"  netloc: %s\" % parts.netloc)\n+    print(\"  path: %s\" % parts.path)\n+    print(\"  username: %s\" % parts.username)\n+    print(\"  password: %s\" % parts.password)\n+    print(\"  hostname: %s\" % parts.hostname)\ndiff --git a/url_validator.patch b/url_validator.patch\nnew file mode 100644\nindex 0000000000..be382106d0\n--- /dev/null\n+++ b/url_validator.patch\n@@ -0,0 +1,24 @@\n+--- django/core/validators.py.orig\t2024-01-01 00:00:00.000000000 +0000\n++++ django/core/validators.py\t2024-01-01 00:00:00.000000000 +0000\n+@@ -92,9 +92,19 @@\n+     )\n+     host_re = '(' + hostname_re + domain_re + tld_re + '|localhost)'\n+ \n++    # Characters allowed in userinfo (username and password) according to RFC 1738\n++    # user = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n++    # password = *[ uchar | \";\" | \"?\" | \"&\" | \"=\" ]\n++    # uchar = unreserved | escape\n++    # unreserved = alpha | digit | safe | extra\n++    # safe = \"$\" | \"-\" | \"_\" | \".\" | \"+\"\n++    # extra = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\n++    # escape = \"%\" hex hex\n++    # Within the user and password field, any \":\", \"@\", or \"/\" must be encoded.\n++    userinfo_chars = r\"[a-zA-Z0-9$\\-_.+!*'(),;?&=]|%[0-9a-fA-F]{2}\"\n++    userinfo_re = r'(?:(?:' + userinfo_chars + r')+(?::(?:' + userinfo_chars + r')*)?@)?'\n++\n+     regex = _lazy_re_compile(\n+         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n+-        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n++        userinfo_re +  # user:pass authentication\n+         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n+         r'(?::\\d{2,5})?'  # port\n", "gold_standard_diff": "diff --git a/django/core/validators.py b/django/core/validators.py\nindex 92394a7eaead..c1c9cd1c87e8 100644\n--- a/django/core/validators.py\n+++ b/django/core/validators.py\n@@ -94,7 +94,7 @@ class URLValidator(RegexValidator):\n \n     regex = _lazy_re_compile(\n         r'^(?:[a-z0-9\\.\\-\\+]*)://'  # scheme is validated separately\n-        r'(?:\\S+(?::\\S*)?@)?'  # user:pass authentication\n+        r'(?:[^\\s:@/]+(?::[^\\s:@/]*)?@)?'  # user:pass authentication\n         r'(?:' + ipv4_re + '|' + ipv6_re + '|' + host_re + ')'\n         r'(?::\\d{2,5})?'  # port\n         r'(?:[/?#][^\\s]*)?'  # resource path\ndiff --git a/tests/validators/invalid_urls.txt b/tests/validators/invalid_urls.txt\nindex 04a0b5fb1b5f..4a092034ff66 100644\n--- a/tests/validators/invalid_urls.txt\n+++ b/tests/validators/invalid_urls.txt\n@@ -57,3 +57,9 @@ http://example.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.\n http://example.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n http://aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaa\n https://test.[com\n+http://foo@bar@example.com\n+http://foo/bar@example.com\n+http://foo:bar:baz@example.com\n+http://foo:bar@baz@example.com\n+http://foo:bar/baz@example.com\n+http://invalid-.com/?m=foo@example.com\ndiff --git a/tests/validators/valid_urls.txt b/tests/validators/valid_urls.txt\nindex 4bc8c03059c0..f79f94814291 100644\n--- a/tests/validators/valid_urls.txt\n+++ b/tests/validators/valid_urls.txt\n@@ -48,7 +48,7 @@ http://foo.bar/?q=Test%20URL-encoded%20stuff\n http://\u0645\u062b\u0627\u0644.\u0625\u062e\u062a\u0628\u0627\u0631\n http://\u4f8b\u5b50.\u6d4b\u8bd5\n http://\u0909\u0926\u093e\u0939\u0930\u0923.\u092a\u0930\u0940\u0915\u094d\u0937\u093e\n-http://-.~_!$&'()*+,;=:%40:80%2f::::::@example.com\n+http://-.~_!$&'()*+,;=%40:80%2f@example.com\n http://xn--7sbb4ac0ad0be6cf.xn--p1ai\n http://1337.net\n http://a.b-c.de\n", "gold_standard_pr_link": "https://github.com/django/django/pull/10097"}