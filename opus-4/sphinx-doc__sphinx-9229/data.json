{"instance_id": "sphinx-doc__sphinx-9229", "score": "I", "diff": "diff --git a/debug_fix.py b/debug_fix.py\nnew file mode 100644\nindex 000000000..1ec22490e\n--- /dev/null\n+++ b/debug_fix.py\n@@ -0,0 +1,103 @@\n+#!/usr/bin/env python\n+\"\"\"Debug script to understand why ScaffoldOpts doesn't work.\"\"\"\n+\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from sphinx.ext.autodoc import DataDocumenter, ModuleDocumenter\n+from sphinx.pycode import ModuleAnalyzer\n+from sphinx.util.docstrings import prepare_docstring\n+from sphinx.application import Sphinx\n+from sphinx.environment import BuildEnvironment\n+from docutils.parsers.rst import directives\n+from docutils.statemachine import StringList\n+\n+# Set up minimal app/env\n+class MockApp:\n+    config = type('config', (), {\n+        'autodoc_type_aliases': {},\n+        'autodoc_typehints_format': 'short',\n+        'autodoc_inherit_docstrings': True,\n+        'autodoc_mock_imports': [],\n+        'autodoc_warningiserror': False\n+    })()\n+    \n+    def emit(self, *args, **kwargs):\n+        pass\n+\n+class MockDirective:\n+    class state:\n+        class document:\n+            class settings:\n+                tab_width = 8\n+                \n+    env = type('env', (), {\n+        'app': MockApp(),\n+        'note_reread': lambda: None\n+    })()\n+\n+# Create test module\n+module_content = '''from typing import Dict, Any, Union, Callable\n+from pathlib import Path\n+\n+ScaffoldOpts = Dict[str, Any]\n+\"\"\"Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.\n+Should be treated as immutable (if required, copy before changing).\n+\"\"\"\n+\n+FileContents = Union[str, None]\n+\"\"\"When the file content is ``None``, the file should not be written to\n+disk (empty files are represented by an empty string ``\"\"`` as content).\n+\"\"\"\n+\n+FileOp = Callable[[Path, FileContents, Dict[str, Any]], Union[Path, None]]\n+\"\"\"Signature of functions considered file operations.\n+\"\"\"\n+'''\n+\n+# Write test module\n+with open('/tmp/test_module.py', 'w') as f:\n+    f.write(module_content)\n+\n+sys.path.insert(0, '/tmp')\n+\n+# Test each type alias\n+from test_module import ScaffoldOpts, FileContents, FileOp\n+\n+for name, obj in [('ScaffoldOpts', ScaffoldOpts), ('FileContents', FileContents), ('FileOp', FileOp)]:\n+    print(f\"\\n=== Testing {name} ===\")\n+    \n+    # Create documenter\n+    documenter = DataDocumenter(MockDirective(), name)\n+    documenter.modname = 'test_module'\n+    documenter.objpath = [name]\n+    documenter.object = obj\n+    documenter.parent = sys.modules['test_module']\n+    documenter.analyzer = None\n+    documenter.env = MockDirective.env\n+    documenter.fullname = f'test_module.{name}'\n+    \n+    # Check get_module_comment\n+    comment = documenter.get_module_comment(name)\n+    print(f\"  get_module_comment: {comment}\")\n+    \n+    # Check get_doc\n+    doc = documenter.get_doc()\n+    print(f\"  get_doc: {doc}\")\n+    \n+    # Test update_content\n+    more_content = StringList()\n+    documenter.update_content(more_content)\n+    print(f\"  update_content added: {list(more_content)}\")\n+\n+# Also check with analyzer\n+print(\"\\n=== Checking ModuleAnalyzer ===\")\n+try:\n+    analyzer = ModuleAnalyzer.for_module('test_module')\n+    analyzer.analyze()\n+    print(\"attr_docs:\", dict(analyzer.attr_docs))\n+except Exception as e:\n+    print(f\"Error: {e}\")\n+\n+os.unlink('/tmp/test_module.py')\ndiff --git a/debug_type_alias.py b/debug_type_alias.py\nnew file mode 100644\nindex 000000000..2b248d08d\n--- /dev/null\n+++ b/debug_type_alias.py\n@@ -0,0 +1,39 @@\n+import inspect\n+from typing import Dict, Any, Union, Callable\n+from pathlib import Path\n+from sphinx.util import inspect as sphinx_inspect\n+\n+# Import our test types\n+from test_type_alias import ScaffoldOpts, FileContents, FileOp\n+\n+print(\"Checking ScaffoldOpts:\")\n+print(f\"  Type: {type(ScaffoldOpts)}\")\n+print(f\"  __doc__: {ScaffoldOpts.__doc__}\")\n+print(f\"  isNewType: {sphinx_inspect.isNewType(ScaffoldOpts)}\")\n+print(f\"  isgenericalias: {sphinx_inspect.isgenericalias(ScaffoldOpts)}\")\n+print(f\"  isinstance TypeVar: {isinstance(ScaffoldOpts, type(type))}\")\n+\n+print(\"\\nChecking FileContents:\")\n+print(f\"  Type: {type(FileContents)}\")\n+print(f\"  __doc__: {FileContents.__doc__}\")\n+print(f\"  isNewType: {sphinx_inspect.isNewType(FileContents)}\")\n+print(f\"  isgenericalias: {sphinx_inspect.isgenericalias(FileContents)}\")\n+\n+print(\"\\nChecking FileOp:\")\n+print(f\"  Type: {type(FileOp)}\")\n+print(f\"  __doc__: {FileOp.__doc__}\")\n+print(f\"  isNewType: {sphinx_inspect.isNewType(FileOp)}\")\n+print(f\"  isgenericalias: {sphinx_inspect.isgenericalias(FileOp)}\")\n+\n+# Check if they have __module__ attribute\n+print(\"\\nModule attributes:\")\n+print(f\"  ScaffoldOpts.__module__: {getattr(ScaffoldOpts, '__module__', 'NOT FOUND')}\")\n+print(f\"  FileContents.__module__: {getattr(FileContents, '__module__', 'NOT FOUND')}\")\n+print(f\"  FileOp.__module__: {getattr(FileOp, '__module__', 'NOT FOUND')}\")\n+\n+# Check getdoc results\n+from sphinx.util.inspect import getdoc\n+print(\"\\ngetdoc results:\")\n+print(f\"  ScaffoldOpts: {getdoc(ScaffoldOpts, lambda obj, name: getattr(obj, name, None))}\")\n+print(f\"  FileContents: {getdoc(FileContents, lambda obj, name: getattr(obj, name, None))}\")\n+print(f\"  FileOp: {getdoc(FileOp, lambda obj, name: getattr(obj, name, None))}\")\ndiff --git a/setup.py b/setup.py\nindex b669afc00..0986baec3 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.14,<0.18',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 000000000..8b1378917\n--- /dev/null\n+++ b/simple_test.py\n@@ -0,0 +1 @@\n+\ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284..224f9da7e 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1798,8 +1798,12 @@ class GenericAliasMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isgenericalias(self.object):\n-            more_content.append(_('alias of %s') % restify(self.object), '')\n-            more_content.append('', '')\n+            # Check if there's a docstring available\n+            doc = self.get_doc()  # type: ignore\n+            if not doc or not any(doc):\n+                # Only add \"alias of\" text if there's no docstring\n+                more_content.append(_('alias of %s') % restify(self.object), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1816,9 +1820,13 @@ class NewTypeMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if inspect.isNewType(self.object):\n-            supertype = restify(self.object.__supertype__)\n-            more_content.append(_('alias of %s') % supertype, '')\n-            more_content.append('', '')\n+            # Check if there's a docstring available\n+            doc = self.get_doc()  # type: ignore\n+            if not doc or not any(doc):\n+                # Only add \"alias of\" text if there's no docstring\n+                supertype = restify(self.object.__supertype__)\n+                more_content.append(_('alias of %s') % supertype, '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \n@@ -1849,18 +1857,22 @@ class TypeVarMixin(DataDocumenterMixinBase):\n \n     def update_content(self, more_content: StringList) -> None:\n         if isinstance(self.object, TypeVar):\n-            attrs = [repr(self.object.__name__)]\n-            for constraint in self.object.__constraints__:\n-                attrs.append(stringify_typehint(constraint))\n-            if self.object.__bound__:\n-                attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n-            if self.object.__covariant__:\n-                attrs.append(\"covariant=True\")\n-            if self.object.__contravariant__:\n-                attrs.append(\"contravariant=True\")\n-\n-            more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n-            more_content.append('', '')\n+            # Check if there's a docstring available\n+            doc = self.get_doc()  # type: ignore\n+            if not doc or not any(doc):\n+                # Only add \"alias of\" text if there's no docstring\n+                attrs = [repr(self.object.__name__)]\n+                for constraint in self.object.__constraints__:\n+                    attrs.append(stringify_typehint(constraint))\n+                if self.object.__bound__:\n+                    attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n+                if self.object.__covariant__:\n+                    attrs.append(\"covariant=True\")\n+                if self.object.__contravariant__:\n+                    attrs.append(\"contravariant=True\")\n+\n+                more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n+                more_content.append('', '')\n \n         super().update_content(more_content)\n \ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 000000000..dc2deb20b\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,129 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to reproduce the issue and verify the fix.\"\"\"\n+\n+import os\n+import sys\n+import shutil\n+import tempfile\n+from pathlib import Path\n+\n+# Create a temporary directory for the test\n+test_dir = tempfile.mkdtemp()\n+print(f\"Test directory: {test_dir}\")\n+\n+# Create the test module with type aliases\n+module_content = '''from pathlib import Path\n+from typing import Any, Callable, Dict, Union\n+\n+# Signatures for the documentation purposes\n+\n+ScaffoldOpts = Dict[str, Any]\n+\"\"\"Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.\n+Should be treated as immutable (if required, copy before changing).\n+\n+Please notice some behaviours given by the options **SHOULD** be observed. For example,\n+files should be overwritten when the **force** option is ``True``. Similarly when\n+**pretend** is ``True``, no operation should be really performed, but any action should\n+be logged as if realized.\n+\"\"\"\n+\n+FileContents = Union[str, None]\n+\"\"\"When the file content is ``None``, the file should not be written to\n+disk (empty files are represented by an empty string ``\"\"`` as content).\n+\"\"\"\n+\n+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\"\"\"Signature of functions considered file operations::\n+\n+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\n+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed\n+  in the disk.\n+- **contents** (:obj:`FileContents`): usually a string that represents a text content\n+  of the file. :obj:`None` indicates the file should not be written.\n+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.\n+\n+If the file is written (or more generally changed, such as new access permissions),\n+by convention they should return the :obj:`file path <pathlib.Path>`.\n+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**\n+might return :obj:`None` if a pre-existing file in the disk is not modified.\n+\n+.. note::\n+    A **FileOp** usually has side effects (e.g. write a file to the disk), see\n+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.\n+\"\"\"\n+'''\n+\n+# Write the test module\n+with open(os.path.join(test_dir, 'file.py'), 'w') as f:\n+    f.write(module_content)\n+\n+# Create conf.py\n+conf_content = '''\n+import os\n+import sys\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+extensions = ['sphinx.ext.autodoc']\n+exclude_patterns = ['_build']\n+'''\n+\n+with open(os.path.join(test_dir, 'conf.py'), 'w') as f:\n+    f.write(conf_content)\n+\n+# Create index.rst\n+index_content = '''\n+Test Type Aliases\n+=================\n+\n+.. automodule:: file\n+   :members:\n+   :undoc-members:\n+'''\n+\n+with open(os.path.join(test_dir, 'index.rst'), 'w') as f:\n+    f.write(index_content)\n+\n+# Run sphinx-build\n+os.chdir(test_dir)\n+result = os.system(f'{sys.executable} -m sphinx -b html -E . _build/html')\n+\n+if result == 0:\n+    print(\"\\nBuild successful!\")\n+    \n+    # Check the generated HTML\n+    html_file = os.path.join(test_dir, '_build/html/index.html')\n+    if os.path.exists(html_file):\n+        with open(html_file, 'r') as f:\n+            content = f.read()\n+        \n+        # Check if docstrings are present\n+        if \"Dictionary with PyScaffold's options\" in content:\n+            print(\"\u2713 ScaffoldOpts docstring found\")\n+        else:\n+            print(\"\u2717 ScaffoldOpts docstring NOT found\")\n+            \n+        if \"When the file content is\" in content:\n+            print(\"\u2713 FileContents docstring found\")\n+        else:\n+            print(\"\u2717 FileContents docstring NOT found\")\n+            \n+        if \"Signature of functions considered file operations\" in content:\n+            print(\"\u2713 FileOp docstring found\")\n+        else:\n+            print(\"\u2717 FileOp docstring NOT found\")\n+            \n+        # Check if \"alias of\" text is present when it shouldn't be\n+        if \"alias of\" in content:\n+            print(\"\\n\u26a0 'alias of' text still present in output\")\n+            # Extract context around \"alias of\"\n+            import re\n+            matches = re.finditer(r'.{50}alias of.{50}', content, re.DOTALL)\n+            for match in matches:\n+                print(f\"  Context: ...{match.group()}...\")\n+else:\n+    print(f\"\\nBuild failed with code {result}\")\n+\n+# Cleanup\n+os.chdir('..')\n+shutil.rmtree(test_dir)\ndiff --git a/test_type_alias.py b/test_type_alias.py\nnew file mode 100644\nindex 000000000..ec7209833\n--- /dev/null\n+++ b/test_type_alias.py\n@@ -0,0 +1,40 @@\n+from pathlib import Path\n+from typing import Any, Callable, Dict, Union\n+\n+# Signatures for the documentation purposes\n+\n+ScaffoldOpts = Dict[str, Any]\n+\"\"\"Dictionary with PyScaffold's options, see ``pyscaffold.api.create_project``.\n+Should be treated as immutable (if required, copy before changing).\n+\n+Please notice some behaviours given by the options **SHOULD** be observed. For example,\n+files should be overwritten when the **force** option is ``True``. Similarly when\n+**pretend** is ``True``, no operation should be really performed, but any action should\n+be logged as if realized.\n+\"\"\"\n+\n+FileContents = Union[str, None]\n+\"\"\"When the file content is ``None``, the file should not be written to\n+disk (empty files are represented by an empty string ``\"\"`` as content).\n+\"\"\"\n+\n+FileOp = Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\"\"\"Signature of functions considered file operations::\n+\n+    Callable[[Path, FileContents, ScaffoldOpts], Union[Path, None]]\n+\n+- **path** (:obj:`pathlib.Path`): file path potentially to be written to/changed\n+  in the disk.\n+- **contents** (:obj:`FileContents`): usually a string that represents a text content\n+  of the file. :obj:`None` indicates the file should not be written.\n+- **opts** (:obj:`ScaffoldOpts`): a dict with PyScaffold's options.\n+\n+If the file is written (or more generally changed, such as new access permissions),\n+by convention they should return the :obj:`file path <pathlib.Path>`.\n+If no file was touched, :obj:`None` should be returned. Please notice a **FileOp**\n+might return :obj:`None` if a pre-existing file in the disk is not modified.\n+\n+.. note::\n+    A **FileOp** usually has side effects (e.g. write a file to the disk), see\n+    :obj:`FileFileContents` and :obj:`ScaffoldOpts` for other conventions.\n+\"\"\"\ndiff --git a/tox.ini b/tox.ini\nindex a363e187f..3b8bc12d0 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -27,7 +27,7 @@ setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version\n     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes\n commands=\n-    python -X dev -m pytest --durations 25 {posargs}\n+    python -X dev -m pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n", "gold_standard_diff": "diff --git a/CHANGES b/CHANGES\nindex da8580fe67a..36caf8f7775 100644\n--- a/CHANGES\n+++ b/CHANGES\n@@ -30,6 +30,7 @@ Features added\n   allow typehints to be included both in the signature and description\n * #4257: autodoc: Add :confval:`autodoc_class_signature` to separate the class\n   entry and the definition of ``__init__()`` method\n+* #8061, #9218: autodoc: Support variable comment for alias classes\n * #3257: autosummary: Support instance attributes for classes\n * #9129: html search: Show search summaries when html_copy_source = False\n * #9120: html theme: Eliminate prompt characters of code-block from copyable\ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex 1f4c98284bc..18fb0c92e91 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1676,7 +1676,11 @@ def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         if self.doc_as_attr:\n             # Don't show the docstring of the class when it is an alias.\n-            return None\n+            comment = self.get_variable_comment()\n+            if comment:\n+                return []\n+            else:\n+                return None\n \n         lines = getattr(self, '_new_docstrings', None)\n         if lines is not None:\n@@ -1721,9 +1725,18 @@ def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n         tab_width = self.directive.state.document.settings.tab_width\n         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n \n+    def get_variable_comment(self) -> Optional[List[str]]:\n+        try:\n+            key = ('', '.'.join(self.objpath))\n+            analyzer = ModuleAnalyzer.for_module(self.get_real_modname())\n+            analyzer.analyze()\n+            return list(self.analyzer.attr_docs.get(key, []))\n+        except PycodeError:\n+            return None\n+\n     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n                     ) -> None:\n-        if self.doc_as_attr:\n+        if self.doc_as_attr and not self.get_variable_comment():\n             try:\n                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n             except AttributeError:\ndiff --git a/tests/roots/test-ext-autodoc/target/classes.py b/tests/roots/test-ext-autodoc/target/classes.py\nindex a3b4c64774d..7526e65bc74 100644\n--- a/tests/roots/test-ext-autodoc/target/classes.py\n+++ b/tests/roots/test-ext-autodoc/target/classes.py\n@@ -30,3 +30,6 @@ class Quux(List[Union[int, float]]):\n \n \n Alias = Foo\n+\n+#: docstring\n+OtherAlias = Bar\ndiff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 096dc939738..ee0c00ae27f 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -327,3 +327,15 @@ def autodoc_process_docstring(*args):\n         '',\n         '   alias of :class:`target.classes.Foo`',\n     ]\n+\n+\n+def test_class_alias_having_doccomment(app):\n+    actual = do_autodoc(app, 'class', 'target.classes.OtherAlias')\n+    assert list(actual) == [\n+        '',\n+        '.. py:attribute:: OtherAlias',\n+        '   :module: target.classes',\n+        '',\n+        '   docstring',\n+        '',\n+    ]\n", "gold_standard_pr_link": "https://github.com/sphinx-doc/sphinx/pull/9229"}