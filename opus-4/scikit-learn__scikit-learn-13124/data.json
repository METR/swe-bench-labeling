{"instance_id": "scikit-learn__scikit-learn-13124", "score": "I", "diff": "diff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 24394f869..ec6fff609 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -620,7 +620,7 @@ class StratifiedKFold(_BaseKFold):\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\n-        rng = self.random_state\n+        rng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\n@@ -651,10 +651,18 @@ class StratifiedKFold(_BaseKFold):\n         # NOTE: Passing the data corresponding to ith class say X[y==class_i]\n         # will break when the data is not 100% stratifiable for all classes.\n         # So we pass np.zeroes(max(c, n_splits)) as data to the KFold\n-        per_cls_cvs = [\n-            KFold(self.n_splits, shuffle=self.shuffle,\n-                  random_state=rng).split(np.zeros(max(count, self.n_splits)))\n-            for count in y_counts]\n+        per_cls_cvs = []\n+        for i, count in enumerate(y_counts):\n+            # Create a different random state for each class to ensure independent shuffling\n+            if self.shuffle and rng is not None:\n+                # Use a different seed for each class based on the base random state\n+                cls_rng = rng.randint(0, 2**32 - 1)\n+            else:\n+                cls_rng = None\n+            per_cls_cvs.append(\n+                KFold(self.n_splits, shuffle=self.shuffle,\n+                      random_state=cls_rng).split(np.zeros(max(count, self.n_splits)))\n+            )\n \n         test_folds = np.zeros(n_samples, dtype=np.int)\n         for test_fold_indices, per_cls_splits in enumerate(zip(*per_cls_cvs)):\ndiff --git a/test_detailed_analysis.py b/test_detailed_analysis.py\nnew file mode 100644\nindex 000000000..1d11b62a7\n--- /dev/null\n+++ b/test_detailed_analysis.py\n@@ -0,0 +1,41 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold, KFold\n+\n+# Reproduce the exact scenario from the issue\n+samples_per_class = 10\n+X = np.linspace(0, samples_per_class*2-1, samples_per_class * 2)\n+y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)), axis=0)\n+\n+print(\"Data:\")\n+print(\"X:\", X)\n+print(\"y:\", y)\n+print(\"\\nClass 1 indices:\", np.where(y == 1)[0])\n+print(\"Class 0 indices:\", np.where(y == 0)[0])\n+\n+# Check what KFold does with shuffle on each class separately\n+print(\"\\n\\n=== Testing KFold shuffle on class data separately ===\")\n+\n+# For class 1 (indices 0-9)\n+print(\"\\nClass 1 (indices 0-9):\")\n+class1_indices = np.where(y == 1)[0]\n+kf1 = KFold(n_splits=10, shuffle=True, random_state=1)\n+for i, (train, test) in enumerate(kf1.split(class1_indices)):\n+    # Map back to original indices\n+    test_original = class1_indices[test]\n+    print(f\"Fold {i}: test index within class = {test}, original index = {test_original}\")\n+\n+# For class 0 (indices 10-19)  \n+print(\"\\nClass 0 (indices 10-19):\")\n+class0_indices = np.where(y == 0)[0]\n+kf0 = KFold(n_splits=10, shuffle=True, random_state=1)\n+for i, (train, test) in enumerate(kf0.split(class0_indices)):\n+    # Map back to original indices\n+    test_original = class0_indices[test]\n+    print(f\"Fold {i}: test index within class = {test}, original index = {test_original}\")\n+\n+# Now let's trace what StratifiedKFold does\n+print(\"\\n\\n=== What StratifiedKFold produces ===\")\n+skf = StratifiedKFold(n_splits=10, shuffle=True, random_state=1)\n+for i, (train, test) in enumerate(skf.split(X, y)):\n+    print(f\"Fold {i}: test = {test}\")\n+    \ndiff --git a/test_issue_understanding.py b/test_issue_understanding.py\nnew file mode 100644\nindex 000000000..a78db4c68\n--- /dev/null\n+++ b/test_issue_understanding.py\n@@ -0,0 +1,43 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+# Create simple data\n+X = np.arange(20)  # [0, 1, 2, ..., 19]\n+y = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])  # First 10 are class 1, last 10 are class 0\n+\n+print(\"X:\", X)\n+print(\"y:\", y)\n+print()\n+\n+# Look at how the shuffling works\n+kf_no_shuffle = StratifiedKFold(n_splits=5, shuffle=False)\n+kf_shuffle1 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+kf_shuffle2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=123)\n+\n+print(\"Without shuffle:\")\n+for i, (train, test) in enumerate(kf_no_shuffle.split(X, y)):\n+    print(f\"Fold {i}: test = {test}\")\n+\n+print(\"\\nWith shuffle (random_state=42):\")\n+for i, (train, test) in enumerate(kf_shuffle1.split(X, y)):\n+    print(f\"Fold {i}: test = {test}\")\n+    \n+print(\"\\nWith shuffle (random_state=123):\")\n+for i, (train, test) in enumerate(kf_shuffle2.split(X, y)):\n+    print(f\"Fold {i}: test = {test}\")\n+\n+# Let's trace through what's happening in the code\n+print(\"\\n\\n=== DEBUGGING ===\")\n+print(\"When shuffle=True with random_state=42:\")\n+kf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+\n+# Get the test folds\n+test_folds = kf._make_test_folds(X, y)\n+print(\"test_folds array:\", test_folds)\n+print(\"This array assigns each sample index to a fold number\")\n+\n+# Check what indices belong to each fold\n+for fold in range(5):\n+    indices = np.where(test_folds == fold)[0]\n+    print(f\"Fold {fold}: indices = {indices}\")\n+    \ndiff --git a/test_none_random_state.py b/test_none_random_state.py\nnew file mode 100644\nindex 000000000..247e8fe1d\n--- /dev/null\n+++ b/test_none_random_state.py\n@@ -0,0 +1,42 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+# Test with random_state=None and shuffle=False (should be deterministic)\n+X = np.arange(20)\n+y = np.concatenate([np.ones(10), np.zeros(10)])\n+\n+print(\"Test 1: shuffle=False, random_state=None (should be deterministic)\")\n+skf1 = StratifiedKFold(n_splits=5, shuffle=False, random_state=None)\n+skf2 = StratifiedKFold(n_splits=5, shuffle=False, random_state=None)\n+\n+results1 = []\n+results2 = []\n+\n+for train, test in skf1.split(X, y):\n+    results1.append(tuple(sorted(test)))\n+\n+for train, test in skf2.split(X, y):\n+    results2.append(tuple(sorted(test)))\n+\n+print(\"Results 1:\", results1)\n+print(\"Results 2:\", results2)\n+print(\"Are they the same?\", results1 == results2)\n+\n+# Test with random_state=None and shuffle=True (should NOT be deterministic)\n+print(\"\\nTest 2: shuffle=True, random_state=None (should NOT be deterministic)\")\n+skf3 = StratifiedKFold(n_splits=5, shuffle=True, random_state=None)\n+skf4 = StratifiedKFold(n_splits=5, shuffle=True, random_state=None)\n+\n+results3 = []\n+results4 = []\n+\n+for train, test in skf3.split(X, y):\n+    results3.append(tuple(sorted(test)))\n+\n+for train, test in skf4.split(X, y):\n+    results4.append(tuple(sorted(test)))\n+\n+print(\"Results 3:\", results3)\n+print(\"Results 4:\", results4)\n+print(\"Are they the same?\", results3 == results4)\n+print(\"(They might be the same by chance, but usually should be different)\")\ndiff --git a/test_stratified_kfold_fix.py b/test_stratified_kfold_fix.py\nnew file mode 100644\nindex 000000000..38b17883c\n--- /dev/null\n+++ b/test_stratified_kfold_fix.py\n@@ -0,0 +1,97 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+# Test 1: Basic functionality should still work\n+print(\"Test 1: Basic functionality\")\n+X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]])\n+y = np.array([0, 0, 1, 1, 0, 0, 1, 1])\n+skf = StratifiedKFold(n_splits=2)\n+for train, test in skf.split(X, y):\n+    print(f\"Train: {train}, Test: {test}\")\n+    # Check stratification is maintained\n+    train_class_counts = np.bincount(y[train])\n+    test_class_counts = np.bincount(y[test])\n+    print(f\"  Train class counts: {train_class_counts}, Test class counts: {test_class_counts}\")\n+\n+# Test 2: Shuffle should produce different pairings with different random states\n+print(\"\\nTest 2: Different random states produce different pairings\")\n+samples_per_class = 10\n+X = np.arange(samples_per_class * 2)\n+y = np.concatenate([np.ones(samples_per_class), np.zeros(samples_per_class)])\n+\n+# Collect pairings for different random states\n+pairings_rs1 = []\n+pairings_rs2 = []\n+\n+skf1 = StratifiedKFold(n_splits=samples_per_class, shuffle=True, random_state=1)\n+for train, test in skf1.split(X, y):\n+    pairings_rs1.append(tuple(sorted(test)))\n+\n+skf2 = StratifiedKFold(n_splits=samples_per_class, shuffle=True, random_state=2)\n+for train, test in skf2.split(X, y):\n+    pairings_rs2.append(tuple(sorted(test)))\n+\n+print(f\"Pairings with random_state=1: {pairings_rs1[:5]}...\")\n+print(f\"Pairings with random_state=2: {pairings_rs2[:5]}...\")\n+print(f\"Are pairings different? {pairings_rs1 != pairings_rs2}\")\n+\n+# Test 3: Without shuffle, pairings should be deterministic\n+print(\"\\nTest 3: Without shuffle, pairings are deterministic\")\n+skf_no_shuffle1 = StratifiedKFold(n_splits=5, shuffle=False)\n+skf_no_shuffle2 = StratifiedKFold(n_splits=5, shuffle=False)\n+\n+pairings_no_shuffle1 = []\n+pairings_no_shuffle2 = []\n+\n+for train, test in skf_no_shuffle1.split(X, y):\n+    pairings_no_shuffle1.append(tuple(sorted(test)))\n+\n+for train, test in skf_no_shuffle2.split(X, y):\n+    pairings_no_shuffle2.append(tuple(sorted(test)))\n+\n+print(f\"First run: {pairings_no_shuffle1}\")\n+print(f\"Second run: {pairings_no_shuffle2}\")\n+print(f\"Are pairings the same? {pairings_no_shuffle1 == pairings_no_shuffle2}\")\n+\n+# Test 4: With shuffle and same random state, results should be reproducible\n+print(\"\\nTest 4: With shuffle and same random state, results are reproducible\")\n+skf_shuffle_same1 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+skf_shuffle_same2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+\n+pairings_same1 = []\n+pairings_same2 = []\n+\n+for train, test in skf_shuffle_same1.split(X, y):\n+    pairings_same1.append(tuple(sorted(test)))\n+\n+for train, test in skf_shuffle_same2.split(X, y):\n+    pairings_same2.append(tuple(sorted(test)))\n+\n+print(f\"First run: {pairings_same1}\")\n+print(f\"Second run: {pairings_same2}\")\n+print(f\"Are pairings the same? {pairings_same1 == pairings_same2}\")\n+\n+# Test 5: Check that we're not getting the same position indices paired\n+print(\"\\nTest 5: Check that shuffle produces varied pairings (not just position-based)\")\n+skf = StratifiedKFold(n_splits=10, shuffle=True, random_state=42)\n+position_based_pairs = 0\n+total_pairs = 0\n+\n+for train, test in skf.split(X, y):\n+    # Check if indices in test set have the same position within their classes\n+    test_class1 = [idx for idx in test if y[idx] == 1]\n+    test_class0 = [idx for idx in test if y[idx] == 0]\n+    \n+    if len(test_class1) == 1 and len(test_class0) == 1:\n+        # Position within class 1: index value itself (0-9)\n+        # Position within class 0: index value - 10 (so 10->0, 11->1, etc.)\n+        pos1 = test_class1[0]\n+        pos0 = test_class0[0] - samples_per_class\n+        \n+        if pos1 == pos0:\n+            position_based_pairs += 1\n+        total_pairs += 1\n+\n+print(f\"Position-based pairs: {position_based_pairs}/{total_pairs}\")\n+print(f\"All pairs position-based? {position_based_pairs == total_pairs}\")\n+print(\"Success! Shuffling now produces varied pairings, not just position-based.\")\ndiff --git a/test_stratified_kfold_issue.py b/test_stratified_kfold_issue.py\nnew file mode 100644\nindex 000000000..4cdb5eacb\n--- /dev/null\n+++ b/test_stratified_kfold_issue.py\n@@ -0,0 +1,32 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold\n+\n+RANDOM_SEED = 1\n+\n+samples_per_class = 10\n+X = np.linspace(0, samples_per_class*2-1, samples_per_class * 2)\n+y = np.concatenate((np.ones(samples_per_class), np.zeros(samples_per_class)), axis=0)\n+\n+print(X, '\\n', y, '\\n')\n+\n+print('\\nshuffle = False\\n')\n+\n+k_fold = StratifiedKFold(n_splits=10, shuffle=False, random_state=RANDOM_SEED)\n+result = 0\n+for fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\n+    print(train_idx, '\\n', test_idx)\n+\n+print('\\nshuffle = True, Random seed =', RANDOM_SEED, '\\n')\n+\n+k_fold = StratifiedKFold(n_splits=10, shuffle=True, random_state=RANDOM_SEED)\n+result = 0\n+for fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\n+    print(train_idx, '\\n', test_idx)\n+\n+RANDOM_SEED += 1\n+print('\\nshuffle = True, Random seed =', RANDOM_SEED, '\\n')\n+  \n+k_fold = StratifiedKFold(n_splits=10, shuffle=True, random_state=RANDOM_SEED)\n+result = 0\n+for fold_n, (train_idx, test_idx) in enumerate(k_fold.split(X, y)):\n+    print(train_idx, '\\n', test_idx)\ndiff --git a/test_verify_fix.py b/test_verify_fix.py\nnew file mode 100644\nindex 000000000..2c5bc7ac1\n--- /dev/null\n+++ b/test_verify_fix.py\n@@ -0,0 +1,33 @@\n+import numpy as np\n+from sklearn.model_selection import StratifiedKFold, RepeatedStratifiedKFold\n+\n+# Test that RepeatedStratifiedKFold still produces deterministic results\n+X = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n+y = [1, 1, 1, 0, 0]\n+random_state = 1944695409\n+rskf = RepeatedStratifiedKFold(\n+    n_splits=2,\n+    n_repeats=2,\n+    random_state=random_state)\n+\n+# Collect results from multiple runs\n+results = []\n+for run in range(3):\n+    run_results = []\n+    for train, test in rskf.split(X, y):\n+        run_results.append((tuple(sorted(train)), tuple(sorted(test))))\n+    results.append(run_results)\n+\n+# Check that all runs produce the same results\n+print(\"Results from first run:\", results[0])\n+print(\"Are all runs identical?\", all(results[i] == results[0] for i in range(len(results))))\n+\n+# Test stratification is maintained\n+for train, test in rskf.split(X, y):\n+    y_train = [y[i] for i in train]\n+    y_test = [y[i] for i in test]\n+    print(f\"Train indices: {train}, y_train: {y_train}\")\n+    print(f\"Test indices: {test}, y_test: {y_test}\")\n+    print(f\"Train class counts: {np.bincount(y_train)}\")\n+    print(f\"Test class counts: {np.bincount(y_test)}\")\n+    print()\n", "gold_standard_diff": "diff --git a/doc/whats_new/v0.21.rst b/doc/whats_new/v0.21.rst\nindex fdd0230fc840b..3d7393eb901e5 100644\n--- a/doc/whats_new/v0.21.rst\n+++ b/doc/whats_new/v0.21.rst\n@@ -200,6 +200,11 @@ Support for Python 3.4 and below has been officially dropped.\n   :func:`~model_selection.validation_curve` only the latter is required.\n   :issue:`12613` and :issue:`12669` by :user:`Marc Torrellas <marctorrellas>`.\n \n+- |Fix| Fixed a bug where :class:`model_selection.StratifiedKFold`\n+  shuffles each class's samples with the same ``random_state``,\n+  making ``shuffle=True`` ineffective.\n+  :issue:`13124` by :user:`Hanmin Qin <qinhanmin2014>`.\n+\n :mod:`sklearn.neighbors`\n ........................\n \ndiff --git a/sklearn/model_selection/_split.py b/sklearn/model_selection/_split.py\nindex 21ffbc49a2004..e8d46faac91d9 100644\n--- a/sklearn/model_selection/_split.py\n+++ b/sklearn/model_selection/_split.py\n@@ -576,8 +576,7 @@ class StratifiedKFold(_BaseKFold):\n             ``n_splits`` default value will change from 3 to 5 in v0.22.\n \n     shuffle : boolean, optional\n-        Whether to shuffle each stratification of the data before splitting\n-        into batches.\n+        Whether to shuffle each class's samples before splitting into batches.\n \n     random_state : int, RandomState instance or None, optional, default=None\n         If int, random_state is the seed used by the random number generator;\n@@ -620,7 +619,7 @@ def __init__(self, n_splits='warn', shuffle=False, random_state=None):\n         super().__init__(n_splits, shuffle, random_state)\n \n     def _make_test_folds(self, X, y=None):\n-        rng = self.random_state\n+        rng = check_random_state(self.random_state)\n         y = np.asarray(y)\n         type_of_target_y = type_of_target(y)\n         allowed_target_types = ('binary', 'multiclass')\ndiff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex 2be8d172ef822..cab88fb669db2 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -493,6 +493,17 @@ def test_shuffle_stratifiedkfold():\n         assert_not_equal(set(test0), set(test1))\n     check_cv_coverage(kf0, X_40, y, groups=None, expected_n_splits=5)\n \n+    # Ensure that we shuffle each class's samples with different\n+    # random_state in StratifiedKFold\n+    # See https://github.com/scikit-learn/scikit-learn/pull/13124\n+    X = np.arange(10)\n+    y = [0] * 5 + [1] * 5\n+    kf1 = StratifiedKFold(5, shuffle=True, random_state=0)\n+    kf2 = StratifiedKFold(5, shuffle=True, random_state=1)\n+    test_set1 = sorted([tuple(s[1]) for s in kf1.split(X, y)])\n+    test_set2 = sorted([tuple(s[1]) for s in kf2.split(X, y)])\n+    assert test_set1 != test_set2\n+\n \n def test_kfold_can_detect_dependent_samples_on_digits():  # see #2372\n     # The digits samples are dependent: they are apparently grouped by authors\n", "gold_standard_pr_link": "https://github.com/scikit-learn/scikit-learn/pull/13124"}