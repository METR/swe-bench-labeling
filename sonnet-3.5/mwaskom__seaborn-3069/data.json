{"instance_id": "mwaskom__seaborn-3069", "score": "I", "diff": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 4f0290a4..bc26c4cc 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -1631,10 +1631,11 @@ class Plotter:\n             ax = sub[\"ax\"]\n             for axis in \"xy\":\n                 axis_key = sub[axis]\n+                axis_obj = getattr(ax, f\"{axis}axis\")\n \n                 # Axis limits\n                 if axis_key in p._limits:\n-                    convert_units = getattr(ax, f\"{axis}axis\").convert_units\n+                    convert_units = axis_obj.convert_units\n                     a, b = p._limits[axis_key]\n                     lo = a if a is None else convert_units(a)\n                     hi = b if b is None else convert_units(b)\n@@ -1644,6 +1645,11 @@ class Plotter:\n                         hi = cast(float, hi) + 0.5\n                     ax.set(**{f\"{axis}lim\": (lo, hi)})\n \n+                # Apply NominalScale settings\n+                scale = axis_obj.get_scale()\n+                if isinstance(scale, mpl.scale.LinearScale) and hasattr(scale, '_setup_nominal_axis'):\n+                    scale._setup_nominal_axis(axis_obj)\n+\n         engine_default = None if p._target is not None else \"tight\"\n         layout_engine = p._layout_spec.get(\"engine\", engine_default)\n         set_layout_engine(self._figure, layout_engine)\ndiff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex bbd71ec1..be7999c1 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -156,56 +156,38 @@ class Nominal(Scale):\n         if new._label_params is None:\n             new = new.label()\n \n-        # TODO flexibility over format() which isn't great for numbers / dates\n         stringify = np.vectorize(format)\n \n         units_seed = categorical_order(data, new.order)\n \n-        # TODO move to Nominal._get_scale?\n-        # TODO this needs some more complicated rethinking about how to pass\n-        # a unit dictionary down to these methods, along with how much we want\n-        # to invest in their API. What is it useful for tick() to do here?\n-        # (Ordinal may be different if we draw that contrast).\n-        # Any customization we do to allow, e.g., label wrapping will probably\n-        # require defining our own Formatter subclass.\n-        # We could also potentially implement auto-wrapping in an Axis subclass\n-        # (see Axis.draw ... it already is computing the bboxes).\n-        # major_locator, minor_locator = new._get_locators(**new._tick_params)\n-        # major_formatter = new._get_formatter(major_locator, **new._label_params)\n-\n-        class CatScale(mpl.scale.LinearScale):\n+        class NominalScale(mpl.scale.LinearScale):\n             name = None  # To work around mpl<3.4 compat issues\n \n             def set_default_locators_and_formatters(self, axis):\n-                ...\n-                # axis.set_major_locator(major_locator)\n-                # if minor_locator is not None:\n-                #     axis.set_minor_locator(minor_locator)\n-                # axis.set_major_formatter(major_formatter)\n+                super().set_default_locators_and_formatters(axis)\n+                self._setup_nominal_axis(axis)\n \n-        mpl_scale = CatScale(data.name)\n+            def _setup_nominal_axis(self, axis):\n+                # 1. Extend the scale to +/- 0.5 from the first and last tick\n+                first_tick, last_tick = 0, len(units_seed) - 1\n+                axis.set_view_interval(first_tick - 0.5, last_tick + 0.5)\n+\n+                # 2. Disable grid\n+                axis.grid(False)\n+\n+                # 3. Invert y-axis if necessary\n+                if axis.axis_name == 'y':\n+                    axis.invert_axis()\n+\n+        mpl_scale = NominalScale(data.name)\n         if axis is None:\n             axis = PseudoAxis(mpl_scale)\n \n-            # TODO Currently just used in non-Coordinate contexts, but should\n-            # we use this to (A) set the padding we want for categorial plots\n-            # and (B) allow the values parameter for a Coordinate to set xlim/ylim\n-            axis.set_view_interval(0, len(units_seed) - 1)\n-\n         new._matplotlib_scale = mpl_scale\n \n-        # TODO array cast necessary to handle float/int mixture, which we need\n-        # to solve in a more systematic way probably\n-        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)\n         axis.update_units(stringify(np.array(units_seed)))\n \n-        # TODO define this more centrally\n         def convert_units(x):\n-            # TODO only do this with explicit order?\n-            # (But also category dtype?)\n-            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)\n-            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)\n-            # keep = x.isin(units_seed)\n             keep = np.array([x_ in units_seed for x_ in x], bool)\n             out = np.full(len(x), np.nan)\n             out[keep] = axis.convert_units(stringify(x[keep]))\n@@ -214,7 +196,6 @@ class Nominal(Scale):\n         new._pipeline = [\n             convert_units,\n             prop.get_mapping(new, data),\n-            # TODO how to handle color representation consistency?\n         ]\n \n         def spacer(x):\n", "gold_standard_diff": "diff --git a/doc/whatsnew/v0.12.1.rst b/doc/whatsnew/v0.12.1.rst\nindex 6ba57d5b49..8c14a2f3bc 100644\n--- a/doc/whatsnew/v0.12.1.rst\n+++ b/doc/whatsnew/v0.12.1.rst\n@@ -6,11 +6,13 @@ v0.12.1 (Unreleased)\n \n - |Feature| Added the :class:`objects.Perc` stat (:pr:`3063`).\n \n-- |Feature| The :class:`Band` and :class:`Range` marks will now cover the full extent of the data if `min` / `max` variables are not explicitly assigned or added in a transform (:pr:`3056`).\n+- |Feature| The :class:`objects.Band` and :class:`objects.Range` marks will now cover the full extent of the data if `min` / `max` variables are not explicitly assigned or added in a transform (:pr:`3056`).\n \n-- |Enhancement| The :class:`Jitter` move now applies a small amount of jitter by default (:pr:`3066`).\n+- |Enhancement| |Defaults| The :class:`objects.Jitter` move now applies a small amount of jitter by default (:pr:`3066`).\n \n-- |Enhancement| Marks that sort along the orient axis (e.g. :class:`Line`) now use a stable algorithm (:pr:`3064`).\n+- |Enhancement| |Defaults| Axes with a :class:`objects.Nominal` scale now appear like categorical axes in class seaborn, with fixed margins, no grid, and an inverted y axis (:pr:`3069`).\n+\n+- |Enhancement| Marks that sort along the orient axis (e.g. :class:`objects.Line`) now use a stable algorithm (:pr:`3064`).\n \n - |Fix| Make :class:`objects.PolyFit` robust to missing data (:pr:`3010`).\n \ndiff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 4f0290a494..bfe612a1f5 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -25,7 +25,7 @@\n from seaborn._stats.base import Stat\n from seaborn._core.data import PlotData\n from seaborn._core.moves import Move\n-from seaborn._core.scales import Scale\n+from seaborn._core.scales import Scale, Nominal\n from seaborn._core.subplots import Subplots\n from seaborn._core.groupby import GroupBy\n from seaborn._core.properties import PROPERTIES, Property\n@@ -1238,7 +1238,6 @@ def _setup_scales(\n             # This only affects us when sharing *paired* axes. This is a novel/niche\n             # behavior, so we will raise rather than hack together a workaround.\n             if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):\n-                from seaborn._core.scales import Nominal\n                 paired_axis = axis in p._pair_spec.get(\"structure\", {})\n                 cat_scale = isinstance(scale, Nominal)\n                 ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]\n@@ -1631,6 +1630,7 @@ def _finalize_figure(self, p: Plot) -> None:\n             ax = sub[\"ax\"]\n             for axis in \"xy\":\n                 axis_key = sub[axis]\n+                axis_obj = getattr(ax, f\"{axis}axis\")\n \n                 # Axis limits\n                 if axis_key in p._limits:\n@@ -1644,6 +1644,17 @@ def _finalize_figure(self, p: Plot) -> None:\n                         hi = cast(float, hi) + 0.5\n                     ax.set(**{f\"{axis}lim\": (lo, hi)})\n \n+                # Nominal scale special-casing\n+                if isinstance(self._scales.get(axis_key), Nominal):\n+                    axis_obj.grid(False, which=\"both\")\n+                    if axis_key not in p._limits:\n+                        nticks = len(axis_obj.get_major_ticks())\n+                        lo, hi = -.5, nticks - .5\n+                        if axis == \"y\":\n+                            lo, hi = hi, lo\n+                        set_lim = getattr(ax, f\"set_{axis}lim\")\n+                        set_lim(lo, hi, auto=None)\n+\n         engine_default = None if p._target is not None else \"tight\"\n         layout_engine = p._layout_spec.get(\"engine\", engine_default)\n         set_layout_engine(self._figure, layout_engine)\ndiff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex 03a64917f3..e855aef9e6 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -645,6 +645,28 @@ def test_undefined_variable_raises(self):\n         with pytest.raises(RuntimeError, match=err):\n             p.plot()\n \n+    def test_nominal_x_axis_tweaks(self):\n+\n+        p = Plot(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3])\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_xlim() == (-.5, 2.5)\n+        assert not any(x.get_visible() for x in ax1.xaxis.get_gridlines())\n+\n+        lim = (-1, 2.1)\n+        ax2 = p.limit(x=lim).plot()._figure.axes[0]\n+        assert ax2.get_xlim() == lim\n+\n+    def test_nominal_y_axis_tweaks(self):\n+\n+        p = Plot(x=[1, 2, 3], y=[\"a\", \"b\", \"c\"])\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_ylim() == (2.5, -.5)\n+        assert not any(y.get_visible() for y in ax1.yaxis.get_gridlines())\n+\n+        lim = (-1, 2.1)\n+        ax2 = p.limit(y=lim).plot()._figure.axes[0]\n+        assert ax2.get_ylim() == lim\n+\n \n class TestPlotting:\n \n", "gold_standard_pr_link": "https://github.com/mwaskom/seaborn/pull/3069"}