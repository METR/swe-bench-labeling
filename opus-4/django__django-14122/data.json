{"instance_id": "django__django-14122", "score": "I", "diff": "diff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..165f7fd5ea\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,84 @@\n+import os\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'django.conf.global_settings'\n+\n+import django\n+from django.conf import settings\n+from django.db import connection\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Count\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+\n+    class Meta:\n+        ordering = ['age']\n+        app_label = 'test_app'\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+\n+# Create test data\n+author1 = Author.objects.create(name=\"John\", age=25)\n+author2 = Author.objects.create(name=\"John\", age=30)\n+author3 = Author.objects.create(name=\"Jane\", age=35)\n+\n+Book.objects.create(title=\"Book 1\", author=author1)\n+Book.objects.create(title=\"Book 2\", author=author1)\n+Book.objects.create(title=\"Book 3\", author=author2)\n+Book.objects.create(title=\"Book 4\", author=author3)\n+\n+# Test the issue\n+print(\"Testing Meta.ordering in GROUP BY issue...\")\n+result = list(Author.objects.values('name').annotate(book_count=Count('books')))\n+print(f\"Query results: {result}\")\n+print(f\"Number of results: {len(result)}\")\n+\n+# Check the actual SQL\n+from django.db import connection\n+qs = Author.objects.values('name').annotate(book_count=Count('books'))\n+sql, params = qs.query.get_compiler('default').as_sql()\n+print(f\"\\nGenerated SQL:\\n{sql}\")\n+print(f\"Params: {params}\")\n+\n+# Expected: 2 results - John with 3 books, Jane with 1 book\n+# But if age is in GROUP BY, we'll get 3 results (John/25, John/30, Jane/35)\n+if len(result) == 3:\n+    print(\"\\nBUG CONFIRMED: Meta.ordering field 'age' is included in GROUP BY!\")\n+    print(\"This causes incorrect aggregation - John's books are split by age.\")\n+elif len(result) == 2:\n+    print(\"\\nGood: Meta.ordering is not affecting GROUP BY.\")\n+    john_count = sum(r['book_count'] for r in result if r['name'] == 'John')\n+    jane_count = sum(r['book_count'] for r in result if r['name'] == 'Jane')\n+    print(f\"John has {john_count} books, Jane has {jane_count} books\")\ndiff --git a/test_meta_ordering_group_by.py b/test_meta_ordering_group_by.py\nnew file mode 100644\nindex 0000000000..0eefa56cb5\n--- /dev/null\n+++ b/test_meta_ordering_group_by.py\n@@ -0,0 +1,112 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Count\n+from django.test import TestCase\n+\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+\n+    class Meta:\n+        ordering = ['age']\n+        app_label = 'test_app'\n+\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class MetaOrderingGroupByTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create authors with same name but different ages\n+        author1 = Author.objects.create(name=\"John\", age=25)\n+        author2 = Author.objects.create(name=\"John\", age=30)\n+        author3 = Author.objects.create(name=\"Jane\", age=35)\n+        \n+        # Create books\n+        Book.objects.create(title=\"Book 1\", author=author1)\n+        Book.objects.create(title=\"Book 2\", author=author1)\n+        Book.objects.create(title=\"Book 3\", author=author2)\n+        Book.objects.create(title=\"Book 4\", author=author3)\n+    \n+    def test_meta_ordering_not_in_group_by(self):\n+        # Test that Meta.ordering fields are not included in GROUP BY\n+        # This should group by author name only, not by age\n+        result = Author.objects.values('name').annotate(book_count=Count('book'))\n+        \n+        # Expected: 2 results - John with 3 books, Jane with 1 book\n+        self.assertEqual(len(result), 2)\n+        \n+        john_result = [r for r in result if r['name'] == 'John'][0]\n+        jane_result = [r for r in result if r['name'] == 'Jane'][0]\n+        \n+        self.assertEqual(john_result['book_count'], 3)\n+        self.assertEqual(jane_result['book_count'], 1)\n+        \n+        # Check the SQL to ensure 'age' is not in GROUP BY\n+        qs = Author.objects.values('name').annotate(book_count=Count('book'))\n+        sql = str(qs.query)\n+        print(\"Generated SQL:\", sql)\n+        \n+        # The GROUP BY clause should only contain the 'name' field, not 'age'\n+        # Even though Meta.ordering includes 'age'\n+        self.assertNotIn('age', sql.lower().split('group by')[1].split('order by')[0])\n+\n+\n+if __name__ == '__main__':\n+    import django\n+    from django.conf import settings\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=False,\n+    )\n+    \n+    django.setup()\n+    \n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Author)\n+        schema_editor.create_model(Book)\n+    \n+    # Run the test\n+    test = MetaOrderingGroupByTest()\n+    test.setUpTestData()\n+    test.test_meta_ordering_not_in_group_by()\n+    print(\"Test passed!\")\ndiff --git a/test_simple.py b/test_simple.py\nnew file mode 100644\nindex 0000000000..3cd429c6a9\n--- /dev/null\n+++ b/test_simple.py\n@@ -0,0 +1,112 @@\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+import django\n+from django.conf import settings\n+\n+# Configure Django\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',  \n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'testapp',\n+    ],\n+    SECRET_KEY='test',\n+)\n+\n+# Setup Django\n+django.setup()\n+\n+# Now we can use Django ORM\n+from django.db import models, connection\n+from django.db.models import Count\n+\n+# Create app directory if it doesn't exist\n+import tempfile\n+temp_dir = tempfile.mkdtemp()\n+sys.path.insert(0, temp_dir)\n+\n+# Create testapp module\n+os.makedirs(os.path.join(temp_dir, 'testapp'), exist_ok=True)\n+with open(os.path.join(temp_dir, 'testapp', '__init__.py'), 'w') as f:\n+    f.write('')\n+\n+# Write models to file\n+models_content = '''\n+from django.db import models\n+\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+    \n+    class Meta:\n+        ordering = ['age']\n+        app_label = 'testapp'\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'testapp'\n+'''\n+\n+with open(os.path.join(temp_dir, 'testapp', 'models.py'), 'w') as f:\n+    f.write(models_content)\n+\n+# Import models\n+from testapp.models import Author, Book\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+\n+# Create test data\n+print(\"Creating test data...\")\n+author1 = Author.objects.create(name=\"John\", age=25)\n+author2 = Author.objects.create(name=\"John\", age=30)\n+author3 = Author.objects.create(name=\"Jane\", age=35)\n+\n+Book.objects.create(title=\"Book 1\", author=author1)\n+Book.objects.create(title=\"Book 2\", author=author1)\n+Book.objects.create(title=\"Book 3\", author=author2) \n+Book.objects.create(title=\"Book 4\", author=author3)\n+\n+# Test the issue\n+print(\"\\nTesting Meta.ordering in GROUP BY issue...\")\n+qs = Author.objects.values('name').annotate(book_count=Count('books'))\n+sql, params = qs.query.get_compiler('default').as_sql()\n+print(f\"\\nGenerated SQL:\\n{sql}\")\n+print(f\"Params: {params}\")\n+\n+# Check if 'age' appears in GROUP BY\n+if 'age' in sql.lower().split('group by')[1].split('order by')[0]:\n+    print(\"\\nBUG CONFIRMED: Meta.ordering field 'age' is included in GROUP BY!\")\n+else:\n+    print(\"\\nNo 'age' field found in GROUP BY clause\")\n+\n+result = list(qs)\n+print(f\"\\nQuery results: {result}\")\n+print(f\"Number of results: {len(result)}\")\n+\n+# Expected: 2 results - John with 3 books, Jane with 1 book\n+# But if age is in GROUP BY, we'll get 3 results\n+if len(result) == 3:\n+    print(\"\\nBUG CONFIRMED by results: Meta.ordering field 'age' is incorrectly included in GROUP BY!\")\n+    print(\"This causes incorrect aggregation - John's books are split by age.\")\n+    for r in result:\n+        print(f\"  {r}\")\n+elif len(result) == 2:\n+    print(\"\\nGood: Meta.ordering is not affecting GROUP BY.\")\n+    john_count = sum(r['book_count'] for r in result if r['name'] == 'John')\n+    jane_count = sum(r['book_count'] for r in result if r['name'] == 'Jane')\n+    print(f\"John has {john_count} books, Jane has {jane_count} books\")\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d7e..f02199d97ca1 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -125,11 +125,12 @@ def get_group_by(self, select, order_by):\n             cols = expr.get_group_by_cols()\n             for col in cols:\n                 expressions.append(col)\n-        for expr, (sql, params, is_ref) in order_by:\n-            # Skip References to the select clause, as all expressions in the\n-            # select clause are already part of the group by.\n-            if not is_ref:\n-                expressions.extend(expr.get_group_by_cols())\n+        if not self._meta_ordering:\n+            for expr, (sql, params, is_ref) in order_by:\n+                # Skip references to the SELECT clause, as all expressions in\n+                # the SELECT clause are already part of the GROUP BY.\n+                if not is_ref:\n+                    expressions.extend(expr.get_group_by_cols())\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\ndiff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex c8e9c98e437d..604c72c1a21e 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -2,7 +2,7 @@\n from operator import attrgetter\n \n from django.db.models import (\n-    CharField, DateTimeField, F, Max, OuterRef, Subquery, Value,\n+    CharField, Count, DateTimeField, F, Max, OuterRef, Subquery, Value,\n )\n from django.db.models.functions import Upper\n from django.test import TestCase\n@@ -484,3 +484,12 @@ def test_order_by_ptr_field_with_default_ordering_by_expression(self):\n         ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n         articles = ChildArticle.objects.order_by('article_ptr')\n         self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n+    def test_default_ordering_does_not_affect_group_by(self):\n+        Article.objects.exclude(headline='Article 4').update(author=self.author_1)\n+        Article.objects.filter(headline='Article 4').update(author=self.author_2)\n+        articles = Article.objects.values('author').annotate(count=Count('author'))\n+        self.assertCountEqual(articles, [\n+            {'author': self.author_1.pk, 'count': 3},\n+            {'author': self.author_2.pk, 'count': 1},\n+        ])\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14122"}