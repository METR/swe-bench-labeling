{"instance_id": "pydata__xarray-7393", "score": "C", "diff": "diff --git a/test_stack_dtype_preservation.py b/test_stack_dtype_preservation.py\nnew file mode 100644\nindex 00000000..2f5d9b29\n--- /dev/null\n+++ b/test_stack_dtype_preservation.py\n@@ -0,0 +1,37 @@\n+\"\"\"Test that stack preserves coordinate dtypes\"\"\"\n+import xarray as xr\n+import numpy as np\n+\n+\n+def test_stack_preserves_dtype():\n+    \"\"\"Test that stacking preserves the dtype of coordinates\"\"\"\n+    # Test with int32\n+    ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})\n+    stacked = ds.stack(b=('a',))\n+    assert ds['a'].values.dtype == stacked['a'].values.dtype, \\\n+        f\"Expected {ds['a'].values.dtype}, got {stacked['a'].values.dtype}\"\n+    \n+    # Test with various dtypes\n+    for dtype in ['i1', 'i2', 'i4', 'i8', 'u1', 'u2', 'u4', 'u8', 'f4', 'f8']:\n+        arr = np.array([0, 1, 2], dtype=dtype)\n+        ds = xr.Dataset(coords={'a': arr})\n+        stacked = ds.stack(b=('a',))\n+        original_dtype = ds['a'].values.dtype\n+        stacked_dtype = stacked['a'].values.dtype\n+        assert original_dtype == stacked_dtype, \\\n+            f\"dtype {dtype}: Expected {original_dtype}, got {stacked_dtype}\"\n+    \n+    # Test with 2D stacking\n+    ds = xr.Dataset(coords={\n+        'x': np.array([0, 1], dtype='i4'),\n+        'y': np.array([10, 20, 30], dtype='i2')\n+    })\n+    stacked = ds.stack(z=('x', 'y'))\n+    assert ds['x'].values.dtype == stacked['x'].values.dtype\n+    assert ds['y'].values.dtype == stacked['y'].values.dtype\n+    \n+    print(\"All tests passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_stack_preserves_dtype()\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex ba937183..704b239a 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -1532,7 +1532,9 @@ class PandasMultiIndexingAdapter(PandasIndexingAdapter):\n \n     def __array__(self, dtype: DTypeLike = None) -> np.ndarray:\n         if self.level is not None:\n-            return self.array.get_level_values(self.level).values\n+            if dtype is None:\n+                dtype = self.dtype\n+            return np.asarray(self.array.get_level_values(self.level).values, dtype=dtype)\n         else:\n             return super().__array__(dtype)\n \n@@ -1568,7 +1570,7 @@ class PandasMultiIndexingAdapter(PandasIndexingAdapter):\n         else:\n             subset = self\n \n-        return np.asarray(subset)\n+        return np.asarray(subset, dtype=self.dtype)\n \n     def _repr_inline_(self, max_width: int) -> str:\n         from xarray.core.formatting import format_array_flat\n", "gold_standard_diff": "diff --git a/doc/whats-new.rst b/doc/whats-new.rst\nindex cd5ecd83978..0b7fc87201b 100644\n--- a/doc/whats-new.rst\n+++ b/doc/whats-new.rst\n@@ -45,6 +45,8 @@ Bug fixes\n - add a ``keep_attrs`` parameter to :py:meth:`Dataset.pad`, :py:meth:`DataArray.pad`,\n   and :py:meth:`Variable.pad` (:pull:`7267`).\n   By `Justus Magin <https://github.com/keewis>`_.\n+- Preserve original dtype on accessing MultiIndex levels (:issue:`7250`,\n+  :pull:`7393`). By `Ian Carroll <https://github.com/itcarroll>`_.\n \n Documentation\n ~~~~~~~~~~~~~\ndiff --git a/xarray/core/indexing.py b/xarray/core/indexing.py\nindex ba937183d24..e49a072df1d 100644\n--- a/xarray/core/indexing.py\n+++ b/xarray/core/indexing.py\n@@ -1531,8 +1531,12 @@ def __init__(\n         self.level = level\n \n     def __array__(self, dtype: DTypeLike = None) -> np.ndarray:\n+        if dtype is None:\n+            dtype = self.dtype\n         if self.level is not None:\n-            return self.array.get_level_values(self.level).values\n+            return np.asarray(\n+                self.array.get_level_values(self.level).values, dtype=dtype\n+            )\n         else:\n             return super().__array__(dtype)\n \ndiff --git a/xarray/tests/test_indexes.py b/xarray/tests/test_indexes.py\nindex 3ecfa73cc89..caf0f51135e 100644\n--- a/xarray/tests/test_indexes.py\n+++ b/xarray/tests/test_indexes.py\n@@ -697,3 +697,10 @@ def test_safe_cast_to_index_datetime_datetime():\n     actual = safe_cast_to_index(np.array(dates))\n     assert_array_equal(expected, actual)\n     assert isinstance(actual, pd.Index)\n+\n+\n+@pytest.mark.parametrize(\"dtype\", [\"int32\", \"float32\"])\n+def test_restore_dtype_on_multiindexes(dtype: str) -> None:\n+    foo = xr.Dataset(coords={\"bar\": (\"bar\", np.array([0, 1], dtype=dtype))})\n+    foo = foo.stack(baz=(\"bar\",))\n+    assert str(foo[\"bar\"].values.dtype) == dtype\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/7393"}