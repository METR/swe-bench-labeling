{"instance_id": "sympy__sympy-20590", "score": "C", "diff": "diff --git a/sympy/core/_print_helpers.py b/sympy/core/_print_helpers.py\nindex 96d7e72676..17098678ee 100644\n--- a/sympy/core/_print_helpers.py\n+++ b/sympy/core/_print_helpers.py\n@@ -16,6 +16,8 @@ class Printable:\n \n     This also adds support for LaTeX printing in jupyter notebooks.\n     \"\"\"\n+    \n+    __slots__ = ()\n \n     # Note, we always use the default ordering (lex) in __str__ and __repr__,\n     # regardless of the global setting. See issue 5487.\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..2d1fbd3cc5\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,60 @@\n+import sympy\n+from sympy import Symbol, Add, Mul, sin, cos, exp, log, sqrt\n+from sympy.abc import x, y, z\n+\n+print(\"Testing Symbol behavior after adding __slots__ to Printable...\")\n+\n+# Test 1: Ensure Symbol doesn't have __dict__\n+s = Symbol('s')\n+assert not hasattr(s, '__dict__'), \"Symbol should not have __dict__\"\n+print(\"\u2713 Test 1 passed: Symbol doesn't have __dict__\")\n+\n+# Test 2: Ensure Symbol still has its expected attributes\n+assert hasattr(s, 'name'), \"Symbol should have 'name' attribute\"\n+assert s.name == 's', \"Symbol name should be 's'\"\n+print(\"\u2713 Test 2 passed: Symbol attributes work correctly\")\n+\n+# Test 3: Test Symbol creation with assumptions\n+s_real = Symbol('s', real=True)\n+assert s_real.is_real, \"Symbol with real=True should be real\"\n+assert not hasattr(s_real, '__dict__'), \"Real Symbol should not have __dict__\"\n+print(\"\u2713 Test 3 passed: Symbol with assumptions works correctly\")\n+\n+# Test 4: Test printing functionality (which is provided by Printable)\n+assert str(s) == 's', \"String representation should work\"\n+assert repr(s) == 's', \"Repr should work\"\n+print(\"\u2713 Test 4 passed: Printing functionality works\")\n+\n+# Test 5: Test LaTeX printing\n+latex_repr = s._repr_latex_()\n+assert latex_repr == '$\\\\displaystyle s$', f\"LaTeX representation incorrect: {latex_repr}\"\n+print(\"\u2713 Test 5 passed: LaTeX printing works\")\n+\n+# Test 6: Test other SymPy objects that inherit from Printable\n+expr = x + y + z\n+assert not hasattr(expr, '__dict__'), \"Add expression should not have __dict__\"\n+print(\"\u2713 Test 6 passed: Add expression doesn't have __dict__\")\n+\n+# Test 7: Test complex expressions\n+complex_expr = sin(x) * cos(y) + exp(z) * log(x)\n+assert not hasattr(complex_expr, '__dict__'), \"Complex expression should not have __dict__\"\n+print(\"\u2713 Test 7 passed: Complex expressions don't have __dict__\")\n+\n+# Test 8: Test mathematical operations\n+result = s + s\n+assert result == 2*s, \"Addition should work\"\n+assert not hasattr(result, '__dict__'), \"Result should not have __dict__\"\n+print(\"\u2713 Test 8 passed: Mathematical operations work correctly\")\n+\n+# Test 9: Test substitution\n+expr = x**2 + 2*x + 1\n+result = expr.subs(x, 5)\n+assert result == 36, \"Substitution should work\"\n+print(\"\u2713 Test 9 passed: Substitution works correctly\")\n+\n+# Test 10: Test differentiation\n+diff_result = expr.diff(x)\n+assert diff_result == 2*x + 2, \"Differentiation should work\"\n+print(\"\u2713 Test 10 passed: Differentiation works correctly\")\n+\n+print(\"\\nAll tests passed! The fix doesn't break existing functionality.\")\ndiff --git a/test_issue_fix.py b/test_issue_fix.py\nnew file mode 100644\nindex 0000000000..dfc3eb0524\n--- /dev/null\n+++ b/test_issue_fix.py\n@@ -0,0 +1,45 @@\n+\"\"\"\n+Test for the specific issue reported:\n+In version 1.6.2 Symbol instances had no `__dict__` attribute.\n+This changed in 1.7 where Symbol('s').__dict__ existed (empty dict).\n+This fix should restore the 1.6.2 behavior.\n+\"\"\"\n+import sympy\n+\n+# Test the exact scenario from the issue\n+s = sympy.Symbol('s')\n+\n+# This should raise AttributeError like in 1.6.2\n+try:\n+    _ = s.__dict__\n+    print(\"FAILED: Symbol.__dict__ exists (it shouldn't)\")\n+except AttributeError:\n+    print(\"PASSED: Symbol object has no attribute '__dict__' (expected behavior)\")\n+\n+# Verify __slots__ is still there\n+print(f\"Symbol.__slots__ = {s.__slots__}\")\n+\n+# Also check various symbol types\n+symbols_to_test = [\n+    sympy.Symbol('x'),\n+    sympy.Symbol('y', real=True),\n+    sympy.Symbol('z', positive=True),\n+    sympy.Symbol('w', integer=True),\n+    sympy.symbols('a:d'),  # multiple symbols\n+]\n+\n+all_good = True\n+for sym in symbols_to_test:\n+    if isinstance(sym, (list, tuple)):\n+        for s in sym:\n+            if hasattr(s, '__dict__'):\n+                print(f\"FAILED: {s} has __dict__\")\n+                all_good = False\n+    else:\n+        if hasattr(sym, '__dict__'):\n+            print(f\"FAILED: {sym} has __dict__\")\n+            all_good = False\n+\n+if all_good:\n+    print(\"\\nAll Symbol instances correctly have no __dict__ attribute!\")\n+    print(\"The issue has been fixed.\")\ndiff --git a/test_other_printables.py b/test_other_printables.py\nnew file mode 100644\nindex 0000000000..9e90fec6f0\n--- /dev/null\n+++ b/test_other_printables.py\n@@ -0,0 +1,20 @@\n+import sympy\n+from sympy.physics.vector import Vector\n+from sympy.physics.vector import ReferenceFrame\n+from sympy.tensor.array import Array\n+\n+print(\"Testing other classes that inherit from Printable...\")\n+\n+# Test Vector\n+N = ReferenceFrame('N')\n+v = 3*N.x + 4*N.y + 5*N.z\n+print(f\"Vector: {v}\")\n+print(f\"Vector has __dict__: {hasattr(v, '__dict__')}\")\n+\n+# Test Array\n+arr = Array([1, 2, 3, 4])\n+print(f\"\\nArray: {arr}\")\n+print(f\"Array has __dict__: {hasattr(arr, '__dict__')}\")\n+\n+# Note: We expect Vector and Array might have __dict__ if they or their\n+# parent classes don't define __slots__, but Basic-derived classes shouldn't\ndiff --git a/test_symbol_dict.py b/test_symbol_dict.py\nnew file mode 100644\nindex 0000000000..146bb0926b\n--- /dev/null\n+++ b/test_symbol_dict.py\n@@ -0,0 +1,17 @@\n+import sympy\n+\n+# Test if Symbol has __dict__\n+s = sympy.Symbol('s')\n+print(\"Symbol('s') has __dict__:\", hasattr(s, '__dict__'))\n+print(\"Symbol('s').__slots__:\", s.__slots__)\n+\n+# Try to access __dict__\n+try:\n+    print(\"Symbol('s').__dict__:\", s.__dict__)\n+except AttributeError as e:\n+    print(\"AttributeError when accessing __dict__:\", e)\n+\n+# Check parent classes\n+print(\"\\nChecking parent classes for __slots__:\")\n+for cls in sympy.Symbol.__mro__:\n+    print(f\"{cls.__name__}: __slots__ = {getattr(cls, '__slots__', 'NOT DEFINED')}\")\n", "gold_standard_diff": "diff --git a/sympy/core/_print_helpers.py b/sympy/core/_print_helpers.py\nindex 96d7e72676f2..d704ed220d44 100644\n--- a/sympy/core/_print_helpers.py\n+++ b/sympy/core/_print_helpers.py\n@@ -17,6 +17,11 @@ class Printable:\n     This also adds support for LaTeX printing in jupyter notebooks.\n     \"\"\"\n \n+    # Since this class is used as a mixin we set empty slots. That means that\n+    # instances of any subclasses that use slots will not need to have a\n+    # __dict__.\n+    __slots__ = ()\n+\n     # Note, we always use the default ordering (lex) in __str__ and __repr__,\n     # regardless of the global setting. See issue 5487.\n     def __str__(self):\ndiff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex faa27b9f2236..09947a0b1c10 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -34,6 +34,12 @@ def test_structure():\n     assert bool(b1)\n \n \n+def test_immutable():\n+    assert not hasattr(b1, '__dict__')\n+    with raises(AttributeError):\n+        b1.x = 1\n+\n+\n def test_equality():\n     instances = [b1, b2, b3, b21, Basic(b1, b1, b1), Basic]\n     for i, b_i in enumerate(instances):\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/20590"}