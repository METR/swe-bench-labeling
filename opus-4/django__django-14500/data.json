{"instance_id": "django__django-14500", "score": "C", "diff": "diff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 57042a8690..db02948772 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -277,6 +277,10 @@ class MigrationExecutor:\n             all_applied = all(m in applied for m in migration.replaces)\n             if all_applied and key not in applied:\n                 self.recorder.record_applied(*key)\n+            elif not all_applied and key in applied:\n+                # If not all replaced migrations are applied, the squashed\n+                # migration should not be marked as applied either.\n+                self.recorder.record_unapplied(*key)\n \n     def detect_soft_applied(self, project_state, migration):\n         \"\"\"\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..4e77c461bd\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,87 @@\n+\"\"\"\n+Test edge cases for the squashed migration fix\n+\"\"\"\n+import os\n+import django\n+from django.conf import settings\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[],\n+    USE_TZ=True,\n+    MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"}\n+)\n+\n+django.setup()\n+\n+def test_edge_cases():\n+    recorder = MigrationRecorder(connection)\n+    executor = MigrationExecutor(connection)\n+    \n+    print(\"Test 1: Apply squashed migration directly when all replaced are applied\")\n+    # Apply both replaced migrations\n+    recorder.record_applied(\"migrations\", \"0001_initial\")\n+    recorder.record_applied(\"migrations\", \"0002_second\")\n+    \n+    # Create new executor to reload state\n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    # Verify squashed migration is marked as applied\n+    applied = recorder.applied_migrations()\n+    assert (\"migrations\", \"0001_squashed_0002\") in applied\n+    print(\"\u2713 Squashed migration is marked as applied when all replaced are applied\")\n+    \n+    # Now unapply the squashed migration directly\n+    recorder.record_unapplied(\"migrations\", \"0001_squashed_0002\")\n+    \n+    # Create new executor and check replacements\n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    # The squashed migration should remain unapplied since we explicitly unapplied it\n+    applied = recorder.applied_migrations()\n+    assert (\"migrations\", \"0001_squashed_0002\") not in applied\n+    print(\"\u2713 Squashed migration remains unapplied after explicit unapply\")\n+    \n+    print(\"\\nTest 2: Ensure squashed migration isn't re-applied if explicitly unapplied\")\n+    # All replaced are still applied\n+    assert (\"migrations\", \"0001_initial\") in applied\n+    assert (\"migrations\", \"0002_second\") in applied\n+    \n+    # Run check_replacements again\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    # Should not re-apply the squashed migration\n+    assert (\"migrations\", \"0001_squashed_0002\") not in applied\n+    print(\"\u2713 Squashed migration is not re-applied automatically\")\n+    \n+    print(\"\\nTest 3: Re-apply squashed migration explicitly\")\n+    recorder.record_applied(\"migrations\", \"0001_squashed_0002\")\n+    \n+    # Now unapply one replaced migration\n+    recorder.record_unapplied(\"migrations\", \"0002_second\")\n+    \n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    # Squashed migration should be unapplied since not all replaced are applied\n+    assert (\"migrations\", \"0001_squashed_0002\") not in applied\n+    print(\"\u2713 Squashed migration is unapplied when not all replaced are applied\")\n+    \n+    print(\"\\nAll edge case tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_edge_cases()\ndiff --git a/test_squashed_migration_unapply.py b/test_squashed_migration_unapply.py\nnew file mode 100644\nindex 0000000000..c9bb675edb\n--- /dev/null\n+++ b/test_squashed_migration_unapply.py\n@@ -0,0 +1,77 @@\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase\n+from django.test.utils import override_settings\n+\n+\n+@override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+class TestSquashedMigrationUnapply(TestCase):\n+    \"\"\"\n+    Test that squashed migrations are properly marked as unapplied when\n+    their replaced migrations are unapplied.\n+    \"\"\"\n+\n+    def test_unapply_replaced_migration_marks_squash_as_unapplied(self):\n+        recorder = MigrationRecorder(connection)\n+        executor = MigrationExecutor(connection)\n+        \n+        # Apply both replaced migrations\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements to mark squashed migration as applied\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Verify squashed migration is marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        \n+        # Now unapply one of the replaced migrations\n+        recorder.record_unapplied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements again \n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # The squashed migration should now be marked as unapplied\n+        applied = recorder.applied_migrations()\n+        self.assertNotIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        self.assertIn((\"migrations\", \"0001_initial\"), applied)\n+        self.assertNotIn((\"migrations\", \"0002_second\"), applied)\n+        \n+    def test_reapply_replaced_migration_marks_squash_as_applied(self):\n+        recorder = MigrationRecorder(connection)\n+        executor = MigrationExecutor(connection)\n+        \n+        # Apply only one replaced migration\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        \n+        # Run check_replacements\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Squashed migration should not be marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertNotIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        \n+        # Apply the second replaced migration\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements again\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Now the squashed migration should be marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+\n+\n+if __name__ == \"__main__\":\n+    from django.test.utils import setup_test_environment\n+    setup_test_environment()\n+    test = TestSquashedMigrationUnapply()\n+    test.test_unapply_replaced_migration_marks_squash_as_unapplied()\n+    test.test_reapply_replaced_migration_marks_squash_as_applied()\n+    print(\"All tests passed!\")\ndiff --git a/test_squashed_unapply.py b/test_squashed_unapply.py\nnew file mode 100644\nindex 0000000000..fc98472ffd\n--- /dev/null\n+++ b/test_squashed_unapply.py\n@@ -0,0 +1,66 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Create a test to demonstrate the issue\n+def test_squashed_migration_unapply():\n+    recorder = MigrationRecorder(connection)\n+    \n+    # Simulate having both replaced migrations applied\n+    recorder.record_applied(\"migrations\", \"0001_initial\")\n+    recorder.record_applied(\"migrations\", \"0002_second\")\n+    \n+    # Create executor and run check_replacements to mark squashed migration as applied\n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    # Verify squashed migration is marked as applied\n+    applied = recorder.applied_migrations()\n+    print(\"Applied migrations after check_replacements:\")\n+    for m in sorted(applied):\n+        print(f\"  {m}\")\n+    \n+    # Now unapply one of the replaced migrations\n+    recorder.record_unapplied(\"migrations\", \"0002_second\")\n+    \n+    # Check what's marked as applied now\n+    applied = recorder.applied_migrations()\n+    print(\"\\nApplied migrations after unapplying 0002_second:\")\n+    for m in sorted(applied):\n+        print(f\"  {m}\")\n+    \n+    # Run check_replacements again to see if it updates the squashed migration status\n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    print(\"\\nApplied migrations after second check_replacements:\")\n+    for m in sorted(applied):\n+        print(f\"  {m}\")\n+    \n+    # The issue: squashed migration should NOT be marked as applied when its replaced\n+    # migrations are not all applied, but currently it remains marked as applied\n+\n+if __name__ == \"__main__\":\n+    test_squashed_migration_unapply()\ndiff --git a/tests/migrations/test_squashed_unapply.py b/tests/migrations/test_squashed_unapply.py\nnew file mode 100644\nindex 0000000000..c9bb675edb\n--- /dev/null\n+++ b/tests/migrations/test_squashed_unapply.py\n@@ -0,0 +1,77 @@\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+from django.test import TestCase\n+from django.test.utils import override_settings\n+\n+\n+@override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations_squashed\"})\n+class TestSquashedMigrationUnapply(TestCase):\n+    \"\"\"\n+    Test that squashed migrations are properly marked as unapplied when\n+    their replaced migrations are unapplied.\n+    \"\"\"\n+\n+    def test_unapply_replaced_migration_marks_squash_as_unapplied(self):\n+        recorder = MigrationRecorder(connection)\n+        executor = MigrationExecutor(connection)\n+        \n+        # Apply both replaced migrations\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements to mark squashed migration as applied\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Verify squashed migration is marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        \n+        # Now unapply one of the replaced migrations\n+        recorder.record_unapplied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements again \n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # The squashed migration should now be marked as unapplied\n+        applied = recorder.applied_migrations()\n+        self.assertNotIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        self.assertIn((\"migrations\", \"0001_initial\"), applied)\n+        self.assertNotIn((\"migrations\", \"0002_second\"), applied)\n+        \n+    def test_reapply_replaced_migration_marks_squash_as_applied(self):\n+        recorder = MigrationRecorder(connection)\n+        executor = MigrationExecutor(connection)\n+        \n+        # Apply only one replaced migration\n+        recorder.record_applied(\"migrations\", \"0001_initial\")\n+        \n+        # Run check_replacements\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Squashed migration should not be marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertNotIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+        \n+        # Apply the second replaced migration\n+        recorder.record_applied(\"migrations\", \"0002_second\")\n+        \n+        # Run check_replacements again\n+        executor = MigrationExecutor(connection)  # Reload to get fresh state\n+        executor.check_replacements()\n+        \n+        # Now the squashed migration should be marked as applied\n+        applied = recorder.applied_migrations()\n+        self.assertIn((\"migrations\", \"0001_squashed_0002\"), applied)\n+\n+\n+if __name__ == \"__main__\":\n+    from django.test.utils import setup_test_environment\n+    setup_test_environment()\n+    test = TestSquashedMigrationUnapply()\n+    test.test_unapply_replaced_migration_marks_squash_as_unapplied()\n+    test.test_reapply_replaced_migration_marks_squash_as_applied()\n+    print(\"All tests passed!\")\ndiff --git a/verify_fix.py b/verify_fix.py\nnew file mode 100644\nindex 0000000000..6160f93428\n--- /dev/null\n+++ b/verify_fix.py\n@@ -0,0 +1,58 @@\n+\"\"\"\n+Verify the fix works correctly\n+\"\"\"\n+import os\n+import sys\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tests.migrations.test_settings')\n+\n+import django\n+django.setup()\n+\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.recorder import MigrationRecorder\n+\n+def test_fix():\n+    # Clean up any existing migration records\n+    recorder = MigrationRecorder(connection)\n+    with connection.cursor() as cursor:\n+        cursor.execute(\"DELETE FROM django_migrations WHERE app = 'migrations'\")\n+    \n+    print(\"Test 1: Normal case - all replaced migrations applied\")\n+    recorder.record_applied(\"migrations\", \"0001_initial\")\n+    recorder.record_applied(\"migrations\", \"0002_second\")\n+    \n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    squashed_applied = (\"migrations\", \"0001_squashed_0002\") in applied\n+    print(f\"  - Squashed migration applied: {squashed_applied}\")\n+    assert squashed_applied, \"Squashed migration should be applied when all replaced are applied\"\n+    \n+    print(\"\\nTest 2: Unapply one replaced migration\")\n+    recorder.record_unapplied(\"migrations\", \"0002_second\")\n+    \n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    squashed_applied = (\"migrations\", \"0001_squashed_0002\") in applied\n+    print(f\"  - Squashed migration applied: {squashed_applied}\")\n+    assert not squashed_applied, \"Squashed migration should NOT be applied when not all replaced are applied\"\n+    \n+    print(\"\\nTest 3: Re-apply the unapplied migration\")\n+    recorder.record_applied(\"migrations\", \"0002_second\")\n+    \n+    executor = MigrationExecutor(connection)\n+    executor.check_replacements()\n+    \n+    applied = recorder.applied_migrations()\n+    squashed_applied = (\"migrations\", \"0001_squashed_0002\") in applied\n+    print(f\"  - Squashed migration applied: {squashed_applied}\")\n+    assert squashed_applied, \"Squashed migration should be applied again when all replaced are applied\"\n+    \n+    print(\"\\nAll tests passed! The fix works correctly.\")\n+\n+if __name__ == \"__main__\":\n+    test_fix()\n", "gold_standard_diff": "From c0e29cec83d000cc0b1087214e4658074fa0499c Mon Sep 17 00:00:00 2001\nFrom: Jacob Walls <jacobtylerwalls@gmail.com>\nDate: Tue, 8 Jun 2021 00:59:04 -0400\nSubject: [PATCH] Fixed #25255 -- Recorded unapplied squashed migrations.\n\n---\n django/db/migrations/executor.py  |  5 ++---\n tests/migrations/test_executor.py | 17 +++++++++++++++++\n 2 files changed, 19 insertions(+), 3 deletions(-)\n\ndiff --git a/django/db/migrations/executor.py b/django/db/migrations/executor.py\nindex 57042a86909c..a8a189f7d9cc 100644\n--- a/django/db/migrations/executor.py\n+++ b/django/db/migrations/executor.py\n@@ -250,12 +250,11 @@ def unapply_migration(self, state, migration, fake=False):\n         if not fake:\n             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:\n                 state = migration.unapply(state, schema_editor)\n-        # For replacement migrations, record individual statuses\n+        # For replacement migrations, also record individual statuses.\n         if migration.replaces:\n             for app_label, name in migration.replaces:\n                 self.recorder.record_unapplied(app_label, name)\n-        else:\n-            self.recorder.record_unapplied(migration.app_label, migration.name)\n+        self.recorder.record_unapplied(migration.app_label, migration.name)\n         # Report progress\n         if self.progress_callback:\n             self.progress_callback(\"unapply_success\", migration, fake)\ndiff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\nindex e61d8f127606..fc80c950fa41 100644\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -653,6 +653,23 @@ def test_migrate_marks_replacement_applied_even_if_it_did_nothing(self):\n             recorder.applied_migrations(),\n         )\n \n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})\n+    def test_migrate_marks_replacement_unapplied(self):\n+        executor = MigrationExecutor(connection)\n+        executor.migrate([('migrations', '0001_squashed_0002')])\n+        try:\n+            self.assertIn(\n+                ('migrations', '0001_squashed_0002'),\n+                executor.recorder.applied_migrations(),\n+            )\n+        finally:\n+            executor.loader.build_graph()\n+            executor.migrate([('migrations', None)])\n+            self.assertNotIn(\n+                ('migrations', '0001_squashed_0002'),\n+                executor.recorder.applied_migrations(),\n+            )\n+\n     # When the feature is False, the operation and the record won't be\n     # performed in a transaction and the test will systematically pass.\n     @skipUnlessDBFeature('can_rollback_ddl')\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14500"}