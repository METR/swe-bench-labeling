{"instance_id": "matplotlib__matplotlib-23299", "score": "I", "diff": "diff --git a/fix.patch b/fix.patch\nnew file mode 100644\nindex 0000000000..b2388666ef\n--- /dev/null\n+++ b/fix.patch\n@@ -0,0 +1,12 @@\n+--- a/lib/matplotlib/__init__.py\n++++ b/lib/matplotlib/__init__.py\n+@@ -674,7 +674,9 @@ class RcParams(MutableMapping, dict):\n+             val = dict.__getitem__(self, key)\n+             if val is rcsetup._auto_backend_sentinel:\n+                 from matplotlib import pyplot as plt\n+-                plt.switch_backend(rcsetup._auto_backend_sentinel)\n++                # Only switch backend if pyplot doesn't have a backend loaded yet\n++                if plt._backend_mod is None:\n++                    plt.switch_backend(rcsetup._auto_backend_sentinel)\n+ \n+         return dict.__getitem__(self, key)\ndiff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724..c44a4536b2 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -674,6 +674,14 @@ class RcParams(MutableMapping, dict):\n             val = dict.__getitem__(self, key)\n             if val is rcsetup._auto_backend_sentinel:\n                 from matplotlib import pyplot as plt\n+                # Check if pyplot already has a backend loaded\n+                if plt._backend_mod is not None:\n+                    # Return the name of the currently loaded backend\n+                    # instead of triggering switch_backend\n+                    import matplotlib.backends\n+                    backend_name = getattr(matplotlib.backends, 'backend', None)\n+                    if backend_name:\n+                        return backend_name\n                 plt.switch_backend(rcsetup._auto_backend_sentinel)\n \n         return dict.__getitem__(self, key)\ndiff --git a/lib/matplotlib/__init__.py.bak2 b/lib/matplotlib/__init__.py.bak2\nnew file mode 100644\nindex 0000000000..c268a56724\n--- /dev/null\n+++ b/lib/matplotlib/__init__.py.bak2\n@@ -0,0 +1,1459 @@\n+\"\"\"\n+An object-oriented plotting library.\n+\n+A procedural interface is provided by the companion pyplot module,\n+which may be imported directly, e.g.::\n+\n+    import matplotlib.pyplot as plt\n+\n+or using ipython::\n+\n+    ipython\n+\n+at your terminal, followed by::\n+\n+    In [1]: %matplotlib\n+    In [2]: import matplotlib.pyplot as plt\n+\n+at the ipython shell prompt.\n+\n+For the most part, direct use of the explicit object-oriented library is\n+encouraged when programming; the implicit pyplot interface is primarily for\n+working interactively. The exceptions to this suggestion are the pyplot\n+functions `.pyplot.figure`, `.pyplot.subplot`, `.pyplot.subplots`, and\n+`.pyplot.savefig`, which can greatly simplify scripting.  See\n+:ref:`api_interfaces` for an explanation of the tradeoffs between the implicit\n+and explicit interfaces.\n+\n+Modules include:\n+\n+    :mod:`matplotlib.axes`\n+        The `~.axes.Axes` class.  Most pyplot functions are wrappers for\n+        `~.axes.Axes` methods.  The axes module is the highest level of OO\n+        access to the library.\n+\n+    :mod:`matplotlib.figure`\n+        The `.Figure` class.\n+\n+    :mod:`matplotlib.artist`\n+        The `.Artist` base class for all classes that draw things.\n+\n+    :mod:`matplotlib.lines`\n+        The `.Line2D` class for drawing lines and markers.\n+\n+    :mod:`matplotlib.patches`\n+        Classes for drawing polygons.\n+\n+    :mod:`matplotlib.text`\n+        The `.Text` and `.Annotation` classes.\n+\n+    :mod:`matplotlib.image`\n+        The `.AxesImage` and `.FigureImage` classes.\n+\n+    :mod:`matplotlib.collections`\n+        Classes for efficient drawing of groups of lines or polygons.\n+\n+    :mod:`matplotlib.colors`\n+        Color specifications and making colormaps.\n+\n+    :mod:`matplotlib.cm`\n+        Colormaps, and the `.ScalarMappable` mixin class for providing color\n+        mapping functionality to other classes.\n+\n+    :mod:`matplotlib.ticker`\n+        Calculation of tick mark locations and formatting of tick labels.\n+\n+    :mod:`matplotlib.backends`\n+        A subpackage with modules for various GUI libraries and output formats.\n+\n+The base matplotlib namespace includes:\n+\n+    `~matplotlib.rcParams`\n+        Default configuration settings; their defaults may be overridden using\n+        a :file:`matplotlibrc` file.\n+\n+    `~matplotlib.use`\n+        Setting the Matplotlib backend.  This should be called before any\n+        figure is created, because it is not possible to switch between\n+        different GUI backends after that.\n+\n+Matplotlib was initially written by John D. Hunter (1968-2012) and is now\n+developed and maintained by a host of others.\n+\n+Occasionally the internal documentation (python docstrings) will refer\n+to MATLAB&reg;, a registered trademark of The MathWorks, Inc.\n+\n+\"\"\"\n+\n+import atexit\n+from collections import namedtuple\n+from collections.abc import MutableMapping\n+import contextlib\n+import functools\n+import importlib\n+import inspect\n+from inspect import Parameter\n+import locale\n+import logging\n+import os\n+from pathlib import Path\n+import pprint\n+import re\n+import shutil\n+import subprocess\n+import sys\n+import tempfile\n+import warnings\n+\n+import numpy\n+from packaging.version import parse as parse_version\n+\n+# cbook must import matplotlib only within function\n+# definitions, so it is safe to import from it here.\n+from . import _api, _version, cbook, _docstring, rcsetup\n+from matplotlib.cbook import sanitize_sequence\n+from matplotlib._api import MatplotlibDeprecationWarning\n+from matplotlib.rcsetup import validate_backend, cycler\n+\n+\n+_log = logging.getLogger(__name__)\n+\n+__bibtex__ = r\"\"\"@Article{Hunter:2007,\n+  Author    = {Hunter, J. D.},\n+  Title     = {Matplotlib: A 2D graphics environment},\n+  Journal   = {Computing in Science \\& Engineering},\n+  Volume    = {9},\n+  Number    = {3},\n+  Pages     = {90--95},\n+  abstract  = {Matplotlib is a 2D graphics package used for Python\n+  for application development, interactive scripting, and\n+  publication-quality image generation across user\n+  interfaces and operating systems.},\n+  publisher = {IEEE COMPUTER SOC},\n+  year      = 2007\n+}\"\"\"\n+\n+# modelled after sys.version_info\n+_VersionInfo = namedtuple('_VersionInfo',\n+                          'major, minor, micro, releaselevel, serial')\n+\n+\n+def _parse_to_version_info(version_str):\n+    \"\"\"\n+    Parse a version string to a namedtuple analogous to sys.version_info.\n+\n+    See:\n+    https://packaging.pypa.io/en/latest/version.html#packaging.version.parse\n+    https://docs.python.org/3/library/sys.html#sys.version_info\n+    \"\"\"\n+    v = parse_version(version_str)\n+    if v.pre is None and v.post is None and v.dev is None:\n+        return _VersionInfo(v.major, v.minor, v.micro, 'final', 0)\n+    elif v.dev is not None:\n+        return _VersionInfo(v.major, v.minor, v.micro, 'alpha', v.dev)\n+    elif v.pre is not None:\n+        releaselevel = {\n+            'a': 'alpha',\n+            'b': 'beta',\n+            'rc': 'candidate'}.get(v.pre[0], 'alpha')\n+        return _VersionInfo(v.major, v.minor, v.micro, releaselevel, v.pre[1])\n+    else:\n+        # fallback for v.post: guess-next-dev scheme from setuptools_scm\n+        return _VersionInfo(v.major, v.minor, v.micro + 1, 'alpha', v.post)\n+\n+\n+def _get_version():\n+    \"\"\"Return the version string used for __version__.\"\"\"\n+    # Only shell out to a git subprocess if really needed, i.e. when we are in\n+    # a matplotlib git repo but not in a shallow clone, such as those used by\n+    # CI, as the latter would trigger a warning from setuptools_scm.\n+    root = Path(__file__).resolve().parents[2]\n+    if ((root / \".matplotlib-repo\").exists()\n+            and (root / \".git\").exists()\n+            and not (root / \".git/shallow\").exists()):\n+        import setuptools_scm\n+        return setuptools_scm.get_version(\n+            root=root,\n+            version_scheme=\"release-branch-semver\",\n+            local_scheme=\"node-and-date\",\n+            fallback_version=_version.version,\n+        )\n+    else:  # Get the version from the _version.py setuptools_scm file.\n+        return _version.version\n+\n+\n+@_api.caching_module_getattr\n+class __getattr__:\n+    __version__ = property(lambda self: _get_version())\n+    __version_info__ = property(\n+        lambda self: _parse_to_version_info(self.__version__))\n+    # module-level deprecations\n+    URL_REGEX = _api.deprecated(\"3.5\", obj_type=\"\")(property(\n+        lambda self: re.compile(r'^http://|^https://|^ftp://|^file:')))\n+\n+\n+def _check_versions():\n+\n+    # Quickfix to ensure Microsoft Visual C++ redistributable\n+    # DLLs are loaded before importing kiwisolver\n+    from . import ft2font\n+\n+    for modname, minver in [\n+            (\"cycler\", \"0.10\"),\n+            (\"dateutil\", \"2.7\"),\n+            (\"kiwisolver\", \"1.0.1\"),\n+            (\"numpy\", \"1.19\"),\n+            (\"pyparsing\", \"2.2.1\"),\n+    ]:\n+        module = importlib.import_module(modname)\n+        if parse_version(module.__version__) < parse_version(minver):\n+            raise ImportError(f\"Matplotlib requires {modname}>={minver}; \"\n+                              f\"you have {module.__version__}\")\n+\n+\n+_check_versions()\n+\n+\n+# The decorator ensures this always returns the same handler (and it is only\n+# attached once).\n+@functools.lru_cache()\n+def _ensure_handler():\n+    \"\"\"\n+    The first time this function is called, attach a `StreamHandler` using the\n+    same format as `logging.basicConfig` to the Matplotlib root logger.\n+\n+    Return this handler every time this function is called.\n+    \"\"\"\n+    handler = logging.StreamHandler()\n+    handler.setFormatter(logging.Formatter(logging.BASIC_FORMAT))\n+    _log.addHandler(handler)\n+    return handler\n+\n+\n+def set_loglevel(level):\n+    \"\"\"\n+    Set Matplotlib's root logger and root logger handler level, creating\n+    the handler if it does not exist yet.\n+\n+    Typically, one should call ``set_loglevel(\"info\")`` or\n+    ``set_loglevel(\"debug\")`` to get additional debugging information.\n+\n+    Parameters\n+    ----------\n+    level : {\"notset\", \"debug\", \"info\", \"warning\", \"error\", \"critical\"}\n+        The log level of the handler.\n+\n+    Notes\n+    -----\n+    The first time this function is called, an additional handler is attached\n+    to Matplotlib's root handler; this handler is reused every time and this\n+    function simply manipulates the logger and handler's level.\n+    \"\"\"\n+    _log.setLevel(level.upper())\n+    _ensure_handler().setLevel(level.upper())\n+\n+\n+def _logged_cached(fmt, func=None):\n+    \"\"\"\n+    Decorator that logs a function's return value, and memoizes that value.\n+\n+    After ::\n+\n+        @_logged_cached(fmt)\n+        def func(): ...\n+\n+    the first call to *func* will log its return value at the DEBUG level using\n+    %-format string *fmt*, and memoize it; later calls to *func* will directly\n+    return that value.\n+    \"\"\"\n+    if func is None:  # Return the actual decorator.\n+        return functools.partial(_logged_cached, fmt)\n+\n+    called = False\n+    ret = None\n+\n+    @functools.wraps(func)\n+    def wrapper(**kwargs):\n+        nonlocal called, ret\n+        if not called:\n+            ret = func(**kwargs)\n+            called = True\n+            _log.debug(fmt, ret)\n+        return ret\n+\n+    return wrapper\n+\n+\n+_ExecInfo = namedtuple(\"_ExecInfo\", \"executable raw_version version\")\n+\n+\n+class ExecutableNotFoundError(FileNotFoundError):\n+    \"\"\"\n+    Error raised when an executable that Matplotlib optionally\n+    depends on can't be found.\n+    \"\"\"\n+    pass\n+\n+\n+@functools.lru_cache()\n+def _get_executable_info(name):\n+    \"\"\"\n+    Get the version of some executable that Matplotlib optionally depends on.\n+\n+    .. warning::\n+       The list of executables that this function supports is set according to\n+       Matplotlib's internal needs, and may change without notice.\n+\n+    Parameters\n+    ----------\n+    name : str\n+        The executable to query.  The following values are currently supported:\n+        \"dvipng\", \"gs\", \"inkscape\", \"magick\", \"pdftocairo\", \"pdftops\".  This\n+        list is subject to change without notice.\n+\n+    Returns\n+    -------\n+    tuple\n+        A namedtuple with fields ``executable`` (`str`) and ``version``\n+        (`packaging.Version`, or ``None`` if the version cannot be determined).\n+\n+    Raises\n+    ------\n+    ExecutableNotFoundError\n+        If the executable is not found or older than the oldest version\n+        supported by Matplotlib.  For debugging purposes, it is also\n+        possible to \"hide\" an executable from Matplotlib by adding it to the\n+        :envvar:`_MPLHIDEEXECUTABLES` environment variable (a comma-separated\n+        list), which must be set prior to any calls to this function.\n+    ValueError\n+        If the executable is not one that we know how to query.\n+    \"\"\"\n+\n+    def impl(args, regex, min_ver=None, ignore_exit_code=False):\n+        # Execute the subprocess specified by args; capture stdout and stderr.\n+        # Search for a regex match in the output; if the match succeeds, the\n+        # first group of the match is the version.\n+        # Return an _ExecInfo if the executable exists, and has a version of\n+        # at least min_ver (if set); else, raise ExecutableNotFoundError.\n+        try:\n+            output = subprocess.check_output(\n+                args, stderr=subprocess.STDOUT,\n+                universal_newlines=True, errors=\"replace\")\n+        except subprocess.CalledProcessError as _cpe:\n+            if ignore_exit_code:\n+                output = _cpe.output\n+            else:\n+                raise ExecutableNotFoundError(str(_cpe)) from _cpe\n+        except OSError as _ose:\n+            raise ExecutableNotFoundError(str(_ose)) from _ose\n+        match = re.search(regex, output)\n+        if match:\n+            raw_version = match.group(1)\n+            version = parse_version(raw_version)\n+            if min_ver is not None and version < parse_version(min_ver):\n+                raise ExecutableNotFoundError(\n+                    f\"You have {args[0]} version {version} but the minimum \"\n+                    f\"version supported by Matplotlib is {min_ver}\")\n+            return _ExecInfo(args[0], raw_version, version)\n+        else:\n+            raise ExecutableNotFoundError(\n+                f\"Failed to determine the version of {args[0]} from \"\n+                f\"{' '.join(args)}, which output {output}\")\n+\n+    if name in os.environ.get(\"_MPLHIDEEXECUTABLES\", \"\").split(\",\"):\n+        raise ExecutableNotFoundError(f\"{name} was hidden\")\n+\n+    if name == \"dvipng\":\n+        return impl([\"dvipng\", \"-version\"], \"(?m)^dvipng(?: .*)? (.+)\", \"1.6\")\n+    elif name == \"gs\":\n+        execs = ([\"gswin32c\", \"gswin64c\", \"mgs\", \"gs\"]  # \"mgs\" for miktex.\n+                 if sys.platform == \"win32\" else\n+                 [\"gs\"])\n+        for e in execs:\n+            try:\n+                return impl([e, \"--version\"], \"(.*)\", \"9\")\n+            except ExecutableNotFoundError:\n+                pass\n+        message = \"Failed to find a Ghostscript installation\"\n+        raise ExecutableNotFoundError(message)\n+    elif name == \"inkscape\":\n+        try:\n+            # Try headless option first (needed for Inkscape version < 1.0):\n+            return impl([\"inkscape\", \"--without-gui\", \"-V\"],\n+                        \"Inkscape ([^ ]*)\")\n+        except ExecutableNotFoundError:\n+            pass  # Suppress exception chaining.\n+        # If --without-gui is not accepted, we may be using Inkscape >= 1.0 so\n+        # try without it:\n+        return impl([\"inkscape\", \"-V\"], \"Inkscape ([^ ]*)\")\n+    elif name == \"magick\":\n+        if sys.platform == \"win32\":\n+            # Check the registry to avoid confusing ImageMagick's convert with\n+            # Windows's builtin convert.exe.\n+            import winreg\n+            binpath = \"\"\n+            for flag in [0, winreg.KEY_WOW64_32KEY, winreg.KEY_WOW64_64KEY]:\n+                try:\n+                    with winreg.OpenKeyEx(\n+                            winreg.HKEY_LOCAL_MACHINE,\n+                            r\"Software\\Imagemagick\\Current\",\n+                            0, winreg.KEY_QUERY_VALUE | flag) as hkey:\n+                        binpath = winreg.QueryValueEx(hkey, \"BinPath\")[0]\n+                except OSError:\n+                    pass\n+            path = None\n+            if binpath:\n+                for name in [\"convert.exe\", \"magick.exe\"]:\n+                    candidate = Path(binpath, name)\n+                    if candidate.exists():\n+                        path = str(candidate)\n+                        break\n+            if path is None:\n+                raise ExecutableNotFoundError(\n+                    \"Failed to find an ImageMagick installation\")\n+        else:\n+            path = \"convert\"\n+        info = impl([path, \"--version\"], r\"^Version: ImageMagick (\\S*)\")\n+        if info.raw_version == \"7.0.10-34\":\n+            # https://github.com/ImageMagick/ImageMagick/issues/2720\n+            raise ExecutableNotFoundError(\n+                f\"You have ImageMagick {info.version}, which is unsupported\")\n+        return info\n+    elif name == \"pdftocairo\":\n+        return impl([\"pdftocairo\", \"-v\"], \"pdftocairo version (.*)\")\n+    elif name == \"pdftops\":\n+        info = impl([\"pdftops\", \"-v\"], \"^pdftops version (.*)\",\n+                    ignore_exit_code=True)\n+        if info and not (\n+                3 <= info.version.major or\n+                # poppler version numbers.\n+                parse_version(\"0.9\") <= info.version < parse_version(\"1.0\")):\n+            raise ExecutableNotFoundError(\n+                f\"You have pdftops version {info.version} but the minimum \"\n+                f\"version supported by Matplotlib is 3.0\")\n+        return info\n+    else:\n+        raise ValueError(\"Unknown executable: {!r}\".format(name))\n+\n+\n+@_api.deprecated(\"3.6\", alternative=\"Vendor the code\")\n+def checkdep_usetex(s):\n+    if not s:\n+        return False\n+    if not shutil.which(\"tex\"):\n+        _log.warning(\"usetex mode requires TeX.\")\n+        return False\n+    try:\n+        _get_executable_info(\"dvipng\")\n+    except ExecutableNotFoundError:\n+        _log.warning(\"usetex mode requires dvipng.\")\n+        return False\n+    try:\n+        _get_executable_info(\"gs\")\n+    except ExecutableNotFoundError:\n+        _log.warning(\"usetex mode requires ghostscript.\")\n+        return False\n+    return True\n+\n+\n+def _get_xdg_config_dir():\n+    \"\"\"\n+    Return the XDG configuration directory, according to the XDG base\n+    directory spec:\n+\n+    https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n+    \"\"\"\n+    return os.environ.get('XDG_CONFIG_HOME') or str(Path.home() / \".config\")\n+\n+\n+def _get_xdg_cache_dir():\n+    \"\"\"\n+    Return the XDG cache directory, according to the XDG base directory spec:\n+\n+    https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n+    \"\"\"\n+    return os.environ.get('XDG_CACHE_HOME') or str(Path.home() / \".cache\")\n+\n+\n+def _get_config_or_cache_dir(xdg_base_getter):\n+    configdir = os.environ.get('MPLCONFIGDIR')\n+    if configdir:\n+        configdir = Path(configdir).resolve()\n+    elif sys.platform.startswith(('linux', 'freebsd')):\n+        # Only call _xdg_base_getter here so that MPLCONFIGDIR is tried first,\n+        # as _xdg_base_getter can throw.\n+        configdir = Path(xdg_base_getter(), \"matplotlib\")\n+    else:\n+        configdir = Path.home() / \".matplotlib\"\n+    try:\n+        configdir.mkdir(parents=True, exist_ok=True)\n+    except OSError:\n+        pass\n+    else:\n+        if os.access(str(configdir), os.W_OK) and configdir.is_dir():\n+            return str(configdir)\n+    # If the config or cache directory cannot be created or is not a writable\n+    # directory, create a temporary one.\n+    tmpdir = os.environ[\"MPLCONFIGDIR\"] = \\\n+        tempfile.mkdtemp(prefix=\"matplotlib-\")\n+    atexit.register(shutil.rmtree, tmpdir)\n+    _log.warning(\n+        \"Matplotlib created a temporary config/cache directory at %s because \"\n+        \"the default path (%s) is not a writable directory; it is highly \"\n+        \"recommended to set the MPLCONFIGDIR environment variable to a \"\n+        \"writable directory, in particular to speed up the import of \"\n+        \"Matplotlib and to better support multiprocessing.\",\n+        tmpdir, configdir)\n+    return tmpdir\n+\n+\n+@_logged_cached('CONFIGDIR=%s')\n+def get_configdir():\n+    \"\"\"\n+    Return the string path of the configuration directory.\n+\n+    The directory is chosen as follows:\n+\n+    1. If the MPLCONFIGDIR environment variable is supplied, choose that.\n+    2. On Linux, follow the XDG specification and look first in\n+       ``$XDG_CONFIG_HOME``, if defined, or ``$HOME/.config``.  On other\n+       platforms, choose ``$HOME/.matplotlib``.\n+    3. If the chosen directory exists and is writable, use that as the\n+       configuration directory.\n+    4. Else, create a temporary directory, and use it as the configuration\n+       directory.\n+    \"\"\"\n+    return _get_config_or_cache_dir(_get_xdg_config_dir)\n+\n+\n+@_logged_cached('CACHEDIR=%s')\n+def get_cachedir():\n+    \"\"\"\n+    Return the string path of the cache directory.\n+\n+    The procedure used to find the directory is the same as for\n+    _get_config_dir, except using ``$XDG_CACHE_HOME``/``$HOME/.cache`` instead.\n+    \"\"\"\n+    return _get_config_or_cache_dir(_get_xdg_cache_dir)\n+\n+\n+@_logged_cached('matplotlib data path: %s')\n+def get_data_path():\n+    \"\"\"Return the path to Matplotlib data.\"\"\"\n+    return str(Path(__file__).with_name(\"mpl-data\"))\n+\n+\n+def matplotlib_fname():\n+    \"\"\"\n+    Get the location of the config file.\n+\n+    The file location is determined in the following order\n+\n+    - ``$PWD/matplotlibrc``\n+    - ``$MATPLOTLIBRC`` if it is not a directory\n+    - ``$MATPLOTLIBRC/matplotlibrc``\n+    - ``$MPLCONFIGDIR/matplotlibrc``\n+    - On Linux,\n+        - ``$XDG_CONFIG_HOME/matplotlib/matplotlibrc`` (if ``$XDG_CONFIG_HOME``\n+          is defined)\n+        - or ``$HOME/.config/matplotlib/matplotlibrc`` (if ``$XDG_CONFIG_HOME``\n+          is not defined)\n+    - On other platforms,\n+      - ``$HOME/.matplotlib/matplotlibrc`` if ``$HOME`` is defined\n+    - Lastly, it looks in ``$MATPLOTLIBDATA/matplotlibrc``, which should always\n+      exist.\n+    \"\"\"\n+\n+    def gen_candidates():\n+        # rely on down-stream code to make absolute.  This protects us\n+        # from having to directly get the current working directory\n+        # which can fail if the user has ended up with a cwd that is\n+        # non-existent.\n+        yield 'matplotlibrc'\n+        try:\n+            matplotlibrc = os.environ['MATPLOTLIBRC']\n+        except KeyError:\n+            pass\n+        else:\n+            yield matplotlibrc\n+            yield os.path.join(matplotlibrc, 'matplotlibrc')\n+        yield os.path.join(get_configdir(), 'matplotlibrc')\n+        yield os.path.join(get_data_path(), 'matplotlibrc')\n+\n+    for fname in gen_candidates():\n+        if os.path.exists(fname) and not os.path.isdir(fname):\n+            return fname\n+\n+    raise RuntimeError(\"Could not find matplotlibrc file; your Matplotlib \"\n+                       \"install is broken\")\n+\n+\n+# rcParams deprecated and automatically mapped to another key.\n+# Values are tuples of (version, new_name, f_old2new, f_new2old).\n+_deprecated_map = {}\n+# rcParams deprecated; some can manually be mapped to another key.\n+# Values are tuples of (version, new_name_or_None).\n+_deprecated_ignore_map = {}\n+# rcParams deprecated; can use None to suppress warnings; remain actually\n+# listed in the rcParams.\n+# Values are tuples of (version,)\n+_deprecated_remain_as_none = {}\n+\n+\n+@_docstring.Substitution(\n+    \"\\n\".join(map(\"- {}\".format, sorted(rcsetup._validators, key=str.lower)))\n+)\n+class RcParams(MutableMapping, dict):\n+    \"\"\"\n+    A dictionary object including validation.\n+\n+    Validating functions are defined and associated with rc parameters in\n+    :mod:`matplotlib.rcsetup`.\n+\n+    The list of rcParams is:\n+\n+    %s\n+\n+    See Also\n+    --------\n+    :ref:`customizing-with-matplotlibrc-files`\n+    \"\"\"\n+\n+    validate = rcsetup._validators\n+\n+    # validate values on the way in\n+    def __init__(self, *args, **kwargs):\n+        self.update(*args, **kwargs)\n+\n+    def __setitem__(self, key, val):\n+        try:\n+            if key in _deprecated_map:\n+                version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+                _api.warn_deprecated(\n+                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+                key = alt_key\n+                val = alt_val(val)\n+            elif key in _deprecated_remain_as_none and val is not None:\n+                version, = _deprecated_remain_as_none[key]\n+                _api.warn_deprecated(version, name=key, obj_type=\"rcparam\")\n+            elif key in _deprecated_ignore_map:\n+                version, alt_key = _deprecated_ignore_map[key]\n+                _api.warn_deprecated(\n+                    version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+                return\n+            elif key == 'backend':\n+                if val is rcsetup._auto_backend_sentinel:\n+                    if 'backend' in self:\n+                        return\n+            try:\n+                cval = self.validate[key](val)\n+            except ValueError as ve:\n+                raise ValueError(f\"Key {key}: {ve}\") from None\n+            dict.__setitem__(self, key, cval)\n+        except KeyError as err:\n+            raise KeyError(\n+                f\"{key} is not a valid rc parameter (see rcParams.keys() for \"\n+                f\"a list of valid parameters)\") from err\n+\n+    def __getitem__(self, key):\n+        if key in _deprecated_map:\n+            version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return inverse_alt(dict.__getitem__(self, alt_key))\n+\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, obj_type=\"rcparam\", alternative=alt_key)\n+            return dict.__getitem__(self, alt_key) if alt_key else None\n+\n+        # In theory, this should only ever be used after the global rcParams\n+        # has been set up, but better be safe e.g. in presence of breakpoints.\n+        elif key == \"backend\" and self is globals().get(\"rcParams\"):\n+            val = dict.__getitem__(self, key)\n+            if val is rcsetup._auto_backend_sentinel:\n+                from matplotlib import pyplot as plt\n+                plt.switch_backend(rcsetup._auto_backend_sentinel)\n+\n+        return dict.__getitem__(self, key)\n+\n+    def _get_backend_or_none(self):\n+        \"\"\"Get the requested backend, if any, without triggering resolution.\"\"\"\n+        backend = dict.__getitem__(self, \"backend\")\n+        return None if backend is rcsetup._auto_backend_sentinel else backend\n+\n+    def __repr__(self):\n+        class_name = self.__class__.__name__\n+        indent = len(class_name) + 1\n+        with _api.suppress_matplotlib_deprecation_warning():\n+            repr_split = pprint.pformat(dict(self), indent=1,\n+                                        width=80 - indent).split('\\n')\n+        repr_indented = ('\\n' + ' ' * indent).join(repr_split)\n+        return '{}({})'.format(class_name, repr_indented)\n+\n+    def __str__(self):\n+        return '\\n'.join(map('{0[0]}: {0[1]}'.format, sorted(self.items())))\n+\n+    def __iter__(self):\n+        \"\"\"Yield sorted list of keys.\"\"\"\n+        with _api.suppress_matplotlib_deprecation_warning():\n+            yield from sorted(dict.__iter__(self))\n+\n+    def __len__(self):\n+        return dict.__len__(self)\n+\n+    def find_all(self, pattern):\n+        \"\"\"\n+        Return the subset of this RcParams dictionary whose keys match,\n+        using :func:`re.search`, the given ``pattern``.\n+\n+        .. note::\n+\n+            Changes to the returned dictionary are *not* propagated to\n+            the parent RcParams dictionary.\n+\n+        \"\"\"\n+        pattern_re = re.compile(pattern)\n+        return RcParams((key, value)\n+                        for key, value in self.items()\n+                        if pattern_re.search(key))\n+\n+    def copy(self):\n+        rccopy = RcParams()\n+        for k in self:  # Skip deprecations and revalidation.\n+            dict.__setitem__(rccopy, k, dict.__getitem__(self, k))\n+        return rccopy\n+\n+\n+def rc_params(fail_on_error=False):\n+    \"\"\"Construct a `RcParams` instance from the default Matplotlib rc file.\"\"\"\n+    return rc_params_from_file(matplotlib_fname(), fail_on_error)\n+\n+\n+@_api.deprecated(\"3.5\")\n+def is_url(filename):\n+    \"\"\"Return whether *filename* is an http, https, ftp, or file URL path.\"\"\"\n+    return __getattr__(\"URL_REGEX\").match(filename) is not None\n+\n+\n+@functools.lru_cache()\n+def _get_ssl_context():\n+    try:\n+        import certifi\n+    except ImportError:\n+        _log.debug(\"Could not import certifi.\")\n+        return None\n+    import ssl\n+    return ssl.create_default_context(cafile=certifi.where())\n+\n+\n+@contextlib.contextmanager\n+def _open_file_or_url(fname):\n+    if (isinstance(fname, str)\n+            and fname.startswith(('http://', 'https://', 'ftp://', 'file:'))):\n+        import urllib.request\n+        ssl_ctx = _get_ssl_context()\n+        if ssl_ctx is None:\n+            _log.debug(\n+                \"Could not get certifi ssl context, https may not work.\"\n+            )\n+        with urllib.request.urlopen(fname, context=ssl_ctx) as f:\n+            yield (line.decode('utf-8') for line in f)\n+    else:\n+        fname = os.path.expanduser(fname)\n+        with open(fname, encoding='utf-8') as f:\n+            yield f\n+\n+\n+def _rc_params_in_file(fname, transform=lambda x: x, fail_on_error=False):\n+    \"\"\"\n+    Construct a `RcParams` instance from file *fname*.\n+\n+    Unlike `rc_params_from_file`, the configuration class only contains the\n+    parameters specified in the file (i.e. default values are not filled in).\n+\n+    Parameters\n+    ----------\n+    fname : path-like\n+        The loaded file.\n+    transform : callable, default: the identity function\n+        A function called on each individual line of the file to transform it,\n+        before further parsing.\n+    fail_on_error : bool, default: False\n+        Whether invalid entries should result in an exception or a warning.\n+    \"\"\"\n+    import matplotlib as mpl\n+    rc_temp = {}\n+    with _open_file_or_url(fname) as fd:\n+        try:\n+            for line_no, line in enumerate(fd, 1):\n+                line = transform(line)\n+                strippedline = cbook._strip_comment(line)\n+                if not strippedline:\n+                    continue\n+                tup = strippedline.split(':', 1)\n+                if len(tup) != 2:\n+                    _log.warning('Missing colon in file %r, line %d (%r)',\n+                                 fname, line_no, line.rstrip('\\n'))\n+                    continue\n+                key, val = tup\n+                key = key.strip()\n+                val = val.strip()\n+                if val.startswith('\"') and val.endswith('\"'):\n+                    val = val[1:-1]  # strip double quotes\n+                if key in rc_temp:\n+                    _log.warning('Duplicate key in file %r, line %d (%r)',\n+                                 fname, line_no, line.rstrip('\\n'))\n+                rc_temp[key] = (val, line, line_no)\n+        except UnicodeDecodeError:\n+            _log.warning('Cannot decode configuration file %r as utf-8.',\n+                         fname)\n+            raise\n+\n+    config = RcParams()\n+\n+    for key, (val, line, line_no) in rc_temp.items():\n+        if key in rcsetup._validators:\n+            if fail_on_error:\n+                config[key] = val  # try to convert to proper type or raise\n+            else:\n+                try:\n+                    config[key] = val  # try to convert to proper type or skip\n+                except Exception as msg:\n+                    _log.warning('Bad value in file %r, line %d (%r): %s',\n+                                 fname, line_no, line.rstrip('\\n'), msg)\n+        elif key in _deprecated_ignore_map:\n+            version, alt_key = _deprecated_ignore_map[key]\n+            _api.warn_deprecated(\n+                version, name=key, alternative=alt_key, obj_type='rcparam',\n+                addendum=\"Please update your matplotlibrc.\")\n+        else:\n+            # __version__ must be looked up as an attribute to trigger the\n+            # module-level __getattr__.\n+            version = ('main' if '.post' in mpl.__version__\n+                       else f'v{mpl.__version__}')\n+            _log.warning(\"\"\"\n+Bad key %(key)s in file %(fname)s, line %(line_no)s (%(line)r)\n+You probably need to get an updated matplotlibrc file from\n+https://github.com/matplotlib/matplotlib/blob/%(version)s/matplotlibrc.template\n+or from the matplotlib source distribution\"\"\",\n+                         dict(key=key, fname=fname, line_no=line_no,\n+                              line=line.rstrip('\\n'), version=version))\n+    return config\n+\n+\n+def rc_params_from_file(fname, fail_on_error=False, use_default_template=True):\n+    \"\"\"\n+    Construct a `RcParams` from file *fname*.\n+\n+    Parameters\n+    ----------\n+    fname : str or path-like\n+        A file with Matplotlib rc settings.\n+    fail_on_error : bool\n+        If True, raise an error when the parser fails to convert a parameter.\n+    use_default_template : bool\n+        If True, initialize with default parameters before updating with those\n+        in the given file. If False, the configuration class only contains the\n+        parameters specified in the file. (Useful for updating dicts.)\n+    \"\"\"\n+    config_from_file = _rc_params_in_file(fname, fail_on_error=fail_on_error)\n+\n+    if not use_default_template:\n+        return config_from_file\n+\n+    with _api.suppress_matplotlib_deprecation_warning():\n+        config = RcParams({**rcParamsDefault, **config_from_file})\n+\n+    if \"\".join(config['text.latex.preamble']):\n+        _log.info(\"\"\"\n+*****************************************************************\n+You have the following UNSUPPORTED LaTeX preamble customizations:\n+%s\n+Please do not ask for support with these customizations active.\n+*****************************************************************\n+\"\"\", '\\n'.join(config['text.latex.preamble']))\n+    _log.debug('loaded rc file %s', fname)\n+\n+    return config\n+\n+\n+# When constructing the global instances, we need to perform certain updates\n+# by explicitly calling the superclass (dict.update, dict.items) to avoid\n+# triggering resolution of _auto_backend_sentinel.\n+rcParamsDefault = _rc_params_in_file(\n+    cbook._get_data_path(\"matplotlibrc\"),\n+    # Strip leading comment.\n+    transform=lambda line: line[1:] if line.startswith(\"#\") else line,\n+    fail_on_error=True)\n+dict.update(rcParamsDefault, rcsetup._hardcoded_defaults)\n+# Normally, the default matplotlibrc file contains *no* entry for backend (the\n+# corresponding line starts with ##, not #; we fill on _auto_backend_sentinel\n+# in that case.  However, packagers can set a different default backend\n+# (resulting in a normal `#backend: foo` line) in which case we should *not*\n+# fill in _auto_backend_sentinel.\n+dict.setdefault(rcParamsDefault, \"backend\", rcsetup._auto_backend_sentinel)\n+rcParams = RcParams()  # The global instance.\n+dict.update(rcParams, dict.items(rcParamsDefault))\n+dict.update(rcParams, _rc_params_in_file(matplotlib_fname()))\n+rcParamsOrig = rcParams.copy()\n+with _api.suppress_matplotlib_deprecation_warning():\n+    # This also checks that all rcParams are indeed listed in the template.\n+    # Assigning to rcsetup.defaultParams is left only for backcompat.\n+    defaultParams = rcsetup.defaultParams = {\n+        # We want to resolve deprecated rcParams, but not backend...\n+        key: [(rcsetup._auto_backend_sentinel if key == \"backend\" else\n+               rcParamsDefault[key]),\n+              validator]\n+        for key, validator in rcsetup._validators.items()}\n+if rcParams['axes.formatter.use_locale']:\n+    locale.setlocale(locale.LC_ALL, '')\n+\n+\n+def rc(group, **kwargs):\n+    \"\"\"\n+    Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,\n+    for ``lines.linewidth`` the group is ``lines``, for\n+    ``axes.facecolor``, the group is ``axes``, and so on.  Group may\n+    also be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n+    *kwargs* is a dictionary attribute name/value pairs, e.g.,::\n+\n+      rc('lines', linewidth=2, color='r')\n+\n+    sets the current `.rcParams` and is equivalent to::\n+\n+      rcParams['lines.linewidth'] = 2\n+      rcParams['lines.color'] = 'r'\n+\n+    The following aliases are available to save typing for interactive users:\n+\n+    =====   =================\n+    Alias   Property\n+    =====   =================\n+    'lw'    'linewidth'\n+    'ls'    'linestyle'\n+    'c'     'color'\n+    'fc'    'facecolor'\n+    'ec'    'edgecolor'\n+    'mew'   'markeredgewidth'\n+    'aa'    'antialiased'\n+    =====   =================\n+\n+    Thus you could abbreviate the above call as::\n+\n+          rc('lines', lw=2, c='r')\n+\n+    Note you can use python's kwargs dictionary facility to store\n+    dictionaries of default parameters.  e.g., you can customize the\n+    font rc as follows::\n+\n+      font = {'family' : 'monospace',\n+              'weight' : 'bold',\n+              'size'   : 'larger'}\n+      rc('font', **font)  # pass in the font dict as kwargs\n+\n+    This enables you to easily switch between several configurations.  Use\n+    ``matplotlib.style.use('default')`` or :func:`~matplotlib.rcdefaults` to\n+    restore the default `.rcParams` after changes.\n+\n+    Notes\n+    -----\n+    Similar functionality is available by using the normal dict interface, i.e.\n+    ``rcParams.update({\"lines.linewidth\": 2, ...})`` (but ``rcParams.update``\n+    does not support abbreviations or grouping).\n+    \"\"\"\n+\n+    aliases = {\n+        'lw':  'linewidth',\n+        'ls':  'linestyle',\n+        'c':   'color',\n+        'fc':  'facecolor',\n+        'ec':  'edgecolor',\n+        'mew': 'markeredgewidth',\n+        'aa':  'antialiased',\n+        }\n+\n+    if isinstance(group, str):\n+        group = (group,)\n+    for g in group:\n+        for k, v in kwargs.items():\n+            name = aliases.get(k) or k\n+            key = '%s.%s' % (g, name)\n+            try:\n+                rcParams[key] = v\n+            except KeyError as err:\n+                raise KeyError(('Unrecognized key \"%s\" for group \"%s\" and '\n+                                'name \"%s\"') % (key, g, name)) from err\n+\n+\n+def rcdefaults():\n+    \"\"\"\n+    Restore the `.rcParams` from Matplotlib's internal default style.\n+\n+    Style-blacklisted `.rcParams` (defined in\n+    ``matplotlib.style.core.STYLE_BLACKLIST``) are not updated.\n+\n+    See Also\n+    --------\n+    matplotlib.rc_file_defaults\n+        Restore the `.rcParams` from the rc file originally loaded by\n+        Matplotlib.\n+    matplotlib.style.use\n+        Use a specific style file.  Call ``style.use('default')`` to restore\n+        the default style.\n+    \"\"\"\n+    # Deprecation warnings were already handled when creating rcParamsDefault,\n+    # no need to reemit them here.\n+    with _api.suppress_matplotlib_deprecation_warning():\n+        from .style.core import STYLE_BLACKLIST\n+        rcParams.clear()\n+        rcParams.update({k: v for k, v in rcParamsDefault.items()\n+                         if k not in STYLE_BLACKLIST})\n+\n+\n+def rc_file_defaults():\n+    \"\"\"\n+    Restore the `.rcParams` from the original rc file loaded by Matplotlib.\n+\n+    Style-blacklisted `.rcParams` (defined in\n+    ``matplotlib.style.core.STYLE_BLACKLIST``) are not updated.\n+    \"\"\"\n+    # Deprecation warnings were already handled when creating rcParamsOrig, no\n+    # need to reemit them here.\n+    with _api.suppress_matplotlib_deprecation_warning():\n+        from .style.core import STYLE_BLACKLIST\n+        rcParams.update({k: rcParamsOrig[k] for k in rcParamsOrig\n+                         if k not in STYLE_BLACKLIST})\n+\n+\n+def rc_file(fname, *, use_default_template=True):\n+    \"\"\"\n+    Update `.rcParams` from file.\n+\n+    Style-blacklisted `.rcParams` (defined in\n+    ``matplotlib.style.core.STYLE_BLACKLIST``) are not updated.\n+\n+    Parameters\n+    ----------\n+    fname : str or path-like\n+        A file with Matplotlib rc settings.\n+\n+    use_default_template : bool\n+        If True, initialize with default parameters before updating with those\n+        in the given file. If False, the current configuration persists\n+        and only the parameters specified in the file are updated.\n+    \"\"\"\n+    # Deprecation warnings were already handled in rc_params_from_file, no need\n+    # to reemit them here.\n+    with _api.suppress_matplotlib_deprecation_warning():\n+        from .style.core import STYLE_BLACKLIST\n+        rc_from_file = rc_params_from_file(\n+            fname, use_default_template=use_default_template)\n+        rcParams.update({k: rc_from_file[k] for k in rc_from_file\n+                         if k not in STYLE_BLACKLIST})\n+\n+\n+@contextlib.contextmanager\n+def rc_context(rc=None, fname=None):\n+    \"\"\"\n+    Return a context manager for temporarily changing rcParams.\n+\n+    Parameters\n+    ----------\n+    rc : dict\n+        The rcParams to temporarily set.\n+    fname : str or path-like\n+        A file with Matplotlib rc settings. If both *fname* and *rc* are given,\n+        settings from *rc* take precedence.\n+\n+    See Also\n+    --------\n+    :ref:`customizing-with-matplotlibrc-files`\n+\n+    Examples\n+    --------\n+    Passing explicit values via a dict::\n+\n+        with mpl.rc_context({'interactive': False}):\n+            fig, ax = plt.subplots()\n+            ax.plot(range(3), range(3))\n+            fig.savefig('example.png')\n+            plt.close(fig)\n+\n+    Loading settings from a file::\n+\n+         with mpl.rc_context(fname='print.rc'):\n+             plt.plot(x, y)  # uses 'print.rc'\n+\n+    \"\"\"\n+    orig = rcParams.copy()\n+    try:\n+        if fname:\n+            rc_file(fname)\n+        if rc:\n+            rcParams.update(rc)\n+        yield\n+    finally:\n+        dict.update(rcParams, orig)  # Revert to the original rcs.\n+\n+\n+def use(backend, *, force=True):\n+    \"\"\"\n+    Select the backend used for rendering and GUI integration.\n+\n+    Parameters\n+    ----------\n+    backend : str\n+        The backend to switch to.  This can either be one of the standard\n+        backend names, which are case-insensitive:\n+\n+        - interactive backends:\n+          GTK3Agg, GTK3Cairo, GTK4Agg, GTK4Cairo, MacOSX, nbAgg, QtAgg,\n+          QtCairo, TkAgg, TkCairo, WebAgg, WX, WXAgg, WXCairo, Qt5Agg, Qt5Cairo\n+\n+        - non-interactive backends:\n+          agg, cairo, pdf, pgf, ps, svg, template\n+\n+        or a string of the form: ``module://my.module.name``.\n+\n+        Switching to an interactive backend is not possible if an unrelated\n+        event loop has already been started (e.g., switching to GTK3Agg if a\n+        TkAgg window has already been opened).  Switching to a non-interactive\n+        backend is always possible.\n+\n+    force : bool, default: True\n+        If True (the default), raise an `ImportError` if the backend cannot be\n+        set up (either because it fails to import, or because an incompatible\n+        GUI interactive framework is already running); if False, silently\n+        ignore the failure.\n+\n+    See Also\n+    --------\n+    :ref:`backends`\n+    matplotlib.get_backend\n+    \"\"\"\n+    name = validate_backend(backend)\n+    # don't (prematurely) resolve the \"auto\" backend setting\n+    if rcParams._get_backend_or_none() == name:\n+        # Nothing to do if the requested backend is already set\n+        pass\n+    else:\n+        # if pyplot is not already imported, do not import it.  Doing\n+        # so may trigger a `plt.switch_backend` to the _default_ backend\n+        # before we get a chance to change to the one the user just requested\n+        plt = sys.modules.get('matplotlib.pyplot')\n+        # if pyplot is imported, then try to change backends\n+        if plt is not None:\n+            try:\n+                # we need this import check here to re-raise if the\n+                # user does not have the libraries to support their\n+                # chosen backend installed.\n+                plt.switch_backend(name)\n+            except ImportError:\n+                if force:\n+                    raise\n+        # if we have not imported pyplot, then we can set the rcParam\n+        # value which will be respected when the user finally imports\n+        # pyplot\n+        else:\n+            rcParams['backend'] = backend\n+    # if the user has asked for a given backend, do not helpfully\n+    # fallback\n+    rcParams['backend_fallback'] = False\n+\n+\n+if os.environ.get('MPLBACKEND'):\n+    rcParams['backend'] = os.environ.get('MPLBACKEND')\n+\n+\n+def get_backend():\n+    \"\"\"\n+    Return the name of the current backend.\n+\n+    See Also\n+    --------\n+    matplotlib.use\n+    \"\"\"\n+    return rcParams['backend']\n+\n+\n+def interactive(b):\n+    \"\"\"\n+    Set whether to redraw after every plotting command (e.g. `.pyplot.xlabel`).\n+    \"\"\"\n+    rcParams['interactive'] = b\n+\n+\n+def is_interactive():\n+    \"\"\"\n+    Return whether to redraw after every plotting command.\n+\n+    .. note::\n+\n+        This function is only intended for use in backends. End users should\n+        use `.pyplot.isinteractive` instead.\n+    \"\"\"\n+    return rcParams['interactive']\n+\n+\n+default_test_modules = [\n+    'matplotlib.tests',\n+    'mpl_toolkits.tests',\n+]\n+\n+\n+def _init_tests():\n+    # The version of FreeType to install locally for running the\n+    # tests.  This must match the value in `setupext.py`\n+    LOCAL_FREETYPE_VERSION = '2.6.1'\n+\n+    from matplotlib import ft2font\n+    if (ft2font.__freetype_version__ != LOCAL_FREETYPE_VERSION or\n+            ft2font.__freetype_build_type__ != 'local'):\n+        _log.warning(\n+            f\"Matplotlib is not built with the correct FreeType version to \"\n+            f\"run tests.  Rebuild without setting system_freetype=1 in \"\n+            f\"mplsetup.cfg.  Expect many image comparison failures below.  \"\n+            f\"Expected freetype version {LOCAL_FREETYPE_VERSION}.  \"\n+            f\"Found freetype version {ft2font.__freetype_version__}.  \"\n+            \"Freetype build type is {}local\".format(\n+                \"\" if ft2font.__freetype_build_type__ == 'local' else \"not \"))\n+\n+\n+@_api.deprecated(\"3.5\", alternative='pytest')\n+def test(verbosity=None, coverage=False, **kwargs):\n+    \"\"\"Run the matplotlib test suite.\"\"\"\n+\n+    try:\n+        import pytest\n+    except ImportError:\n+        print(\"matplotlib.test requires pytest to run.\")\n+        return -1\n+\n+    if not os.path.isdir(os.path.join(os.path.dirname(__file__), 'tests')):\n+        print(\"Matplotlib test data is not installed\")\n+        return -1\n+\n+    old_backend = get_backend()\n+    try:\n+        use('agg')\n+\n+        args = kwargs.pop('argv', [])\n+        provide_default_modules = True\n+        use_pyargs = True\n+        for arg in args:\n+            if any(arg.startswith(module_path)\n+                   for module_path in default_test_modules):\n+                provide_default_modules = False\n+                break\n+            if os.path.exists(arg):\n+                provide_default_modules = False\n+                use_pyargs = False\n+                break\n+        if use_pyargs:\n+            args += ['--pyargs']\n+        if provide_default_modules:\n+            args += default_test_modules\n+\n+        if coverage:\n+            args += ['--cov']\n+\n+        if verbosity:\n+            args += ['-' + 'v' * verbosity]\n+\n+        retcode = pytest.main(args, **kwargs)\n+    finally:\n+        if old_backend.lower() != 'agg':\n+            use(old_backend)\n+\n+    return retcode\n+\n+\n+test.__test__ = False  # pytest: this function is not a test\n+\n+\n+def _replacer(data, value):\n+    \"\"\"\n+    Either returns ``data[value]`` or passes ``data`` back, converts either to\n+    a sequence.\n+    \"\"\"\n+    try:\n+        # if key isn't a string don't bother\n+        if isinstance(value, str):\n+            # try to use __getitem__\n+            value = data[value]\n+    except Exception:\n+        # key does not exist, silently fall back to key\n+        pass\n+    return sanitize_sequence(value)\n+\n+\n+def _label_from_arg(y, default_name):\n+    try:\n+        return y.name\n+    except AttributeError:\n+        if isinstance(default_name, str):\n+            return default_name\n+    return None\n+\n+\n+def _add_data_doc(docstring, replace_names):\n+    \"\"\"\n+    Add documentation for a *data* field to the given docstring.\n+\n+    Parameters\n+    ----------\n+    docstring : str\n+        The input docstring.\n+    replace_names : list of str or None\n+        The list of parameter names which arguments should be replaced by\n+        ``data[name]`` (if ``data[name]`` does not throw an exception).  If\n+        None, replacement is attempted for all arguments.\n+\n+    Returns\n+    -------\n+    str\n+        The augmented docstring.\n+    \"\"\"\n+    if (docstring is None\n+            or replace_names is not None and len(replace_names) == 0):\n+        return docstring\n+    docstring = inspect.cleandoc(docstring)\n+\n+    data_doc = (\"\"\"\\\n+    If given, all parameters also accept a string ``s``, which is\n+    interpreted as ``data[s]`` (unless this raises an exception).\"\"\"\n+                if replace_names is None else f\"\"\"\\\n+    If given, the following parameters also accept a string ``s``, which is\n+    interpreted as ``data[s]`` (unless this raises an exception):\n+\n+    {', '.join(map('*{}*'.format, replace_names))}\"\"\")\n+    # using string replacement instead of formatting has the advantages\n+    # 1) simpler indent handling\n+    # 2) prevent problems with formatting characters '{', '%' in the docstring\n+    if _log.level <= logging.DEBUG:\n+        # test_data_parameter_replacement() tests against these log messages\n+        # make sure to keep message and test in sync\n+        if \"data : indexable object, optional\" not in docstring:\n+            _log.debug(\"data parameter docstring error: no data parameter\")\n+        if 'DATA_PARAMETER_PLACEHOLDER' not in docstring:\n+            _log.debug(\"data parameter docstring error: missing placeholder\")\n+    return docstring.replace('    DATA_PARAMETER_PLACEHOLDER', data_doc)\n+\n+\n+def _preprocess_data(func=None, *, replace_names=None, label_namer=None):\n+    \"\"\"\n+    A decorator to add a 'data' kwarg to a function.\n+\n+    When applied::\n+\n+        @_preprocess_data()\n+        def func(ax, *args, **kwargs): ...\n+\n+    the signature is modified to ``decorated(ax, *args, data=None, **kwargs)``\n+    with the following behavior:\n+\n+    - if called with ``data=None``, forward the other arguments to ``func``;\n+    - otherwise, *data* must be a mapping; for any argument passed in as a\n+      string ``name``, replace the argument by ``data[name]`` (if this does not\n+      throw an exception), then forward the arguments to ``func``.\n+\n+    In either case, any argument that is a `MappingView` is also converted to a\n+    list.\n+\n+    Parameters\n+    ----------\n+    replace_names : list of str or None, default: None\n+        The list of parameter names for which lookup into *data* should be\n+        attempted. If None, replacement is attempted for all arguments.\n+    label_namer : str, default: None\n+        If set e.g. to \"namer\" (which must be a kwarg in the function's\n+        signature -- not as ``**kwargs``), if the *namer* argument passed in is\n+        a (string) key of *data* and no *label* kwarg is passed, then use the\n+        (string) value of the *namer* as *label*. ::\n+\n+            @_preprocess_data(label_namer=\"foo\")\n+            def func(foo, label=None): ...\n+\n+            func(\"key\", data={\"key\": value})\n+            # is equivalent to\n+            func.__wrapped__(value, label=\"key\")\n+    \"\"\"\n+\n+    if func is None:  # Return the actual decorator.\n+        return functools.partial(\n+            _preprocess_data,\n+            replace_names=replace_names, label_namer=label_namer)\n+\n+    sig = inspect.signature(func)\n+    varargs_name = None\n+    varkwargs_name = None\n+    arg_names = []\n+    params = list(sig.parameters.values())\n+    for p in params:\n+        if p.kind is Parameter.VAR_POSITIONAL:\n+            varargs_name = p.name\n+        elif p.kind is Parameter.VAR_KEYWORD:\n+            varkwargs_name = p.name\n+        else:\n+            arg_names.append(p.name)\n+    data_param = Parameter(\"data\", Parameter.KEYWORD_ONLY, default=None)\n+    if varkwargs_name:\n+        params.insert(-1, data_param)\n+    else:\n+        params.append(data_param)\n+    new_sig = sig.replace(parameters=params)\n+    arg_names = arg_names[1:]  # remove the first \"ax\" / self arg\n+\n+    assert {*arg_names}.issuperset(replace_names or []) or varkwargs_name, (\n+        \"Matplotlib internal error: invalid replace_names ({!r}) for {!r}\"\n+        .format(replace_names, func.__name__))\n+    assert label_namer is None or label_namer in arg_names, (\n+        \"Matplotlib internal error: invalid label_namer ({!r}) for {!r}\"\n+        .format(label_namer, func.__name__))\n+\n+    @functools.wraps(func)\n+    def inner(ax, *args, data=None, **kwargs):\n+        if data is None:\n+            return func(ax, *map(sanitize_sequence, args), **kwargs)\n+\n+        bound = new_sig.bind(ax, *args, **kwargs)\n+        auto_label = (bound.arguments.get(label_namer)\n+                      or bound.kwargs.get(label_namer))\n+\n+        for k, v in bound.arguments.items():\n+            if k == varkwargs_name:\n+                for k1, v1 in v.items():\n+                    if replace_names is None or k1 in replace_names:\n+                        v[k1] = _replacer(data, v1)\n+            elif k == varargs_name:\n+                if replace_names is None:\n+                    bound.arguments[k] = tuple(_replacer(data, v1) for v1 in v)\n+            else:\n+                if replace_names is None or k in replace_names:\n+                    bound.arguments[k] = _replacer(data, v)\n+\n+        new_args = bound.args\n+        new_kwargs = bound.kwargs\n+\n+        args_and_kwargs = {**bound.arguments, **bound.kwargs}\n+        if label_namer and \"label\" not in args_and_kwargs:\n+            new_kwargs[\"label\"] = _label_from_arg(\n+                args_and_kwargs.get(label_namer), auto_label)\n+\n+        return func(*new_args, **new_kwargs)\n+\n+    inner.__doc__ = _add_data_doc(inner.__doc__, replace_names)\n+    inner.__signature__ = new_sig\n+    return inner\n+\n+\n+_log.debug('interactive is %s', is_interactive())\n+_log.debug('platform is %s', sys.platform)\n+\n+\n+# workaround: we must defer colormaps import to after loading rcParams, because\n+# colormap creation depends on rcParams\n+from matplotlib.cm import _colormaps as colormaps\n+from matplotlib.colors import _color_sequences as color_sequences\ndiff --git a/test_bug.py b/test_bug.py\nnew file mode 100644\nindex 0000000000..0fa19b659e\n--- /dev/null\n+++ b/test_bug.py\n@@ -0,0 +1,12 @@\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+\n+# fig1 = plt.figure()  # <- UNCOMMENT THIS LINE AND IT WILL WORK\n+# plt.ion()            # <- ALTERNATIVELY, UNCOMMENT THIS LINE AND IT WILL ALSO WORK\n+with rc_context():\n+    fig2 = plt.figure()\n+before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+get_backend()\n+after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+assert before == after, '\\n' + before + '\\n' + after\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..9f3af43147\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,72 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+\n+print(\"Test 1: Original bug - figure created in rc_context should not be removed\")\n+with rc_context():\n+    fig1 = plt.figure()\n+before = len(plt._pylab_helpers.Gcf.figs)\n+backend = get_backend()\n+after = len(plt._pylab_helpers.Gcf.figs)\n+assert before == after == 1, f\"Expected 1 figure, but before={before}, after={after}\"\n+print(f\"\u2713 Test 1 passed: backend={backend}, figures preserved\")\n+plt.close('all')\n+\n+print(\"\\nTest 2: Figure created outside rc_context\")\n+fig2 = plt.figure()\n+before = len(plt._pylab_helpers.Gcf.figs)\n+backend = get_backend()\n+after = len(plt._pylab_helpers.Gcf.figs)\n+assert before == after == 1, f\"Expected 1 figure, but before={before}, after={after}\"\n+print(f\"\u2713 Test 2 passed: backend={backend}, figures preserved\")\n+plt.close('all')\n+\n+print(\"\\nTest 3: Multiple calls to get_backend\")\n+fig3 = plt.figure()\n+for i in range(3):\n+    before = len(plt._pylab_helpers.Gcf.figs)\n+    backend = get_backend()\n+    after = len(plt._pylab_helpers.Gcf.figs)\n+    assert before == after == 1, f\"Expected 1 figure on iteration {i}, but before={before}, after={after}\"\n+print(f\"\u2713 Test 3 passed: Multiple get_backend() calls work correctly\")\n+plt.close('all')\n+\n+print(\"\\nTest 4: Nested rc_context\")\n+with rc_context():\n+    fig4 = plt.figure()\n+    with rc_context():\n+        fig5 = plt.figure()\n+    before = len(plt._pylab_helpers.Gcf.figs)\n+    backend = get_backend()\n+    after = len(plt._pylab_helpers.Gcf.figs)\n+    assert before == after == 2, f\"Expected 2 figures, but before={before}, after={after}\"\n+print(f\"\u2713 Test 4 passed: Nested rc_context works correctly\")\n+plt.close('all')\n+\n+print(\"\\nAll tests passed!\")\n+\n+# Test the original issue examples from the bug report\n+print(\"\\nTesting original issue examples:\")\n+\n+# First uncommented line example\n+matplotlib._pylab_helpers.Gcf.figs.clear()\n+matplotlib.pyplot._backend_mod = None\n+matplotlib.rcParams['backend'] = matplotlib.rcsetup._auto_backend_sentinel\n+\n+fig1 = plt.figure()\n+with rc_context():\n+    fig2 = plt.figure()\n+before = len(plt._pylab_helpers.Gcf.figs)\n+get_backend()\n+after = len(plt._pylab_helpers.Gcf.figs)\n+assert before == after == 2, f\"With fig before rc_context: Expected 2 figures, but before={before}, after={after}\"\n+print(\"\u2713 Example with figure before rc_context works\")\n+plt.close('all')\n+\n+# Test plt.close() still works\n+print(\"\\nTest plt.close() functionality:\")\n+fig = plt.figure()\n+assert len(plt._pylab_helpers.Gcf.figs) == 1\n+plt.close(fig)\n+assert len(plt._pylab_helpers.Gcf.figs) == 0\n+print(\"\u2713 plt.close() works correctly\")\ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..ed26cd92fd\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,27 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context, rcParams\n+import matplotlib.rcsetup as rcsetup\n+\n+print(\"Initial backend:\", dict.__getitem__(rcParams, 'backend'))\n+print(\"Is auto sentinel?\", dict.__getitem__(rcParams, 'backend') is rcsetup._auto_backend_sentinel)\n+\n+# Check if plt was already imported before rc_context\n+with rc_context():\n+    fig2 = plt.figure()\n+    print(\"\\nAfter creating figure in rc_context:\")\n+    print(\"Backend:\", dict.__getitem__(rcParams, 'backend'))\n+    print(\"Is auto sentinel?\", dict.__getitem__(rcParams, 'backend') is rcsetup._auto_backend_sentinel)\n+    print(\"Gcf.figs:\", plt._pylab_helpers.Gcf.figs)\n+\n+print(\"\\nBefore get_backend():\")\n+print(\"Backend:\", dict.__getitem__(rcParams, 'backend'))\n+print(\"Is auto sentinel?\", dict.__getitem__(rcParams, 'backend') is rcsetup._auto_backend_sentinel)\n+print(\"Gcf.figs:\", plt._pylab_helpers.Gcf.figs)\n+\n+backend = get_backend()\n+print(\"\\nAfter get_backend():\")\n+print(\"Backend returned:\", backend)\n+print(\"Backend:\", dict.__getitem__(rcParams, 'backend'))\n+print(\"Is auto sentinel?\", dict.__getitem__(rcParams, 'backend') is rcsetup._auto_backend_sentinel)\n+print(\"Gcf.figs:\", plt._pylab_helpers.Gcf.figs)\ndiff --git a/test_debug2.py b/test_debug2.py\nnew file mode 100644\nindex 0000000000..238c97a5f4\n--- /dev/null\n+++ b/test_debug2.py\n@@ -0,0 +1,23 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context, rcParams\n+import matplotlib.rcsetup as rcsetup\n+\n+print(\"pyplot._backend_mod before anything:\", plt._backend_mod)\n+\n+with rc_context():\n+    fig2 = plt.figure()\n+    print(\"\\nAfter creating figure in rc_context:\")\n+    print(\"pyplot._backend_mod:\", plt._backend_mod)\n+    \n+print(\"\\nAfter exiting rc_context:\")\n+print(\"pyplot._backend_mod:\", plt._backend_mod)\n+\n+print(\"\\nBefore get_backend():\")\n+print(\"Gcf.figs:\", plt._pylab_helpers.Gcf.figs)\n+\n+backend = get_backend()\n+print(\"\\nAfter get_backend():\")\n+print(\"Backend returned:\", backend)\n+print(\"pyplot._backend_mod:\", plt._backend_mod)\n+print(\"Gcf.figs:\", plt._pylab_helpers.Gcf.figs)\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..3ffeb02d76\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,47 @@\n+import matplotlib\n+import matplotlib.pyplot as plt\n+from matplotlib import rc_context, get_backend\n+import matplotlib.rcsetup\n+\n+# Test 1: Ensure get_backend works before any figures are created\n+print(\"Test 1: get_backend() before any figures\")\n+backend = get_backend()\n+print(f\"\u2713 Backend: {backend}\")\n+\n+# Test 2: Backend switching still works normally\n+print(\"\\nTest 2: Backend switching works\")\n+try:\n+    matplotlib.use('Agg', force=True)\n+    backend = get_backend()\n+    assert backend == 'agg', f\"Expected 'agg' but got {backend}\"\n+    print(\"\u2713 Backend switching works\")\n+except Exception as e:\n+    print(f\"\u2717 Backend switching failed: {e}\")\n+\n+# Test 3: rc_context with explicit backend setting\n+print(\"\\nTest 3: rc_context with explicit backend\")\n+with rc_context({'backend': 'agg'}):\n+    fig = plt.figure()\n+    backend_inside = get_backend()\n+    assert backend_inside == 'agg'\n+backend_outside = get_backend()\n+nfigs = len(plt.get_fignums())\n+assert nfigs == 1, f\"Expected 1 figure but got {nfigs}\"\n+print(f\"\u2713 rc_context with explicit backend works, figures preserved\")\n+\n+plt.close('all')\n+\n+# Test 4: Verify the auto sentinel behavior is preserved for fresh start\n+print(\"\\nTest 4: Auto sentinel behavior\")\n+# Reset to initial state\n+matplotlib._pylab_helpers.Gcf.figs.clear()\n+matplotlib.pyplot._backend_mod = None\n+matplotlib.rcParams['backend'] = matplotlib.rcsetup._auto_backend_sentinel\n+\n+# When no backend is loaded and we create a figure, it should auto-detect\n+fig = plt.figure()\n+backend = get_backend()\n+assert backend != matplotlib.rcsetup._auto_backend_sentinel, \"Backend should be resolved, not sentinel\"\n+print(f\"\u2713 Auto backend resolution works: {backend}\")\n+\n+print(\"\\nAll edge case tests passed!\")\ndiff --git a/test_exact_bug_scenario.py b/test_exact_bug_scenario.py\nnew file mode 100644\nindex 0000000000..fd27b905ab\n--- /dev/null\n+++ b/test_exact_bug_scenario.py\n@@ -0,0 +1,21 @@\n+#!/usr/bin/env python\n+\"\"\"Test the exact scenario from the bug report\"\"\"\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+\n+# Exact code from the bug report\n+# fig1 = plt.figure()  # <- UNCOMMENT THIS LINE AND IT WILL WORK\n+# plt.ion()            # <- ALTERNATIVELY, UNCOMMENT THIS LINE AND IT WILL ALSO WORK\n+with rc_context():\n+    fig2 = plt.figure()\n+before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+get_backend()\n+after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+assert before == after, '\\n' + before + '\\n' + after\n+print(\"\u2713 Bug is fixed: Figures are preserved after get_backend()\")\n+\n+# Also test that plt.close works as mentioned in the bug report  \n+plt.close(fig2)\n+assert len(plt._pylab_helpers.Gcf.figs) == 0, \"plt.close should remove the figure\"\n+print(\"\u2713 plt.close(fig2) works correctly\")\ndiff --git a/test_uncommented_scenarios.py b/test_uncommented_scenarios.py\nnew file mode 100644\nindex 0000000000..8b13789179\n--- /dev/null\n+++ b/test_uncommented_scenarios.py\n@@ -0,0 +1 @@\n+\n", "gold_standard_diff": "From 7fce03e84b41526c55e07ce9a1c6b8298f9809b3 Mon Sep 17 00:00:00 2001\nFrom: Thomas A Caswell <tcaswell@gmail.com>\nDate: Fri, 17 Jun 2022 21:29:36 -0400\nSubject: [PATCH 1/4] FIX/API: Do not reset rcParams['backend'] in rc_context\n\nThe motivating issue is that if the backend was the auto backend sentinel and\nthe backend was first fully resolved in an `rc_context` block, then we would\nreset back to the sentinel an exit which would lead to strange behavior with\nfigures being erroneously closed.\n\nThis special cases the 'backend' key to not be reset on `__exit__`\n\nCloses #23298\n---\n doc/api/next_api_changes/behavior/23299-TAC.rst | 9 +++++++++\n lib/matplotlib/__init__.py                      | 5 ++++-\n lib/matplotlib/tests/test_rcparams.py           | 7 +++++++\n 3 files changed, 20 insertions(+), 1 deletion(-)\n create mode 100644 doc/api/next_api_changes/behavior/23299-TAC.rst\n\ndiff --git a/doc/api/next_api_changes/behavior/23299-TAC.rst b/doc/api/next_api_changes/behavior/23299-TAC.rst\nnew file mode 100644\nindex 000000000000..95116f65c553\n--- /dev/null\n+++ b/doc/api/next_api_changes/behavior/23299-TAC.rst\n@@ -0,0 +1,9 @@\n+mpl.rc_context no longer resests the `'backend'` key\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+If you want to rest :rc:`backend` after the context, you must use\n+`matplotlib.use` to change the backend.  Previously the key would be reset, but\n+it would have any of the expected side-effects because internally\n+`matplotlib.rc_context` side-steps the custom logic in the\n+`~matplotlib.RcParams` class (because we copied the values from ``rcParamms``\n+so it does not need to be re-validated.\ndiff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex c268a56724c9..528be266ffac 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -1059,6 +1059,8 @@ def rc_context(rc=None, fname=None):\n     \"\"\"\n     Return a context manager for temporarily changing rcParams.\n \n+    The :rc:`backend` will not be reset by the context manager.\n+\n     Parameters\n     ----------\n     rc : dict\n@@ -1087,7 +1089,8 @@ def rc_context(rc=None, fname=None):\n              plt.plot(x, y)  # uses 'print.rc'\n \n     \"\"\"\n-    orig = rcParams.copy()\n+    orig = dict(rcParams.copy())\n+    del orig['backend']\n     try:\n         if fname:\n             rc_file(fname)\ndiff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 99856b344255..d5f316f54595 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -496,6 +496,13 @@ def test_keymaps():\n         assert isinstance(mpl.rcParams[k], list)\n \n \n+def test_no_backend_reset_rccontext():\n+    assert mpl.rcParams['backend'] != 'module://aardvark'\n+    with mpl.rc_context():\n+        mpl.rcParams['backend'] = 'module://aardvark'\n+    assert mpl.rcParams['backend'] == 'module://aardvark'\n+\n+\n def test_rcparams_reset_after_fail():\n     # There was previously a bug that meant that if rc_context failed and\n     # raised an exception due to issues in the supplied rc parameters, the\n\nFrom da15745b530daf6cc5b92e660066f48cb7b47429 Mon Sep 17 00:00:00 2001\nFrom: Thomas A Caswell <tcaswell@gmail.com>\nDate: Wed, 22 Jun 2022 14:24:13 -0400\nSubject: [PATCH 2/4] DOC: Simplify API note text\n\nCo-authored-by: Tim Hoffmann <2836374+timhoffm@users.noreply.github.com>\n---\n doc/api/next_api_changes/behavior/23299-TAC.rst | 11 ++++-------\n 1 file changed, 4 insertions(+), 7 deletions(-)\n\ndiff --git a/doc/api/next_api_changes/behavior/23299-TAC.rst b/doc/api/next_api_changes/behavior/23299-TAC.rst\nindex 95116f65c553..530912929d6f 100644\n--- a/doc/api/next_api_changes/behavior/23299-TAC.rst\n+++ b/doc/api/next_api_changes/behavior/23299-TAC.rst\n@@ -1,9 +1,6 @@\n-mpl.rc_context no longer resests the `'backend'` key\n+mpl.rc_context no longer resests the value of `rcParams['backend']`\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-If you want to rest :rc:`backend` after the context, you must use\n-`matplotlib.use` to change the backend.  Previously the key would be reset, but\n-it would have any of the expected side-effects because internally\n-`matplotlib.rc_context` side-steps the custom logic in the\n-`~matplotlib.RcParams` class (because we copied the values from ``rcParamms``\n-so it does not need to be re-validated.\n+`matplotlib.rc_context` did incorrectly reset the value of `rcParams['backend']` if backend\n+resolution was triggered in the context. This affected only the value. The actual backend\n+was not reset. Now, `matpotlib.rc_context` dose not modify `rcParams['backend']` anymore.\n\nFrom 545fff0b35a9448900802360ffb6093ef83eb2ed Mon Sep 17 00:00:00 2001\nFrom: Thomas A Caswell <tcaswell@gmail.com>\nDate: Wed, 22 Jun 2022 14:25:19 -0400\nSubject: [PATCH 3/4] DOC: minor re-wording of API note\n\n---\n doc/api/next_api_changes/behavior/23299-TAC.rst | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/doc/api/next_api_changes/behavior/23299-TAC.rst b/doc/api/next_api_changes/behavior/23299-TAC.rst\nindex 530912929d6f..6602f15e4fc3 100644\n--- a/doc/api/next_api_changes/behavior/23299-TAC.rst\n+++ b/doc/api/next_api_changes/behavior/23299-TAC.rst\n@@ -1,6 +1,6 @@\n-mpl.rc_context no longer resests the value of `rcParams['backend']`\n-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+mpl.rc_context no longer resets the value of :rc:`backend`\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-`matplotlib.rc_context` did incorrectly reset the value of `rcParams['backend']` if backend\n+`matplotlib.rc_context` incorrectly reset the value of :rc:`backend` if backend\n resolution was triggered in the context. This affected only the value. The actual backend\n-was not reset. Now, `matpotlib.rc_context` dose not modify `rcParams['backend']` anymore.\n+was not changed. Now, `matplotlib.rc_context` does not reset  :rc:`backend` anymore.\n\nFrom 4d6bab4cfd74d8c13dfd2321cc0ad1cb3eaecd9f Mon Sep 17 00:00:00 2001\nFrom: Thomas A Caswell <tcaswell@gmail.com>\nDate: Mon, 27 Jun 2022 21:24:38 -0400\nSubject: [PATCH 4/4] DOC: make title shorter\n\n---\n doc/api/next_api_changes/behavior/23299-TAC.rst | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/doc/api/next_api_changes/behavior/23299-TAC.rst b/doc/api/next_api_changes/behavior/23299-TAC.rst\nindex 6602f15e4fc3..745bd47d6c6b 100644\n--- a/doc/api/next_api_changes/behavior/23299-TAC.rst\n+++ b/doc/api/next_api_changes/behavior/23299-TAC.rst\n@@ -1,4 +1,4 @@\n-mpl.rc_context no longer resets the value of :rc:`backend`\n+mpl.rc_context no longer resets the value of ``'backend'``\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n `matplotlib.rc_context` incorrectly reset the value of :rc:`backend` if backend\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/23299"}