{"instance_id": "django__django-12708", "score": "C", "diff": "diff --git a/debug_constraints.py b/debug_constraints.py\nnew file mode 100644\nindex 0000000000..624850f18f\n--- /dev/null\n+++ b/debug_constraints.py\n@@ -0,0 +1,62 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Create a test model with both index_together and unique_together\n+class TestModel(models.Model):\n+    field1 = models.CharField(max_length=50)\n+    field2 = models.CharField(max_length=50)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+def debug_constraints():\n+    # Create the table\n+    with connection.schema_editor() as editor:\n+        editor.create_model(TestModel)\n+        \n+        # Add both index_together and unique_together\n+        editor.alter_index_together(TestModel, [], [['field1', 'field2']])\n+        editor.alter_unique_together(TestModel, [], [['field1', 'field2']])\n+        \n+        print(\"Created model with index_together and unique_together\")\n+        \n+        # Check what constraints exist\n+        with connection.cursor() as cursor:\n+            constraints = connection.introspection.get_constraints(cursor, 'test_model')\n+            print(\"\\nAll constraints:\")\n+            for name, info in constraints.items():\n+                print(f\"  {name}: {info}\")\n+        \n+        # Check what _constraint_names returns for index=True\n+        columns = ['field1', 'field2']\n+        constraint_names = editor._constraint_names(TestModel, columns, index=True)\n+        print(f\"\\nConstraints with index=True: {constraint_names}\")\n+        \n+        # Check what _constraint_names returns for unique=True\n+        constraint_names = editor._constraint_names(TestModel, columns, unique=True)\n+        print(f\"Constraints with unique=True: {constraint_names}\")\n+\n+if __name__ == '__main__':\n+    debug_constraints()\ndiff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401ab..4a509c43df 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -407,6 +407,16 @@ class BaseDatabaseSchemaEditor:\n             model, columns, exclude=meta_constraint_names | meta_index_names,\n             **constraint_kwargs\n         )\n+        # When we're looking for an index to delete but not a unique constraint,\n+        # we need to exclude unique constraints that also have index=True\n+        if constraint_kwargs.get('index') and not constraint_kwargs.get('unique'):\n+            # Filter out any constraints that are unique\n+            with self.connection.cursor() as cursor:\n+                constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)\n+            constraint_names = [\n+                name for name in constraint_names\n+                if not constraints.get(name, {}).get('unique', False)\n+            ]\n         if len(constraint_names) != 1:\n             raise ValueError(\"Found wrong number (%s) of constraints for %s(%s)\" % (\n                 len(constraint_names),\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..7a24910fb3\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,54 @@\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Create a test model with both index_together and unique_together\n+class TestModel(models.Model):\n+    field1 = models.CharField(max_length=50)\n+    field2 = models.CharField(max_length=50)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+def reproduce_issue():\n+    # Create the table\n+    with connection.schema_editor() as editor:\n+        editor.create_model(TestModel)\n+        \n+        # Add both index_together and unique_together\n+        editor.alter_index_together(TestModel, [], [['field1', 'field2']])\n+        editor.alter_unique_together(TestModel, [], [['field1', 'field2']])\n+        \n+        print(\"Successfully created model with index_together and unique_together\")\n+        \n+        # Try to remove index_together - this should fail\n+        try:\n+            editor.alter_index_together(TestModel, [['field1', 'field2']], [])\n+            print(\"Successfully removed index_together\")\n+        except ValueError as e:\n+            print(f\"ERROR: {e}\")\n+            print(\"This is the bug we need to fix!\")\n+\n+if __name__ == '__main__':\n+    reproduce_issue()\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/test_index_unique_together.py b/test_index_unique_together.py\nnew file mode 100644\nindex 0000000000..791cca826b\n--- /dev/null\n+++ b/test_index_unique_together.py\n@@ -0,0 +1,48 @@\n+from django.db import models, connection\n+from django.db.migrations import Migration, CreateModel, AlterIndexTogether, AlterUniqueTogether\n+from django.db.migrations.state import ProjectState\n+from django.test import TestCase\n+from django.db.backends.base.schema import BaseDatabaseSchemaEditor\n+\n+# Test model\n+class TestModel(models.Model):\n+    field1 = models.CharField(max_length=50)\n+    field2 = models.CharField(max_length=50)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+# Create a test to reproduce the issue\n+def test_delete_index_together_with_unique_together():\n+    # Create initial state with both index_together and unique_together\n+    initial_state = ProjectState()\n+    initial_state.add_model(TestModel._meta.object_name, \n+                           fields=[\n+                               ('id', models.AutoField(primary_key=True)),\n+                               ('field1', models.CharField(max_length=50)),\n+                               ('field2', models.CharField(max_length=50)),\n+                           ],\n+                           options={\n+                               'index_together': [['field1', 'field2']],\n+                               'unique_together': [['field1', 'field2']],\n+                               'db_table': 'test_model',\n+                           },\n+                           app_label='test_app')\n+    \n+    # Create migration to remove index_together\n+    migration = Migration('test_migration', 'test_app')\n+    migration.operations = [\n+        AlterIndexTogether(\n+            name='TestModel',\n+            index_together=[],\n+        ),\n+    ]\n+    \n+    # Apply migration\n+    with connection.schema_editor() as editor:\n+        # This should fail with ValueError\n+        migration.apply(initial_state, editor)\n+\n+if __name__ == '__main__':\n+    test_delete_index_together_with_unique_together()\ndiff --git a/test_index_unique_together_fix.py b/test_index_unique_together_fix.py\nnew file mode 100644\nindex 0000000000..9974807c7d\n--- /dev/null\n+++ b/test_index_unique_together_fix.py\n@@ -0,0 +1,120 @@\n+\"\"\"\n+Test case for the fix of deleting index_together when unique_together exists on the same fields.\n+\n+This test ensures that when both index_together and unique_together are defined on the same\n+fields, we can successfully delete the index_together without getting a ValueError.\n+\n+This resolves the issue described in Django ticket where the deletion of index_together\n+was failing with \"Found wrong number (2) of constraints\" error.\n+\"\"\"\n+\n+import os\n+import django\n+from django.conf import settings\n+from django.test import TestCase, TransactionTestCase\n+from django.db import models, connection\n+\n+# Configure Django if not already configured\n+if not settings.configured:\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+        USE_TZ=True,\n+    )\n+    django.setup()\n+\n+\n+class TestModel(models.Model):\n+    field1 = models.CharField(max_length=50)\n+    field2 = models.CharField(max_length=50)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        db_table = 'test_model'\n+\n+\n+class IndexUniqueTogetherTest(TransactionTestCase):\n+    \"\"\"Test case for index_together and unique_together interaction.\"\"\"\n+    \n+    def test_delete_index_together_with_unique_together(self):\n+        \"\"\"Test that index_together can be deleted when unique_together exists on the same fields.\"\"\"\n+        # Disable FK checks for SQLite\n+        with connection.cursor() as cursor:\n+            cursor.execute(\"PRAGMA foreign_keys = OFF\")\n+        \n+        with connection.schema_editor() as editor:\n+            # Create the model\n+            editor.create_model(TestModel)\n+            \n+            # Add both index_together and unique_together on the same fields\n+            editor.alter_index_together(TestModel, [], [['field1', 'field2']])\n+            editor.alter_unique_together(TestModel, [], [['field1', 'field2']])\n+            \n+            # This should not raise ValueError anymore\n+            editor.alter_index_together(TestModel, [['field1', 'field2']], [])\n+            \n+            # Verify the unique constraint still exists\n+            with connection.cursor() as cursor:\n+                constraints = connection.introspection.get_constraints(cursor, 'test_model')\n+                unique_constraints = [\n+                    name for name, info in constraints.items()\n+                    if info['unique'] and info['columns'] == ['field1', 'field2']\n+                ]\n+                self.assertEqual(len(unique_constraints), 1)\n+            \n+            # Clean up\n+            editor.delete_model(TestModel)\n+    \n+    def test_delete_unique_together_with_index_together(self):\n+        \"\"\"Test that unique_together can be deleted when index_together exists on the same fields.\"\"\"\n+        # Disable FK checks for SQLite\n+        with connection.cursor() as cursor:\n+            cursor.execute(\"PRAGMA foreign_keys = OFF\")\n+        \n+        with connection.schema_editor() as editor:\n+            # Create the model\n+            editor.create_model(TestModel)\n+            \n+            # Add both index_together and unique_together on the same fields\n+            editor.alter_index_together(TestModel, [], [['field1', 'field2']])\n+            editor.alter_unique_together(TestModel, [], [['field1', 'field2']])\n+            \n+            # This should work correctly\n+            editor.alter_unique_together(TestModel, [['field1', 'field2']], [])\n+            \n+            # Verify the index still exists\n+            with connection.cursor() as cursor:\n+                constraints = connection.introspection.get_constraints(cursor, 'test_model')\n+                index_constraints = [\n+                    name for name, info in constraints.items()\n+                    if info['index'] and not info['unique'] and info['columns'] == ['field1', 'field2']\n+                ]\n+                self.assertEqual(len(index_constraints), 1)\n+            \n+            # Clean up\n+            editor.delete_model(TestModel)\n+\n+\n+if __name__ == '__main__':\n+    # Run as standalone test\n+    from django.test import TestCase\n+    import unittest\n+    \n+    # Create test suite\n+    suite = unittest.TestSuite()\n+    suite.addTest(IndexUniqueTogetherTest('test_delete_index_together_with_unique_together'))\n+    suite.addTest(IndexUniqueTogetherTest('test_delete_unique_together_with_index_together'))\n+    \n+    # Run tests\n+    runner = unittest.TextTestRunner(verbosity=2)\n+    result = runner.run(suite)\n+    \n+    # Exit with appropriate code\n+    exit(0 if result.wasSuccessful() else 1)\ndiff --git a/test_scenarios.py b/test_scenarios.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\n", "gold_standard_diff": "diff --git a/django/db/backends/base/schema.py b/django/db/backends/base/schema.py\nindex 61f88401abff..2e2d7bbb6039 100644\n--- a/django/db/backends/base/schema.py\n+++ b/django/db/backends/base/schema.py\n@@ -393,7 +393,12 @@ def alter_index_together(self, model, old_index_together, new_index_together):\n         news = {tuple(fields) for fields in new_index_together}\n         # Deleted indexes\n         for fields in olds.difference(news):\n-            self._delete_composed_index(model, fields, {'index': True}, self.sql_delete_index)\n+            self._delete_composed_index(\n+                model,\n+                fields,\n+                {'index': True, 'unique': False},\n+                self.sql_delete_index,\n+            )\n         # Created indexes\n         for field_names in news.difference(olds):\n             fields = [model._meta.get_field(field) for field in field_names]\ndiff --git a/tests/migrations/test_base.py b/tests/migrations/test_base.py\nindex c4c8b1ee6c10..28a57f552d25 100644\n--- a/tests/migrations/test_base.py\n+++ b/tests/migrations/test_base.py\n@@ -62,7 +62,11 @@ def assertIndexExists(self, table, columns, value=True, using='default', index_t\n                 any(\n                     c[\"index\"]\n                     for c in connections[using].introspection.get_constraints(cursor, table).values()\n-                    if c['columns'] == list(columns) and (index_type is None or c['type'] == index_type)\n+                    if (\n+                        c['columns'] == list(columns) and\n+                        (index_type is None or c['type'] == index_type) and\n+                        not c['unique']\n+                    )\n                 ),\n             )\n \n@@ -80,6 +84,14 @@ def assertConstraintExists(self, table, name, value=True, using='default'):\n     def assertConstraintNotExists(self, table, name):\n         return self.assertConstraintExists(table, name, False)\n \n+    def assertUniqueConstraintExists(self, table, columns, value=True, using='default'):\n+        with connections[using].cursor() as cursor:\n+            constraints = connections[using].introspection.get_constraints(cursor, table).values()\n+            self.assertEqual(\n+                value,\n+                any(c['unique'] for c in constraints if c['columns'] == list(columns)),\n+            )\n+\n     def assertFKExists(self, table, columns, to, value=True, using='default'):\n         with connections[using].cursor() as cursor:\n             self.assertEqual(\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 55c20213b01d..401cae6eae02 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,6 +1759,29 @@ def test_alter_index_together_remove(self):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_remove_with_unique_together(self):\n+        app_label = 'test_alintoremove_wunto'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        # Add index together.\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        # Remove index together.\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n     @skipUnlessDBFeature('supports_table_check_constraints')\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12708"}