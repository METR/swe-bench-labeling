{"instance_id": "django__django-11551", "score": "C", "diff": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2f1..9fd77b5d41 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\n", "gold_standard_diff": "From ed668796f6c7e59ca3f35e9d87d940e043a3eff3 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Wed, 10 Jul 2019 00:27:06 +0200\nSubject: [PATCH] Fixed #30543 -- Fixed checks of ModelAdmin.list_display for\n fields accessible only via instance.\n\nCo-Authored-By: Andrew Simons <andrewsimons@bubblegroup.com>\n---\n django/contrib/admin/checks.py  | 42 ++++++++++++++++-----------------\n tests/modeladmin/test_checks.py | 21 ++++++++++++++++-\n 2 files changed, 41 insertions(+), 22 deletions(-)\n\ndiff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2f170..0c32301284b4 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ def _check_list_display_item(self, obj, item, label):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        try:\n+            field = obj.model._meta.get_field(item)\n+        except FieldDoesNotExist:\n             try:\n-                field = obj.model._meta.get_field(item)\n-            except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n-                    return [\n-                        checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n-                            obj=obj.__class__,\n-                            id='admin.E109',\n-                        )\n-                    ]\n-                return []\n-        else:\n+                field = getattr(obj.model, item)\n+            except AttributeError:\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' refers to '%s', which is not a \"\n+                        \"callable, an attribute of '%s', or an attribute or \"\n+                        \"method on '%s.%s'.\" % (\n+                            label, item, obj.__class__.__name__,\n+                            obj.model._meta.app_label, obj.model._meta.object_name,\n+                        ),\n+                        obj=obj.__class__,\n+                        id='admin.E108',\n+                    )\n+                ]\n+        if isinstance(field, models.ManyToManyField):\n             return [\n                 checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n+                    \"The value of '%s' must not be a ManyToManyField.\" % label,\n                     obj=obj.__class__,\n-                    id='admin.E108',\n+                    id='admin.E109',\n                 )\n             ]\n+        return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex a1b7001f68e9..98cc56d67c3d 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -3,7 +3,7 @@\n from django.contrib.admin.options import VERTICAL, ModelAdmin, TabularInline\n from django.contrib.admin.sites import AdminSite\n from django.core.checks import Error\n-from django.db.models import F\n+from django.db.models import F, Field, Model\n from django.db.models.functions import Upper\n from django.forms.models import BaseModelFormSet\n from django.test import SimpleTestCase\n@@ -509,6 +509,25 @@ def a_method(self, obj):\n \n         self.assertIsValid(TestModelAdmin, ValidationTestModel)\n \n+    def test_valid_field_accessible_via_instance(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+\n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('field',)\n+\n+        self.assertIsValid(TestModelAdmin, TestModel)\n+\n \n class ListDisplayLinksCheckTests(CheckTestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/11551"}