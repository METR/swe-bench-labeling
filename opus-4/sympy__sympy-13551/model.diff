diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..f12f3ef316 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -275,18 +275,18 @@ def _eval_product(self, term, limits):
             return poly.LC()**(n - a + 1) * A * B
 
         elif term.is_Add:
-            p, q = term.as_numer_denom()
-            q = self._eval_product(q, (k, a, n))
-            if q.is_Number:
-
-                # There is expression, which couldn't change by
-                # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).
-                # We have to catch this case.
-
-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])
-            else:
-                p = self._eval_product(p, (k, a, n))
-            return p / q
+            # For Add expressions, we cannot split the product into a sum of products
+            # since Product(a + b) != Product(a) + Product(b)
+            # We should only handle special cases where we can factor or simplify
+            
+            # Try to see if we can factor the expression
+            factored = term.factor()
+            if factored != term and factored.is_Mul:
+                # If factoring gives us a multiplication, we can use the Mul handling
+                return self._eval_product(factored, (k, a, n))
+            
+            # Otherwise, we cannot evaluate this product in closed form
+            return None
 
         elif term.is_Mul:
             exclude, include = [], []
diff --git a/test_issue_regression.py b/test_issue_regression.py
new file mode 100644
index 0000000000..6640e5a532
--- /dev/null
+++ b/test_issue_regression.py
@@ -0,0 +1,44 @@
+"""
+Regression test for the Product issue where Product(n + 1 / 2**k, [k, 0, n-1]) 
+was incorrectly evaluated.
+
+The issue was that for Add expressions, the code was incorrectly trying to split
+the product into a sum of products, which is mathematically wrong:
+Product(a + b) != Product(a) + Product(b)
+"""
+
+from sympy import Product, simplify, Rational
+from sympy.abc import n, k
+
+def test_product_issue():
+    """Test that Product(n + 1/2**k, [k, 0, n-1]) evaluates correctly"""
+    
+    # Create the product
+    p = Product(n + 1 / 2**k, [k, 0, n-1])
+    
+    # Before the fix, this would incorrectly give 2**(n*(-n + 1)/2) + n**n
+    # which evaluates to 9/2 for n=2
+    result = p.doit()
+    
+    # Test n=2
+    # Product should be: (2 + 1/2^0) * (2 + 1/2^1) = (2 + 1) * (2 + 1/2) = 3 * 2.5 = 7.5 = 15/2
+    value_n2 = result.subs(n, 2).doit()
+    assert value_n2 == Rational(15, 2), f"Expected 15/2 for n=2, got {value_n2}"
+    
+    # Test n=3  
+    # Product should be: (3 + 1) * (3 + 1/2) * (3 + 1/4) = 4 * 3.5 * 3.25 = 45.5 = 91/2
+    value_n3 = result.subs(n, 3).doit()
+    assert value_n3 == Rational(91, 2), f"Expected 91/2 for n=3, got {value_n3}"
+    
+    # Test n=1
+    # Product should be: (1 + 1/2^0) = (1 + 1) = 2
+    value_n1 = result.subs(n, 1).doit()
+    assert value_n1 == 2, f"Expected 2 for n=1, got {value_n1}"
+    
+    print("All tests passed! The issue is fixed.")
+    print(f"Product(n + 1/2**k, [k, 0, n-1]) = {result}")
+    print(f"For n=2: {value_n2} (correct, was 9/2 before fix)")
+    print(f"For n=3: {value_n3}")
+
+if __name__ == "__main__":
+    test_product_issue()
diff --git a/test_product_fix.py b/test_product_fix.py
new file mode 100644
index 0000000000..40a76ab175
--- /dev/null
+++ b/test_product_fix.py
@@ -0,0 +1,86 @@
+from sympy import *
+from sympy.abc import n, k, m, x, i
+
+def test_issue_fix():
+    """Test that the original issue is fixed"""
+    p = Product(n + 1 / 2**k, [k, 0, n-1])
+    result = p.doit()
+    
+    # For n=2, the product should be (2 + 2^0) * (2 + 2^(-1)) = 3 * 2.5 = 7.5 = 15/2
+    assert result.subs(n, 2).doit() == Rational(15, 2)
+    
+    # For n=3, the product should be (3 + 1) * (3 + 1/2) * (3 + 1/4) = 4 * 3.5 * 3.25 = 45.5 = 91/2
+    assert result.subs(n, 3).doit() == Rational(91, 2)
+    
+    print("Original issue test passed!")
+
+def test_existing_functionality():
+    """Test that existing product functionality still works"""
+    
+    # Test 1: Simple product
+    assert Product(k, [k, 1, n]).doit() == factorial(n)
+    
+    # Test 2: Constant product
+    assert Product(5, [k, 1, n]).doit() == 5**n
+    
+    # Test 3: Power product
+    result = Product(2**k, [k, 1, n]).doit()
+    expected = 2**(n*(n + 1)/2)
+    assert simplify(result - expected) == 0
+    
+    # Test 4: Polynomial product with specific value
+    p = Product(k**2, [k, 1, 3]).doit()
+    assert p == 36  # 1 * 4 * 9 = 36
+    
+    # Test 5: Empty product
+    assert Product(k, [k, 1, 0]).doit() == 1
+    
+    # Test 6: Single term product
+    assert Product(k, [k, 5, 5]).doit() == 5
+    
+    print("Existing functionality tests passed!")
+
+def test_add_expressions():
+    """Test that Add expressions are handled correctly"""
+    
+    # Test 1: Non-factorable Add should remain unevaluated
+    p1 = Product(k + exp(k), [k, 1, n])
+    assert isinstance(p1.doit(), Product)
+    
+    # Test 2: Factorable Add should be evaluated
+    p2 = Product(2*(k + 1), [k, 1, n])  # This is actually Mul, not Add
+    result2 = p2.doit()
+    # RisingFactorial(2, n) = 2*3*...*(n+1) = factorial(n+1)/factorial(1) = factorial(n+1)
+    expected = 2**n * factorial(n+1)
+    assert simplify(result2.subs(n, 3) - expected.subs(n, 3)) == 0
+    
+    # Test 3: Complex Add expression
+    p3 = Product(k + I, [k, 1, 3])
+    result3 = p3.doit()
+    expected = (1 + I) * (2 + I) * (3 + I)
+    assert simplify(result3 - expected) == 0
+    
+    print("Add expression tests passed!")
+
+def test_edge_cases():
+    """Test edge cases"""
+    
+    # Test with symbolic limits
+    p1 = Product(k + 1, [k, m, n])
+    result1 = p1.doit()
+    # Should give rising factorial or remain unevaluated
+    
+    # Test with negative powers
+    p2 = Product(1 + 1/k, [k, 1, 3])
+    result2 = p2.doit()
+    expected = 2 * Rational(3, 2) * Rational(4, 3)
+    assert result2 == expected
+    
+    print("Edge case tests passed!")
+
+if __name__ == "__main__":
+    test_issue_fix()
+    test_existing_functionality()
+    test_add_expressions()
+    test_edge_cases()
+    print("\nAll tests passed!")
