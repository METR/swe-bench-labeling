diff --git a/setup.py b/setup.py
index 2538952e3..94e1d8b32 100644
--- a/setup.py
+++ b/setup.py
@@ -15,22 +15,22 @@ if sys.version_info < (3, 6):
     sys.exit(1)
 
 install_requires = [
-    'sphinxcontrib-applehelp',
-    'sphinxcontrib-devhelp',
+    'sphinxcontrib-applehelp<=1.0.7',
+    'sphinxcontrib-devhelp<=1.0.5',
     'sphinxcontrib-jsmath',
-    'sphinxcontrib-htmlhelp',
-    'sphinxcontrib-serializinghtml',
-    'sphinxcontrib-qthelp',
-    'Jinja2>=2.3',
+    'sphinxcontrib-htmlhelp<=2.0.4',
+    'sphinxcontrib-serializinghtml<=1.1.9',
+    'sphinxcontrib-qthelp<=1.0.6',
+    'Jinja2<3.0',
     'Pygments>=2.0',
     'docutils>=0.14,<0.18',
     'snowballstemmer>=1.1',
     'babel>=1.3',
-    'alabaster>=0.7,<0.8',
+    'alabaster>=0.7,<0.7.12',
     'imagesize',
     'requests>=2.5.0',
     'setuptools',
-    'packaging',
+    'packaging', 'markupsafe<=2.0.1',
 ]
 
 extras_require = {
diff --git a/sphinx/domains/python.py b/sphinx/domains/python.py
index 7d39d80ed..ba021b36b 100644
--- a/sphinx/domains/python.py
+++ b/sphinx/domains/python.py
@@ -304,7 +304,7 @@ class PyXrefMixin:
     def make_xrefs(self, rolename: str, domain: str, target: str,
                    innernode: Type[TextlikeNode] = nodes.emphasis,
                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:
-        delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+|\.\.\.)'
+        delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+|\s*\|\s*|\.\.\.)'
         delims_re = re.compile(delims)
         sub_targets = re.split(delims, target)
 
diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py
index 6d48e910c..b9f5511b0 100644
--- a/sphinx/util/docfields.py
+++ b/sphinx/util/docfields.py
@@ -75,7 +75,19 @@ class Field:
     def make_xrefs(self, rolename: str, domain: str, target: str,
                    innernode: Type[TextlikeNode] = addnodes.literal_emphasis,
                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:
-        return [self.make_xref(rolename, domain, target, innernode, contnode, env)]
+        # Check if this is a union type with pipe character
+        if '|' in target and domain == 'py':
+            # Split on pipe and create xrefs for each type
+            parts = [part.strip() for part in target.split('|')]
+            result: List[Node] = []
+            for i, part in enumerate(parts):
+                if i > 0:
+                    # Add separator between types
+                    result.append(nodes.Text(' | '))
+                result.append(self.make_xref(rolename, domain, part, innernode, None, env))
+            return result
+        else:
+            return [self.make_xref(rolename, domain, target, innernode, contnode, env)]
 
     def make_entry(self, fieldarg: str, content: List[Node]) -> Tuple[str, List[Node]]:
         return (fieldarg, content)
diff --git a/test_ext_docfields_union.py b/test_ext_docfields_union.py
new file mode 100644
index 000000000..c4004caa0
--- /dev/null
+++ b/test_ext_docfields_union.py
@@ -0,0 +1,106 @@
+"""
+Tests for union type support in docfields using pipe character
+
+This tests the enhancement that allows specifying multiple types using the | (pipe) character.
+"""
+
+import pytest
+from docutils import nodes
+from sphinx import addnodes
+from sphinx.util.docfields import Field, TypedField
+from sphinx.domains.python import PyTypedField, PyField, PyXrefMixin
+
+
+def test_field_make_xrefs_with_union():
+    """Test Field.make_xrefs with union types using pipe character"""
+    field = Field('test', label='Test')
+    
+    # Test single type (no pipe)
+    xrefs = field.make_xrefs('class', 'py', 'str')
+    assert len(xrefs) == 1
+    assert isinstance(xrefs[0], addnodes.pending_xref)
+    assert xrefs[0].get('reftarget') == 'str'
+    
+    # Test union type with pipe
+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')
+    assert len(xrefs) == 3
+    assert isinstance(xrefs[0], addnodes.pending_xref)
+    assert xrefs[0].get('reftarget') == 'bytes'
+    assert isinstance(xrefs[1], nodes.Text)
+    assert xrefs[1].astext() == ' | '
+    assert isinstance(xrefs[2], addnodes.pending_xref)
+    assert xrefs[2].get('reftarget') == 'str'
+    
+    # Test multiple union types
+    xrefs = field.make_xrefs('class', 'py', 'int | float | complex')
+    assert len(xrefs) == 5
+    assert xrefs[0].get('reftarget') == 'int'
+    assert xrefs[1].astext() == ' | '
+    assert xrefs[2].get('reftarget') == 'float'
+    assert xrefs[3].astext() == ' | '
+    assert xrefs[4].get('reftarget') == 'complex'
+    
+    # Test with extra spaces
+    xrefs = field.make_xrefs('class', 'py', 'bytes  |  str')
+    assert len(xrefs) == 3
+    assert xrefs[0].get('reftarget') == 'bytes'
+    assert xrefs[2].get('reftarget') == 'str'
+
+
+def test_typed_field_with_union():
+    """Test TypedField with union types"""
+    field = TypedField('parameter', names=('param',), typenames=('type',),
+                       typerolename='class')
+    
+    # Test union type
+    xrefs = field.make_xrefs('class', 'py', 'list | tuple | set')
+    assert len(xrefs) == 5
+    assert all(isinstance(x, (addnodes.pending_xref, nodes.Text)) for x in xrefs)
+
+
+def test_pyxref_mixin_make_xrefs():
+    """Test PyXrefMixin.make_xrefs with various delimiters including pipe"""
+    
+    class TestPyXref(PyXrefMixin):
+        def make_xref(self, rolename, domain, target, innernode=nodes.emphasis,
+                      contnode=None, env=None):
+            # Simplified version without env dependency
+            if not rolename:
+                return contnode or innernode(target, target)
+            refnode = addnodes.pending_xref('', refdomain=domain, refexplicit=False,
+                                            reftype=rolename, reftarget=target)
+            refnode += contnode or innernode(target, target)
+            return refnode
+    
+    mixin = TestPyXref()
+    
+    # Test pipe delimiter
+    xrefs = mixin.make_xrefs('class', 'py', 'bytes | str')
+    assert len(xrefs) == 3
+    assert isinstance(xrefs[0], addnodes.pending_xref)
+    assert xrefs[0].get('reftarget') == 'bytes'
+    assert isinstance(xrefs[1], nodes.emphasis)
+    assert xrefs[1].astext() == ' | '
+    assert isinstance(xrefs[2], addnodes.pending_xref)
+    assert xrefs[2].get('reftarget') == 'str'
+    
+    # Test 'or' delimiter (existing functionality)
+    xrefs = mixin.make_xrefs('class', 'py', 'bytes or str')
+    assert len(xrefs) == 3
+    assert xrefs[0].get('reftarget') == 'bytes'
+    assert xrefs[1].astext() == ' or '
+    assert xrefs[2].get('reftarget') == 'str'
+    
+    # Test comma delimiter (existing functionality)
+    xrefs = mixin.make_xrefs('class', 'py', 'List[int, str]')
+    assert len(xrefs) == 5
+    assert xrefs[0].get('reftarget') == 'List'
+    assert xrefs[2].get('reftarget') == 'int'
+    assert xrefs[4].get('reftarget') == 'str'
+
+
+if __name__ == '__main__':
+    test_field_make_xrefs_with_union()
+    test_typed_field_with_union()
+    test_pyxref_mixin_make_xrefs()
+    print("All tests passed!")
diff --git a/test_py_typed_field.py b/test_py_typed_field.py
new file mode 100644
index 000000000..1d67a67f1
--- /dev/null
+++ b/test_py_typed_field.py
@@ -0,0 +1,23 @@
+"""Test PyTypedField with union types"""
+
+from sphinx.domains.python import PyTypedField
+from sphinx import addnodes
+from docutils import nodes
+
+def test_py_typed_field():
+    # Test with PyTypedField
+    field = PyTypedField('parameter', names=('param',), typenames=('type',), 
+                         typerolename='class')
+    
+    # Test union types
+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')
+    print(f"PyTypedField union type: {xrefs}")
+    print(f"Number of elements: {len(xrefs)}")
+    for i, node in enumerate(xrefs):
+        if isinstance(node, nodes.Text):
+            print(f"Element {i}: Text node - '{node.astext()}'")
+        elif isinstance(node, addnodes.pending_xref):
+            print(f"Element {i}: XRef to '{node.get('reftarget')}'")
+
+if __name__ == '__main__':
+    test_py_typed_field()
diff --git a/test_union_simple.py b/test_union_simple.py
new file mode 100644
index 000000000..e37dd1682
--- /dev/null
+++ b/test_union_simple.py
@@ -0,0 +1,63 @@
+"""Simple test to see if union types work"""
+
+import os
+import tempfile
+import subprocess
+
+# Create test directory
+tmpdir = tempfile.mkdtemp(prefix="sphinx_union_test_")
+print(f"Test directory: {tmpdir}")
+
+# Create conf.py
+with open(os.path.join(tmpdir, 'conf.py'), 'w') as f:
+    f.write('''
+project = 'Test'
+extensions = []
+''')
+
+# Create index.rst
+with open(os.path.join(tmpdir, 'index.rst'), 'w') as f:
+    f.write('''
+Test
+====
+
+.. py:function:: foo(text)
+
+   :param text: The text
+   :type text: bytes | str
+''')
+
+# Build
+result = subprocess.run(
+    ['sphinx-build', '-b', 'html', '-v', tmpdir, os.path.join(tmpdir, '_build')],
+    capture_output=True,
+    text=True
+)
+
+print("\nBuild stdout:")
+print(result.stdout)
+if result.stderr:
+    print("\nBuild stderr:")
+    print(result.stderr)
+
+# Check HTML
+html_file = os.path.join(tmpdir, '_build', 'index.html')
+if os.path.exists(html_file):
+    with open(html_file, 'r') as f:
+        content = f.read()
+    
+    # Extract the relevant part
+    import re
+    match = re.search(r'<em[^>]*>bytes[^<]*</em>.*?<em[^>]*>str[^<]*</em>', content, re.DOTALL)
+    if match:
+        print(f"\nFound in HTML: {match.group()}")
+    else:
+        # Try to find any mention
+        if 'bytes' in content and 'str' in content:
+            # Find context around bytes
+            idx = content.find('bytes')
+            if idx > 0:
+                print(f"\nContext around 'bytes': ...{content[idx-50:idx+50]}...")
+                
+print(f"\n\nOutput saved in: {tmpdir}")
+print("To examine: less " + html_file)
diff --git a/test_union_types.py b/test_union_types.py
new file mode 100644
index 000000000..c5b04f10a
--- /dev/null
+++ b/test_union_types.py
@@ -0,0 +1,39 @@
+"""Test for union types with pipe character"""
+
+from sphinx.util.docfields import TypedField
+from sphinx import addnodes
+from docutils import nodes
+
+def test_union_types():
+    # Parse the type string
+    field = TypedField('parameter', names=('param',), typenames=('type',), 
+                       typerolename='class')
+    
+    # Test new behavior with pipe
+    xrefs = field.make_xrefs('class', 'py', 'bytes | str')
+    print(f"Union type behavior: {xrefs}")
+    print(f"Number of elements: {len(xrefs)}")
+    for i, node in enumerate(xrefs):
+        if isinstance(node, nodes.Text):
+            print(f"Element {i}: Text node - '{node.astext()}'")
+        elif isinstance(node, addnodes.pending_xref):
+            print(f"Element {i}: XRef to '{node.get('reftarget')}'")
+            
+    # Test with multiple types
+    print("\nTest with 3 types:")
+    xrefs = field.make_xrefs('class', 'py', 'int | float | str')
+    for i, node in enumerate(xrefs):
+        if isinstance(node, nodes.Text):
+            print(f"Element {i}: Text node - '{node.astext()}'")
+        elif isinstance(node, addnodes.pending_xref):
+            print(f"Element {i}: XRef to '{node.get('reftarget')}'")
+            
+    # Test without pipe (should work as before)
+    print("\nTest without pipe:")
+    xrefs = field.make_xrefs('class', 'py', 'str')
+    print(f"Single type: {len(xrefs)} element(s)")
+    if xrefs and isinstance(xrefs[0], addnodes.pending_xref):
+        print(f"XRef to '{xrefs[0].get('reftarget')}'")
+
+if __name__ == '__main__':
+    test_union_types()
diff --git a/test_union_types_full.py b/test_union_types_full.py
new file mode 100644
index 000000000..e4ed5a7cc
--- /dev/null
+++ b/test_union_types_full.py
@@ -0,0 +1,118 @@
+"""
+Test for union types with pipe character in Sphinx documentation
+"""
+
+import os
+import tempfile
+import shutil
+from pathlib import Path
+
+def create_test_project():
+    """Create a test Sphinx project with union types"""
+    
+    # Create temporary directory
+    tmpdir = tempfile.mkdtemp()
+    print(f"Created temp dir: {tmpdir}")
+    
+    # Create conf.py
+    conf_content = '''
+project = 'Test Union Types'
+extensions = ['sphinx.ext.autodoc']
+'''
+    
+    with open(os.path.join(tmpdir, 'conf.py'), 'w') as f:
+        f.write(conf_content)
+    
+    # Create index.rst with function documentation
+    index_content = '''
+Test Union Types
+================
+
+.. py:function:: foo(text)
+
+   Process some text.
+
+   :param text: The text to process
+   :type text: bytes | str
+   :returns: Processed text
+   :rtype: str
+
+.. py:function:: bar(value)
+
+   Process a numeric value.
+
+   :param value: The value to process  
+   :type value: int | float | complex
+   :returns: Result
+   :rtype: float
+
+.. py:function:: baz(data)
+
+   Process data without union type.
+
+   :param data: The data to process
+   :type data: dict
+   :returns: Processed data
+   :rtype: dict
+'''
+    
+    with open(os.path.join(tmpdir, 'index.rst'), 'w') as f:
+        f.write(index_content)
+    
+    return tmpdir
+
+def build_and_check(tmpdir):
+    """Build the documentation and check output"""
+    import subprocess
+    
+    # Build HTML documentation
+    result = subprocess.run(
+        ['sphinx-build', '-b', 'html', tmpdir, os.path.join(tmpdir, '_build', 'html')],
+        capture_output=True,
+        text=True
+    )
+    
+    print("Build output:")
+    print(result.stdout)
+    if result.stderr:
+        print("Build errors:")
+        print(result.stderr)
+    
+    # Read the generated HTML
+    html_file = os.path.join(tmpdir, '_build', 'html', 'index.html')
+    if os.path.exists(html_file):
+        with open(html_file, 'r') as f:
+            html_content = f.read()
+        
+        # Check for union types in output
+        if 'bytes' in html_content and 'str' in html_content:
+            print("\n✓ Union types found in HTML output")
+            
+            # Look for the specific pattern
+            import re
+            # Search for links to bytes and str
+            bytes_link = re.search(r'<a[^>]*>bytes</a>', html_content)
+            str_link = re.search(r'<a[^>]*>str</a>', html_content)
+            
+            if bytes_link and str_link:
+                print("✓ Both types are properly linked")
+            else:
+                print("✗ Types might not be properly linked")
+                
+    else:
+        print("✗ HTML file not found")
+    
+    return result.returncode == 0
+
+if __name__ == '__main__':
+    tmpdir = create_test_project()
+    try:
+        success = build_and_check(tmpdir)
+        if success:
+            print("\n✓ Test passed!")
+        else:
+            print("\n✗ Test failed!")
+    finally:
+        # Clean up
+        shutil.rmtree(tmpdir)
+        print(f"\nCleaned up temp dir: {tmpdir}")
diff --git a/tox.ini b/tox.ini
index a363e187f..3b8bc12d0 100644
--- a/tox.ini
+++ b/tox.ini
@@ -27,7 +27,7 @@ setenv =
     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils,ignore::DeprecationWarning:pip._vendor.packaging.version
     PYTEST_ADDOPTS = {env:PYTEST_ADDOPTS:} --color yes
 commands=
-    python -X dev -m pytest --durations 25 {posargs}
+    python -X dev -m pytest -rA --durations 25 {posargs}
 
 [testenv:flake8]
 basepython = python3
