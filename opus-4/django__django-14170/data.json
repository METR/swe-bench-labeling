{"instance_id": "django__django-14170", "score": "I", "diff": "diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py\nindex 90e6f41be0..c306e2535e 100644\n--- a/django/db/models/functions/datetime.py\n+++ b/django/db/models/functions/datetime.py\n@@ -7,6 +7,7 @@ from django.db.models.fields import (\n )\n from django.db.models.lookups import (\n     Transform, YearExact, YearGt, YearGte, YearLt, YearLte,\n+    Exact, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual,\n )\n from django.utils import timezone\n \n@@ -164,11 +165,38 @@ ExtractYear.register_lookup(YearGte)\n ExtractYear.register_lookup(YearLt)\n ExtractYear.register_lookup(YearLte)\n \n-ExtractIsoYear.register_lookup(YearExact)\n-ExtractIsoYear.register_lookup(YearGt)\n-ExtractIsoYear.register_lookup(YearGte)\n-ExtractIsoYear.register_lookup(YearLt)\n-ExtractIsoYear.register_lookup(YearLte)\n+# ISO year lookups should not use the BETWEEN optimization\n+# because ISO year boundaries don't align with calendar year boundaries\n+class IsoYearExact(Exact):\n+    \"\"\"Exact lookup for ISO year that doesn't use BETWEEN optimization.\"\"\"\n+    pass\n+\n+\n+class IsoYearGt(GreaterThan):\n+    \"\"\"Greater than lookup for ISO year.\"\"\"\n+    pass\n+\n+\n+class IsoYearGte(GreaterThanOrEqual):\n+    \"\"\"Greater than or equal lookup for ISO year.\"\"\"\n+    pass\n+\n+\n+class IsoYearLt(LessThan):\n+    \"\"\"Less than lookup for ISO year.\"\"\"\n+    pass\n+\n+\n+class IsoYearLte(LessThanOrEqual):\n+    \"\"\"Less than or equal lookup for ISO year.\"\"\"\n+    pass\n+\n+\n+ExtractIsoYear.register_lookup(IsoYearExact)\n+ExtractIsoYear.register_lookup(IsoYearGt)\n+ExtractIsoYear.register_lookup(IsoYearGte)\n+ExtractIsoYear.register_lookup(IsoYearLt)\n+ExtractIsoYear.register_lookup(IsoYearLte)\n \n \n class Now(Func):\ndiff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex 258600127f..b20ace5b76 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -108,20 +108,34 @@ class DateFunctionTests(TestCase):\n                 qs = DTModel.objects.filter(**{'start_datetime__%s__exact' % lookup: 2015})\n                 self.assertEqual(qs.count(), 1)\n                 query_string = str(qs.query).lower()\n-                self.assertEqual(query_string.count(' between '), 1)\n-                self.assertEqual(query_string.count('extract'), 0)\n+                if lookup == 'year':\n+                    # Regular year lookup should use BETWEEN optimization\n+                    self.assertEqual(query_string.count(' between '), 1)\n+                    self.assertEqual(query_string.count('extract'), 0)\n+                else:\n+                    # ISO year lookup should NOT use BETWEEN optimization\n+                    self.assertEqual(query_string.count(' between '), 0)\n+                    self.assertGreaterEqual(query_string.count('extract'), 1)\n                 # exact is implied and should be the same\n                 qs = DTModel.objects.filter(**{'start_datetime__%s' % lookup: 2015})\n                 self.assertEqual(qs.count(), 1)\n                 query_string = str(qs.query).lower()\n-                self.assertEqual(query_string.count(' between '), 1)\n-                self.assertEqual(query_string.count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(query_string.count(' between '), 1)\n+                    self.assertEqual(query_string.count('extract'), 0)\n+                else:\n+                    self.assertEqual(query_string.count(' between '), 0)\n+                    self.assertGreaterEqual(query_string.count('extract'), 1)\n                 # date and datetime fields should behave the same\n                 qs = DTModel.objects.filter(**{'start_date__%s' % lookup: 2015})\n                 self.assertEqual(qs.count(), 1)\n                 query_string = str(qs.query).lower()\n-                self.assertEqual(query_string.count(' between '), 1)\n-                self.assertEqual(query_string.count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(query_string.count(' between '), 1)\n+                    self.assertEqual(query_string.count('extract'), 0)\n+                else:\n+                    self.assertEqual(query_string.count(' between '), 0)\n+                    self.assertGreaterEqual(query_string.count('extract'), 1)\n                 # an expression rhs cannot use the between optimization.\n                 qs = DTModel.objects.annotate(\n                     start_year=ExtractYear('start_datetime'),\n@@ -144,10 +158,16 @@ class DateFunctionTests(TestCase):\n             with self.subTest(lookup):\n                 qs = DTModel.objects.filter(**{'start_datetime__%s__gt' % lookup: 2015})\n                 self.assertEqual(qs.count(), 1)\n-                self.assertEqual(str(qs.query).lower().count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)\n+                else:\n+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)\n                 qs = DTModel.objects.filter(**{'start_datetime__%s__gte' % lookup: 2015})\n                 self.assertEqual(qs.count(), 2)\n-                self.assertEqual(str(qs.query).lower().count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)\n+                else:\n+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)\n                 qs = DTModel.objects.annotate(\n                     start_year=ExtractYear('start_datetime'),\n                 ).filter(**{'end_datetime__%s__gte' % lookup: F('start_year')})\n@@ -167,10 +187,16 @@ class DateFunctionTests(TestCase):\n             with self.subTest(lookup):\n                 qs = DTModel.objects.filter(**{'start_datetime__%s__lt' % lookup: 2016})\n                 self.assertEqual(qs.count(), 1)\n-                self.assertEqual(str(qs.query).count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(str(qs.query).count('extract'), 0)\n+                else:\n+                    self.assertGreaterEqual(str(qs.query).count('extract'), 1)\n                 qs = DTModel.objects.filter(**{'start_datetime__%s__lte' % lookup: 2016})\n                 self.assertEqual(qs.count(), 2)\n-                self.assertEqual(str(qs.query).count('extract'), 0)\n+                if lookup == 'year':\n+                    self.assertEqual(str(qs.query).count('extract'), 0)\n+                else:\n+                    self.assertGreaterEqual(str(qs.query).count('extract'), 1)\n                 qs = DTModel.objects.annotate(\n                     end_year=ExtractYear('end_datetime'),\n                 ).filter(**{'start_datetime__%s__lte' % lookup: F('end_year')})\n", "gold_standard_diff": "diff --git a/django/db/backends/base/operations.py b/django/db/backends/base/operations.py\nindex 0fcc607bcfb0..f6a043e31f52 100644\n--- a/django/db/backends/base/operations.py\n+++ b/django/db/backends/base/operations.py\n@@ -526,30 +526,46 @@ def adapt_ipaddressfield_value(self, value):\n         \"\"\"\n         return value or None\n \n-    def year_lookup_bounds_for_date_field(self, value):\n+    def year_lookup_bounds_for_date_field(self, value, iso_year=False):\n         \"\"\"\n         Return a two-elements list with the lower and upper bound to be used\n         with a BETWEEN operator to query a DateField value using a year\n         lookup.\n \n         `value` is an int, containing the looked-up year.\n+        If `iso_year` is True, return bounds for ISO-8601 week-numbering years.\n         \"\"\"\n-        first = datetime.date(value, 1, 1)\n-        second = datetime.date(value, 12, 31)\n+        if iso_year:\n+            first = datetime.date.fromisocalendar(value, 1, 1)\n+            second = (\n+                datetime.date.fromisocalendar(value + 1, 1, 1) -\n+                datetime.timedelta(days=1)\n+            )\n+        else:\n+            first = datetime.date(value, 1, 1)\n+            second = datetime.date(value, 12, 31)\n         first = self.adapt_datefield_value(first)\n         second = self.adapt_datefield_value(second)\n         return [first, second]\n \n-    def year_lookup_bounds_for_datetime_field(self, value):\n+    def year_lookup_bounds_for_datetime_field(self, value, iso_year=False):\n         \"\"\"\n         Return a two-elements list with the lower and upper bound to be used\n         with a BETWEEN operator to query a DateTimeField value using a year\n         lookup.\n \n         `value` is an int, containing the looked-up year.\n+        If `iso_year` is True, return bounds for ISO-8601 week-numbering years.\n         \"\"\"\n-        first = datetime.datetime(value, 1, 1)\n-        second = datetime.datetime(value, 12, 31, 23, 59, 59, 999999)\n+        if iso_year:\n+            first = datetime.datetime.fromisocalendar(value, 1, 1)\n+            second = (\n+                datetime.datetime.fromisocalendar(value + 1, 1, 1) -\n+                datetime.timedelta(microseconds=1)\n+            )\n+        else:\n+            first = datetime.datetime(value, 1, 1)\n+            second = datetime.datetime(value, 12, 31, 23, 59, 59, 999999)\n         if settings.USE_TZ:\n             tz = timezone.get_current_timezone()\n             first = timezone.make_aware(first, tz)\ndiff --git a/django/db/models/lookups.py b/django/db/models/lookups.py\nindex 916478d075b1..6c923fe1a68e 100644\n--- a/django/db/models/lookups.py\n+++ b/django/db/models/lookups.py\n@@ -539,11 +539,17 @@ class IRegex(Regex):\n \n class YearLookup(Lookup):\n     def year_lookup_bounds(self, connection, year):\n+        from django.db.models.functions import ExtractIsoYear\n+        iso_year = isinstance(self.lhs, ExtractIsoYear)\n         output_field = self.lhs.lhs.output_field\n         if isinstance(output_field, DateTimeField):\n-            bounds = connection.ops.year_lookup_bounds_for_datetime_field(year)\n+            bounds = connection.ops.year_lookup_bounds_for_datetime_field(\n+                year, iso_year=iso_year,\n+            )\n         else:\n-            bounds = connection.ops.year_lookup_bounds_for_date_field(year)\n+            bounds = connection.ops.year_lookup_bounds_for_date_field(\n+                year, iso_year=iso_year,\n+            )\n         return bounds\n \n     def as_sql(self, compiler, connection):\ndiff --git a/docs/releases/4.0.txt b/docs/releases/4.0.txt\nindex 2b82c62d0229..f47b2fb5a02b 100644\n--- a/docs/releases/4.0.txt\n+++ b/docs/releases/4.0.txt\n@@ -289,7 +289,10 @@ Database backend API\n This section describes changes that may be needed in third-party database\n backends.\n \n-* ...\n+* ``DatabaseOperations.year_lookup_bounds_for_date_field()`` and\n+  ``year_lookup_bounds_for_datetime_field()`` methods now take the optional\n+  ``iso_year`` argument in order to support bounds for ISO-8601 week-numbering\n+  years.\n \n :mod:`django.contrib.gis`\n -------------------------\ndiff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex 258600127f93..63040f519837 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -359,9 +359,9 @@ def test_extract_iso_year_func_boundaries(self):\n             week_52_day_2014 = timezone.make_aware(week_52_day_2014, is_dst=False)\n             week_53_day_2015 = timezone.make_aware(week_53_day_2015, is_dst=False)\n         days = [week_52_day_2014, week_1_day_2014_2015, week_53_day_2015]\n-        self.create_model(week_53_day_2015, end_datetime)\n-        self.create_model(week_52_day_2014, end_datetime)\n-        self.create_model(week_1_day_2014_2015, end_datetime)\n+        obj_1_iso_2014 = self.create_model(week_52_day_2014, end_datetime)\n+        obj_1_iso_2015 = self.create_model(week_1_day_2014_2015, end_datetime)\n+        obj_2_iso_2015 = self.create_model(week_53_day_2015, end_datetime)\n         qs = DTModel.objects.filter(start_datetime__in=days).annotate(\n             extracted=ExtractIsoYear('start_datetime'),\n         ).order_by('start_datetime')\n@@ -371,6 +371,19 @@ def test_extract_iso_year_func_boundaries(self):\n             (week_53_day_2015, 2015),\n         ], lambda m: (m.start_datetime, m.extracted))\n \n+        qs = DTModel.objects.filter(\n+            start_datetime__iso_year=2015,\n+        ).order_by('start_datetime')\n+        self.assertSequenceEqual(qs, [obj_1_iso_2015, obj_2_iso_2015])\n+        qs = DTModel.objects.filter(\n+            start_datetime__iso_year__gt=2014,\n+        ).order_by('start_datetime')\n+        self.assertSequenceEqual(qs, [obj_1_iso_2015, obj_2_iso_2015])\n+        qs = DTModel.objects.filter(\n+            start_datetime__iso_year__lte=2014,\n+        ).order_by('start_datetime')\n+        self.assertSequenceEqual(qs, [obj_1_iso_2014])\n+\n     def test_extract_month_func(self):\n         start_datetime = datetime(2015, 6, 15, 14, 30, 50, 321)\n         end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14170"}