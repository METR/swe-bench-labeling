{"instance_id": "django__django-12209", "score": "C", "diff": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0..8d7b89c122 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -847,8 +847,10 @@ class Model(metaclass=ModelBase):\n         if not pk_set and (force_update or update_fields):\n             raise ValueError(\"Cannot force an update in save() with no primary key.\")\n         updated = False\n-        # Skip an UPDATE when adding an instance and primary key has a default.\n+        # Skip an UPDATE when adding an instance and primary key has a default,\n+        # but only if a primary key value hasn't been explicitly set.\n         if (\n+            not pk_set and\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..f7f4a8a28b\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,129 @@\n+from uuid import uuid4\n+import django\n+from django.conf import settings\n+\n+# Set up Django first\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db import connection\n+from django.test.utils import CaptureQueriesContext\n+\n+# Define test models\n+class SampleWithDefault(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'testapp'\n+\n+class SampleNoDefault(models.Model):\n+    id = models.UUIDField(primary_key=True)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'testapp'\n+\n+class SampleAutoField(models.Model):\n+    # Using default AutoField\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'testapp'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(SampleWithDefault)\n+    schema_editor.create_model(SampleNoDefault) \n+    schema_editor.create_model(SampleAutoField)\n+\n+def get_query_type(queries):\n+    \"\"\"Extract INSERT/UPDATE from query list\"\"\"\n+    for q in queries:\n+        sql = q['sql'].upper()\n+        if 'INSERT' in sql:\n+            return 'INSERT'\n+        elif 'UPDATE' in sql:\n+            return 'UPDATE'\n+    return 'UNKNOWN'\n+\n+print(\"Comprehensive test of save() behavior\")\n+print(\"=\"*60)\n+\n+# Test 1: Creating new instance with pk field having default - should INSERT\n+print(\"\\n1. Creating new instance with pk field having default\")\n+with CaptureQueriesContext(connection) as context:\n+    s1 = SampleWithDefault.objects.create(name='Test 1')\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+print(f\"   Created with id: {s1.pk}\")\n+\n+# Test 2: Creating new instance without explicit pk but field has default - should INSERT\n+print(\"\\n2. Creating new instance (save) without explicit pk but field has default\")\n+s2 = SampleWithDefault(name='Test 2')\n+with CaptureQueriesContext(connection) as context:\n+    s2.save()\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+print(f\"   Created with id: {s2.pk}\")\n+\n+# Test 3: Save existing instance with explicit pk (our bug fix) - should UPDATE\n+print(\"\\n3. Save new instance with explicit existing pk (bug fix test)\")\n+s3 = SampleWithDefault(pk=s1.pk, name='Test 3 Updated')\n+print(f\"   s3._state.adding = {s3._state.adding}\")\n+with CaptureQueriesContext(connection) as context:\n+    s3.save()\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+updated = SampleWithDefault.objects.get(pk=s1.pk)\n+print(f\"   Name after save: {updated.name}\")\n+\n+# Test 4: Save loaded instance - should UPDATE\n+print(\"\\n4. Save loaded instance\")\n+s4 = SampleWithDefault.objects.get(pk=s1.pk)\n+s4.name = 'Test 4 Updated'\n+print(f\"   s4._state.adding = {s4._state.adding}\")\n+with CaptureQueriesContext(connection) as context:\n+    s4.save()\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+\n+# Test 5: Model with no default on pk - existing behavior should be preserved\n+print(\"\\n5. Model with no default on pk - save with explicit existing pk\")\n+snd1 = SampleNoDefault.objects.create(id=uuid4(), name='No Default 1')\n+snd2 = SampleNoDefault(pk=snd1.pk, name='No Default Updated')\n+print(f\"   snd2._state.adding = {snd2._state.adding}\")\n+with CaptureQueriesContext(connection) as context:\n+    snd2.save()\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+\n+# Test 6: AutoField model - existing behavior  \n+print(\"\\n6. AutoField model - save with explicit existing pk\")\n+sa1 = SampleAutoField.objects.create(name='Auto 1')\n+sa2 = SampleAutoField(pk=sa1.pk, name='Auto Updated')\n+print(f\"   sa2._state.adding = {sa2._state.adding}\")\n+with CaptureQueriesContext(connection) as context:\n+    sa2.save()\n+print(f\"   Query type: {get_query_type(context.captured_queries)}\")\n+\n+# Test 7: force_insert=True should still force INSERT\n+print(\"\\n7. Force insert with explicit existing pk (should fail)\")\n+s5 = SampleWithDefault(pk=s1.pk, name='Force Insert')\n+try:\n+    s5.save(force_insert=True)\n+    print(\"   ERROR: force_insert=True didn't raise exception!\")\n+except Exception as e:\n+    print(f\"   Expected error: {e}\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..a1b2c4844c\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,102 @@\n+from uuid import uuid4\n+import django\n+from django.conf import settings\n+\n+# Set up Django first\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.test import TestCase, TransactionTestCase\n+from django.db import connection\n+from django.test.utils import CaptureQueriesContext\n+\n+# Define our test model\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'testapp'\n+\n+# Test the issue\n+def test_save_with_explicit_pk():\n+    # Create initial object\n+    s0 = Sample.objects.create()\n+    print(f\"Created s0 with id: {s0.pk}\")\n+    \n+    # Try to save with same pk - this should UPDATE not INSERT\n+    s1 = Sample(pk=s0.pk, name='Test 1')\n+    \n+    with CaptureQueriesContext(connection) as context:\n+        s1.save()\n+    \n+    # Print the queries\n+    for query in context.captured_queries:\n+        print(f\"Query: {query['sql']}\")\n+        \n+    # Verify the result\n+    saved = Sample.objects.get(pk=s0.pk)\n+    print(f\"Saved object name: {saved.name}\")\n+    \n+    # Also test without default on pk field\n+    class SampleNoDefault(models.Model):\n+        id = models.UUIDField(primary_key=True)\n+        name = models.CharField(blank=True, max_length=100)\n+        \n+        class Meta:\n+            app_label = 'testapp'\n+    \n+    print(\"\\nNow testing without default on pk field...\")\n+    s2 = SampleNoDefault.objects.create(id=uuid4())\n+    print(f\"Created s2 with id: {s2.pk}\")\n+    \n+    s3 = SampleNoDefault(pk=s2.pk, name='Test 2')\n+    with CaptureQueriesContext(connection) as context:\n+        s3.save()\n+    \n+    for query in context.captured_queries:\n+        print(f\"Query: {query['sql']}\")\n+\n+if __name__ == \"__main__\":\n+    # Set up Django\n+    import django\n+    from django.conf import settings\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=False,\n+    )\n+    \n+    django.setup()\n+    \n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Sample)\n+        \n+    test_save_with_explicit_pk()\ndiff --git a/test_issue_simple.py b/test_issue_simple.py\nnew file mode 100644\nindex 0000000000..85b122b09b\n--- /dev/null\n+++ b/test_issue_simple.py\n@@ -0,0 +1,66 @@\n+from uuid import uuid4\n+import django\n+from django.conf import settings\n+\n+# Set up Django first\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=False,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db import connection\n+from django.test.utils import CaptureQueriesContext\n+\n+# Define our test model\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'testapp'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Sample)\n+\n+print(\"Testing issue with explicit pk and default field...\")\n+print(\"=\" * 50)\n+\n+# Create initial object\n+s0 = Sample.objects.create()\n+print(f\"Created s0 with id: {s0.pk}\")\n+\n+# Try to save with same pk - this should UPDATE not INSERT\n+print(\"\\nAttempting to save a new instance with existing pk...\")\n+s1 = Sample(pk=s0.pk, name='Test 1')\n+print(f\"s1._state.adding = {s1._state.adding}\")\n+\n+try:\n+    with CaptureQueriesContext(connection) as context:\n+        s1.save()\n+    \n+    # Print the queries\n+    print(\"\\nQueries executed:\")\n+    for query in context.captured_queries:\n+        print(f\"  {query['sql']}\")\n+        \n+    # Verify the result\n+    saved = Sample.objects.get(pk=s0.pk)\n+    print(f\"\\nResult: Object saved successfully!\")\n+    print(f\"Saved object name: {saved.name}\")\n+except Exception as e:\n+    print(f\"\\nError: {e}\")\n+    print(\"This confirms the bug - it's trying to INSERT instead of UPDATE\")\ndiff --git a/test_loaddata.py b/test_loaddata.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\n", "gold_standard_diff": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0d0..844c01e95eeb 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -849,6 +849,7 @@ def _save_table(self, raw=False, cls=None, force_insert=False,\n         updated = False\n         # Skip an UPDATE when adding an instance and primary key has a default.\n         if (\n+            not raw and\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\ndiff --git a/docs/ref/models/instances.txt b/docs/ref/models/instances.txt\nindex 9345bc0fe0bd..1524ad2fcd79 100644\n--- a/docs/ref/models/instances.txt\n+++ b/docs/ref/models/instances.txt\n@@ -465,8 +465,9 @@ How Django knows to UPDATE vs. INSERT\n \n You may have noticed Django database objects use the same ``save()`` method\n for creating and changing objects. Django abstracts the need to use ``INSERT``\n-or ``UPDATE`` SQL statements. Specifically, when you call ``save()``, Django\n-follows this algorithm:\n+or ``UPDATE`` SQL statements. Specifically, when you call ``save()`` and the\n+object's primary key attribute does **not** define a\n+:attr:`~django.db.models.Field.default`, Django follows this algorithm:\n \n * If the object's primary key attribute is set to a value that evaluates to\n   ``True`` (i.e., a value other than ``None`` or the empty string), Django\n@@ -475,6 +476,11 @@ follows this algorithm:\n   didn't update anything (e.g. if primary key is set to a value that doesn't\n   exist in the database), Django executes an ``INSERT``.\n \n+If the object's primary key attribute defines a\n+:attr:`~django.db.models.Field.default` then Django executes an ``UPDATE`` if\n+it is an existing model instance and primary key is set to a value that exists\n+in the database. Otherwise, Django executes an ``INSERT``.\n+\n The one gotcha here is that you should be careful not to specify a primary-key\n value explicitly when saving new objects, if you cannot guarantee the\n primary-key value is unused. For more on this nuance, see `Explicitly specifying\n@@ -490,6 +496,12 @@ which returns ``NULL``. In such cases it is possible to revert to the old\n algorithm by setting the :attr:`~django.db.models.Options.select_on_save`\n option to ``True``.\n \n+.. versionchanged:: 3.0\n+\n+    ``Model.save()`` no longer attempts to find a row when saving a new\n+    ``Model`` instance and a default value for the primary key is provided, and\n+    always executes an ``INSERT``.\n+\n .. _ref-models-force-insert:\n \n Forcing an INSERT or UPDATE\ndiff --git a/docs/releases/3.0.2.txt b/docs/releases/3.0.2.txt\nindex ebb85d1f46a7..e232fa81f8f2 100644\n--- a/docs/releases/3.0.2.txt\n+++ b/docs/releases/3.0.2.txt\n@@ -18,3 +18,7 @@ Bugfixes\n * Fixed a regression in Django 3.0 that caused a migration crash on PostgreSQL\n   10+ when adding a foreign key and changing data in the same migration\n   (:ticket:`31106`).\n+\n+* Fixed a regression in Django 3.0 where loading fixtures crashed for models\n+  defining a :attr:`~django.db.models.Field.default` for the primary key\n+  (:ticket:`31071`).\ndiff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt\nindex 435755f732a3..f133c58654b0 100644\n--- a/docs/releases/3.0.txt\n+++ b/docs/releases/3.0.txt\n@@ -372,6 +372,27 @@ Tests\n Backwards incompatible changes in 3.0\n =====================================\n \n+``Model.save()`` when providing a default for the primary key\n+-------------------------------------------------------------\n+\n+:meth:`.Model.save` no longer attempts to find a row when saving a new\n+``Model`` instance and a default value for the primary key is provided, and\n+always performs a single ``INSERT`` query. In older Django versions,\n+``Model.save()`` performed either an ``INSERT`` or an ``UPDATE`` based on\n+whether or not the row exists.\n+\n+This makes calling ``Model.save()`` while providing a default primary key value\n+equivalent to passing :ref:`force_insert=True <ref-models-force-insert>` to\n+model's ``save()``. Attempts to use a new ``Model`` instance to update an\n+existing row will result in an ``IntegrityError``.\n+\n+In order to update an existing model for a specific primary key value, use the\n+:meth:`~django.db.models.query.QuerySet.update_or_create` method or\n+``QuerySet.filter(pk=\u2026).update(\u2026)`` instead. For example::\n+\n+    >>> MyModel.objects.update_or_create(pk=existing_pk, defaults={'name': 'new name'})\n+    >>> MyModel.objects.filter(pk=existing_pk).update(name='new name')\n+\n Database backend API\n --------------------\n \ndiff --git a/tests/serializers/models/data.py b/tests/serializers/models/data.py\nindex 89564f756c5c..eaa2aa60e606 100644\n--- a/tests/serializers/models/data.py\n+++ b/tests/serializers/models/data.py\n@@ -4,6 +4,8 @@\n NULL values, where allowed.\n The basic idea is to have a model for each Django data type.\n \"\"\"\n+import uuid\n+\n from django.contrib.contenttypes.fields import (\n     GenericForeignKey, GenericRelation,\n )\n@@ -257,6 +259,10 @@ class UUIDData(models.Model):\n     data = models.UUIDField(primary_key=True)\n \n \n+class UUIDDefaultData(models.Model):\n+    data = models.UUIDField(primary_key=True, default=uuid.uuid4)\n+\n+\n class FKToUUID(models.Model):\n     data = models.ForeignKey(UUIDData, models.CASCADE)\n \ndiff --git a/tests/serializers/test_data.py b/tests/serializers/test_data.py\nindex 493da7e7cc5d..1ddba02565ce 100644\n--- a/tests/serializers/test_data.py\n+++ b/tests/serializers/test_data.py\n@@ -26,7 +26,7 @@\n     ModifyingSaveData, NullBooleanData, O2OData, PositiveBigIntegerData,\n     PositiveIntegerData, PositiveIntegerPKData, PositiveSmallIntegerData,\n     PositiveSmallIntegerPKData, SlugData, SlugPKData, SmallData, SmallPKData,\n-    Tag, TextData, TimeData, UniqueAnchor, UUIDData,\n+    Tag, TextData, TimeData, UniqueAnchor, UUIDData, UUIDDefaultData,\n )\n from .tests import register_tests\n \n@@ -351,6 +351,7 @@ def inherited_compare(testcase, pk, klass, data):\n     # (pk_obj, 790, XMLPKData, \"<foo></foo>\"),\n     (pk_obj, 791, UUIDData, uuid_obj),\n     (fk_obj, 792, FKToUUID, uuid_obj),\n+    (pk_obj, 793, UUIDDefaultData, uuid_obj),\n \n     (data_obj, 800, AutoNowDateTimeData, datetime.datetime(2006, 6, 16, 10, 42, 37)),\n     (data_obj, 810, ModifyingSaveData, 42),\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12209"}