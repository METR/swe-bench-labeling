diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 0000000000..a84d6f53df
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,52 @@
+import html
+
+# Simulating what happens in trim_punctuation
+middle = 'google.com/?q=1&lt!'
+print(f"Original middle: '{middle}'")
+
+middle_unescaped = html.unescape(middle)
+print(f"Unescaped middle: '{middle_unescaped}'")
+
+TRAILING_PUNCTUATION_CHARS = '.,:;!'
+stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)
+print(f"Stripped unescaped: '{stripped}'")
+
+# The problematic line
+new_middle = middle[:len(stripped) - len(middle_unescaped)]
+print(f"New middle (wrong): '{new_middle}'")
+
+# Let's see what's happening
+print(f"\nlen(middle): {len(middle)}")
+print(f"len(middle_unescaped): {len(middle_unescaped)}")
+print(f"len(stripped): {len(stripped)}")
+print(f"Index calculation: {len(stripped)} - {len(middle_unescaped)} = {len(stripped) - len(middle_unescaped)}")
+
+# What we should get:
+# We need to find where the trailing punctuation starts in the original (escaped) string
+# The punctuation that was stripped is the '!'
+trimmed_chars = middle_unescaped[len(stripped):]
+print(f"\nTrimmed chars from unescaped: '{trimmed_chars}'")
+
+# We need to find where this starts in the original string
+# First, let's figure out the correct approach
+print("\n--- Correct approach ---")
+# We know that in the unescaped version, we trimmed from position len(stripped)
+# We need to find the corresponding position in the escaped version
+
+# The issue is that we can't directly map character positions between escaped and unescaped strings
+# because entities like &lt; take multiple characters but represent one character
+
+# A better approach: find what was trimmed and then find it in the original
+if middle_unescaped != stripped:
+    # Find the position where trimming starts in the escaped string
+    # We need to be careful with HTML entities
+    
+    # One approach: unescape progressively to find the right position
+    for i in range(len(middle), -1, -1):
+        partial = middle[:i]
+        partial_unescaped = html.unescape(partial)
+        if partial_unescaped == stripped:
+            print(f"Correct position found at index {i}")
+            print(f"Correct new_middle: '{middle[:i]}'")
+            print(f"Correct trail would be: '{middle[i:]}'")
+            break
diff --git a/django/utils/html.py b/django/utils/html.py
index 3bc02b8dd3..309cc18746 100644
--- a/django/utils/html.py
+++ b/django/utils/html.py
@@ -283,9 +283,17 @@ def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):
             middle_unescaped = html.unescape(middle)
             stripped = middle_unescaped.rstrip(TRAILING_PUNCTUATION_CHARS)
             if middle_unescaped != stripped:
-                trail = middle[len(stripped):] + trail
-                middle = middle[:len(stripped) - len(middle_unescaped)]
-                trimmed_something = True
+                # Find the correct position in the escaped string where trimming should occur
+                # We can't use simple string length arithmetic because HTML entities like
+                # &lt; take multiple characters but represent a single character when unescaped
+                # So we need to find the position by unescaping progressively
+                for i in range(len(middle), -1, -1):
+                    partial_unescaped = html.unescape(middle[:i])
+                    if partial_unescaped == stripped:
+                        trail = middle[i:] + trail
+                        middle = middle[:i]
+                        trimmed_something = True
+                        break
         return lead, middle, trail
 
     def is_email_simple(value):
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 0000000000..f3eae2f3b7
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,53 @@
+from django.utils.html import urlize
+
+# Test cases
+test_cases = [
+    # Original issue
+    ('Search for google.com/?q=1&lt! and see.', 
+     'Search for <a href="http://google.com/?q=1%3C">google.com/?q=1&lt</a>! and see.'),
+    
+    # Test with other HTML entities
+    ('Visit example.com&amp; for more', 
+     'Visit <a href="http://example.com&amp;">example.com&amp;</a> for more'),
+    
+    ('Check out site.com&gt!', 
+     'Check out <a href="http://site.com%3E">site.com&gt</a>!'),
+    
+    # Test with multiple punctuation
+    ('Go to test.com&lt!!!', 
+     'Go to <a href="http://test.com%3C">test.com&lt</a>!!!'),
+    
+    # Test without HTML entities  
+    ('Visit google.com!', 
+     'Visit <a href="http://google.com">google.com</a>!'),
+    
+    # Test with query parameters and no entities
+    ('Search google.com/?q=test!',
+     'Search <a href="http://google.com/?q=test">google.com/?q=test</a>!'),
+     
+    # Edge case: entity at the very end without punctuation
+    ('Visit site.com&lt',
+     'Visit <a href="http://site.com%3C">site.com&lt</a>'),
+     
+    # Multiple entities
+    ('Check test.com/&amp;&lt!',
+     'Check <a href="http://test.com/&amp;%3C">test.com/&amp;&lt</a>!'),
+]
+
+print("Testing urlize() with HTML entities and trailing punctuation:\n")
+all_passed = True
+
+for i, (input_text, expected) in enumerate(test_cases, 1):
+    result = urlize(input_text)
+    passed = result == expected
+    all_passed &= passed
+    
+    print(f"Test {i}: {'✓' if passed else '✗'}")
+    print(f"  Input:    {input_text}")
+    print(f"  Expected: {expected}")
+    print(f"  Got:      {result}")
+    if not passed:
+        print(f"  FAILED!")
+    print()
+
+print(f"\nAll tests {'passed' if all_passed else 'FAILED'}!")
diff --git a/test_escape_detail.py b/test_escape_detail.py
new file mode 100644
index 0000000000..e5b59e6dde
--- /dev/null
+++ b/test_escape_detail.py
@@ -0,0 +1,14 @@
+from django.utils.html import urlize
+
+# Test simple cases
+print("Test 1:")
+result = urlize('Search for google.com/?q=1&lt! and see.')
+print(f"Result: {repr(result)}")
+
+print("\nTest 2:")
+result2 = urlize('Check test.com/&amp;&lt!')
+print(f"Result: {repr(result2)}")
+
+# Check if it's being treated as SafeString
+print(f"\nResult type: {type(result)}")
+print(f"Result.__html__() exists: {hasattr(result, '__html__')}")
diff --git a/test_escaping.py b/test_escaping.py
new file mode 100644
index 0000000000..7745fb749f
--- /dev/null
+++ b/test_escaping.py
@@ -0,0 +1,11 @@
+from django.utils.html import urlize, escape
+
+# Test the issue
+result = urlize('Search for google.com/?q=1&lt! and see.')
+print("Default (autoescape=None):", result)
+
+result2 = urlize('Search for google.com/?q=1&lt! and see.', autoescape=False)
+print("With autoescape=False:", result2)
+
+result3 = urlize('Search for google.com/?q=1&lt! and see.', autoescape=True)
+print("With autoescape=True:", result3)
diff --git a/test_issue.py b/test_issue.py
new file mode 100644
index 0000000000..6aa9bcfae7
--- /dev/null
+++ b/test_issue.py
@@ -0,0 +1,10 @@
+from django.utils.html import urlize
+
+# Test case from the issue
+result = urlize('Search for google.com/?q=1&lt! and see.')
+print("Result:", result)
+print("Expected:", 'Search for <a href="http://google.com/?q=1%3C">google.com/?q=1&lt</a>! and see.')
+
+# Let's test a simpler case too
+simple_test = urlize('test.com&lt!')
+print("\nSimple test:", simple_test)
diff --git a/test_regex.py b/test_regex.py
new file mode 100644
index 0000000000..2e6f1b881c
--- /dev/null
+++ b/test_regex.py
@@ -0,0 +1,17 @@
+import re
+
+simple_url_2_re = re.compile(
+    r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$',
+    re.IGNORECASE
+)
+
+test_urls = [
+    'example.com&amp;',
+    'site.com&gt',
+    'test.com&lt',
+    'site.com&lt',
+    'google.com/?q=1&lt',
+]
+
+for url in test_urls:
+    print(f"Testing '{url}': {bool(simple_url_2_re.match(url))}")
diff --git a/test_specific.py b/test_specific.py
new file mode 100644
index 0000000000..9e46685eef
--- /dev/null
+++ b/test_specific.py
@@ -0,0 +1,19 @@
+import sys
+sys.path.insert(0, '/testbed')
+
+from django.utils.html import urlize
+
+# From the test file
+expected1 = 'Search for <a href="http://google.com/?q=1%3C" rel="nofollow">google.com/?q=1&lt</a>! and see.'
+result1 = urlize('Search for google.com/?q=1&lt! and see.')
+print("Test 1 passes:", result1 == expected1)
+print("Expected:", repr(expected1))
+print("Got:     ", repr(result1))
+
+print()
+
+expected2 = 'Check <a href="http://test.com/&amp;%3C" rel="nofollow">test.com/&amp;&lt</a>!'
+result2 = urlize('Check test.com/&amp;&lt!')
+print("Test 2 passes:", result2 == expected2)
+print("Expected:", repr(expected2))
+print("Got:     ", repr(result2))
diff --git a/tests/template_tests/filter_tests/test_urlize.py b/tests/template_tests/filter_tests/test_urlize.py
index 3843cc3e0a..47e5f8e752 100644
--- a/tests/template_tests/filter_tests/test_urlize.py
+++ b/tests/template_tests/filter_tests/test_urlize.py
@@ -368,6 +368,25 @@ class FunctionTests(SimpleTestCase):
             'Search for <a href="http://google.com/?q=dj%21%60%3F" rel="nofollow">google.com/?q=dj!`?</a>! and see.',
         )
 
+    def test_html_entities_in_url(self):
+        """
+        Check urlize correctly handles URLs with HTML entities and trailing
+        punctuation.
+        """
+        # Debug output
+        result = urlize('Search for google.com/?q=1&lt! and see.')
+        print("\nDEBUG test_html_entities_in_url:")
+        print(f"Got: {repr(result)}")
+        
+        self.assertEqual(
+            urlize('Search for google.com/?q=1&lt! and see.'),
+            'Search for <a href="http://google.com/?q=1%3C">google.com/?q=1&lt</a>! and see.',
+        )
+        self.assertEqual(
+            urlize('Check test.com/&amp;&lt!'),
+            'Check <a href="http://test.com/&amp;%3C">test.com/&amp;&lt</a>!',
+        )
+
     def test_non_string_input(self):
         self.assertEqual(urlize(123), '123')
 
