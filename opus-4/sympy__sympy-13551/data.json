{"instance_id": "sympy__sympy-13551", "score": "C", "diff": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 66aafde2d6..f12f3ef316 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -275,18 +275,18 @@ def _eval_product(self, term, limits):\n             return poly.LC()**(n - a + 1) * A * B\n \n         elif term.is_Add:\n-            p, q = term.as_numer_denom()\n-            q = self._eval_product(q, (k, a, n))\n-            if q.is_Number:\n-\n-                # There is expression, which couldn't change by\n-                # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).\n-                # We have to catch this case.\n-\n-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n-            else:\n-                p = self._eval_product(p, (k, a, n))\n-            return p / q\n+            # For Add expressions, we cannot split the product into a sum of products\n+            # since Product(a + b) != Product(a) + Product(b)\n+            # We should only handle special cases where we can factor or simplify\n+            \n+            # Try to see if we can factor the expression\n+            factored = term.factor()\n+            if factored != term and factored.is_Mul:\n+                # If factoring gives us a multiplication, we can use the Mul handling\n+                return self._eval_product(factored, (k, a, n))\n+            \n+            # Otherwise, we cannot evaluate this product in closed form\n+            return None\n \n         elif term.is_Mul:\n             exclude, include = [], []\ndiff --git a/test_issue_regression.py b/test_issue_regression.py\nnew file mode 100644\nindex 0000000000..6640e5a532\n--- /dev/null\n+++ b/test_issue_regression.py\n@@ -0,0 +1,44 @@\n+\"\"\"\n+Regression test for the Product issue where Product(n + 1 / 2**k, [k, 0, n-1]) \n+was incorrectly evaluated.\n+\n+The issue was that for Add expressions, the code was incorrectly trying to split\n+the product into a sum of products, which is mathematically wrong:\n+Product(a + b) != Product(a) + Product(b)\n+\"\"\"\n+\n+from sympy import Product, simplify, Rational\n+from sympy.abc import n, k\n+\n+def test_product_issue():\n+    \"\"\"Test that Product(n + 1/2**k, [k, 0, n-1]) evaluates correctly\"\"\"\n+    \n+    # Create the product\n+    p = Product(n + 1 / 2**k, [k, 0, n-1])\n+    \n+    # Before the fix, this would incorrectly give 2**(n*(-n + 1)/2) + n**n\n+    # which evaluates to 9/2 for n=2\n+    result = p.doit()\n+    \n+    # Test n=2\n+    # Product should be: (2 + 1/2^0) * (2 + 1/2^1) = (2 + 1) * (2 + 1/2) = 3 * 2.5 = 7.5 = 15/2\n+    value_n2 = result.subs(n, 2).doit()\n+    assert value_n2 == Rational(15, 2), f\"Expected 15/2 for n=2, got {value_n2}\"\n+    \n+    # Test n=3  \n+    # Product should be: (3 + 1) * (3 + 1/2) * (3 + 1/4) = 4 * 3.5 * 3.25 = 45.5 = 91/2\n+    value_n3 = result.subs(n, 3).doit()\n+    assert value_n3 == Rational(91, 2), f\"Expected 91/2 for n=3, got {value_n3}\"\n+    \n+    # Test n=1\n+    # Product should be: (1 + 1/2^0) = (1 + 1) = 2\n+    value_n1 = result.subs(n, 1).doit()\n+    assert value_n1 == 2, f\"Expected 2 for n=1, got {value_n1}\"\n+    \n+    print(\"All tests passed! The issue is fixed.\")\n+    print(f\"Product(n + 1/2**k, [k, 0, n-1]) = {result}\")\n+    print(f\"For n=2: {value_n2} (correct, was 9/2 before fix)\")\n+    print(f\"For n=3: {value_n3}\")\n+\n+if __name__ == \"__main__\":\n+    test_product_issue()\ndiff --git a/test_product_fix.py b/test_product_fix.py\nnew file mode 100644\nindex 0000000000..40a76ab175\n--- /dev/null\n+++ b/test_product_fix.py\n@@ -0,0 +1,86 @@\n+from sympy import *\n+from sympy.abc import n, k, m, x, i\n+\n+def test_issue_fix():\n+    \"\"\"Test that the original issue is fixed\"\"\"\n+    p = Product(n + 1 / 2**k, [k, 0, n-1])\n+    result = p.doit()\n+    \n+    # For n=2, the product should be (2 + 2^0) * (2 + 2^(-1)) = 3 * 2.5 = 7.5 = 15/2\n+    assert result.subs(n, 2).doit() == Rational(15, 2)\n+    \n+    # For n=3, the product should be (3 + 1) * (3 + 1/2) * (3 + 1/4) = 4 * 3.5 * 3.25 = 45.5 = 91/2\n+    assert result.subs(n, 3).doit() == Rational(91, 2)\n+    \n+    print(\"Original issue test passed!\")\n+\n+def test_existing_functionality():\n+    \"\"\"Test that existing product functionality still works\"\"\"\n+    \n+    # Test 1: Simple product\n+    assert Product(k, [k, 1, n]).doit() == factorial(n)\n+    \n+    # Test 2: Constant product\n+    assert Product(5, [k, 1, n]).doit() == 5**n\n+    \n+    # Test 3: Power product\n+    result = Product(2**k, [k, 1, n]).doit()\n+    expected = 2**(n*(n + 1)/2)\n+    assert simplify(result - expected) == 0\n+    \n+    # Test 4: Polynomial product with specific value\n+    p = Product(k**2, [k, 1, 3]).doit()\n+    assert p == 36  # 1 * 4 * 9 = 36\n+    \n+    # Test 5: Empty product\n+    assert Product(k, [k, 1, 0]).doit() == 1\n+    \n+    # Test 6: Single term product\n+    assert Product(k, [k, 5, 5]).doit() == 5\n+    \n+    print(\"Existing functionality tests passed!\")\n+\n+def test_add_expressions():\n+    \"\"\"Test that Add expressions are handled correctly\"\"\"\n+    \n+    # Test 1: Non-factorable Add should remain unevaluated\n+    p1 = Product(k + exp(k), [k, 1, n])\n+    assert isinstance(p1.doit(), Product)\n+    \n+    # Test 2: Factorable Add should be evaluated\n+    p2 = Product(2*(k + 1), [k, 1, n])  # This is actually Mul, not Add\n+    result2 = p2.doit()\n+    # RisingFactorial(2, n) = 2*3*...*(n+1) = factorial(n+1)/factorial(1) = factorial(n+1)\n+    expected = 2**n * factorial(n+1)\n+    assert simplify(result2.subs(n, 3) - expected.subs(n, 3)) == 0\n+    \n+    # Test 3: Complex Add expression\n+    p3 = Product(k + I, [k, 1, 3])\n+    result3 = p3.doit()\n+    expected = (1 + I) * (2 + I) * (3 + I)\n+    assert simplify(result3 - expected) == 0\n+    \n+    print(\"Add expression tests passed!\")\n+\n+def test_edge_cases():\n+    \"\"\"Test edge cases\"\"\"\n+    \n+    # Test with symbolic limits\n+    p1 = Product(k + 1, [k, m, n])\n+    result1 = p1.doit()\n+    # Should give rising factorial or remain unevaluated\n+    \n+    # Test with negative powers\n+    p2 = Product(1 + 1/k, [k, 1, 3])\n+    result2 = p2.doit()\n+    expected = 2 * Rational(3, 2) * Rational(4, 3)\n+    assert result2 == expected\n+    \n+    print(\"Edge case tests passed!\")\n+\n+if __name__ == \"__main__\":\n+    test_issue_fix()\n+    test_existing_functionality()\n+    test_add_expressions()\n+    test_edge_cases()\n+    print(\"\\nAll tests passed!\")\n", "gold_standard_diff": "diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py\nindex 66aafde2d60b..da71482e2850 100644\n--- a/sympy/concrete/products.py\n+++ b/sympy/concrete/products.py\n@@ -282,8 +282,8 @@ def _eval_product(self, term, limits):\n                 # There is expression, which couldn't change by\n                 # as_numer_denom(). E.g. n**(2/3) + 1 --> (n**(2/3) + 1, 1).\n                 # We have to catch this case.\n-\n-                p = sum([self._eval_product(i, (k, a, n)) for i in p.as_coeff_Add()])\n+                from sympy.concrete.summations import Sum\n+                p = exp(Sum(log(p), (k, a, n)))\n             else:\n                 p = self._eval_product(p, (k, a, n))\n             return p / q\ndiff --git a/sympy/concrete/tests/test_products.py b/sympy/concrete/tests/test_products.py\nindex 311d5153e2fc..283f926926f6 100644\n--- a/sympy/concrete/tests/test_products.py\n+++ b/sympy/concrete/tests/test_products.py\n@@ -355,6 +355,13 @@ def test_issue_9983():\n     assert product(1 + 1/n**(S(2)/3), (n, 1, oo)) == p.doit()\n \n \n+def test_issue_13546():\n+    n = Symbol('n')\n+    k = Symbol('k')\n+    p = Product(n + 1 / 2**k, (k, 0, n-1)).doit()\n+    assert p.subs(n, 2).doit() == S(15)/2\n+\n+\n def test_rewrite_Sum():\n     assert Product(1 - S.Half**2/k**2, (k, 1, oo)).rewrite(Sum) == \\\n         exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13551"}