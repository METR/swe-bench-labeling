{"instance_id": "sympy__sympy-13852", "score": "I", "diff": "diff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex 3911dadd10..85c432ae53 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -128,10 +128,13 @@ def test_polylog_expansion():\n     assert polylog(s, 1) == zeta(s)\n     assert polylog(s, -1) == -dirichlet_eta(s)\n \n-    assert myexpand(polylog(1, z), -log(1 + exp_polar(-I*pi)*z))\n+    assert myexpand(polylog(1, z), -log(1 - z))\n     assert myexpand(polylog(0, z), z/(1 - z))\n     assert myexpand(polylog(-1, z), z**2/(1 - z)**2 + z/(1 - z))\n     assert myexpand(polylog(-5, z), None)\n+    \n+    # Test special value polylog(2, 1/2)\n+    assert polylog(2, S.Half) == -log(2)**2/2 + pi**2/12\n \n \n def test_lerchphi_expansion():\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex b8e2b66195..1181d10232 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,7 +253,7 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(z*exp_polar(-I*pi) + 1)\n+    -log(1 - z)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n@@ -277,6 +277,10 @@ def eval(cls, s, z):\n             return -dirichlet_eta(s)\n         elif z == 0:\n             return 0\n+        # Special case: polylog(2, 1/2) = -log(2)**2/2 + pi**2/12\n+        elif s == 2 and z == S.Half:\n+            from sympy import log\n+            return -log(2)**2/2 + pi**2/12\n \n     def fdiff(self, argindex=1):\n         s, z = self.args\n@@ -288,10 +292,10 @@ def _eval_rewrite_as_lerchphi(self, s, z):\n         return z*lerchphi(z, s, 1)\n \n     def _eval_expand_func(self, **hints):\n-        from sympy import log, expand_mul, Dummy, exp_polar, I\n+        from sympy import log, expand_mul, Dummy\n         s, z = self.args\n         if s == 1:\n-            return -log(1 + exp_polar(-I*pi)*z)\n+            return -log(1 - z)\n         if s.is_Integer and s <= 0:\n             u = Dummy('u')\n             start = u/(1 - u)\ndiff --git a/test_final_verification.py b/test_final_verification.py\nnew file mode 100644\nindex 0000000000..4881e833a2\n--- /dev/null\n+++ b/test_final_verification.py\n@@ -0,0 +1,45 @@\n+from sympy import *\n+from sympy.abc import z, s\n+\n+print(\"=== Testing polylog(2, 1/2) evaluation ===\")\n+result = polylog(2, Rational(1,2))\n+expected = -log(2)**2/2 + pi**2/12\n+print(f\"polylog(2, 1/2) = {result}\")\n+print(f\"Expected: {expected}\")\n+print(f\"Are they equal? {result == expected}\")\n+\n+print(\"\\n=== Testing polylog(1, z) expansion ===\")\n+expanded = expand_func(polylog(1, z))\n+print(f\"expand_func(polylog(1, z)) = {expanded}\")\n+print(f\"Expected: -log(1 - z)\")\n+print(f\"Are they equal? {expanded == -log(1 - z)}\")\n+\n+print(\"\\n=== Testing derivative consistency ===\")\n+# According to the issue, polylog(1, z) and -log(1-z) should be the same function\n+# so their derivatives should be equal\n+deriv1 = diff(polylog(1, z), z)\n+deriv2 = diff(-log(1 - z), z)\n+print(f\"diff(polylog(1, z), z) = {deriv1}\")\n+print(f\"diff(-log(1 - z), z) = {deriv2}\")\n+\n+# After expansion, the derivative should still be consistent\n+deriv3 = diff(expand_func(polylog(1, z)), z)\n+print(f\"diff(expand_func(polylog(1, z)), z) = {deriv3}\")\n+print(f\"Simplified difference: {simplify(deriv3 - deriv2)}\")\n+\n+print(\"\\n=== Testing numerical values ===\")\n+# Test at z = 0.5\n+z_val = 0.5\n+poly_val = polylog(1, z_val).evalf()\n+log_val = (-log(1 - z_val)).evalf()\n+print(f\"polylog(1, 0.5).evalf() = {poly_val}\")\n+print(f\"(-log(1 - 0.5)).evalf() = {log_val}\")\n+print(f\"Difference: {abs(poly_val - log_val)}\")\n+\n+print(\"\\n=== Testing expand_func no longer uses exp_polar ===\")\n+expanded_str = str(expand_func(polylog(1, z)))\n+has_exp_polar = \"exp_polar\" in expanded_str\n+print(f\"expand_func(polylog(1, z)) = {expanded_str}\")\n+print(f\"Contains exp_polar? {has_exp_polar}\")\n+\n+print(\"\\n=== All tests completed ===\")\ndiff --git a/test_issue_scenarios.py b/test_issue_scenarios.py\nnew file mode 100644\nindex 0000000000..0806837103\n--- /dev/null\n+++ b/test_issue_scenarios.py\n@@ -0,0 +1,36 @@\n+from sympy import *\n+from sympy.functions.special.zeta_functions import polylog\n+\n+print(\"Testing the exact scenarios from the issue:\")\n+print()\n+\n+# Test 1: polylog(2, Rational(1,2))\n+print(\"In [1]: polylog(2, Rational(1,2))\")\n+result = polylog(2, Rational(1,2))\n+print(f\"Out[1]: {result}\")\n+print()\n+\n+# Test 2: polylog(2, Rational(1,2)).expand(func=True)\n+print(\"In [2]: polylog(2, Rational(1,2)).expand(func=True)\")\n+result2 = polylog(2, Rational(1,2)).expand(func=True)\n+print(f\"Out[2]: {result2}\")\n+print()\n+\n+print(\"The answer should be -log(2)**2/2 + pi**2/12\")\n+expected = -log(2)**2/2 + pi**2/12\n+print(f\"Expected: {expected}\")\n+print()\n+\n+# Test expand_func on polylog(1, z)\n+print(\"Testing expand_func(polylog(1, z)):\")\n+from sympy.abc import z\n+result3 = expand_func(polylog(1, z))\n+print(f\"Result: {result3}\")\n+print(\"No longer contains exp_polar(-I*pi)!\")\n+print()\n+\n+# Verify derivative consistency\n+print(\"Verifying derivative consistency:\")\n+print(f\"expand_func(diff(polylog(1, z) + log(1 - z), z)) = {expand_func(diff(polylog(1, z) + log(1 - z), z))}\")\n+print(\"Should simplify to 0\")\n+print(f\"simplify(...) = {simplify(diff(polylog(1, z) + log(1 - z), z))}\")\ndiff --git a/test_polylog_issue.py b/test_polylog_issue.py\nnew file mode 100644\nindex 0000000000..0513b89dbc\n--- /dev/null\n+++ b/test_polylog_issue.py\n@@ -0,0 +1,26 @@\n+from sympy import *\n+from sympy.abc import z, s\n+\n+# Test current behavior\n+print(\"Testing polylog(2, 1/2):\")\n+print(f\"polylog(2, Rational(1,2)) = {polylog(2, Rational(1,2))}\")\n+print(f\"expand_func(polylog(2, Rational(1,2))) = {expand_func(polylog(2, Rational(1,2)))}\")\n+\n+# The expected value\n+expected = -log(2)**2/2 + pi**2/12\n+print(f\"Expected value: {expected}\")\n+print(f\"Expected value (numerical): {expected.evalf()}\")\n+print(f\"polylog(2, 1/2) numerical: {polylog(2, Rational(1,2)).evalf()}\")\n+\n+print(\"\\nTesting polylog(1, z) expansion:\")\n+print(f\"expand_func(polylog(1, z)) = {expand_func(polylog(1, z))}\")\n+print(f\"Expected: -log(1 - z)\")\n+\n+# Check derivative consistency\n+print(\"\\nDerivative check:\")\n+print(f\"diff(polylog(1, z), z) = {diff(polylog(1, z), z)}\")\n+print(f\"diff(expand_func(polylog(1, z)), z) = {diff(expand_func(polylog(1, z)), z)}\")\n+print(f\"diff(-log(1-z), z) = {diff(-log(1-z), z)}\")\n+\n+# Verify they should be the same\n+print(f\"\\nSimplify diff(polylog(1, z) + log(1 - z), z) = {simplify(diff(polylog(1, z) + log(1 - z), z))}\")\n", "gold_standard_diff": "From 1c752d37e6904a2476597a79e8aaa565f4bfd428 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sat, 6 Jan 2018 23:48:31 +0000\nSubject: [PATCH 1/5] Implement special values of dilogarithm, most notably at\n 2 and 1/2\n\nExpressions such as polylog(2, 2) and polylog(2, 1/2) now evaluate\nin closed form. Closes #7132.\n\nThe values are confirmed by comparing\n https://en.wikipedia.org/wiki/Spence%27s_function#Special_values\nand\n http://functions.wolfram.com/ZetaFunctionsandPolylogarithms/PolyLog2/03/02/\nand additionally checked by floating point evaluation.\n---\n .../special/tests/test_zeta_functions.py        |  9 ++++++++-\n sympy/functions/special/zeta_functions.py       | 17 +++++++++++++++--\n 2 files changed, 23 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex 3911dadd103b..d0880b613d68 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -1,6 +1,6 @@\n from sympy import (Symbol, zeta, nan, Rational, Float, pi, dirichlet_eta, log,\n                    zoo, expand_func, polylog, lerchphi, S, exp, sqrt, I,\n-                   exp_polar, polar_lift, O, stieltjes)\n+                   exp_polar, polar_lift, O, stieltjes, Abs)\n from sympy.utilities.randtest import (test_derivative_numerically as td,\n                       random_complex_number as randcplx, verify_numerically as tn)\n \n@@ -134,6 +134,13 @@ def test_polylog_expansion():\n     assert myexpand(polylog(-5, z), None)\n \n \n+def test_polylog_values():\n+    assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n+    assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n+    for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n+        assert Abs(polylog(2, z) - polylog(2, z + 1e-13)).evalf() < 1e-12\n+\n+\n def test_lerchphi_expansion():\n     assert myexpand(lerchphi(1, s, a), zeta(s, a))\n     assert myexpand(lerchphi(z, s, 1), polylog(s, z)/z)\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex b8e2b66195e0..05a42d27febb 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -1,12 +1,12 @@\n \"\"\" Riemann zeta and related function. \"\"\"\n from __future__ import print_function, division\n \n-from sympy.core import Function, S, sympify, pi\n+from sympy.core import Function, S, sympify, pi, I\n from sympy.core.function import ArgumentIndexError\n from sympy.core.compatibility import range\n from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic\n from sympy.functions.elementary.exponential import log\n-\n+from sympy.functions.elementary.miscellaneous import sqrt\n \n ###############################################################################\n ###################### LERCH TRANSCENDENT #####################################\n@@ -277,6 +277,19 @@ def eval(cls, s, z):\n             return -dirichlet_eta(s)\n         elif z == 0:\n             return 0\n+        if s == 2:\n+            if z == S.Half:\n+                return pi**2/12 - log(2)**2/2\n+            elif z == 2:\n+                return pi**2/4 - I*pi*log(2)\n+            elif z == -(sqrt(5) - 1)/2:\n+                return -pi**2/15 + log((sqrt(5)-1)/2)**2/2\n+            elif z == -(sqrt(5) + 1)/2:\n+                return -pi**2/10 - log((sqrt(5)+1)/2)**2\n+            elif z == (3 - sqrt(5))/2:\n+                return pi**2/15 - log((sqrt(5)-1)/2)**2\n+            elif z == (sqrt(5) - 1)/2:\n+                return pi**2/10 - log((sqrt(5)-1)/2)**2\n \n     def fdiff(self, argindex=1):\n         s, z = self.args\n\nFrom eae3ee5a41b0df5e1ab7b5b8ed429adbbdcda86d Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sun, 7 Jan 2018 15:44:37 +0000\nSubject: [PATCH 2/5] Test polylog values by comparing with evaluations with\n evaluate=False\n\nTo make sure none of special polylog values are mistyped, they are compared to\nwhat mpmath returns without going through SymPy eval method.\n---\n sympy/functions/special/tests/test_zeta_functions.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex d0880b613d68..1fc2de37b5b4 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -138,7 +138,7 @@ def test_polylog_values():\n     assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n     assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n     for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n-        assert Abs(polylog(2, z) - polylog(2, z + 1e-13)).evalf() < 1e-12\n+        assert Abs(polylog(2, z).evalf() - polylog(2, z, evaluate=False).evalf()) < 1e-15\n \n \n def test_lerchphi_expansion():\n\nFrom 95779840d5a4291d46aebb4eb0567748b123ce24 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Sun, 7 Jan 2018 22:55:33 +0000\nSubject: [PATCH 3/5] Polylog should return S.Zero instead of Python's 0 when\n z=0\n\nThe returned value is expected to be a SymPy object, \"return 0\"\nin a SymPy function is incorrect.\n---\n sympy/functions/special/zeta_functions.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 05a42d27febb..09da612c1d60 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -276,7 +276,7 @@ def eval(cls, s, z):\n         elif z == -1:\n             return -dirichlet_eta(s)\n         elif z == 0:\n-            return 0\n+            return S.Zero\n         if s == 2:\n             if z == S.Half:\n                 return pi**2/12 - log(2)**2/2\n\nFrom 39e1eb8d22692f8a470cf8e26b4c7b1313f03cc6 Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Mon, 8 Jan 2018 14:36:23 +0000\nSubject: [PATCH 4/5] Evaluate polylog(s, z) for s in [-1, 0, 1], without\n exp_polar\n\npolylog(s, z) has simple formulas for s in -1, 0, 1. They should be\nused by eval, just as it uses the formulas for z in -1, 0, 1 without\nthe user needing to expand_func. For example:\n```\n>>> polylog(2, S(1)/2)\n-log(2)**2/2 + pi**2/12\n>>> polylog(1, S(1)/2)\nlog(2)     # previously this returned unevaluated\n```\nOne has to draw the line somewhere, and I left s = -2 and the rest\nun-evaluated, subject to the user applying expand_func\n\nPer the discussion at #13853 the expansion for s = -1 is simply\n-log(1 - z), as it appears in Wikipedia, Wolfram, etc.\n---\n sympy/functions/special/tests/test_zeta_functions.py | 10 ++++++++--\n sympy/functions/special/zeta_functions.py            | 12 +++++++++---\n 2 files changed, 17 insertions(+), 5 deletions(-)\n\ndiff --git a/sympy/functions/special/tests/test_zeta_functions.py b/sympy/functions/special/tests/test_zeta_functions.py\nindex 1fc2de37b5b4..486047694445 100644\n--- a/sympy/functions/special/tests/test_zeta_functions.py\n+++ b/sympy/functions/special/tests/test_zeta_functions.py\n@@ -128,17 +128,23 @@ def test_polylog_expansion():\n     assert polylog(s, 1) == zeta(s)\n     assert polylog(s, -1) == -dirichlet_eta(s)\n \n-    assert myexpand(polylog(1, z), -log(1 + exp_polar(-I*pi)*z))\n+    assert myexpand(polylog(1, z), -log(1 - z))\n     assert myexpand(polylog(0, z), z/(1 - z))\n-    assert myexpand(polylog(-1, z), z**2/(1 - z)**2 + z/(1 - z))\n+    assert myexpand(polylog(-1, z), z/(1 - z)**2)\n+    assert ((1-z)**3 * expand_func(polylog(-2, z))).simplify() == z*(1 + z)\n     assert myexpand(polylog(-5, z), None)\n \n \n def test_polylog_values():\n+    import random\n     assert polylog(2, 2) == pi**2/4 - I*pi*log(2)\n     assert polylog(2, S.Half) == pi**2/12 - log(2)**2/2\n     for z in [S.Half, 2, (sqrt(5)-1)/2, -(sqrt(5)-1)/2, -(sqrt(5)+1)/2, (3-sqrt(5))/2]:\n         assert Abs(polylog(2, z).evalf() - polylog(2, z, evaluate=False).evalf()) < 1e-15\n+    for s in [-1, 0, 1]:\n+        for _ in range(10):\n+            z = random.uniform(-5, 5) + I*random.uniform(-5, 5)\n+            assert Abs(polylog(s, z).evalf() - polylog(s, z, evaluate=False).evalf()) < 1e-15\n \n \n def test_lerchphi_expansion():\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 09da612c1d60..80fbd78bd7d0 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,7 +253,7 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(z*exp_polar(-I*pi) + 1)\n+    -log(1 - z)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n@@ -277,7 +277,7 @@ def eval(cls, s, z):\n             return -dirichlet_eta(s)\n         elif z == 0:\n             return S.Zero\n-        if s == 2:\n+        elif s == 2:\n             if z == S.Half:\n                 return pi**2/12 - log(2)**2/2\n             elif z == 2:\n@@ -290,6 +290,12 @@ def eval(cls, s, z):\n                 return pi**2/15 - log((sqrt(5)-1)/2)**2\n             elif z == (sqrt(5) - 1)/2:\n                 return pi**2/10 - log((sqrt(5)-1)/2)**2\n+        elif s == 1:\n+            return -log(1 - z)\n+        elif s == 0:\n+            return z/(1 - z)\n+        elif s == -1:\n+            return z/(1 - z)**2\n \n     def fdiff(self, argindex=1):\n         s, z = self.args\n@@ -304,7 +310,7 @@ def _eval_expand_func(self, **hints):\n         from sympy import log, expand_mul, Dummy, exp_polar, I\n         s, z = self.args\n         if s == 1:\n-            return -log(1 + exp_polar(-I*pi)*z)\n+            return -log(1 - z)\n         if s.is_Integer and s <= 0:\n             u = Dummy('u')\n             start = u/(1 - u)\n\nFrom 2a0ff1748f50829a47b66c7dc6056729ec7059fc Mon Sep 17 00:00:00 2001\nFrom: Leonid Kovalev <normalhuman@users.noreply.github.com>\nDate: Mon, 8 Jan 2018 19:39:12 +0000\nSubject: [PATCH 5/5] Do not expand polylog(1, z) to -log(1-z) without\n expand_func\n\nIt seemed like a good idea, but series summation methods work better\nwith polylog when the sum is to be expressed in terms of zeta function.\n---\n sympy/functions/special/zeta_functions.py | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py\nindex 80fbd78bd7d0..8e9737aaf647 100644\n--- a/sympy/functions/special/zeta_functions.py\n+++ b/sympy/functions/special/zeta_functions.py\n@@ -253,7 +253,7 @@ class polylog(Function):\n     >>> from sympy import expand_func\n     >>> from sympy.abc import z\n     >>> expand_func(polylog(1, z))\n-    -log(1 - z)\n+    -log(-z + 1)\n     >>> expand_func(polylog(0, z))\n     z/(-z + 1)\n \n@@ -290,8 +290,9 @@ def eval(cls, s, z):\n                 return pi**2/15 - log((sqrt(5)-1)/2)**2\n             elif z == (sqrt(5) - 1)/2:\n                 return pi**2/10 - log((sqrt(5)-1)/2)**2\n-        elif s == 1:\n-            return -log(1 - z)\n+        # For s = 0 or -1 use explicit formulas to evaluate, but\n+        # automatically expanding polylog(1, z) to -log(1-z) seems undesirable\n+        # for summation methods based on hypergeometric functions\n         elif s == 0:\n             return z/(1 - z)\n         elif s == -1:\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/13852"}