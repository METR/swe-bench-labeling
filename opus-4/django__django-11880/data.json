{"instance_id": "django__django-11880", "score": "C", "diff": "diff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7..4cc3133ca0 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -200,6 +200,7 @@ class Field:\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n         result.validators = self.validators[:]\n+        result.error_messages = copy.deepcopy(self.error_messages, memo)\n         return result\n \n \ndiff --git a/test_deepcopy_comprehensive.py b/test_deepcopy_comprehensive.py\nnew file mode 100644\nindex 0000000000..bd145443a3\n--- /dev/null\n+++ b/test_deepcopy_comprehensive.py\n@@ -0,0 +1,102 @@\n+#!/usr/bin/env python\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        USE_I18N=True,\n+        SECRET_KEY='test-key',\n+    )\n+    django.setup()\n+\n+import copy\n+from django.forms import CharField, IntegerField, EmailField, Form, ModelForm\n+from django.core.exceptions import ValidationError\n+\n+# Test case 1: Basic deepcopy with custom error messages\n+print(\"Test 1: Basic deepcopy with custom error messages\")\n+field1 = CharField(error_messages={'required': 'Original message', 'invalid': 'Invalid input'})\n+field2 = copy.deepcopy(field1)\n+\n+# Modify the error message in field2\n+field2.error_messages['required'] = 'Modified message'\n+field2.error_messages['new_error'] = 'New error message'\n+\n+print(f\"field1 error_messages: {field1.error_messages}\")\n+print(f\"field2 error_messages: {field2.error_messages}\")\n+print(f\"field1 has 'new_error'? {'new_error' in field1.error_messages}\")\n+print()\n+\n+# Test case 2: Ensure default error messages are preserved\n+print(\"Test 2: Default error messages preservation\")\n+int_field1 = IntegerField()\n+int_field2 = copy.deepcopy(int_field1)\n+\n+# Modify error message in field2\n+int_field2.error_messages['invalid'] = 'Custom invalid number message'\n+\n+print(f\"int_field1 'invalid' message: {int_field1.error_messages.get('invalid', 'NOT FOUND')}\")\n+print(f\"int_field2 'invalid' message: {int_field2.error_messages.get('invalid', 'NOT FOUND')}\")\n+print()\n+\n+# Test case 3: Nested dictionary modifications\n+print(\"Test 3: Complex error message structure\")\n+field3 = CharField(error_messages={'required': {'code': 'REQ001', 'message': 'Field is required'}})\n+field4 = copy.deepcopy(field3)\n+\n+# Modify nested structure\n+if isinstance(field4.error_messages['required'], dict):\n+    field4.error_messages['required']['code'] = 'REQ002'\n+\n+print(f\"field3 error_messages: {field3.error_messages}\")\n+print(f\"field4 error_messages: {field4.error_messages}\")\n+print()\n+\n+# Test case 4: Form fields isolation\n+print(\"Test 4: Form fields isolation\")\n+class TestForm(Form):\n+    name = CharField(error_messages={'required': 'Name is required'})\n+    email = EmailField(error_messages={'invalid': 'Invalid email'})\n+\n+form1 = TestForm()\n+form2 = TestForm()\n+\n+# Modify the error messages in form2\n+form2.fields['name'].error_messages['required'] = 'Modified: Name is required'\n+form2.fields['email'].error_messages['invalid'] = 'Modified: Invalid email'\n+\n+print(f\"form1 name required: {form1.fields['name'].error_messages['required']}\")\n+print(f\"form2 name required: {form2.fields['name'].error_messages['required']}\")\n+print(f\"form1 email invalid: {form1.fields['email'].error_messages['invalid']}\")\n+print(f\"form2 email invalid: {form2.fields['email'].error_messages['invalid']}\")\n+print()\n+\n+# Test case 5: Validators still work correctly\n+print(\"Test 5: Validators functionality\")\n+field5 = IntegerField(min_value=0, max_value=100)\n+field6 = copy.deepcopy(field5)\n+\n+try:\n+    field5.clean(-1)\n+except ValidationError as e:\n+    print(f\"field5 validation error: {e}\")\n+\n+try:\n+    field6.clean(101)\n+except ValidationError as e:\n+    print(f\"field6 validation error: {e}\")\n+\n+print()\n+\n+# Test case 6: Widget deepcopy still works\n+print(\"Test 6: Widget deepcopy verification\")\n+field7 = CharField(widget=CharField.widget(attrs={'class': 'custom-class'}))\n+field8 = copy.deepcopy(field7)\n+\n+field8.widget.attrs['class'] = 'modified-class'\n+\n+print(f\"field7 widget class: {field7.widget.attrs.get('class', 'NO CLASS')}\")\n+print(f\"field8 widget class: {field8.widget.attrs.get('class', 'NO CLASS')}\")\ndiff --git a/test_deepcopy_issue.py b/test_deepcopy_issue.py\nnew file mode 100644\nindex 0000000000..bc26cdb6a7\n--- /dev/null\n+++ b/test_deepcopy_issue.py\n@@ -0,0 +1,44 @@\n+#!/usr/bin/env python\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        USE_I18N=True,\n+        SECRET_KEY='test-key',\n+    )\n+    django.setup()\n+\n+import copy\n+from django.forms import CharField, Form\n+\n+# Test case 1: Direct field deepcopy\n+field1 = CharField(error_messages={'required': 'Original message'})\n+field2 = copy.deepcopy(field1)\n+\n+# Modify the error message in field2\n+field2.error_messages['required'] = 'Modified message'\n+\n+print(\"Test 1 - Direct field deepcopy:\")\n+print(f\"field1 error_messages: {field1.error_messages}\")\n+print(f\"field2 error_messages: {field2.error_messages}\")\n+print(f\"Same dictionary? {field1.error_messages is field2.error_messages}\")\n+print()\n+\n+# Test case 2: Form fields\n+class TestForm(Form):\n+    name = CharField(error_messages={'required': 'Name is required'})\n+\n+form1 = TestForm()\n+form2 = TestForm()\n+\n+# Modify the error message in form2\n+form2.fields['name'].error_messages['required'] = 'Modified: Name is required'\n+\n+print(\"Test 2 - Form fields:\")\n+print(f\"form1.fields['name'].error_messages: {form1.fields['name'].error_messages}\")\n+print(f\"form2.fields['name'].error_messages: {form2.fields['name'].error_messages}\")\n+print(f\"Same dictionary? {form1.fields['name'].error_messages is form2.fields['name'].error_messages}\")\ndiff --git a/test_field_deepcopy.py b/test_field_deepcopy.py\nnew file mode 100644\nindex 0000000000..25166d7ab6\n--- /dev/null\n+++ b/test_field_deepcopy.py\n@@ -0,0 +1,127 @@\n+\"\"\"\n+Test for form field deepcopy fix - ensuring error_messages are properly deep copied\n+\"\"\"\n+import os\n+import sys\n+sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n+\n+import django\n+from django.conf import settings\n+\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_I18N=True,\n+        SECRET_KEY='test',\n+    )\n+    django.setup()\n+\n+import copy\n+from django.test import TestCase\n+from django.forms import CharField, IntegerField, Form\n+\n+\n+class FieldDeepCopyTest(TestCase):\n+    \"\"\"Test that form field deepcopy properly handles error_messages\"\"\"\n+    \n+    def test_deepcopy_error_messages_isolation(self):\n+        \"\"\"Test that error_messages are properly isolated after deepcopy\"\"\"\n+        field1 = CharField(error_messages={'required': 'Original message'})\n+        field2 = copy.deepcopy(field1)\n+        \n+        # Modify field2's error message\n+        field2.error_messages['required'] = 'Modified message'\n+        \n+        # Assert that field1's error message is unchanged\n+        self.assertEqual(field1.error_messages['required'], 'Original message')\n+        self.assertEqual(field2.error_messages['required'], 'Modified message')\n+        self.assertIsNot(field1.error_messages, field2.error_messages)\n+    \n+    def test_deepcopy_nested_error_messages(self):\n+        \"\"\"Test that nested structures in error_messages are properly deep copied\"\"\"\n+        field1 = CharField(error_messages={'required': {'code': 'REQ001', 'text': 'Required'}})\n+        field2 = copy.deepcopy(field1)\n+        \n+        # Modify nested structure\n+        field2.error_messages['required']['code'] = 'REQ002'\n+        \n+        # Assert original is unchanged\n+        self.assertEqual(field1.error_messages['required']['code'], 'REQ001')\n+        self.assertEqual(field2.error_messages['required']['code'], 'REQ002')\n+    \n+    def test_form_instances_have_isolated_error_messages(self):\n+        \"\"\"Test that different form instances have isolated field error messages\"\"\"\n+        class TestForm(Form):\n+            name = CharField(error_messages={'required': 'Name is required'})\n+        \n+        form1 = TestForm()\n+        form2 = TestForm()\n+        \n+        # Modify form2's field error message\n+        form2.fields['name'].error_messages['required'] = 'Modified: Name is required'\n+        \n+        # Assert form1 is unchanged\n+        self.assertEqual(form1.fields['name'].error_messages['required'], 'Name is required')\n+        self.assertEqual(form2.fields['name'].error_messages['required'], 'Modified: Name is required')\n+    \n+    def test_default_error_messages_preserved(self):\n+        \"\"\"Test that default error messages are preserved and isolated\"\"\"\n+        field1 = IntegerField()\n+        field2 = copy.deepcopy(field1)\n+        \n+        # Get the default invalid message\n+        default_msg = field1.error_messages.get('invalid')\n+        self.assertIsNotNone(default_msg)\n+        \n+        # Modify field2's error message\n+        field2.error_messages['invalid'] = 'Custom invalid message'\n+        \n+        # Assert field1 still has default\n+        self.assertEqual(field1.error_messages['invalid'], default_msg)\n+        self.assertEqual(field2.error_messages['invalid'], 'Custom invalid message')\n+    \n+    def test_widget_deepcopy_still_works(self):\n+        \"\"\"Test that widget deepcopy functionality is not affected\"\"\"\n+        from django.forms.widgets import TextInput\n+        \n+        field1 = CharField(widget=TextInput(attrs={'class': 'original'}))\n+        field2 = copy.deepcopy(field1)\n+        \n+        # Modify field2's widget\n+        field2.widget.attrs['class'] = 'modified'\n+        \n+        # Assert widgets are isolated\n+        self.assertEqual(field1.widget.attrs['class'], 'original')\n+        self.assertEqual(field2.widget.attrs['class'], 'modified')\n+        self.assertIsNot(field1.widget, field2.widget)\n+    \n+    def test_validators_still_copied_correctly(self):\n+        \"\"\"Test that validators list is still shallow copied as expected\"\"\"\n+        from django.core.validators import MinValueValidator, MaxValueValidator\n+        \n+        field1 = IntegerField(min_value=0, max_value=100)\n+        field2 = copy.deepcopy(field1)\n+        \n+        # Both fields should have validators\n+        self.assertTrue(any(isinstance(v, MinValueValidator) for v in field1.validators))\n+        self.assertTrue(any(isinstance(v, MaxValueValidator) for v in field1.validators))\n+        self.assertTrue(any(isinstance(v, MinValueValidator) for v in field2.validators))\n+        self.assertTrue(any(isinstance(v, MaxValueValidator) for v in field2.validators))\n+        \n+        # Validators list should be different instances\n+        self.assertIsNot(field1.validators, field2.validators)\n+\n+\n+if __name__ == '__main__':\n+    import unittest\n+    unittest.main()\ndiff --git a/test_modelform_deepcopy.py b/test_modelform_deepcopy.py\nnew file mode 100644\nindex 0000000000..999f91d0a3\n--- /dev/null\n+++ b/test_modelform_deepcopy.py\n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python\n+import os\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        USE_I18N=True,\n+        SECRET_KEY='test-key',\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+    )\n+    django.setup()\n+\n+from django.db import models\n+from django.forms import ModelForm\n+\n+# Create a simple model\n+class TestModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    email = models.EmailField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create a ModelForm\n+class TestModelForm(ModelForm):\n+    class Meta:\n+        model = TestModel\n+        fields = ['name', 'email']\n+        error_messages = {\n+            'name': {\n+                'required': 'Name is required',\n+            },\n+            'email': {\n+                'invalid': 'Invalid email address',\n+            }\n+        }\n+\n+# Test ModelForm instances\n+form1 = TestModelForm()\n+form2 = TestModelForm()\n+\n+print(\"Initial error messages:\")\n+print(f\"form1 name required: {form1.fields['name'].error_messages.get('required', 'NOT SET')}\")\n+print(f\"form2 name required: {form2.fields['name'].error_messages.get('required', 'NOT SET')}\")\n+\n+# Modify form2's error message\n+form2.fields['name'].error_messages['required'] = 'Modified: Name is required'\n+\n+print(\"\\nAfter modification:\")\n+print(f\"form1 name required: {form1.fields['name'].error_messages.get('required', 'NOT SET')}\")\n+print(f\"form2 name required: {form2.fields['name'].error_messages.get('required', 'NOT SET')}\")\n+print(f\"Same dictionary? {form1.fields['name'].error_messages is form2.fields['name'].error_messages}\")\n", "gold_standard_diff": "From a28d1b38e55cf588cfaae97de6a575d5c9f90a96 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Tue, 8 Oct 2019 09:38:28 +0200\nSubject: [PATCH] Fixed #30839 -- Fixed Field.__deepcopy__() so forms don't\n share error messages.\n\n---\n django/forms/fields.py                |  1 +\n tests/forms_tests/tests/test_forms.py | 11 +++++++++++\n 2 files changed, 12 insertions(+)\n\ndiff --git a/django/forms/fields.py b/django/forms/fields.py\nindex 03cd8af8d7b2..36ec63492904 100644\n--- a/django/forms/fields.py\n+++ b/django/forms/fields.py\n@@ -199,6 +199,7 @@ def __deepcopy__(self, memo):\n         result = copy.copy(self)\n         memo[id(self)] = result\n         result.widget = copy.deepcopy(self.widget, memo)\n+        result.error_messages = self.error_messages.copy()\n         result.validators = self.validators[:]\n         return result\n \ndiff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 45f5405fee87..269567dac88b 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3685,6 +3685,17 @@ def test_empty_data_files_multi_value_dict(self):\n         self.assertIsInstance(p.data, MultiValueDict)\n         self.assertIsInstance(p.files, MultiValueDict)\n \n+    def test_field_deep_copy_error_messages(self):\n+        class CustomCharField(CharField):\n+            def __init__(self, **kwargs):\n+                kwargs['error_messages'] = {'invalid': 'Form custom error message.'}\n+                super().__init__(**kwargs)\n+\n+        field = CustomCharField()\n+        field_copy = copy.deepcopy(field)\n+        self.assertIsInstance(field_copy, CustomCharField)\n+        self.assertIsNot(field_copy.error_messages, field.error_messages)\n+\n \n class CustomRenderer(DjangoTemplates):\n     pass\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11880"}