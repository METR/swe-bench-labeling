{"instance_id": "django__django-11734", "score": "I", "diff": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 2b59dd301a..d04e643b6b 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -567,7 +567,12 @@ class OuterRef(F):\n                            summarize=False, for_save=False, simple_col=False):\n         if isinstance(self.name, self.__class__):\n             return self.name\n-        return ResolvedOuterRef(self.name)\n+        resolved = ResolvedOuterRef(self.name)\n+        if query and query.negated:\n+            # When used in a negated context (exclude or ~Q), wrap the resolved\n+            # OuterRef in a Value to prevent the \"only be used in a subquery\" error\n+            return Value(resolved, output_field=resolved.output_field)\n+        return resolved\n \n \n class Func(SQLiteNumericMixin, Expression):\n", "gold_standard_diff": "From 600628f8f0ab077c62223a54a6c8cde6cbbd1ed1 Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <simon.charette@zapier.com>\nDate: Sun, 1 Sep 2019 14:25:28 -0400\nSubject: [PATCH 1/2] Refs #28442 -- Adjusted related lookups handling of\n expression rhs.\n\nExpressions should never be prepared as other Lookup.get_prep_lookup\nimplementations hint at by returning early on the presence of the\nresolve_expression attribute.\n\nThe previous solution was only handling lookups against related fields\npointing at AutoFields and would break for foreign keys to other fields.\n\nIt was also causing bidirectional coupling between model fields and\nexpressions which the method level import of OuterRef was a symptom of.\n---\n django/db/models/fields/__init__.py        | 4 ----\n django/db/models/fields/related_lookups.py | 2 +-\n 2 files changed, 1 insertion(+), 5 deletions(-)\n\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 6e924a4adfc9..9ce46e3f7363 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -2332,10 +2332,6 @@ def get_db_prep_value(self, value, connection, prepared=False):\n             value = connection.ops.validate_autopk_value(value)\n         return value\n \n-    def get_prep_value(self, value):\n-        from django.db.models.expressions import OuterRef\n-        return value if isinstance(value, OuterRef) else super().get_prep_value(value)\n-\n     def contribute_to_class(self, cls, name, **kwargs):\n         assert not cls._meta.auto_field, (\n             \"Model %s can't have more than one auto-generated field.\"\ndiff --git a/django/db/models/fields/related_lookups.py b/django/db/models/fields/related_lookups.py\nindex 12f7fb0b9b67..c20e220141ac 100644\n--- a/django/db/models/fields/related_lookups.py\n+++ b/django/db/models/fields/related_lookups.py\n@@ -101,7 +101,7 @@ def as_sql(self, compiler, connection):\n \n class RelatedLookupMixin:\n     def get_prep_lookup(self):\n-        if not isinstance(self.lhs, MultiColSource) and self.rhs_is_direct_value():\n+        if not isinstance(self.lhs, MultiColSource) and not hasattr(self.rhs, 'resolve_expression'):\n             # If we get here, we are dealing with single-column relations.\n             self.rhs = get_normalized_value(self.rhs, self.lhs)[0]\n             # We need to run the related field's get_prep_value(). Consider case\n\nFrom 13a8884a08342817094cc6287c7ae346100a297d Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <simon.charette@zapier.com>\nDate: Sun, 1 Sep 2019 14:35:27 -0400\nSubject: [PATCH 2/2] Fixed #30739 -- Fixed exclusion of multi-valued lookup\n against outer rhs.\n\nOuterRef right hand sides have to be nested, just like F rhs have to,\nduring the subquery pushdown split_exclude performs to ensure they are\nresolved against the outer query aliases.\n---\n django/db/models/sql/query.py |  4 +++-\n tests/queries/tests.py        | 14 +++++++++++---\n 2 files changed, 14 insertions(+), 4 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 35f3c5e1ea55..8e55bd092d8a 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1702,7 +1702,9 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n         handle.\n         \"\"\"\n         filter_lhs, filter_rhs = filter_expr\n-        if isinstance(filter_rhs, F):\n+        if isinstance(filter_rhs, OuterRef):\n+            filter_expr = (filter_lhs, OuterRef(filter_rhs))\n+        elif isinstance(filter_rhs, F):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 8339c52a02ef..081fb89d5466 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -6,7 +6,7 @@\n \n from django.core.exceptions import EmptyResultSet, FieldError\n from django.db import DEFAULT_DB_ALIAS, connection\n-from django.db.models import Count, F, Q\n+from django.db.models import Count, Exists, F, OuterRef, Q\n from django.db.models.sql.constants import LOUTER\n from django.db.models.sql.where import NothingNode, WhereNode\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n@@ -2754,10 +2754,10 @@ def setUpTestData(cls):\n         Food.objects.create(name='oranges')\n         Eaten.objects.create(food=f1, meal='dinner')\n         j1 = Job.objects.create(name='Manager')\n-        r1 = Responsibility.objects.create(description='Playing golf')\n+        cls.r1 = Responsibility.objects.create(description='Playing golf')\n         j2 = Job.objects.create(name='Programmer')\n         r2 = Responsibility.objects.create(description='Programming')\n-        JobResponsibilities.objects.create(job=j1, responsibility=r1)\n+        JobResponsibilities.objects.create(job=j1, responsibility=cls.r1)\n         JobResponsibilities.objects.create(job=j2, responsibility=r2)\n \n     def test_to_field(self):\n@@ -2810,6 +2810,14 @@ def test_exclude_reverse_fk_field_ref(self):\n     def test_exclude_with_circular_fk_relation(self):\n         self.assertEqual(ObjectB.objects.exclude(objecta__objectb__name=F('name')).count(), 0)\n \n+    def test_subquery_exclude_outerref(self):\n+        qs = JobResponsibilities.objects.filter(\n+            Exists(Responsibility.objects.exclude(jobs=OuterRef('job'))),\n+        )\n+        self.assertTrue(qs.exists())\n+        self.r1.delete()\n+        self.assertFalse(qs.exists())\n+\n \n class ExcludeTest17600(TestCase):\n     \"\"\"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11734"}