diff --git a/django/db/models/fields/related.py b/django/db/models/fields/related.py
index fad5560486..99beac9776 100644
--- a/django/db/models/fields/related.py
+++ b/django/db/models/fields/related.py
@@ -1180,7 +1180,12 @@ class ForeignKey(ForeignObject):
         return self.target_field.rel_db_type(connection=connection)
 
     def db_parameters(self, connection):
-        return {"type": self.db_type(connection), "check": self.db_check(connection)}
+        target_db_params = self.target_field.db_parameters(connection)
+        return {
+            "type": self.db_type(connection),
+            "check": self.db_check(connection),
+            "collation": target_db_params.get("collation"),
+        }
 
     def convert_empty_strings(self, value, expression, connection):
         if (not value) and isinstance(value, str):
diff --git a/test_collation_issue.py b/test_collation_issue.py
new file mode 100644
index 0000000000..dc7e2f0906
--- /dev/null
+++ b/test_collation_issue.py
@@ -0,0 +1,69 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "django.conf.global_settings")
+settings.configure(
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    }
+)
+django.setup()
+
+from django.test import TestCase
+from django.db import models, connection
+from django.db.backends.base.schema import BaseDatabaseSchemaEditor
+
+
+class CollationTestModel(models.Model):
+    id = models.CharField(primary_key=True, max_length=22, db_collation='utf8_bin')
+    
+    class Meta:
+        app_label = 'test_app'
+
+
+class RelatedModel(models.Model):
+    test_model = models.ForeignKey(CollationTestModel, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test_app'
+
+
+def test_foreign_key_collation():
+    """Test that ForeignKey fields inherit the collation from their target field"""
+    
+    # Get the target field (CollationTestModel.id)
+    target_field = CollationTestModel._meta.get_field('id')
+    
+    # Get the ForeignKey field
+    fk_field = RelatedModel._meta.get_field('test_model')
+    
+    # Check db_parameters
+    target_db_params = target_field.db_parameters(connection)
+    fk_db_params = fk_field.db_parameters(connection)
+    
+    print("Target field db_parameters:", target_db_params)
+    print("ForeignKey field db_parameters:", fk_db_params)
+    
+    # The issue: ForeignKey doesn't include collation
+    assert 'collation' in target_db_params
+    assert target_db_params['collation'] == 'utf8_bin'
+    
+    # This will fail with the current implementation
+    if 'collation' not in fk_db_params:
+        print("ERROR: ForeignKey field does not include collation from target field!")
+        print("This causes MySQL foreign key constraint errors.")
+    else:
+        print("SUCCESS: ForeignKey includes collation from target field")
+
+
+if __name__ == "__main__":
+    test_foreign_key_collation()
diff --git a/test_fk_collation.py b/test_fk_collation.py
new file mode 100644
index 0000000000..5cf9093a31
--- /dev/null
+++ b/test_fk_collation.py
@@ -0,0 +1,107 @@
+"""
+Test for ForeignKey collation propagation
+"""
+from django.test import TestCase, skipUnlessDBFeature
+from django.db import models, connection
+from django.db.models import Model, CharField, ForeignKey, OneToOneField, CASCADE
+
+
+class ForeignKeyCollationTests(TestCase):
+    """Test that ForeignKey fields inherit collation from their target fields."""
+    
+    @skipUnlessDBFeature("supports_collation_on_charfield")
+    def test_foreign_key_inherits_collation(self):
+        """ForeignKey should inherit db_collation from the target field."""
+        collation = connection.features.test_collations.get("non_default")
+        if not collation:
+            self.skipTest("Language collations are not supported.")
+        
+        class CollatedPK(Model):
+            id = CharField(
+                primary_key=True,
+                max_length=10,
+                db_collation=collation
+            )
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        class RelatedModel(Model):
+            collated = ForeignKey(CollatedPK, on_delete=CASCADE)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        # Get fields
+        pk_field = CollatedPK._meta.get_field('id')
+        fk_field = RelatedModel._meta.get_field('collated')
+        
+        # Check db_parameters
+        pk_params = pk_field.db_parameters(connection)
+        fk_params = fk_field.db_parameters(connection)
+        
+        # ForeignKey should have the same collation as the target field
+        self.assertEqual(pk_params.get('collation'), collation)
+        self.assertEqual(fk_params.get('collation'), collation)
+    
+    @skipUnlessDBFeature("supports_collation_on_charfield") 
+    def test_one_to_one_field_inherits_collation(self):
+        """OneToOneField should inherit db_collation from the target field."""
+        collation = connection.features.test_collations.get("non_default")
+        if not collation:
+            self.skipTest("Language collations are not supported.")
+        
+        class CollatedPK(Model):
+            id = CharField(
+                primary_key=True,
+                max_length=10,
+                db_collation=collation
+            )
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        class RelatedModel(Model):
+            collated = OneToOneField(CollatedPK, on_delete=CASCADE)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        # Get fields
+        pk_field = CollatedPK._meta.get_field('id')
+        o2o_field = RelatedModel._meta.get_field('collated')
+        
+        # Check db_parameters
+        pk_params = pk_field.db_parameters(connection)
+        o2o_params = o2o_field.db_parameters(connection)
+        
+        # OneToOneField should have the same collation as the target field
+        self.assertEqual(pk_params.get('collation'), collation)
+        self.assertEqual(o2o_params.get('collation'), collation)
+    
+    def test_foreign_key_no_collation(self):
+        """ForeignKey should return None for collation when target has none."""
+        
+        class RegularPK(Model):
+            id = CharField(primary_key=True, max_length=10)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        class RelatedModel(Model):
+            regular = ForeignKey(RegularPK, on_delete=CASCADE)
+            
+            class Meta:
+                app_label = 'test_app'
+        
+        # Get fields
+        pk_field = RegularPK._meta.get_field('id')
+        fk_field = RelatedModel._meta.get_field('regular')
+        
+        # Check db_parameters
+        pk_params = pk_field.db_parameters(connection)
+        fk_params = fk_field.db_parameters(connection)
+        
+        # Both should have None for collation
+        self.assertIsNone(pk_params.get('collation'))
+        self.assertIsNone(fk_params.get('collation'))
diff --git a/test_mysql_migration.py b/test_mysql_migration.py
new file mode 100644
index 0000000000..3751cd1c1e
--- /dev/null
+++ b/test_mysql_migration.py
@@ -0,0 +1,94 @@
+import os
+import django
+from django.conf import settings
+
+# Configure Django settings
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "django.conf.global_settings")
+settings.configure(
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+        'django.contrib.auth',
+    ],
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+        }
+    }
+)
+django.setup()
+
+from django.db import models, connection
+from django.db.backends.mysql.schema import DatabaseSchemaEditor
+
+
+class Account(models.Model):
+    id = models.CharField(primary_key=True, db_collation='utf8_bin', db_index=True, max_length=22)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'b_manage_account'
+
+
+class Address(models.Model):
+    id = models.CharField(primary_key=True, db_collation='utf8_bin', db_index=True, max_length=22)
+    account = models.OneToOneField(Account, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'b_manage_address'
+
+
+class Profile(models.Model):
+    id = models.CharField(primary_key=True, db_collation='utf8_bin', db_index=True, max_length=22)
+    account = models.ForeignKey('Account', verbose_name='account', null=True, blank=True, on_delete=models.CASCADE)
+    
+    class Meta:
+        app_label = 'test_app'
+        db_table = 'b_manage_profile'
+
+
+def test_mysql_collation_in_sql():
+    """Test that the generated SQL includes collation for foreign key fields"""
+    
+    # Create a mock schema editor
+    with connection.schema_editor() as editor:
+        # Simulate adding a foreign key field
+        field = Address._meta.get_field('account')
+        
+        # Get the column SQL
+        definition, params = editor.column_sql(Address, field)
+        
+        print(f"Generated SQL for Address.account: {definition}")
+        
+        # Check if collation is included
+        if 'utf8_bin' in definition:
+            print("SUCCESS: Collation is included in the foreign key column definition")
+        else:
+            print("ERROR: Collation is missing from the foreign key column definition")
+        
+        # Also test for Profile.account (nullable FK)
+        field2 = Profile._meta.get_field('account')
+        definition2, params2 = editor.column_sql(Profile, field2)
+        
+        print(f"\nGenerated SQL for Profile.account: {definition2}")
+        
+        if 'utf8_bin' in definition2:
+            print("SUCCESS: Collation is included in the nullable foreign key column definition")
+        else:
+            print("ERROR: Collation is missing from the nullable foreign key column definition")
+
+
+if __name__ == "__main__":
+    if connection.vendor == 'mysql':
+        test_mysql_collation_in_sql()
+    else:
+        print("This test requires MySQL connection. Testing db_parameters instead...")
+        # Fallback test
+        account_field = Account._meta.get_field('id')
+        address_fk_field = Address._meta.get_field('account')
+        profile_fk_field = Profile._meta.get_field('account')
+        
+        print("Account.id db_parameters:", account_field.db_parameters(connection))
+        print("Address.account db_parameters:", address_fk_field.db_parameters(connection))
+        print("Profile.account db_parameters:", profile_fk_field.db_parameters(connection))
