{"instance_id": "sympy__sympy-24661", "score": "I", "diff": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 52711d1324..652aee5349 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -897,14 +897,15 @@ def stringify_expr(s: str, local_dict: DICT, global_dict: DICT,\n     return untokenize(tokens)\n \n \n-def eval_expr(code, local_dict: DICT, global_dict: DICT):\n+def eval_expr(code, local_dict: DICT, global_dict: DICT, evaluate=True):\n     \"\"\"\n     Evaluate Python code generated by ``stringify_expr``.\n \n     Generally, ``parse_expr`` should be used.\n     \"\"\"\n-    expr = eval(\n-        code, global_dict, local_dict)  # take local objects in preference\n+    from sympy.core.parameters import evaluate as sympy_evaluate\n+    with sympy_evaluate(evaluate):\n+        expr = eval(code, global_dict, local_dict)  # take local objects in preference\n     return expr\n \n \n@@ -914,6 +915,9 @@ def parse_expr(s: str, local_dict: Optional[DICT] = None,\n                global_dict: Optional[DICT] = None, evaluate=True):\n     \"\"\"Converts the string ``s`` to a SymPy expression, in ``local_dict``.\n \n+    Note: The `evaluate` parameter is now properly handled for all expressions,\n+    including relationals.\n+\n     Parameters\n     ==========\n \n@@ -1075,7 +1079,7 @@ def parse_expr(s: str, local_dict: Optional[DICT] = None,\n         code = compile(evaluateFalse(code), '<string>', 'eval')\n \n     try:\n-        rv = eval_expr(code, local_dict, global_dict)\n+        rv = eval_expr(code, local_dict, global_dict, evaluate=evaluate)\n         # restore neutral definitions for names\n         for i in local_dict.pop(null, ()):\n             local_dict[i] = null\ndiff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 7c43e1fce3..70268e4b7e 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -319,6 +319,11 @@ def test_issue_19501():\n         (implicit_multiplication_application,)))\n     assert eq.free_symbols == {x}\n \n+def test_relational_evaluate_false():\n+    from sympy import Lt\n+    assert parse_expr('1 < 2', evaluate=False) == Lt(1, 2, evaluate=False)\n+    assert str(parse_expr('1 < 2', evaluate=False)) == '1 < 2'\n+\n \n def test_parsing_definitions():\n     from sympy.abc import x\n", "gold_standard_diff": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 52711d132478..130302099da4 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -1119,6 +1119,29 @@ class EvaluateFalseTransformer(ast.NodeTransformer):\n         'exp', 'ln', 'log', 'sqrt', 'cbrt',\n     )\n \n+    relational_operators = {\n+        ast.NotEq: 'Ne',\n+        ast.Lt: 'Lt',\n+        ast.LtE: 'Le',\n+        ast.Gt: 'Gt',\n+        ast.GtE: 'Ge',\n+        ast.Eq: 'Eq'\n+    }\n+    def visit_Compare(self, node):\n+        if node.ops[0].__class__ in self.relational_operators:\n+            sympy_class = self.relational_operators[node.ops[0].__class__]\n+            right = self.visit(node.comparators[0])\n+            left = self.visit(node.left)\n+            new_node = ast.Call(\n+                func=ast.Name(id=sympy_class, ctx=ast.Load()),\n+                args=[left, right],\n+                keywords=[ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load()))],\n+                starargs=None,\n+                kwargs=None\n+            )\n+            return new_node\n+        return node\n+\n     def flatten(self, args, func):\n         result = []\n         for arg in args:\ndiff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 7c43e1fce32c..6088ceffd907 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -6,7 +6,7 @@\n import types\n \n from sympy.assumptions import Q\n-from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq\n+from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq, Lt, Le, Gt, Ge, Ne\n from sympy.functions import exp, factorial, factorial2, sin, Min, Max\n from sympy.logic import And\n from sympy.series import Limit\n@@ -279,6 +279,17 @@ def test_parse_function_issue_3539():\n     f = Function('f')\n     assert parse_expr('f(x)') == f(x)\n \n+def test_issue_24288():\n+    inputs = {\n+        \"1 < 2\": Lt(1, 2, evaluate=False),\n+        \"1 <= 2\": Le(1, 2, evaluate=False),\n+        \"1 > 2\": Gt(1, 2, evaluate=False),\n+        \"1 >= 2\": Ge(1, 2, evaluate=False),\n+        \"1 != 2\": Ne(1, 2, evaluate=False),\n+        \"1 == 2\": Eq(1, 2, evaluate=False)\n+    }\n+    for text, result in inputs.items():\n+        assert parse_expr(text, evaluate=False) == result\n \n def test_split_symbols_numeric():\n     transformations = (\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/24661"}