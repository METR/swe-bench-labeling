{"instance_id": "scikit-learn__scikit-learn-26194", "score": "I", "diff": "diff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex 0cdead923..7b3c3d5e9 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -1083,7 +1083,10 @@ def roc_curve(\n     # to make sure that the curve starts at (0, 0)\n     tps = np.r_[0, tps]\n     fps = np.r_[0, fps]\n-    thresholds = np.r_[thresholds[0] + 1, thresholds]\n+    if thresholds[0] <= 1:\n+        thresholds = np.r_[min(thresholds[0] + 1, 1), thresholds]\n+    else:\n+        thresholds = np.r_[thresholds[0] + 1, thresholds]\n \n     if fps[-1] <= 0:\n         warnings.warn(\ndiff --git a/sklearn/metrics/tests/test_ranking.py b/sklearn/metrics/tests/test_ranking.py\nindex f38f118c3..911cd8ee0 100644\n--- a/sklearn/metrics/tests/test_ranking.py\n+++ b/sklearn/metrics/tests/test_ranking.py\n@@ -1160,6 +1160,14 @@ def test_average_precision_constant_values():\n     assert average_precision_score(y_true, y_score) == 0.25\n \n \n+def test_roc_curve_with_probability_estimates():\n+    rng = np.random.RandomState(42)\n+    y_true = rng.randint(0, 2, size=10)\n+    y_score = rng.rand(10)\n+    fpr, tpr, thresholds = roc_curve(y_true, y_score)\n+    assert np.all(np.logical_or(thresholds <= 1, thresholds == thresholds[0] + 1))\n+    assert thresholds[0] <= 1\n+\n def test_average_precision_score_pos_label_errors():\n     # Raise an error when pos_label is not in binary y_true\n     y_true = np.array([0, 1])\n", "gold_standard_diff": "diff --git a/doc/modules/model_evaluation.rst b/doc/modules/model_evaluation.rst\nindex 537f23e49d2dc..c0b0ab67de786 100644\n--- a/doc/modules/model_evaluation.rst\n+++ b/doc/modules/model_evaluation.rst\n@@ -1366,7 +1366,7 @@ function::\n     >>> tpr\n     array([0. , 0.5, 0.5, 1. , 1. ])\n     >>> thresholds\n-    array([1.8 , 0.8 , 0.4 , 0.35, 0.1 ])\n+    array([ inf, 0.8 , 0.4 , 0.35, 0.1 ])\n \n Compared to metrics such as the subset accuracy, the Hamming loss, or the\n F1 score, ROC doesn't require optimizing a threshold for each label.\ndiff --git a/doc/whats_new/v1.3.rst b/doc/whats_new/v1.3.rst\nindex e47c74a54edd6..6a5c0812a8622 100644\n--- a/doc/whats_new/v1.3.rst\n+++ b/doc/whats_new/v1.3.rst\n@@ -366,6 +366,11 @@ Changelog\n - |API| The `eps` parameter of the :func:`log_loss` has been deprecated and will be\n   removed in 1.5. :pr:`25299` by :user:`Omar Salman <OmarManzoor>`.\n \n+- |Fix| In :func:`metrics.roc_curve`, use the threshold value `np.inf` instead of\n+  arbritrary `max(y_score) + 1`. This threshold is associated with the ROC curve point\n+  `tpr=0` and `fpr=0`.\n+  :pr:`26194` by :user:`Guillaume Lemaitre <glemaitre>`.\n+\n :mod:`sklearn.model_selection`\n ..............................\n \ndiff --git a/sklearn/metrics/_ranking.py b/sklearn/metrics/_ranking.py\nindex 0cdead9233898..7a3b7f0cc2663 100644\n--- a/sklearn/metrics/_ranking.py\n+++ b/sklearn/metrics/_ranking.py\n@@ -1016,10 +1016,10 @@ def roc_curve(\n         Increasing true positive rates such that element `i` is the true\n         positive rate of predictions with score >= `thresholds[i]`.\n \n-    thresholds : ndarray of shape = (n_thresholds,)\n+    thresholds : ndarray of shape (n_thresholds,)\n         Decreasing thresholds on the decision function used to compute\n         fpr and tpr. `thresholds[0]` represents no instances being predicted\n-        and is arbitrarily set to `max(y_score) + 1`.\n+        and is arbitrarily set to `np.inf`.\n \n     See Also\n     --------\n@@ -1036,6 +1036,10 @@ def roc_curve(\n     are reversed upon returning them to ensure they correspond to both ``fpr``\n     and ``tpr``, which are sorted in reversed order during their calculation.\n \n+    An arbritrary threshold is added for the case `tpr=0` and `fpr=0` to\n+    ensure that the curve starts at `(0, 0)`. This threshold corresponds to the\n+    `np.inf`.\n+\n     References\n     ----------\n     .. [1] `Wikipedia entry for the Receiver operating characteristic\n@@ -1056,7 +1060,7 @@ def roc_curve(\n     >>> tpr\n     array([0. , 0.5, 0.5, 1. , 1. ])\n     >>> thresholds\n-    array([1.8 , 0.8 , 0.4 , 0.35, 0.1 ])\n+    array([ inf, 0.8 , 0.4 , 0.35, 0.1 ])\n     \"\"\"\n     fps, tps, thresholds = _binary_clf_curve(\n         y_true, y_score, pos_label=pos_label, sample_weight=sample_weight\n@@ -1083,7 +1087,8 @@ def roc_curve(\n     # to make sure that the curve starts at (0, 0)\n     tps = np.r_[0, tps]\n     fps = np.r_[0, fps]\n-    thresholds = np.r_[thresholds[0] + 1, thresholds]\n+    # get dtype of `y_score` even if it is an array-like\n+    thresholds = np.r_[np.inf, thresholds]\n \n     if fps[-1] <= 0:\n         warnings.warn(\ndiff --git a/sklearn/metrics/tests/test_ranking.py b/sklearn/metrics/tests/test_ranking.py\nindex f38f118c38c0a..d40e48456fe9d 100644\n--- a/sklearn/metrics/tests/test_ranking.py\n+++ b/sklearn/metrics/tests/test_ranking.py\n@@ -418,13 +418,13 @@ def test_roc_curve_drop_intermediate():\n     y_true = [0, 0, 0, 0, 1, 1]\n     y_score = [0.0, 0.2, 0.5, 0.6, 0.7, 1.0]\n     tpr, fpr, thresholds = roc_curve(y_true, y_score, drop_intermediate=True)\n-    assert_array_almost_equal(thresholds, [2.0, 1.0, 0.7, 0.0])\n+    assert_array_almost_equal(thresholds, [np.inf, 1.0, 0.7, 0.0])\n \n     # Test dropping thresholds with repeating scores\n     y_true = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]\n     y_score = [0.0, 0.1, 0.6, 0.6, 0.7, 0.8, 0.9, 0.6, 0.7, 0.8, 0.9, 0.9, 1.0]\n     tpr, fpr, thresholds = roc_curve(y_true, y_score, drop_intermediate=True)\n-    assert_array_almost_equal(thresholds, [2.0, 1.0, 0.9, 0.7, 0.6, 0.0])\n+    assert_array_almost_equal(thresholds, [np.inf, 1.0, 0.9, 0.7, 0.6, 0.0])\n \n \n def test_roc_curve_fpr_tpr_increasing():\n@@ -2199,3 +2199,17 @@ def test_ranking_metric_pos_label_types(metric, classes):\n         assert not np.isnan(metric_1).any()\n         assert not np.isnan(metric_2).any()\n         assert not np.isnan(thresholds).any()\n+\n+\n+def test_roc_curve_with_probablity_estimates(global_random_seed):\n+    \"\"\"Check that thresholds do not exceed 1.0 when `y_score` is a probability\n+    estimate.\n+\n+    Non-regression test for:\n+    https://github.com/scikit-learn/scikit-learn/issues/26193\n+    \"\"\"\n+    rng = np.random.RandomState(global_random_seed)\n+    y_true = rng.randint(0, 2, size=10)\n+    y_score = rng.rand(10)\n+    _, _, thresholds = roc_curve(y_true, y_score)\n+    assert np.isinf(thresholds[0])\n", "gold_standard_pr_link": "https://github.com/scikit-learn/scikit-learn/pull/26194"}