{"instance_id": "django__django-13810", "score": "C", "diff": "diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py\nindex 8e8c3da06a..be8a114eb1 100644\n--- a/django/core/handlers/base.py\n+++ b/django/core/handlers/base.py\n@@ -51,11 +51,11 @@ class BaseHandler:\n                 middleware_is_async = middleware_can_async\n             try:\n                 # Adapt handler, if needed.\n-                handler = self.adapt_method_mode(\n+                adapted_handler = self.adapt_method_mode(\n                     middleware_is_async, handler, handler_is_async,\n                     debug=settings.DEBUG, name='middleware %s' % middleware_path,\n                 )\n-                mw_instance = middleware(handler)\n+                mw_instance = middleware(adapted_handler)\n             except MiddlewareNotUsed as exc:\n                 if settings.DEBUG:\n                     if str(exc):\ndiff --git a/test_middleware_bug.py b/test_middleware_bug.py\nnew file mode 100644\nindex 0000000000..8718f4ace2\n--- /dev/null\n+++ b/test_middleware_bug.py\n@@ -0,0 +1,88 @@\n+\"\"\"\n+Test to demonstrate the MiddlewareNotUsed bug in ASGI context.\n+\"\"\"\n+import asyncio\n+import sys\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.http import HttpResponse\n+\n+\n+class AsyncMiddlewareRaisingNotUsed:\n+    \"\"\"An async-capable middleware that raises MiddlewareNotUsed.\"\"\"\n+    sync_capable = False\n+    async_capable = True\n+    \n+    def __init__(self, get_response):\n+        raise MiddlewareNotUsed(\"This async middleware is not used\")\n+\n+\n+class SyncOnlyMiddleware:\n+    \"\"\"A synchronous-only middleware that comes after the one raising MiddlewareNotUsed.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        self.get_response = get_response\n+        print(f\"SyncOnlyMiddleware: got handler {get_response}, is coroutine function: {asyncio.iscoroutinefunction(get_response)}\")\n+    \n+    def __call__(self, request):\n+        response = self.get_response(request)\n+        response['X-Sync-Middleware'] = 'yes'\n+        return response\n+\n+\n+async def async_view(request):\n+    return HttpResponse(\"Async view response\")\n+\n+\n+def test_issue():\n+    \"\"\"Test that demonstrates the MiddlewareNotUsed issue.\"\"\"\n+    import django\n+    from django.conf import settings\n+    from django.urls import path\n+    from django.core.handlers.asgi import ASGIHandler\n+    from django.test import RequestFactory\n+    \n+    # Configure Django\n+    settings.configure(\n+        DEBUG=True,\n+        SECRET_KEY='test',\n+        ROOT_URLCONF='test_middleware_bug',\n+        MIDDLEWARE=[\n+            'test_middleware_bug.AsyncMiddlewareRaisingNotUsed',\n+            'test_middleware_bug.SyncOnlyMiddleware',\n+        ],\n+        ALLOWED_HOSTS=['*'],\n+    )\n+    django.setup()\n+    \n+    # Define URL patterns\n+    import test_middleware_bug\n+    test_middleware_bug.urlpatterns = [\n+        path('async/', async_view),\n+    ]\n+    \n+    # Create ASGI handler - this will load middleware\n+    handler = ASGIHandler()\n+    \n+    # Create a test request\n+    rf = RequestFactory()\n+    request = rf.get('/async/')\n+    \n+    # Try to get response - this should fail with the issue\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    try:\n+        response = loop.run_until_complete(handler.get_response_async(request))\n+        print(f\"Response status: {response.status_code}\")\n+        print(f\"Response content: {response.content}\")\n+    except Exception as e:\n+        print(f\"Error: {type(e).__name__}: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+    finally:\n+        loop.close()\n+\n+\n+if __name__ == '__main__':\n+    test_issue()\ndiff --git a/test_middleware_issue.py b/test_middleware_issue.py\nnew file mode 100644\nindex 0000000000..ae6d5634c6\n--- /dev/null\n+++ b/test_middleware_issue.py\n@@ -0,0 +1,93 @@\n+import asyncio\n+import sys\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.core.handlers.asgi import ASGIHandler\n+from django.http import HttpResponse\n+from django.test import override_settings, SimpleTestCase, RequestFactory\n+from django.utils.decorators import sync_and_async_middleware\n+\n+\n+class MiddlewareRaisingNotUsed:\n+    \"\"\"Middleware that raises MiddlewareNotUsed.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        raise MiddlewareNotUsed(\"This middleware is not used\")\n+\n+\n+class SyncOnlyMiddleware:\n+    \"\"\"A synchronous-only middleware.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        self.get_response = get_response\n+    \n+    def __call__(self, request):\n+        response = self.get_response(request)\n+        response['X-Sync-Middleware'] = 'yes'\n+        return response\n+\n+\n+def sync_view(request):\n+    return HttpResponse(\"Sync view response\")\n+\n+\n+async def async_view(request):\n+    # Force an error to trigger the issue\n+    raise Exception(\"Test error\")\n+\n+\n+# Create a simple test to show the issue\n+def test_issue():\n+    \"\"\"Test that demonstrates the MiddlewareNotUsed issue.\"\"\"\n+    import django\n+    from django.conf import settings\n+    from django.urls import path\n+    \n+    # Configure Django\n+    settings.configure(\n+        DEBUG=True,\n+        SECRET_KEY='test',\n+        ROOT_URLCONF='test_middleware_issue',\n+        MIDDLEWARE=[\n+            'test_middleware_issue.MiddlewareRaisingNotUsed',\n+            'test_middleware_issue.SyncOnlyMiddleware',\n+        ],\n+        ALLOWED_HOSTS=['*'],\n+    )\n+    django.setup()\n+    \n+    # Define URL patterns\n+    import test_middleware_issue\n+    test_middleware_issue.urlpatterns = [\n+        path('sync/', sync_view),\n+        path('async/', async_view),\n+    ]\n+    \n+    # Create ASGI handler\n+    handler = ASGIHandler()\n+    \n+    # Create a test request\n+    rf = RequestFactory()\n+    request = rf.get('/async/')\n+    \n+    # Try to get response - this should fail with the issue\n+    loop = asyncio.new_event_loop()\n+    asyncio.set_event_loop(loop)\n+    try:\n+        response = loop.run_until_complete(handler.get_response_async(request))\n+        print(f\"Response status: {response.status_code}\")\n+        print(f\"Response content: {response.content}\")\n+        print(f\"Sync middleware header: {response.get('X-Sync-Middleware', 'NOT FOUND')}\")\n+    except Exception as e:\n+        print(f\"Error: {type(e).__name__}: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+    finally:\n+        loop.close()\n+\n+\n+if __name__ == '__main__':\n+    test_issue()\ndiff --git a/test_middleware_not_used_asgi.py b/test_middleware_not_used_asgi.py\nnew file mode 100644\nindex 0000000000..2f01be0791\n--- /dev/null\n+++ b/test_middleware_not_used_asgi.py\n@@ -0,0 +1,76 @@\n+import asyncio\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.core.handlers.asgi import ASGIHandler\n+from django.http import HttpResponse\n+from django.test import override_settings, SimpleTestCase\n+from django.utils.decorators import sync_and_async_middleware\n+\n+\n+class MiddlewareRaisingNotUsed:\n+    \"\"\"Middleware that raises MiddlewareNotUsed.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        raise MiddlewareNotUsed(\"This middleware is not used\")\n+\n+\n+class SyncOnlyMiddleware:\n+    \"\"\"A synchronous-only middleware.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        self.get_response = get_response\n+    \n+    def __call__(self, request):\n+        response = self.get_response(request)\n+        response['X-Sync-Middleware'] = 'yes'\n+        return response\n+\n+\n+def sync_view(request):\n+    return HttpResponse(\"Sync view response\")\n+\n+\n+async def async_view(request):\n+    return HttpResponse(\"Async view response\")\n+\n+\n+class TestMiddlewareNotUsedASGI(SimpleTestCase):\n+    @override_settings(\n+        MIDDLEWARE=[\n+            'test_middleware_not_used_asgi.MiddlewareRaisingNotUsed',\n+            'test_middleware_not_used_asgi.SyncOnlyMiddleware',\n+        ],\n+        ROOT_URLCONF='test_middleware_not_used_asgi',\n+        DEBUG=True,\n+    )\n+    async def test_middleware_not_used_with_async_handler(self):\n+        \"\"\"Test that MiddlewareNotUsed doesn't corrupt the handler chain in ASGI.\"\"\"\n+        from django.core.handlers.asgi import ASGIHandler\n+        from django.test import RequestFactory\n+        \n+        # Create ASGI handler\n+        handler = ASGIHandler()\n+        \n+        # Create a test request\n+        rf = RequestFactory()\n+        request = rf.get('/async/')\n+        \n+        # The handler should work correctly even though MiddlewareNotUsed was raised\n+        response = await handler.get_response_async(request)\n+        \n+        # The response should be valid and include the header from SyncOnlyMiddleware\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response['X-Sync-Middleware'], 'yes')\n+        self.assertEqual(response.content, b\"Async view response\")\n+\n+\n+# URL patterns for the test\n+from django.urls import path\n+\n+urlpatterns = [\n+    path('sync/', sync_view),\n+    path('async/', async_view),\n+]\ndiff --git a/test_middleware_not_used_fix.py b/test_middleware_not_used_fix.py\nnew file mode 100644\nindex 0000000000..87ed613ec7\n--- /dev/null\n+++ b/test_middleware_not_used_fix.py\n@@ -0,0 +1,96 @@\n+\"\"\"\n+Test for the fix to MiddlewareNotUsed issue in ASGI context.\n+\"\"\"\n+import asyncio\n+from django.core.exceptions import MiddlewareNotUsed\n+from django.core.handlers.asgi import ASGIHandler\n+from django.http import HttpResponse\n+from django.test import SimpleTestCase, override_settings, RequestFactory\n+from django.urls import path\n+\n+\n+class AsyncMiddlewareRaisingNotUsed:\n+    \"\"\"An async-capable middleware that raises MiddlewareNotUsed.\"\"\"\n+    sync_capable = False\n+    async_capable = True\n+    \n+    def __init__(self, get_response):\n+        raise MiddlewareNotUsed(\"This async middleware is not used\")\n+\n+\n+class SyncOnlyMiddleware:\n+    \"\"\"A synchronous-only middleware that comes after the one raising MiddlewareNotUsed.\"\"\"\n+    sync_capable = True\n+    async_capable = False\n+    \n+    def __init__(self, get_response):\n+        self.get_response = get_response\n+    \n+    def __call__(self, request):\n+        response = self.get_response(request)\n+        response['X-Sync-Middleware'] = 'processed'\n+        return response\n+\n+\n+async def async_view(request):\n+    return HttpResponse(\"Async view response\")\n+\n+\n+# URL patterns for the test\n+urlpatterns = [\n+    path('async/', async_view),\n+]\n+\n+\n+class TestMiddlewareNotUsedFix(SimpleTestCase):\n+    @override_settings(\n+        MIDDLEWARE=[\n+            'test_middleware_not_used_fix.AsyncMiddlewareRaisingNotUsed',\n+            'test_middleware_not_used_fix.SyncOnlyMiddleware',\n+        ],\n+        ROOT_URLCONF='test_middleware_not_used_fix',\n+        DEBUG=True,\n+    )\n+    def test_middleware_not_used_doesnt_corrupt_handler_chain(self):\n+        \"\"\"\n+        Test that when MiddlewareNotUsed is raised, the handler chain is not corrupted\n+        and subsequent middleware receives the correct handler.\n+        \"\"\"\n+        handler = ASGIHandler()\n+        rf = RequestFactory()\n+        request = rf.get('/async/')\n+        \n+        # Run the async handler\n+        loop = asyncio.new_event_loop()\n+        asyncio.set_event_loop(loop)\n+        try:\n+            response = loop.run_until_complete(handler.get_response_async(request))\n+            \n+            # The response should be successful and include the header from SyncOnlyMiddleware\n+            self.assertEqual(response.status_code, 200)\n+            self.assertEqual(response['X-Sync-Middleware'], 'processed')\n+            self.assertEqual(response.content, b'Async view response')\n+        finally:\n+            loop.close()\n+\n+\n+if __name__ == '__main__':\n+    import django\n+    from django.conf import settings\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        SECRET_KEY='test',\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+    )\n+    django.setup()\n+    \n+    from django.test import TestCase\n+    import unittest\n+    \n+    suite = unittest.TestLoader().loadTestsFromTestCase(TestMiddlewareNotUsedFix)\n+    runner = unittest.TextTestRunner(verbosity=2)\n+    runner.run(suite)\ndiff --git a/test_sync_middleware_not_used.py b/test_sync_middleware_not_used.py\nnew file mode 100644\nindex 0000000000..8b13789179\n--- /dev/null\n+++ b/test_sync_middleware_not_used.py\n@@ -0,0 +1 @@\n+\n", "gold_standard_diff": "diff --git a/django/core/handlers/base.py b/django/core/handlers/base.py\nindex 8e8c3da06aa5..728e449703c9 100644\n--- a/django/core/handlers/base.py\n+++ b/django/core/handlers/base.py\n@@ -51,11 +51,11 @@ def load_middleware(self, is_async=False):\n                 middleware_is_async = middleware_can_async\n             try:\n                 # Adapt handler, if needed.\n-                handler = self.adapt_method_mode(\n+                adapted_handler = self.adapt_method_mode(\n                     middleware_is_async, handler, handler_is_async,\n                     debug=settings.DEBUG, name='middleware %s' % middleware_path,\n                 )\n-                mw_instance = middleware(handler)\n+                mw_instance = middleware(adapted_handler)\n             except MiddlewareNotUsed as exc:\n                 if settings.DEBUG:\n                     if str(exc):\n@@ -63,6 +63,8 @@ def load_middleware(self, is_async=False):\n                     else:\n                         logger.debug('MiddlewareNotUsed: %r', middleware_path)\n                 continue\n+            else:\n+                handler = adapted_handler\n \n             if mw_instance is None:\n                 raise ImproperlyConfigured(\ndiff --git a/docs/releases/3.1.5.txt b/docs/releases/3.1.5.txt\nindex 0d1111844613..eea060d11220 100644\n--- a/docs/releases/3.1.5.txt\n+++ b/docs/releases/3.1.5.txt\n@@ -12,3 +12,7 @@ Bugfixes\n * Fixed ``__isnull=True`` lookup on key transforms for\n   :class:`~django.db.models.JSONField` with Oracle and SQLite\n   (:ticket:`32252`).\n+\n+* Fixed a bug in Django 3.1 that caused a crash when processing middlewares in\n+  an async context with a middleware that raises a ``MiddlewareNotUsed``\n+  exception (:ticket:`32299`).\ndiff --git a/tests/middleware_exceptions/tests.py b/tests/middleware_exceptions/tests.py\nindex 8b019ba5248a..2a389ce125c4 100644\n--- a/tests/middleware_exceptions/tests.py\n+++ b/tests/middleware_exceptions/tests.py\n@@ -181,6 +181,25 @@ def test_do_not_log_when_debug_is_false(self):\n             with self.assertLogs('django.request', 'DEBUG'):\n                 self.client.get('/middleware_exceptions/view/')\n \n+    @override_settings(MIDDLEWARE=[\n+        'middleware_exceptions.middleware.SyncAndAsyncMiddleware',\n+        'middleware_exceptions.tests.MyMiddleware',\n+    ])\n+    async def test_async_and_sync_middleware_chain_async_call(self):\n+        with self.assertLogs('django.request', 'DEBUG') as cm:\n+            response = await self.async_client.get('/middleware_exceptions/view/')\n+        self.assertEqual(response.content, b'OK')\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(\n+            cm.records[0].getMessage(),\n+            'Asynchronous middleware middleware_exceptions.tests.MyMiddleware '\n+            'adapted.',\n+        )\n+        self.assertEqual(\n+            cm.records[1].getMessage(),\n+            \"MiddlewareNotUsed: 'middleware_exceptions.tests.MyMiddleware'\",\n+        )\n+\n \n @override_settings(\n     DEBUG=True,\n", "gold_standard_pr_link": "https://github.com/django/django/pull/13810"}