{"instance_id": "pydata__xarray-6599", "score": "I", "diff": "diff --git a/check_azimuth_data.py b/check_azimuth_data.py\nnew file mode 100644\nindex 00000000..8b137891\n--- /dev/null\n+++ b/check_azimuth_data.py\n@@ -0,0 +1 @@\n+\ndiff --git a/check_expected.py b/check_expected.py\nnew file mode 100644\nindex 00000000..7a414130\n--- /dev/null\n+++ b/check_expected.py\n@@ -0,0 +1,41 @@\n+import numpy as np\n+\n+# Convert nanosecond values to seconds\n+time_values_ns = np.array([0, 10000000000, 20000000000, 30000000000, 40000000000, 50000000000])\n+time_values_s = time_values_ns / 1e9\n+print(\"Time values in seconds:\", time_values_s)\n+\n+# Expected results from the issue\n+expected = np.array([\n+    [4447392.16      , 1450539.74      , 5299608.57      ],\n+    [4505537.25588366, 1448882.82238152, 5250846.359196  ],\n+    [4563174.92026797, 1446979.12250014, 5201491.44401733],\n+    [4620298.31815291, 1444829.59596699, 5151549.377964  ],\n+    [4676900.67053846, 1442435.23739315, 5101025.78153601],\n+    [4732975.25442459, 1439797.08038974, 5049926.34223336]\n+])\n+\n+# Coefficients\n+coeffs = np.array([\n+    [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+    [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+    [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+    [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+    [4.44739216e06, 1.45053974e06, 5.29960857e06],\n+])\n+\n+# Manual polyval using seconds\n+print(\"\\nManual polyval calculation using seconds:\")\n+for i, t in enumerate(time_values_s):\n+    result = []\n+    for axis in range(3):\n+        # Horner's method from degree 4 down to 0\n+        val = coeffs[0, axis]  # degree 4\n+        for deg in range(1, 5):\n+            val = val * t + coeffs[deg, axis]\n+        result.append(val)\n+    print(f\"t={t}s: {result}\")\n+    \n+print(\"\\nExpected values:\")\n+for i in range(6):\n+    print(f\"t={time_values_s[i]}s: {expected[i]}\")\ndiff --git a/check_units.py b/check_units.py\nnew file mode 100644\nindex 00000000..86eb070a\n--- /dev/null\n+++ b/check_units.py\n@@ -0,0 +1,37 @@\n+import numpy as np\n+\n+# Let's use np.polyval to check\n+time_values_ns = np.array([0, 10000000000, 20000000000, 30000000000, 40000000000, 50000000000])\n+time_values_s = time_values_ns / 1e9\n+print(\"Time values in seconds:\", time_values_s)\n+\n+# Coefficients (note: numpy polyval expects highest degree first)\n+coeffs = np.array([\n+    [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+    [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+    [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+    [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+    [4.44739216e06, 1.45053974e06, 5.29960857e06],\n+])\n+\n+# Try using numpy's polyval with seconds\n+print(\"\\nUsing numpy.polyval with seconds:\")\n+for i, t in enumerate(time_values_s):\n+    result = []\n+    for axis in range(3):\n+        val = np.polyval(coeffs[:, axis], t)\n+        result.append(val)\n+    print(f\"t={t}s: {result}\")\n+\n+# Try using time in nanoseconds\n+print(\"\\nUsing numpy.polyval with nanoseconds:\")  \n+for i, t in enumerate(time_values_ns):\n+    result = []\n+    for axis in range(3):\n+        val = np.polyval(coeffs[:, axis], t)\n+        result.append(val)\n+    print(f\"t={t}ns: {result}\")\n+\n+# Check what the current xarray code is getting\n+print(\"\\nCurrent xarray is using values:\", time_values_ns)\n+print(\"Which produces the wrong results in the 1e+30 range\")\ndiff --git a/debug_polyval.py b/debug_polyval.py\nnew file mode 100644\nindex 00000000..d3915b45\n--- /dev/null\n+++ b/debug_polyval.py\n@@ -0,0 +1,35 @@\n+import xarray as xr\n+import numpy as np\n+\n+values = np.array(\n+    [\n+        \"2021-04-01T05:25:19.000000000\",\n+        \"2021-04-01T05:25:29.000000000\",\n+        \"2021-04-01T05:25:39.000000000\",\n+        \"2021-04-01T05:25:49.000000000\",\n+        \"2021-04-01T05:25:59.000000000\",\n+        \"2021-04-01T05:26:09.000000000\",\n+    ],\n+    dtype=\"datetime64[ns]\",\n+)\n+azimuth_time = xr.DataArray(\n+    values, name=\"azimuth_time\", coords={\"azimuth_time\": values - values[0]}\n+)\n+\n+# Check the actual data vs the coordinate\n+print(\"azimuth_time.data:\", azimuth_time.data)\n+print(\"azimuth_time.data dtype:\", azimuth_time.data.dtype)\n+print()\n+print(\"azimuth_time coords:\", azimuth_time.coords[\"azimuth_time\"].data)\n+print(\"azimuth_time coords dtype:\", azimuth_time.coords[\"azimuth_time\"].data.dtype)\n+print()\n+\n+# Now let's see what _ensure_numeric does to both\n+from xarray.core.computation import _ensure_numeric\n+numeric_time = _ensure_numeric(azimuth_time)\n+print(\"After _ensure_numeric:\")\n+print(\"numeric_time.data:\", numeric_time.data)\n+print(\"numeric_time.data dtype:\", numeric_time.data.dtype)\n+print()\n+print(\"numeric_time coords:\", numeric_time.coords[\"azimuth_time\"].data)\n+print(\"numeric_time coords dtype:\", numeric_time.coords[\"azimuth_time\"].data.dtype)\ndiff --git a/debug_polyval_step.py b/debug_polyval_step.py\nnew file mode 100644\nindex 00000000..f1c3c119\n--- /dev/null\n+++ b/debug_polyval_step.py\n@@ -0,0 +1,77 @@\n+import xarray as xr\n+import numpy as np\n+\n+values = np.array(\n+    [\n+        \"2021-04-01T05:25:19.000000000\",\n+        \"2021-04-01T05:25:29.000000000\",\n+        \"2021-04-01T05:25:39.000000000\",\n+        \"2021-04-01T05:25:49.000000000\",\n+        \"2021-04-01T05:25:59.000000000\",\n+        \"2021-04-01T05:26:09.000000000\",\n+    ],\n+    dtype=\"datetime64[ns]\",\n+)\n+azimuth_time = xr.DataArray(\n+    values, name=\"azimuth_time\", coords={\"azimuth_time\": values - values[0]}\n+)\n+\n+polyfit_coefficients = xr.DataArray(\n+    [\n+        [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+        [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+        [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+        [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+        [4.44739216e06, 1.45053974e06, 5.29960857e06],\n+    ],\n+    dims=(\"degree\", \"axis\"),\n+    coords={\"axis\": [0, 1, 2], \"degree\": [4, 3, 2, 1, 0]},\n+)\n+\n+# Let's manually simulate the polyval with debug output\n+from xarray.core.computation import _ensure_numeric\n+from xarray.core.common import zeros_like\n+\n+degree_dim = \"degree\"\n+coord = azimuth_time\n+coeffs = polyfit_coefficients\n+\n+# Apply _ensure_numeric\n+coord_numeric = _ensure_numeric(coord)\n+print(\"coord after _ensure_numeric:\")\n+print(coord_numeric)\n+print(\"coord_numeric.data:\", coord_numeric.data)\n+print()\n+\n+# Get max degree\n+max_deg = coeffs[degree_dim].max().item()\n+print(f\"max_deg: {max_deg}\")\n+\n+# Reindex coefficients \n+coeffs_reindexed = coeffs.reindex(\n+    {degree_dim: np.arange(max_deg + 1)}, fill_value=0, copy=False\n+)\n+print(\"\\ncoeffs_reindexed:\")\n+print(coeffs_reindexed)\n+\n+# Start Horner's method\n+res = coeffs_reindexed.isel({degree_dim: max_deg}, drop=True) + zeros_like(coord_numeric)\n+print(f\"\\nInitial res (degree {max_deg}):\")\n+print(res)\n+\n+# Continue with Horner's method\n+for deg in range(max_deg - 1, -1, -1):\n+    print(f\"\\nBefore multiplication (deg={deg}):\")\n+    print(f\"res values: {res.values}\")\n+    print(f\"coord_numeric values: {coord_numeric.values}\")\n+    \n+    res *= coord_numeric\n+    print(f\"After multiplication:\")\n+    print(f\"res values: {res.values}\")\n+    \n+    res += coeffs_reindexed.isel({degree_dim: deg}, drop=True)\n+    print(f\"After addition of coeffs[{deg}]:\")\n+    print(f\"res values: {res.values}\")\n+\n+print(\"\\nFinal result:\")\n+print(res)\ndiff --git a/test_datetime_conversion.py b/test_datetime_conversion.py\nnew file mode 100644\nindex 00000000..a80cf90b\n--- /dev/null\n+++ b/test_datetime_conversion.py\n@@ -0,0 +1,16 @@\n+import numpy as np\n+from xarray.core.duck_array_ops import datetime_to_numeric\n+\n+# Test with timedelta64[ns]\n+td_array = np.array([0, 10000000000, 20000000000], dtype='timedelta64[ns]')\n+print(\"Original timedelta array:\", td_array)\n+print(\"dtype:\", td_array.dtype)\n+\n+# Without datetime_unit\n+result = datetime_to_numeric(td_array, offset=None, datetime_unit=None)\n+print(\"\\nResult without datetime_unit:\", result)\n+print(\"dtype:\", result.dtype)\n+\n+# Let's check what division by timedelta64(1, None) does\n+print(\"\\nArray / np.timedelta64(1):\", td_array / np.timedelta64(1))\n+print(\"Array / np.timedelta64(1, 'ns'):\", td_array / np.timedelta64(1, 'ns'))\ndiff --git a/test_datetime_to_numeric.py b/test_datetime_to_numeric.py\nnew file mode 100644\nindex 00000000..e1a78fcd\n--- /dev/null\n+++ b/test_datetime_to_numeric.py\n@@ -0,0 +1,22 @@\n+import numpy as np\n+from xarray.core.duck_array_ops import datetime_to_numeric\n+\n+# Test with timedelta64\n+td_array = np.array([0, 10000000000, 20000000000], dtype='timedelta64[ns]')\n+print(\"Original timedelta array:\", td_array)\n+print(\"dtype:\", td_array.dtype)\n+\n+# Try with datetime offset (wrong for timedeltas)\n+result = datetime_to_numeric(td_array, offset=np.datetime64(\"1970-01-01\"), datetime_unit=\"ns\")\n+print(\"Result with datetime offset:\", result)\n+\n+# Try with None offset\n+result2 = datetime_to_numeric(td_array, offset=None, datetime_unit=\"ns\")\n+print(\"Result with None offset:\", result2)\n+\n+# Try without datetime_unit\n+result3 = datetime_to_numeric(td_array, offset=None, datetime_unit=None)\n+print(\"Result without datetime_unit:\", result3)\n+\n+# Expected values for seconds (in nanoseconds)\n+print(\"Expected values (seconds):\", td_array / np.timedelta64(1, 's'))\ndiff --git a/test_polyval_issue.py b/test_polyval_issue.py\nnew file mode 100644\nindex 00000000..aab53129\n--- /dev/null\n+++ b/test_polyval_issue.py\n@@ -0,0 +1,47 @@\n+import xarray as xr\n+import numpy as np\n+\n+values = np.array(\n+    [\n+        \"2021-04-01T05:25:19.000000000\",\n+        \"2021-04-01T05:25:29.000000000\",\n+        \"2021-04-01T05:25:39.000000000\",\n+        \"2021-04-01T05:25:49.000000000\",\n+        \"2021-04-01T05:25:59.000000000\",\n+        \"2021-04-01T05:26:09.000000000\",\n+    ],\n+    dtype=\"datetime64[ns]\",\n+)\n+azimuth_time = xr.DataArray(\n+    values, name=\"azimuth_time\", coords={\"azimuth_time\": values - values[0]}\n+)\n+\n+polyfit_coefficients = xr.DataArray(\n+    [\n+        [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+        [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+        [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+        [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+        [4.44739216e06, 1.45053974e06, 5.29960857e06],\n+    ],\n+    dims=(\"degree\", \"axis\"),\n+    coords={\"axis\": [0, 1, 2], \"degree\": [4, 3, 2, 1, 0]},\n+)\n+\n+print(\"azimuth_time coordinates:\")\n+print(azimuth_time.coords[\"azimuth_time\"])\n+print(f\"dtype: {azimuth_time.coords['azimuth_time'].dtype}\")\n+print()\n+\n+print(\"Result of polyval:\")\n+result = xr.polyval(azimuth_time, polyfit_coefficients)\n+print(result)\n+print()\n+\n+# Let's also check what happens during the conversion\n+from xarray.core.computation import _ensure_numeric\n+numeric_time = _ensure_numeric(azimuth_time)\n+print(\"After _ensure_numeric conversion:\")\n+print(numeric_time.coords[\"azimuth_time\"])\n+print(f\"dtype: {numeric_time.coords['azimuth_time'].dtype}\")\n+print(f\"values: {numeric_time.coords['azimuth_time'].values}\")\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 823cbe02..f7938493 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1934,13 +1934,61 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n \n     def to_floatable(x: DataArray) -> DataArray:\n         if x.dtype.kind in \"mM\":\n-            return x.copy(\n-                data=datetime_to_numeric(\n+            # Use appropriate offset based on dtype kind\n+            # 'm' for timedelta64, 'M' for datetime64\n+            if x.dtype.kind == \"m\":\n+                # For timedelta64, use None or zero offset\n+                offset = None\n+            else:\n+                # For datetime64, use the epoch\n+                offset = np.datetime64(\"1970-01-01\")\n+            \n+            # Convert the data\n+            # For timedelta64, don't specify datetime_unit to preserve original units\n+            if x.dtype.kind == \"m\":\n+                new_data = datetime_to_numeric(\n                     x.data,\n-                    offset=np.datetime64(\"1970-01-01\"),\n+                    offset=offset,\n+                    datetime_unit=None,\n+                )\n+            else:\n+                new_data = datetime_to_numeric(\n+                    x.data,\n+                    offset=offset,\n                     datetime_unit=\"ns\",\n-                ),\n-            )\n+                )\n+            \n+            # Also need to convert any datetime/timedelta coordinates\n+            new_coords = {}\n+            for coord_name, coord_var in x.coords.items():\n+                if coord_var.dtype.kind in \"mM\":\n+                    # Use appropriate offset for coordinate dtype\n+                    if coord_var.dtype.kind == \"m\":\n+                        coord_offset = None\n+                    else:\n+                        coord_offset = np.datetime64(\"1970-01-01\")\n+                    \n+                    # For timedelta64 coordinates, don't specify datetime_unit\n+                    if coord_var.dtype.kind == \"m\":\n+                        new_coords[coord_name] = coord_var.copy(\n+                            data=datetime_to_numeric(\n+                                coord_var.data,\n+                                offset=coord_offset,\n+                                datetime_unit=None,\n+                            )\n+                        )\n+                    else:\n+                        new_coords[coord_name] = coord_var.copy(\n+                            data=datetime_to_numeric(\n+                                coord_var.data,\n+                                offset=coord_offset,\n+                                datetime_unit=\"ns\",\n+                            )\n+                        )\n+                else:\n+                    new_coords[coord_name] = coord_var\n+            \n+            return x.copy(data=new_data).assign_coords(new_coords)\n         return x\n \n     if isinstance(data, Dataset):\n", "gold_standard_diff": "From f678977f470f0e752150d97afc4487d7c7647036 Mon Sep 17 00:00:00 2001\nFrom: Michael Niklas <mick.niklas@gmail.com>\nDate: Thu, 12 May 2022 17:11:56 +0200\nSubject: [PATCH 1/2] re-add timedelta support for polyval\n\n---\n xarray/core/computation.py       | 6 +++++-\n xarray/tests/test_computation.py | 6 ++++++\n 2 files changed, 11 insertions(+), 1 deletion(-)\n\ndiff --git a/xarray/core/computation.py b/xarray/core/computation.py\nindex 823cbe02560..8d450cceef9 100644\n--- a/xarray/core/computation.py\n+++ b/xarray/core/computation.py\n@@ -1933,7 +1933,8 @@ def _ensure_numeric(data: T_Xarray) -> T_Xarray:\n     from .dataset import Dataset\n \n     def to_floatable(x: DataArray) -> DataArray:\n-        if x.dtype.kind in \"mM\":\n+        if x.dtype.kind == \"M\":\n+            # datetimes\n             return x.copy(\n                 data=datetime_to_numeric(\n                     x.data,\n@@ -1941,6 +1942,9 @@ def to_floatable(x: DataArray) -> DataArray:\n                     datetime_unit=\"ns\",\n                 ),\n             )\n+        elif x.dtype.kind == \"m\":\n+            # timedeltas\n+            return x.astype(float)\n         return x\n \n     if isinstance(data, Dataset):\ndiff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex 737ed82bc05..a3156214c08 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -2010,6 +2010,12 @@ def test_where_attrs() -> None:\n             ),\n             id=\"datetime\",\n         ),\n+        pytest.param(\n+            xr.DataArray(np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"),\n+            xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n+            xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n+            id=\"timedelta\",\n+        ),\n     ],\n )\n def test_polyval(\n\nFrom 01b8638ba6251c8987d512484c00960540bbea7a Mon Sep 17 00:00:00 2001\nFrom: \"pre-commit-ci[bot]\"\n <66853113+pre-commit-ci[bot]@users.noreply.github.com>\nDate: Thu, 12 May 2022 15:14:24 +0000\nSubject: [PATCH 2/2] [pre-commit.ci] auto fixes from pre-commit.com hooks\n\nfor more information, see https://pre-commit.ci\n---\n xarray/tests/test_computation.py | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex a3156214c08..b8aa05c75e7 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -2011,7 +2011,9 @@ def test_where_attrs() -> None:\n             id=\"datetime\",\n         ),\n         pytest.param(\n-            xr.DataArray(np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"),\n+            xr.DataArray(\n+                np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"\n+            ),\n             xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n             xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n             id=\"timedelta\",\n", "gold_standard_pr_link": "https://github.com/pydata/xarray/pull/6599"}