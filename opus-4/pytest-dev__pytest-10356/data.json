{"instance_id": "pytest-dev__pytest-10356", "score": "I", "diff": "diff --git a/pytest_test.ini b/pytest_test.ini\nnew file mode 100644\nindex 000000000..5720dae4c\n--- /dev/null\n+++ b/pytest_test.ini\n@@ -0,0 +1,6 @@\n+[pytest]\n+markers =\n+    foo: foo marker\n+    bar: bar marker\n+    baz: baz marker\n+    qux: qux marker\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c92..95da2fd8e 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -360,6 +360,28 @@ def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n     mark_list = getattr(obj, \"pytestmark\", [])\n     if not isinstance(mark_list, list):\n         mark_list = [mark_list]\n+    \n+    # If obj is a class, we need to collect markers from all classes in MRO\n+    # but without duplicates from the direct pytestmark attribute\n+    if inspect.isclass(obj):\n+        # First check if obj has its own pytestmark that's not inherited\n+        own_mark_list = []\n+        if \"pytestmark\" in obj.__dict__:\n+            own_mark_list = mark_list\n+        \n+        # Now collect from all parent classes in MRO (excluding object)\n+        mro_marks = []\n+        for cls in obj.__mro__[1:-1]:  # Skip self (obj) and object\n+            # Only get marks that are directly on the class\n+            if \"pytestmark\" in cls.__dict__:\n+                cls_marks = getattr(cls, \"pytestmark\", [])\n+                if not isinstance(cls_marks, list):\n+                    cls_marks = [cls_marks]\n+                mro_marks.extend(cls_marks)\n+        \n+        # Combine MRO marks with own marks\n+        mark_list = mro_marks + own_mark_list\n+    \n     return normalize_mark_list(mark_list)\n \n \ndiff --git a/test_issue_scenario.py b/test_issue_scenario.py\nnew file mode 100644\nindex 000000000..2ca0ddb1e\n--- /dev/null\n+++ b/test_issue_scenario.py\n@@ -0,0 +1,32 @@\n+# This is the exact test scenario from the issue\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        # In practice markers are resolved using MRO (so foo wins), unless the\n+        # metaclass is applied\n+        pass\n+\n+# Let's verify it works by checking markers programmatically\n+def test_verify_markers():\n+    \"\"\"Verify that TestDings.test_dings has both foo and bar markers\"\"\"\n+    from _pytest.mark.structures import get_unpacked_marks\n+    \n+    # Get marks from the test class\n+    marks = list(get_unpacked_marks(TestDings))\n+    mark_names = [m.name for m in marks]\n+    \n+    print(f\"Marks on TestDings: {mark_names}\")\n+    \n+    # Both foo and bar should be present\n+    assert \"foo\" in mark_names\n+    assert \"bar\" in mark_names\ndiff --git a/test_mark_inheritance.py b/test_mark_inheritance.py\nnew file mode 100644\nindex 000000000..3be51c9a2\n--- /dev/null\n+++ b/test_mark_inheritance.py\n@@ -0,0 +1,24 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        # In practice markers are resolved using MRO (so foo wins)\n+        pass\n+\n+# Let's also test the markers directly\n+if __name__ == \"__main__\":\n+    # Check what markers are on the test\n+    import inspect\n+    test_func = TestDings.test_dings\n+    print(\"Direct pytestmark on TestDings:\", getattr(TestDings, 'pytestmark', None))\n+    print(\"Direct pytestmark on Foo:\", getattr(Foo, 'pytestmark', None))\n+    print(\"Direct pytestmark on Bar:\", getattr(Bar, 'pytestmark', None))\ndiff --git a/test_mark_inheritance_detailed.py b/test_mark_inheritance_detailed.py\nnew file mode 100644\nindex 000000000..c154aaad3\n--- /dev/null\n+++ b/test_mark_inheritance_detailed.py\n@@ -0,0 +1,36 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self, request):\n+        # Get all markers on this test\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"bar\" in markers\n+\n+# Test with single inheritance too\n+@pytest.mark.baz\n+class TestSingleInheritance(Foo):\n+    def test_single(self, request):\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"baz\" in markers\n+\n+# Test deep inheritance\n+@pytest.mark.qux\n+class TestDeepInheritance(TestDings):\n+    def test_deep(self, request):\n+        markers = [m.name for m in request.node.iter_markers()]\n+        print(f\"Markers on test: {markers}\")\n+        assert \"foo\" in markers\n+        assert \"bar\" in markers\n+        assert \"qux\" in markers\ndiff --git a/test_mark_mro_simple.py b/test_mark_mro_simple.py\nnew file mode 100644\nindex 000000000..13eb06964\n--- /dev/null\n+++ b/test_mark_mro_simple.py\n@@ -0,0 +1,14 @@\n+import pytest\n+\n+@pytest.mark.foo\n+class Foo:\n+    pass\n+\n+@pytest.mark.bar\n+class Bar:\n+    pass\n+\n+class TestDings(Foo, Bar):\n+    def test_dings(self):\n+        # This test should have both markers, foo and bar.\n+        pass\n", "gold_standard_diff": "From d8c783268c6876379f5a3a0251b72d0d6d22d0cf Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:18:26 +0200\nSubject: [PATCH 1/6] fix #7792: consider marks from the mro\n\ncloses #9105 as superseeded\n---\n changelog/7792.bugfix.rst      |  1 +\n src/_pytest/mark/structures.py | 29 +++++++++++++++++++++++------\n testing/test_mark.py           | 23 +++++++++++++++++++++++\n 3 files changed, 47 insertions(+), 6 deletions(-)\n create mode 100644 changelog/7792.bugfix.rst\n\ndiff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nnew file mode 100644\nindex 00000000000..00e09ebe849\n--- /dev/null\n+++ b/changelog/7792.bugfix.rst\n@@ -0,0 +1 @@\n+Consider the full mro when getting marks from classes.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c9243..e9e00612529 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,12 +355,29 @@ def __call__(self, *args: object, **kwargs: object):\n         return self.with_args(*args, **kwargs)\n \n \n-def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n+def get_unpacked_marks(\n+    obj: object | type,\n+    consider_mro: bool = True,\n+) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n-    return normalize_mark_list(mark_list)\n+    if isinstance(obj, type):\n+        if not consider_mro:\n+            mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\n+        else:\n+            mark_lists = [x.__dict__.get(\"pytestmark\", []) for x in obj.__mro__]\n+        mark_list = []\n+        for item in mark_lists:\n+            if isinstance(item, list):\n+                mark_list.extend(item)\n+            else:\n+                mark_list.append(item)\n+    else:\n+        mark_attribute = getattr(obj, \"pytestmark\", [])\n+        if isinstance(mark_attribute, list):\n+            mark_list = mark_attribute\n+        else:\n+            mark_list = [mark_attribute]\n+    return list(normalize_mark_list(mark_list))\n \n \n def normalize_mark_list(\n@@ -388,7 +405,7 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    obj.pytestmark = [*get_unpacked_marks(obj, consider_mro=False), mark]\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 65f2581bd63..8c20fe8b17d 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1109,3 +1109,26 @@ def test_foo():\n     result = pytester.runpytest(foo, \"-m\", expr)\n     result.stderr.fnmatch_lines([expected])\n     assert result.ret == ExitCode.USAGE_ERROR\n+\n+\n+def test_mark_mro():\n+    @pytest.mark.xfail(\"a\")\n+    class A:\n+        pass\n+\n+    @pytest.mark.xfail(\"b\")\n+    class B:\n+        pass\n+\n+    @pytest.mark.xfail(\"c\")\n+    class C(A, B):\n+        pass\n+\n+    from _pytest.mark.structures import get_unpacked_marks\n+\n+    all_marks = list(get_unpacked_marks(C))\n+\n+    nk = [(x.name, x.args[0]) for x in all_marks]\n+    assert nk == [(\"xfail\", \"c\"), (\"xfail\", \"a\"), (\"xfail\", \"b\")]\n+\n+    assert list(get_unpacked_marks(C, consider_mro=False)) == []\n\nFrom 4e7486d3fb95f97422283fc7f21b24e8aa6ef2c8 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:28:03 +0200\nSubject: [PATCH 2/6] fixup: annotations\n\n---\n src/_pytest/mark/structures.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex e9e00612529..0b1daefd639 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -356,7 +356,7 @@ def __call__(self, *args: object, **kwargs: object):\n \n \n def get_unpacked_marks(\n-    obj: object | type,\n+    obj: Union[object, type],\n     consider_mro: bool = True,\n ) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n\nFrom 13e594a31474136fb185eff7084760f724897d6b Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:35:26 +0200\nSubject: [PATCH 3/6] fixup: mark mro test reformatt\n\n---\n testing/test_mark.py | 15 ++++++++-------\n 1 file changed, 8 insertions(+), 7 deletions(-)\n\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 8c20fe8b17d..6199dc0b374 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1112,23 +1112,24 @@ def test_foo():\n \n \n def test_mark_mro():\n-    @pytest.mark.xfail(\"a\")\n+    xfail = pytest.mark.xfail\n+\n+    @xfail(\"a\")\n     class A:\n         pass\n \n-    @pytest.mark.xfail(\"b\")\n+    @xfail(\"b\")\n     class B:\n         pass\n \n-    @pytest.mark.xfail(\"c\")\n+    @xfail(\"c\")\n     class C(A, B):\n         pass\n \n     from _pytest.mark.structures import get_unpacked_marks\n \n-    all_marks = list(get_unpacked_marks(C))\n+    all_marks = get_unpacked_marks(C)\n \n-    nk = [(x.name, x.args[0]) for x in all_marks]\n-    assert nk == [(\"xfail\", \"c\"), (\"xfail\", \"a\"), (\"xfail\", \"b\")]\n+    assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n \n-    assert list(get_unpacked_marks(C, consider_mro=False)) == []\n+    assert get_unpacked_marks(C, consider_mro=False) == [pytest.mark.xfail(\"c\").mark]\n\nFrom c42bb36009445e0cf1915dd5d1b762639a710675 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Sat, 8 Oct 2022 08:35:53 +0200\nSubject: [PATCH 4/6] fixup: mark mro test reformatt\n\n---\n testing/test_mark.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 6199dc0b374..ebb70e2470b 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1132,4 +1132,4 @@ class C(A, B):\n \n     assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n \n-    assert get_unpacked_marks(C, consider_mro=False) == [pytest.mark.xfail(\"c\").mark]\n+    assert get_unpacked_marks(C, consider_mro=False) == [xfail(\"c\").mark]\n\nFrom f13f4360d3ff379144f32b4bbb4b4fa4a7a8cf23 Mon Sep 17 00:00:00 2001\nFrom: Ronny Pfannschmidt <opensource@ronnypfannschmidt.de>\nDate: Wed, 12 Oct 2022 10:20:16 +0200\nSubject: [PATCH 5/6] Apply suggestions from code review\n\nCo-authored-by: Ran Benita <ran@unusedvar.com>\n---\n changelog/7792.bugfix.rst      | 6 +++++-\n src/_pytest/mark/structures.py | 8 +++++++-\n testing/test_mark.py           | 2 +-\n 3 files changed, 13 insertions(+), 3 deletions(-)\n\ndiff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nindex 00e09ebe849..8f65637896d 100644\n--- a/changelog/7792.bugfix.rst\n+++ b/changelog/7792.bugfix.rst\n@@ -1 +1,5 @@\n-Consider the full mro when getting marks from classes.\n+Marks are now inherited according to the full MRO in test classes. Previously, if a test class inherited from two or more classes, only marks from the first super-class would apply.\n+\n+When inheriting marks from super-classes, marks from the sub-classes are now ordered before marks from the super-classes, in MRO order. Previously it was the reverse.\n+\n+When inheriting marks from super-classes, the `pytestmark` attribute of the sub-class now only contains the marks directly applied to it. Previously, it also contained marks from its super-classes. Please note that this attribute should not normally be accessed directly; use :func:`pytest.Node.iter_markers` instead.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 0b1daefd639..b93bf6ed9fc 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -357,9 +357,15 @@ def __call__(self, *args: object, **kwargs: object):\n \n def get_unpacked_marks(\n     obj: Union[object, type],\n+    *,\n     consider_mro: bool = True,\n ) -> List[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+    \n+    If obj is a class and consider_mro is true, return marks applied to\n+    this class and all of its super-classes in MRO order. If consider_mro\n+    is false, only return marks applied directly to this class.\n+    \"\"\"\n     if isinstance(obj, type):\n         if not consider_mro:\n             mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex ebb70e2470b..e2d1a40c38a 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1111,7 +1111,7 @@ def test_foo():\n     assert result.ret == ExitCode.USAGE_ERROR\n \n \n-def test_mark_mro():\n+def test_mark_mro() -> None:\n     xfail = pytest.mark.xfail\n \n     @xfail(\"a\")\n\nFrom c543e0c4e83f63943efb0cb06b6c94990c4eb0a9 Mon Sep 17 00:00:00 2001\nFrom: \"pre-commit-ci[bot]\"\n <66853113+pre-commit-ci[bot]@users.noreply.github.com>\nDate: Wed, 12 Oct 2022 08:21:16 +0000\nSubject: [PATCH 6/6] [pre-commit.ci] auto fixes from pre-commit.com hooks\n\nfor more information, see https://pre-commit.ci\n---\n src/_pytest/mark/structures.py | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex b93bf6ed9fc..5186c9ea3b6 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -361,7 +361,7 @@ def get_unpacked_marks(\n     consider_mro: bool = True,\n ) -> List[Mark]:\n     \"\"\"Obtain the unpacked marks that are stored on an object.\n-    \n+\n     If obj is a class and consider_mro is true, return marks applied to\n     this class and all of its super-classes in MRO order. If consider_mro\n     is false, only return marks applied directly to this class.\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10356"}