diff --git a/demo_fix.py b/demo_fix.py
new file mode 100644
index 0000000000..bc96e142c4
--- /dev/null
+++ b/demo_fix.py
@@ -0,0 +1,33 @@
+#!/usr/bin/env python3
+"""
+Demonstration that the fix for Rational('0.5', '100') works correctly.
+This was returning 1/100100 instead of 1/200 due to string multiplication.
+"""
+
+from sympy import Rational
+
+print("Testing the bug case:")
+print("=====================")
+print("Rational('0.5', '100') =", Rational('0.5', '100'))
+print("Rational(0.5, 100) =", Rational(0.5, 100))
+print()
+
+print("Both should be equal to 1/200:")
+assert Rational('0.5', '100') == Rational(1, 200)
+assert Rational(0.5, 100) == Rational(1, 200)
+assert Rational('0.5', '100') == Rational(0.5, 100)
+print("âœ“ All assertions passed!")
+print()
+
+print("Other test cases to ensure nothing broke:")
+print("=========================================")
+test_cases = [
+    (Rational('1', '2'), "Rational('1', '2')"),
+    (Rational('0.25', '0.5'), "Rational('0.25', '0.5')"),
+    (Rational('10', '20'), "Rational('10', '20')"),
+    (Rational(1, 2), "Rational(1, 2)"),
+    (Rational(0.25, 0.5), "Rational(0.25, 0.5)"),
+]
+
+for result, expr in test_cases:
+    print(f"{expr} = {result}")
diff --git a/fix_explanation.md b/fix_explanation.md
new file mode 100644
index 0000000000..a042ab0af4
--- /dev/null
+++ b/fix_explanation.md
@@ -0,0 +1,29 @@
+# Fix for Rational String Multiplication Bug
+
+## Problem Description
+When calling `Rational('0.5', '100')`, the result was incorrectly `1/100100` instead of the expected `1/200`.
+
+## Root Cause
+The bug occurred in the `__new__` method of the `Rational` class in `/testbed/sympy/core/numbers.py`. When both arguments were strings, the code performed string multiplication instead of numeric multiplication.
+
+Specifically, at line 1630:
+```python
+q *= p.q  # where q='100' (string) and p.q=2 (int)
+```
+
+This resulted in `'100' * 2 = '100100'` (string repetition) instead of `100 * 2 = 200`.
+
+## Solution
+The fix separates the conversion and calculation steps:
+
+1. First, convert both `p` and `q` to their numeric components
+2. Store the numerators and denominators separately
+3. Then perform the arithmetic operations on the numeric values
+
+This ensures that no string operations occur during the calculation phase.
+
+## Code Changes
+The fix modifies lines 1628-1640 in `/testbed/sympy/core/numbers.py`, replacing the in-place operations with explicit numeric calculations that avoid string multiplication.
+
+## Test Coverage
+Added test cases to `test_Rational_new()` in `/testbed/sympy/core/tests/test_numbers.py` to ensure this bug doesn't reoccur.
diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py
index 52f7ea45ad..c98ece3e9a 100644
--- a/sympy/core/numbers.py
+++ b/sympy/core/numbers.py
@@ -1627,17 +1627,23 @@ def __new__(cls, p, q=None, gcd=None):
 
         if not isinstance(p, SYMPY_INTS):
             p = Rational(p)
-            q *= p.q
-            p = p.p
+            p_num = p.p
+            p_den = p.q
         else:
-            p = int(p)
+            p_num = int(p)
+            p_den = 1
 
         if not isinstance(q, SYMPY_INTS):
             q = Rational(q)
-            p *= q.q
-            q = q.p
+            q_num = q.p
+            q_den = q.q
         else:
-            q = int(q)
+            q_num = int(q)
+            q_den = 1
+        
+        # Now calculate the final p and q
+        p = p_num * q_den
+        q = q_num * p_den
 
         # p and q are now ints
         if q == 0:
diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py
index 8baf408933..5c4ee65083 100644
--- a/sympy/core/tests/test_numbers.py
+++ b/sympy/core/tests/test_numbers.py
@@ -369,6 +369,10 @@ def test_Rational_new():
     assert n.q == 4
     assert n.p == -2
 
+    # Test for issue with string arguments
+    assert Rational('0.5', '100') == Rational(1, 200)
+    assert Rational('0.5', '100') == Rational(0.5, 100)
+
 
 def test_Number_new():
     """"
diff --git a/test_rational_bug.py b/test_rational_bug.py
new file mode 100644
index 0000000000..3c3d9fd127
--- /dev/null
+++ b/test_rational_bug.py
@@ -0,0 +1,37 @@
+from sympy import Rational
+
+# Test cases
+print("Test 1: Rational('0.5', '100')")
+r1 = Rational('0.5', '100')
+print(f"Result: {r1}")
+print(f"p={r1.p}, q={r1.q}")
+print()
+
+print("Test 2: Rational(0.5, 100)")
+r2 = Rational(0.5, 100)
+print(f"Result: {r2}")
+print(f"p={r2.p}, q={r2.q}")
+print()
+
+print("Test 3: Rational('0.5')")
+r3 = Rational('0.5')
+print(f"Result: {r3}")
+print(f"p={r3.p}, q={r3.q}")
+print()
+
+print("Test 4: Rational('100')")
+r4 = Rational('100')
+print(f"Result: {r4}")
+print(f"p={r4.p}, q={r4.q}")
+print()
+
+# Let's add some debug prints to understand the issue
+import fractions
+print("Test 5: fractions.Fraction('0.5')")
+f1 = fractions.Fraction('0.5')
+print(f"Result: {f1}, numerator={f1.numerator}, denominator={f1.denominator}")
+print()
+
+print("Test 6: fractions.Fraction('100')")
+f2 = fractions.Fraction('100')
+print(f"Result: {f2}, numerator={f2.numerator}, denominator={f2.denominator}")
diff --git a/test_rational_comprehensive.py b/test_rational_comprehensive.py
new file mode 100644
index 0000000000..b12a60219d
--- /dev/null
+++ b/test_rational_comprehensive.py
@@ -0,0 +1,75 @@
+from sympy import Rational, S
+import sys
+
+def test_rational():
+    """Test various Rational creation scenarios"""
+    test_cases = [
+        # (args, expected_p, expected_q, description)
+        ((1, 2), 1, 2, "integers"),
+        (('1', '2'), 1, 2, "string integers"),
+        ((0.5,), 1, 2, "single float"),
+        (('0.5',), 1, 2, "single string float"),
+        ((0.5, 100), 1, 200, "float and int"),
+        (('0.5', '100'), 1, 200, "string float and string int - THE BUG CASE"),
+        ((1, 3), 1, 3, "1/3 as integers"),
+        (('1', '3'), 1, 3, "1/3 as strings"),
+        ((2, 4), 1, 2, "reducible fraction"),
+        (('2', '4'), 1, 2, "reducible fraction as strings"),
+        ((2, 4, 1), 2, 4, "with gcd=1"),
+        ((Rational(1, 2), 2), 1, 4, "Rational and int"),
+        ((1, Rational(2, 3)), 3, 2, "int and Rational"),
+        ((Rational(1, 2), Rational(3, 4)), 2, 3, "Rational and Rational"),
+        ((-1, 2), -1, 2, "negative numerator"),
+        ((1, -2), -1, 2, "negative denominator"),
+        (('-1', '2'), -1, 2, "negative string numerator"),
+        (('1', '-2'), -1, 2, "negative string denominator"),
+        ((0, 5), 0, 1, "zero numerator"),
+        (('0', '5'), 0, 1, "zero string numerator"),
+        ((5,), 5, 1, "single integer"),
+        (('5',), 5, 1, "single string integer"),
+        ((Rational(3, 4),), 3, 4, "single Rational"),
+        (('1.5', '0.5'), 3, 1, "string decimal division"),
+        (('0.1', '0.2'), 1, 2, "small string decimals"),
+        ((0.1, 0.2), 1, 2, "small float decimals (approximate due to float repr)"),
+    ]
+    
+    failed = 0
+    for args, expected_p, expected_q, desc in test_cases:
+        try:
+            r = Rational(*args)
+            if r.p != expected_p or r.q != expected_q:
+                print(f"FAIL: {desc}")
+                print(f"  Args: {args}")
+                print(f"  Expected: {expected_p}/{expected_q}")
+                print(f"  Got: {r.p}/{r.q} = {r}")
+                failed += 1
+            else:
+                print(f"PASS: {desc} -> {r}")
+        except Exception as e:
+            print(f"ERROR: {desc}")
+            print(f"  Args: {args}")
+            print(f"  Exception: {e}")
+            failed += 1
+    
+    # Special cases that should raise errors
+    error_cases = [
+        ((1, 0), "division by zero"),
+        (('1', '0'), "string division by zero"),
+        (('invalid',), "invalid string"),
+        (('1/2/3',), "multiple slashes"),
+    ]
+    
+    for args, desc in error_cases:
+        try:
+            r = Rational(*args)
+            print(f"FAIL: {desc} should have raised an error but got {r}")
+            failed += 1
+        except Exception:
+            print(f"PASS: {desc} correctly raised an error")
+    
+    print(f"\nTotal failed: {failed}")
+    return failed == 0
+
+if __name__ == "__main__":
+    success = test_rational()
+    sys.exit(0 if success else 1)
diff --git a/test_rational_debug.py b/test_rational_debug.py
new file mode 100644
index 0000000000..730463c3d9
--- /dev/null
+++ b/test_rational_debug.py
@@ -0,0 +1,33 @@
+from sympy.core.numbers import Rational, SYMPY_INTS
+import fractions
+
+# Let's manually trace through what happens with Rational('0.5', '100')
+print("=== Tracing Rational('0.5', '100') ===")
+p = '0.5'
+q = '100'
+
+print(f"Initial: p={repr(p)}, q={repr(q)}")
+
+# Line 1628-1631: Since p is not in SYMPY_INTS
+print(f"p is not in SYMPY_INTS, so calling Rational(p)")
+p_rational = Rational(p)  # This should give us 1/2
+print(f"p_rational = {p_rational}, p_rational.p = {p_rational.p}, p_rational.q = {p_rational.q}")
+
+# Now back in the original call
+print(f"\nBack in original call:")
+print(f"q before: {repr(q)}")
+print(f"q *= p_rational.q: {q} *= {p_rational.q}")
+# Here's the problem! q is a string '100', so q *= 2 will do string multiplication!
+try:
+    q_result = q * p_rational.q
+    print(f"q after multiplication: {repr(q_result)}")
+except Exception as e:
+    print(f"Error during multiplication: {e}")
+
+# Let's see what Python does with string multiplication
+print(f"\nString multiplication test:")
+print(f"'100' * 2 = {repr('100' * 2)}")
+print(f"'100' * 1 = {repr('100' * 1)}")
+
+# This explains the bug! When q is a string and we do q *= p.q,
+# it's doing string multiplication instead of numeric multiplication
