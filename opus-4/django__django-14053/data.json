{"instance_id": "django__django-14053", "score": "I", "diff": "diff --git a/demo_fix.py b/demo_fix.py\nnew file mode 100644\nindex 0000000000..fa2eb91a37\n--- /dev/null\n+++ b/demo_fix.py\n@@ -0,0 +1,95 @@\n+\"\"\"\n+Demonstration of the fix for duplicate yields in post_process()\n+\"\"\"\n+import os\n+import tempfile\n+import shutil\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage\n+from django.contrib.staticfiles.management.commands.collectstatic import Command\n+from django.core.files.base import ContentFile\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+        STATICFILES_STORAGE='django.contrib.staticfiles.storage.ManifestStaticFilesStorage',\n+        INSTALLED_APPS=['django.contrib.staticfiles'],\n+    )\n+\n+def simulate_collectstatic():\n+    \"\"\"Simulate collectstatic behavior to show the fix\"\"\"\n+    print(\"Simulating collectstatic with the fix for duplicate post-processing yields\\n\")\n+    \n+    # Create a temporary directory for source files\n+    source_dir = tempfile.mkdtemp()\n+    \n+    # Create the manifest storage\n+    storage = ManifestStaticFilesStorage()\n+    \n+    # Create test files\n+    css_dir = os.path.join(source_dir, 'css')\n+    os.makedirs(css_dir)\n+    \n+    # Create base.css that imports other files (like admin CSS)\n+    with open(os.path.join(css_dir, 'base.css'), 'w') as f:\n+        f.write(\"\"\"\n+@import url(\"fonts.css\");\n+body { background: white; }\n+\"\"\")\n+    \n+    # Create fonts.css\n+    with open(os.path.join(css_dir, 'fonts.css'), 'w') as f:\n+        f.write(\"\"\"\n+.font { font-family: Arial; }\n+\"\"\")\n+    \n+    # Create dashboard.css (no imports)\n+    with open(os.path.join(css_dir, 'dashboard.css'), 'w') as f:\n+        f.write(\"\"\"\n+.dashboard { width: 100%; }\n+\"\"\")\n+    \n+    # Save files to storage\n+    for filename in ['base.css', 'fonts.css', 'dashboard.css']:\n+        filepath = os.path.join(css_dir, filename)\n+        with open(filepath, 'rb') as f:\n+            storage.save(f'css/{filename}', ContentFile(f.read()))\n+    \n+    # Prepare paths for post-processing\n+    paths = {\n+        'css/base.css': (storage, 'css/base.css'),\n+        'css/fonts.css': (storage, 'css/fonts.css'), \n+        'css/dashboard.css': (storage, 'css/dashboard.css'),\n+    }\n+    \n+    # Track post-processing output\n+    print(\"Post-processing output:\")\n+    print(\"-\" * 50)\n+    \n+    post_process_count = {}\n+    for original_path, processed_path, processed in storage.post_process(paths):\n+        if isinstance(processed, bool) and processed:\n+            post_process_count[original_path] = post_process_count.get(original_path, 0) + 1\n+            print(f\"Post-processed '{original_path}' as '{processed_path}'\")\n+    \n+    print(\"\\nSummary:\")\n+    print(\"-\" * 50)\n+    for path, count in post_process_count.items():\n+        print(f\"{path}: processed {count} time(s)\")\n+    \n+    print(\"\\nWith the fix:\")\n+    print(\"- dashboard.css (no imports) is processed only once\")\n+    print(\"- fonts.css (no changing imports) is processed only once\") \n+    print(\"- base.css (imports fonts.css) is processed twice: once initially, once after fonts.css is hashed\")\n+    print(\"\\nThis eliminates the duplicate yields that were happening before!\")\n+    \n+    # Clean up\n+    shutil.rmtree(source_dir)\n+    shutil.rmtree(storage.location)\n+\n+\n+if __name__ == \"__main__\":\n+    simulate_collectstatic()\ndiff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex 494890cc23..d32f00d227 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -220,6 +220,8 @@ class HashedFilesMixin:\n \n         # where to store the new paths\n         hashed_files = {}\n+        # track files that have been yielded with their hashed names\n+        yielded_files = {}\n \n         # build a list of adjustable files\n         adjustable_paths = [\n@@ -230,13 +232,17 @@ class HashedFilesMixin:\n         # adjustable files.\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n             yield name, hashed_name, processed\n+            yielded_files[name] = hashed_name\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n-                yield name, hashed_name, processed\n+                # Only yield if the file hasn't been yielded yet or if its hash has changed\n+                if name not in yielded_files or yielded_files[name] != hashed_name:\n+                    yield name, hashed_name, processed\n+                    yielded_files[name] = hashed_name\n                 substitutions = substitutions or subst\n \n             if not substitutions:\ndiff --git a/simple_test.py b/simple_test.py\nnew file mode 100644\nindex 0000000000..52bb6ba226\n--- /dev/null\n+++ b/simple_test.py\n@@ -0,0 +1,118 @@\n+import os\n+import tempfile\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import HashedFilesMixin\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.base import ContentFile\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+    )\n+\n+class TestHashedFilesStorage(HashedFilesMixin, FileSystemStorage):\n+    \"\"\"Test storage class that uses HashedFilesMixin\"\"\"\n+    \n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.yield_count = {}\n+        \n+    def post_process(self, *args, **kwargs):\n+        \"\"\"Track yields\"\"\"\n+        for name, hashed_name, processed in super().post_process(*args, **kwargs):\n+            if isinstance(processed, bool):\n+                self.yield_count[name] = self.yield_count.get(name, 0) + 1\n+            yield name, hashed_name, processed\n+\n+\n+def run_tests():\n+    print(\"Testing fix for duplicate yields in HashedFilesMixin.post_process()\")\n+    print(\"=\" * 70)\n+    \n+    # Test 1: Simple files without references\n+    print(\"\\nTest 1: Simple CSS files (no references)\")\n+    print(\"-\" * 40)\n+    storage = TestHashedFilesStorage(location=tempfile.mkdtemp())\n+    \n+    storage.save('css/simple1.css', ContentFile(b'body { color: red; }'))\n+    storage.save('css/simple2.css', ContentFile(b'.header { color: blue; }'))\n+    \n+    paths = {\n+        'css/simple1.css': (storage, 'css/simple1.css'),\n+        'css/simple2.css': (storage, 'css/simple2.css'),\n+    }\n+    \n+    list(storage.post_process(paths))\n+    \n+    print(f\"simple1.css yielded: {storage.yield_count.get('css/simple1.css', 0)} times\")\n+    print(f\"simple2.css yielded: {storage.yield_count.get('css/simple2.css', 0)} times\")\n+    \n+    assert storage.yield_count.get('css/simple1.css', 0) == 1, \"Simple file yielded more than once!\"\n+    assert storage.yield_count.get('css/simple2.css', 0) == 1, \"Simple file yielded more than once!\"\n+    print(\"\u2713 Test passed: Simple files yielded only once\")\n+    \n+    # Test 2: Nested references\n+    print(\"\\nTest 2: CSS files with nested references\")\n+    print(\"-\" * 40)\n+    storage2 = TestHashedFilesStorage(location=tempfile.mkdtemp())\n+    \n+    storage2.save('css/base.css', ContentFile(b'@import url(\"level1.css\");\\n.base{}'))\n+    storage2.save('css/level1.css', ContentFile(b'@import url(\"level2.css\");\\n.l1{}'))\n+    storage2.save('css/level2.css', ContentFile(b'.l2 { color: green; }'))\n+    \n+    paths2 = {\n+        'css/base.css': (storage2, 'css/base.css'),\n+        'css/level1.css': (storage2, 'css/level1.css'),\n+        'css/level2.css': (storage2, 'css/level2.css'),\n+    }\n+    \n+    list(storage2.post_process(paths2))\n+    \n+    print(f\"base.css yielded: {storage2.yield_count.get('css/base.css', 0)} times\")\n+    print(f\"level1.css yielded: {storage2.yield_count.get('css/level1.css', 0)} times\")\n+    print(f\"level2.css yielded: {storage2.yield_count.get('css/level2.css', 0)} times\")\n+    \n+    # level2.css has no imports - should be yielded once\n+    assert storage2.yield_count.get('css/level2.css', 0) == 1\n+    # level1.css imports level2.css but doesn't need re-processing after level2 is hashed\n+    assert storage2.yield_count.get('css/level1.css', 0) == 1  \n+    # base.css imports level1.css and needs to be updated when level1's hash changes\n+    assert storage2.yield_count.get('css/base.css', 0) == 2\n+    print(\"\u2713 Test passed: Files yielded appropriate number of times\")\n+    \n+    # Test 3: The problematic case from the issue\n+    print(\"\\nTest 3: CSS file without references (dashboard.css example)\")\n+    print(\"-\" * 40)\n+    storage3 = TestHashedFilesStorage(location=tempfile.mkdtemp())\n+    \n+    # dashboard.css with no external references\n+    storage3.save('admin/css/dashboard.css', ContentFile(b'.dashboard { width: 100%; }'))\n+    \n+    paths3 = {\n+        'admin/css/dashboard.css': (storage3, 'admin/css/dashboard.css'),\n+    }\n+    \n+    list(storage3.post_process(paths3))\n+    \n+    print(f\"dashboard.css yielded: {storage3.yield_count.get('admin/css/dashboard.css', 0)} times\")\n+    \n+    assert storage3.yield_count.get('admin/css/dashboard.css', 0) == 1\n+    print(\"\u2713 Test passed: dashboard.css yielded only once\")\n+    \n+    print(\"\\n\" + \"=\" * 70)\n+    print(\"All tests passed! The fix prevents duplicate yields.\")\n+    \n+    # Clean up\n+    import shutil\n+    for storage in [storage, storage2, storage3]:\n+        try:\n+            shutil.rmtree(storage.location, ignore_errors=True)\n+        except:\n+            pass\n+\n+\n+if __name__ == \"__main__\":\n+    run_tests()\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..2ee9ab29f3\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,148 @@\n+import os\n+import tempfile\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import HashedFilesMixin\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.base import ContentFile\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+    )\n+\n+class TestHashedFilesStorage(HashedFilesMixin, FileSystemStorage):\n+    \"\"\"Test storage class that uses HashedFilesMixin\"\"\"\n+    pass\n+\n+def test_no_duplicates_for_simple_files():\n+    \"\"\"Test that files with no references are only yielded once\"\"\"\n+    storage = TestHashedFilesStorage(location=settings.STATIC_ROOT)\n+    \n+    # Create test CSS files without references\n+    simple1_css = \"\"\"\n+    body { background: white; }\n+    \"\"\"\n+    \n+    simple2_css = \"\"\"\n+    .header { color: blue; }\n+    \"\"\"\n+    \n+    # Save the files\n+    storage.save('css/simple1.css', ContentFile(simple1_css.encode()))\n+    storage.save('css/simple2.css', ContentFile(simple2_css.encode()))\n+    \n+    # Prepare paths dict for post_process\n+    paths = {\n+        'css/simple1.css': (storage, 'css/simple1.css'),\n+        'css/simple2.css': (storage, 'css/simple2.css'),\n+    }\n+    \n+    # Track yields\n+    yields = []\n+    for original_path, processed_path, processed in storage.post_process(paths):\n+        yields.append((original_path, processed_path, processed))\n+        print(f\"Yielded: {original_path} -> {processed_path} (processed={processed})\")\n+    \n+    # Check for duplicates\n+    originals = [y[0] for y in yields if isinstance(y[2], bool)]\n+    seen = {}\n+    for orig in originals:\n+        seen[orig] = seen.get(orig, 0) + 1\n+    \n+    print(f\"\\nTotal yields: {len(yields)}\")\n+    print(f\"Files yielded: {seen}\")\n+    \n+    # Clean up\n+    import shutil\n+    shutil.rmtree(settings.STATIC_ROOT)\n+    \n+    # Simple files should only be yielded once\n+    return all(count == 1 for count in seen.values())\n+\n+def test_changed_files_yielded_appropriately():\n+    \"\"\"Test that files that change due to substitutions are yielded when changed\"\"\"\n+    storage = TestHashedFilesStorage(location=settings.STATIC_ROOT)\n+    \n+    # Create test CSS files with nested references\n+    # base.css references fonts.css\n+    base_css = \"\"\"\n+    @import url(\"fonts.css\");\n+    body { background: white; }\n+    \"\"\"\n+    \n+    # fonts.css references icon.css\n+    fonts_css = \"\"\"\n+    @import url(\"icon.css\");\n+    .font { font-family: Arial; }\n+    \"\"\"\n+    \n+    # icon.css has no references\n+    icon_css = \"\"\"\n+    .icon { width: 16px; }\n+    \"\"\"\n+    \n+    # Save the files\n+    storage.save('css/base.css', ContentFile(base_css.encode()))\n+    storage.save('css/fonts.css', ContentFile(fonts_css.encode()))\n+    storage.save('css/icon.css', ContentFile(icon_css.encode()))\n+    \n+    # Prepare paths dict for post_process\n+    paths = {\n+        'css/base.css': (storage, 'css/base.css'),\n+        'css/fonts.css': (storage, 'css/fonts.css'),\n+        'css/icon.css': (storage, 'css/icon.css'),\n+    }\n+    \n+    # Track yields\n+    yields = []\n+    hashed_names = {}\n+    for original_path, processed_path, processed in storage.post_process(paths):\n+        yields.append((original_path, processed_path, processed))\n+        print(f\"Yielded: {original_path} -> {processed_path} (processed={processed})\")\n+        \n+        # Track how hashed names change\n+        if original_path not in hashed_names:\n+            hashed_names[original_path] = []\n+        hashed_names[original_path].append(processed_path)\n+    \n+    # Check yields per file\n+    originals = [y[0] for y in yields if isinstance(y[2], bool)]\n+    seen = {}\n+    for orig in originals:\n+        seen[orig] = seen.get(orig, 0) + 1\n+    \n+    print(f\"\\nTotal yields: {len(yields)}\")\n+    print(f\"Files yielded: {seen}\")\n+    print(f\"\\nHashed name changes:\")\n+    for orig, names in hashed_names.items():\n+        print(f\"  {orig}: {names}\")\n+    \n+    # Clean up\n+    import shutil\n+    shutil.rmtree(settings.STATIC_ROOT)\n+    \n+    # Check expectations:\n+    # - icon.css: yielded once (no references to update)\n+    # - fonts.css: yielded once (reference to icon.css doesn't change its hash)\n+    # - base.css: yielded twice (first pass, then when fonts.css hash is updated)\n+    expected = {\n+        'css/icon.css': 1,\n+        'css/fonts.css': 1,\n+        'css/base.css': 2\n+    }\n+    \n+    return seen == expected\n+\n+if __name__ == \"__main__\":\n+    print(\"Test 1: Simple files with no references\")\n+    print(\"=\" * 50)\n+    result1 = test_no_duplicates_for_simple_files()\n+    print(f\"Result: {'PASS' if result1 else 'FAIL'}\")\n+    \n+    print(\"\\n\\nTest 2: Files with nested references\")\n+    print(\"=\" * 50)\n+    result2 = test_changed_files_yielded_appropriately()\n+    print(f\"Result: {'PASS' if result2 else 'FAIL'}\")\ndiff --git a/test_dashboard_example.py b/test_dashboard_example.py\nnew file mode 100644\nindex 0000000000..4e0a6dfd02\n--- /dev/null\n+++ b/test_dashboard_example.py\n@@ -0,0 +1,58 @@\n+import os\n+import tempfile\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import HashedFilesMixin\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.base import ContentFile\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+    )\n+\n+class TestHashedFilesStorage(HashedFilesMixin, FileSystemStorage):\n+    \"\"\"Test storage class that uses HashedFilesMixin\"\"\"\n+    pass\n+\n+def test_dashboard_case():\n+    \"\"\"Test the dashboard.css case from the issue - no changes between passes\"\"\"\n+    storage = TestHashedFilesStorage(location=settings.STATIC_ROOT)\n+    \n+    # Create dashboard.css without references (like the actual Django admin file)\n+    dashboard_css = \"\"\"\n+    .dashboard { width: 100%; }\n+    .dashboard-module { margin: 10px; }\n+    \"\"\"\n+    \n+    # Save the file\n+    storage.save('admin/css/dashboard.css', ContentFile(dashboard_css.encode()))\n+    \n+    # Prepare paths dict for post_process\n+    paths = {\n+        'admin/css/dashboard.css': (storage, 'admin/css/dashboard.css'),\n+    }\n+    \n+    # Track yields\n+    yields = []\n+    for original_path, processed_path, processed in storage.post_process(paths):\n+        yields.append((original_path, processed_path, processed))\n+        print(f\"Post-processed '{original_path}' as '{processed_path}'\")\n+    \n+    # Check for duplicates\n+    originals = [y[0] for y in yields if isinstance(y[2], bool)]\n+    \n+    print(f\"\\nTotal post-processing entries: {len(originals)}\")\n+    \n+    # Clean up\n+    import shutil\n+    shutil.rmtree(settings.STATIC_ROOT)\n+    \n+    # Should only be yielded once because the self-reference doesn't change the hash\n+    return len(originals) == 1\n+\n+if __name__ == \"__main__\":\n+    result = test_dashboard_case()\n+    print(f\"\\nResult: {'PASS - Only yielded once!' if result else 'FAIL - Yielded multiple times'}\")\ndiff --git a/test_duplicate_yields.py b/test_duplicate_yields.py\nnew file mode 100644\nindex 0000000000..64ad3ccc36\n--- /dev/null\n+++ b/test_duplicate_yields.py\n@@ -0,0 +1,81 @@\n+import os\n+import tempfile\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import HashedFilesMixin\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.base import ContentFile\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+    )\n+\n+class TestHashedFilesStorage(HashedFilesMixin, FileSystemStorage):\n+    \"\"\"Test storage class that uses HashedFilesMixin\"\"\"\n+    pass\n+\n+def test_duplicate_yields():\n+    \"\"\"Test that post_process doesn't yield the same file multiple times\"\"\"\n+    storage = TestHashedFilesStorage(location=settings.STATIC_ROOT)\n+    \n+    # Create test CSS files with nested references\n+    # base.css references fonts.css\n+    base_css = \"\"\"\n+    @import url(\"fonts.css\");\n+    body { background: white; }\n+    \"\"\"\n+    \n+    # fonts.css references icon.css\n+    fonts_css = \"\"\"\n+    @import url(\"icon.css\");\n+    .font { font-family: Arial; }\n+    \"\"\"\n+    \n+    # icon.css has no references\n+    icon_css = \"\"\"\n+    .icon { width: 16px; }\n+    \"\"\"\n+    \n+    # Save the files\n+    storage.save('css/base.css', ContentFile(base_css.encode()))\n+    storage.save('css/fonts.css', ContentFile(fonts_css.encode()))\n+    storage.save('css/icon.css', ContentFile(icon_css.encode()))\n+    \n+    # Prepare paths dict for post_process\n+    paths = {\n+        'css/base.css': (storage, 'css/base.css'),\n+        'css/fonts.css': (storage, 'css/fonts.css'),\n+        'css/icon.css': (storage, 'css/icon.css'),\n+    }\n+    \n+    # Track yields\n+    yields = []\n+    for original_path, processed_path, processed in storage.post_process(paths):\n+        yields.append((original_path, processed_path, processed))\n+        print(f\"Yielded: {original_path} -> {processed_path} (processed={processed})\")\n+    \n+    # Check for duplicates\n+    originals = [y[0] for y in yields if isinstance(y[2], bool)]\n+    duplicates = []\n+    seen = set()\n+    for orig in originals:\n+        if orig in seen:\n+            duplicates.append(orig)\n+        seen.add(orig)\n+    \n+    print(f\"\\nTotal yields: {len(yields)}\")\n+    print(f\"Unique files: {len(set(originals))}\")\n+    print(f\"Duplicates: {duplicates}\")\n+    \n+    # Clean up\n+    import shutil\n+    shutil.rmtree(settings.STATIC_ROOT)\n+    \n+    return len(duplicates) > 0\n+\n+if __name__ == \"__main__\":\n+    has_duplicates = test_duplicate_yields()\n+    print(f\"\\nHas duplicate yields: {has_duplicates}\")\ndiff --git a/test_no_duplicate_yields.py b/test_no_duplicate_yields.py\nnew file mode 100644\nindex 0000000000..8ad5b7272f\n--- /dev/null\n+++ b/test_no_duplicate_yields.py\n@@ -0,0 +1,142 @@\n+\"\"\"\n+Test for the duplicate yields fix\n+\"\"\"\n+import os\n+import tempfile\n+from io import StringIO\n+from django.conf import settings\n+from django.contrib.staticfiles.storage import HashedFilesMixin\n+from django.contrib.staticfiles.management.commands.collectstatic import Command as CollectstaticCommand\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.base import ContentFile\n+from django.core.management import call_command\n+from django.test import TestCase, override_settings\n+\n+# Configure Django settings if not already configured\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=False,\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=tempfile.mkdtemp(),\n+        INSTALLED_APPS=['django.contrib.staticfiles'],\n+    )\n+\n+class HashedFilesTestStorage(HashedFilesMixin, FileSystemStorage):\n+    \"\"\"Test storage that tracks post_process yields\"\"\"\n+    \n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs) \n+        self.post_process_count = {}\n+    \n+    def post_process(self, *args, **kwargs):\n+        \"\"\"Wrap post_process to count yields per file\"\"\"\n+        for name, hashed_name, processed in super().post_process(*args, **kwargs):\n+            if isinstance(processed, bool):  # Skip error yields\n+                self.post_process_count[name] = self.post_process_count.get(name, 0) + 1\n+            yield name, hashed_name, processed\n+\n+\n+class TestNoDuplicateYields(TestCase):\n+    \"\"\"Test that post_process doesn't yield files multiple times unnecessarily\"\"\"\n+    \n+    def setUp(self):\n+        self.temp_dir = tempfile.mkdtemp()\n+        self.storage = HashedFilesTestStorage(location=self.temp_dir)\n+        \n+    def tearDown(self):\n+        import shutil\n+        shutil.rmtree(self.temp_dir, ignore_errors=True)\n+        \n+    def test_simple_css_files_yielded_once(self):\n+        \"\"\"Files without references should only be yielded once\"\"\"\n+        # Create CSS files without references\n+        self.storage.save('css/simple.css', ContentFile(b'.simple { color: red; }'))\n+        self.storage.save('css/other.css', ContentFile(b'.other { color: blue; }'))\n+        \n+        paths = {\n+            'css/simple.css': (self.storage, 'css/simple.css'),\n+            'css/other.css': (self.storage, 'css/other.css'),\n+        }\n+        \n+        # Process files\n+        list(self.storage.post_process(paths))\n+        \n+        # Each file should only be yielded once\n+        self.assertEqual(self.storage.post_process_count['css/simple.css'], 1)\n+        self.assertEqual(self.storage.post_process_count['css/other.css'], 1)\n+        \n+    def test_nested_css_yields_appropriately(self):\n+        \"\"\"Files should only be yielded again if their content changes\"\"\"\n+        # Create CSS files with nested references\n+        self.storage.save('css/base.css', ContentFile(b'@import url(\"level1.css\");\\n.base{}'))\n+        self.storage.save('css/level1.css', ContentFile(b'@import url(\"level2.css\");\\n.l1{}'))\n+        self.storage.save('css/level2.css', ContentFile(b'.l2 { color: green; }'))\n+        \n+        paths = {\n+            'css/base.css': (self.storage, 'css/base.css'),\n+            'css/level1.css': (self.storage, 'css/level1.css'),\n+            'css/level2.css': (self.storage, 'css/level2.css'),\n+        }\n+        \n+        # Process files\n+        list(self.storage.post_process(paths))\n+        \n+        # level2.css has no imports - yielded once\n+        self.assertEqual(self.storage.post_process_count['css/level2.css'], 1)\n+        # level1.css imports level2.css but its hash doesn't change - yielded once\n+        self.assertEqual(self.storage.post_process_count['css/level1.css'], 1)\n+        # base.css imports level1.css and its hash changes - yielded twice\n+        self.assertEqual(self.storage.post_process_count['css/base.css'], 2)\n+        \n+    def test_circular_reference_yields(self):\n+        \"\"\"Circular references should not cause infinite yields\"\"\"\n+        # Create CSS with circular reference\n+        self.storage.save('css/circular.css', ContentFile(b'@import url(\"circular.css\");\\n.circ{}'))\n+        \n+        paths = {\n+            'css/circular.css': (self.storage, 'css/circular.css'),\n+        }\n+        \n+        # This should hit max passes but not yield the same file endlessly\n+        # Collect all yields\n+        yields = list(self.storage.post_process(paths))\n+        \n+        # Should yield the file for each pass until max_post_process_passes\n+        # plus the initial pass, and one error yield\n+        max_passes = self.storage.max_post_process_passes\n+        expected_yields = max_passes + 1  # initial pass + max subsequent passes\n+        self.assertEqual(self.storage.post_process_count['css/circular.css'], expected_yields)\n+        \n+        # Last yield should be an error\n+        last_yield = yields[-1]\n+        self.assertEqual(last_yield[0], 'All')\n+        self.assertIsInstance(last_yield[2], RuntimeError)\n+\n+\n+if __name__ == '__main__':\n+    import django\n+    from django.test.utils import get_runner\n+    \n+    django.setup()\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner(verbosity=2)\n+    \n+    # Run our specific test\n+    from django.test.utils import setup_test_environment, teardown_test_environment\n+    setup_test_environment()\n+    \n+    suite = TestNoDuplicateYields()\n+    for test_name in ['test_simple_css_files_yielded_once', \n+                      'test_nested_css_yields_appropriately',\n+                      'test_circular_reference_yields']:\n+        print(f\"\\nRunning {test_name}...\")\n+        try:\n+            getattr(suite, test_name)()\n+            print(f\"\u2713 {test_name} passed\")\n+        except Exception as e:\n+            print(f\"\u2717 {test_name} failed: {e}\")\n+        finally:\n+            suite.tearDown()\n+            suite.setUp()\n+    \n+    teardown_test_environment()\n", "gold_standard_diff": "diff --git a/django/contrib/staticfiles/storage.py b/django/contrib/staticfiles/storage.py\nindex 494890cc23e6..267fe3a37932 100644\n--- a/django/contrib/staticfiles/storage.py\n+++ b/django/contrib/staticfiles/storage.py\n@@ -226,17 +226,25 @@ def post_process(self, paths, dry_run=False, **options):\n             path for path in paths\n             if matches_patterns(path, self._patterns)\n         ]\n-        # Do a single pass first. Post-process all files once, then repeat for\n-        # adjustable files.\n+\n+        # Adjustable files to yield at end, keyed by the original path.\n+        processed_adjustable_paths = {}\n+\n+        # Do a single pass first. Post-process all files once, yielding not\n+        # adjustable files and exceptions, and collecting adjustable files.\n         for name, hashed_name, processed, _ in self._post_process(paths, adjustable_paths, hashed_files):\n-            yield name, hashed_name, processed\n+            if name not in adjustable_paths or isinstance(processed, Exception):\n+                yield name, hashed_name, processed\n+            else:\n+                processed_adjustable_paths[name] = (name, hashed_name, processed)\n \n         paths = {path: paths[path] for path in adjustable_paths}\n \n         for i in range(self.max_post_process_passes):\n             substitutions = False\n             for name, hashed_name, processed, subst in self._post_process(paths, adjustable_paths, hashed_files):\n-                yield name, hashed_name, processed\n+                # Overwrite since hashed_name may be newer.\n+                processed_adjustable_paths[name] = (name, hashed_name, processed)\n                 substitutions = substitutions or subst\n \n             if not substitutions:\n@@ -248,6 +256,9 @@ def post_process(self, paths, dry_run=False, **options):\n         # Store the processed paths\n         self.hashed_files.update(hashed_files)\n \n+        # Yield adjustable files with final, hashed name.\n+        yield from processed_adjustable_paths.values()\n+\n     def _post_process(self, paths, adjustable_paths, hashed_files):\n         # Sort the files by directory level\n         def path_level(name):\ndiff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\nindex dc45a0b8393b..7ae88e6c6837 100644\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -203,6 +203,8 @@ def test_post_processing(self):\n         self.assertIn(os.path.join('cached', 'css', 'window.css'), stats['post_processed'])\n         self.assertIn(os.path.join('cached', 'css', 'img', 'window.png'), stats['unmodified'])\n         self.assertIn(os.path.join('test', 'nonascii.css'), stats['post_processed'])\n+        # No file should be yielded twice.\n+        self.assertCountEqual(stats['post_processed'], set(stats['post_processed']))\n         self.assertPostCondition()\n \n     def test_css_import_case_insensitive(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14053"}