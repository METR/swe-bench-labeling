diff --git a/sympy/functions/special/zeta_functions.py b/sympy/functions/special/zeta_functions.py
index b8e2b66195..14cb96dbb4 100644
--- a/sympy/functions/special/zeta_functions.py
+++ b/sympy/functions/special/zeta_functions.py
@@ -253,10 +253,21 @@ class polylog(Function):
     >>> from sympy import expand_func
     >>> from sympy.abc import z
     >>> expand_func(polylog(1, z))
-    -log(z*exp_polar(-I*pi) + 1)
+    -log(1 - z)
     >>> expand_func(polylog(0, z))
     z/(-z + 1)
 
+    For :math:`s = 2` and rational :math:`z`, the polylogarithm can be expressed
+    in terms of elementary functions:
+
+    >>> from sympy import S
+    >>> expand_func(polylog(2, S(1)/2))
+    -log(2)**2/2 + pi**2/12
+    >>> expand_func(polylog(2, S(1)/3))
+    -log(3)**2/2 + pi**2/6 + 3*log(3)/2
+    >>> expand_func(polylog(2, S(2)/3))
+    -log(3)**2/2 - 3*log(3)/8 + pi**2/6
+
     The derivative with respect to :math:`z` can be computed in closed form:
 
     >>> polylog(s, z).diff(z)
@@ -288,10 +299,20 @@ def _eval_rewrite_as_lerchphi(self, s, z):
         return z*lerchphi(z, s, 1)
 
     def _eval_expand_func(self, **hints):
-        from sympy import log, expand_mul, Dummy, exp_polar, I
+        from sympy import log, expand_mul, Dummy, pi, S
         s, z = self.args
         if s == 1:
-            return -log(1 + exp_polar(-I*pi)*z)
+            return -log(1 - z)
+        if s == 2:
+            if z == S.Half:
+                return -log(2)**2/2 + pi**2/12
+            elif z.is_rational:
+                p, q = z.as_numer_denom()
+                return (pi**2/6 - log(q)**2/2 
+                        - sum((-1)**k * (q-p)**k * log(q-p) / (k * p**k) 
+                              for k in range(1, q))
+                        + sum((-1)**k * q**k * log(q) / (k * p**k) 
+                              for k in range(1, q)))
         if s.is_Integer and s <= 0:
             u = Dummy('u')
             start = u/(1 - u)
