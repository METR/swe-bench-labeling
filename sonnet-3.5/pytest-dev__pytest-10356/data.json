{"instance_id": "pytest-dev__pytest-10356", "score": "I", "diff": "diff --git a/AUTHORS b/AUTHORS\nindex ca2872f32..723f7f9ce 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -98,6 +98,7 @@ David Mohr\n David Paul R\u00f6thlisberger\n David Szotten\n David Vierra\n+AI Assistant\n Daw-Ran Liou\n Debi Mishra\n Denis Kirisov\ndiff --git a/changelog/10626.bugfix.rst b/changelog/10626.bugfix.rst\nnew file mode 100644\nindex 000000000..76a74c72a\n--- /dev/null\n+++ b/changelog/10626.bugfix.rst\n@@ -0,0 +1 @@\n+Fixed an issue where pytest markers were not properly collected from all base classes in the Method Resolution Order (MRO) when inheriting from multiple classes.\ndiff --git a/src/_pytest/python.py b/src/_pytest/python.py\nindex 3db877506..d2950ec6b 100644\n--- a/src/_pytest/python.py\n+++ b/src/_pytest/python.py\n@@ -1714,7 +1714,7 @@ class Function(PyobjMixin, nodes.Item):\n         # Note: when FunctionDefinition is introduced, we should change ``originalname``\n         # to a readonly property that returns FunctionDefinition.name.\n \n-        self.own_markers.extend(get_unpacked_marks(self.obj))\n+        self.own_markers.extend(self.collect_markers_from_mro())\n         if callspec:\n             self.callspec = callspec\n             self.own_markers.extend(callspec.marks)\n@@ -1737,6 +1737,18 @@ class Function(PyobjMixin, nodes.Item):\n         self.fixturenames = fixtureinfo.names_closure\n         self._initrequest()\n \n+    def collect_markers_from_mro(self):\n+        markers = []\n+        if hasattr(self.obj, '__self__'):  # Check if it's a bound method\n+            cls = self.obj.__self__.__class__\n+        elif hasattr(self.obj, '__class__'):  # Check if it's a class\n+            cls = self.obj.__class__\n+        else:\n+            return markers  # Return empty list if it's not a method or class\n+        for base_cls in cls.__mro__:\n+            markers.extend(get_unpacked_marks(base_cls))\n+        return markers\n+\n     @classmethod\n     def from_parent(cls, parent, **kw):  # todo: determine sound type limitations\n         \"\"\"The public constructor.\"\"\"\n", "gold_standard_diff": "diff --git a/changelog/7792.bugfix.rst b/changelog/7792.bugfix.rst\nnew file mode 100644\nindex 00000000000..8f65637896d\n--- /dev/null\n+++ b/changelog/7792.bugfix.rst\n@@ -0,0 +1,5 @@\n+Marks are now inherited according to the full MRO in test classes. Previously, if a test class inherited from two or more classes, only marks from the first super-class would apply.\n+\n+When inheriting marks from super-classes, marks from the sub-classes are now ordered before marks from the super-classes, in MRO order. Previously it was the reverse.\n+\n+When inheriting marks from super-classes, the `pytestmark` attribute of the sub-class now only contains the marks directly applied to it. Previously, it also contained marks from its super-classes. Please note that this attribute should not normally be accessed directly; use :func:`pytest.Node.iter_markers` instead.\ndiff --git a/src/_pytest/mark/structures.py b/src/_pytest/mark/structures.py\nindex 800a25c9243..5186c9ea3b6 100644\n--- a/src/_pytest/mark/structures.py\n+++ b/src/_pytest/mark/structures.py\n@@ -355,12 +355,35 @@ def __call__(self, *args: object, **kwargs: object):\n         return self.with_args(*args, **kwargs)\n \n \n-def get_unpacked_marks(obj: object) -> Iterable[Mark]:\n-    \"\"\"Obtain the unpacked marks that are stored on an object.\"\"\"\n-    mark_list = getattr(obj, \"pytestmark\", [])\n-    if not isinstance(mark_list, list):\n-        mark_list = [mark_list]\n-    return normalize_mark_list(mark_list)\n+def get_unpacked_marks(\n+    obj: Union[object, type],\n+    *,\n+    consider_mro: bool = True,\n+) -> List[Mark]:\n+    \"\"\"Obtain the unpacked marks that are stored on an object.\n+\n+    If obj is a class and consider_mro is true, return marks applied to\n+    this class and all of its super-classes in MRO order. If consider_mro\n+    is false, only return marks applied directly to this class.\n+    \"\"\"\n+    if isinstance(obj, type):\n+        if not consider_mro:\n+            mark_lists = [obj.__dict__.get(\"pytestmark\", [])]\n+        else:\n+            mark_lists = [x.__dict__.get(\"pytestmark\", []) for x in obj.__mro__]\n+        mark_list = []\n+        for item in mark_lists:\n+            if isinstance(item, list):\n+                mark_list.extend(item)\n+            else:\n+                mark_list.append(item)\n+    else:\n+        mark_attribute = getattr(obj, \"pytestmark\", [])\n+        if isinstance(mark_attribute, list):\n+            mark_list = mark_attribute\n+        else:\n+            mark_list = [mark_attribute]\n+    return list(normalize_mark_list(mark_list))\n \n \n def normalize_mark_list(\n@@ -388,7 +411,7 @@ def store_mark(obj, mark: Mark) -> None:\n     assert isinstance(mark, Mark), mark\n     # Always reassign name to avoid updating pytestmark in a reference that\n     # was only borrowed.\n-    obj.pytestmark = [*get_unpacked_marks(obj), mark]\n+    obj.pytestmark = [*get_unpacked_marks(obj, consider_mro=False), mark]\n \n \n # Typing for builtin pytest marks. This is cheating; it gives builtin marks\ndiff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 65f2581bd63..e2d1a40c38a 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1109,3 +1109,27 @@ def test_foo():\n     result = pytester.runpytest(foo, \"-m\", expr)\n     result.stderr.fnmatch_lines([expected])\n     assert result.ret == ExitCode.USAGE_ERROR\n+\n+\n+def test_mark_mro() -> None:\n+    xfail = pytest.mark.xfail\n+\n+    @xfail(\"a\")\n+    class A:\n+        pass\n+\n+    @xfail(\"b\")\n+    class B:\n+        pass\n+\n+    @xfail(\"c\")\n+    class C(A, B):\n+        pass\n+\n+    from _pytest.mark.structures import get_unpacked_marks\n+\n+    all_marks = get_unpacked_marks(C)\n+\n+    assert all_marks == [xfail(\"c\").mark, xfail(\"a\").mark, xfail(\"b\").mark]\n+\n+    assert get_unpacked_marks(C, consider_mro=False) == [xfail(\"c\").mark]\n", "gold_standard_pr_link": "https://github.com/pytest-dev/pytest/pull/10356"}