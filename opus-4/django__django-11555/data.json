{"instance_id": "django__django-11555", "score": "C", "diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex eaccc96d7d..ad83b31188 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,8 +722,58 @@ class SQLCompiler:\n \n             results = []\n             for item in opts.ordering:\n-                results.extend(self.find_ordering_name(item, opts, alias,\n-                                                       order, already_seen))\n+                # Handle expressions (e.g., OrderBy objects) in Meta.ordering\n+                if hasattr(item, 'resolve_expression'):\n+                    # For expressions, we create a transform function that prefixes\n+                    # field references with the correct alias\n+                    def make_transform(original_expr, alias):\n+                        def transform(target, alias2):\n+                            # Clone the expression and update field references\n+                            expr = original_expr.copy()\n+                            # If the expression contains field references (F objects),\n+                            # they need to be prefixed with the table alias\n+                            from django.db.models import F\n+                            \n+                            def update_refs(node):\n+                                if isinstance(node, F):\n+                                    # Create a new F object with the prefixed name\n+                                    return F(f\"{alias}.{node.name}\")\n+                                for child in node.get_source_expressions():\n+                                    if hasattr(child, 'get_source_expressions'):\n+                                        update_refs(child)\n+                            \n+                            update_refs(expr)\n+                            return expr\n+                        return transform\n+                    \n+                    if isinstance(item, Value):\n+                        # output_field must be resolved for constants.\n+                        item = Cast(item, item.output_field)\n+                    if not isinstance(item, OrderBy):\n+                        item = item.asc()\n+                    if not self.query.standard_ordering:\n+                        item = item.copy()\n+                        item.reverse_ordering()\n+                    \n+                    # Get field references from the expression\n+                    from django.db.models import F\n+                    base_expr = item.expression if isinstance(item, OrderBy) else item\n+                    \n+                    # For F() expressions, we need to handle them specially\n+                    if isinstance(base_expr, F):\n+                        # Use the standard field lookup mechanism\n+                        field_name = base_expr.name\n+                        results.extend(self.find_ordering_name(\n+                            field_name if not isinstance(item, OrderBy) or not item.descending else f\"-{field_name}\",\n+                            opts, alias, order, already_seen\n+                        ))\n+                    else:\n+                        # For other expressions, just pass them through\n+                        # but they might not work correctly with joins\n+                        results.append((item, False))\n+                else:\n+                    results.extend(self.find_ordering_name(item, opts, alias,\n+                                                           order, already_seen))\n             return results\n         targets, alias, _ = self.query.trim_joins(targets, joins, path)\n         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]\ndiff --git a/test_order_bug2.py b/test_order_bug2.py\nnew file mode 100644\nindex 0000000000..f6b617673f\n--- /dev/null\n+++ b/test_order_bug2.py\n@@ -0,0 +1,38 @@\n+from django.db import models\n+from django.db.models import F\n+from django.db.models.expressions import OrderBy\n+\n+# Test models to reproduce the issue  \n+class BaseModel(models.Model):\n+    created_at = models.DateTimeField(auto_now_add=True)\n+    \n+    class Meta:\n+        # Using an expression in ordering\n+        ordering = [OrderBy(F('created_at'), descending=True)]\n+        app_label = 'test_app'\n+\n+class DerivedModel(BaseModel):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Another test with deeper inheritance\n+class GrandParent(models.Model):\n+    gp_field = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        ordering = [OrderBy(F('gp_field'))]\n+        app_label = 'test_app'\n+\n+class Parent(GrandParent):\n+    p_field = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class Child(Parent):\n+    c_field = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\ndiff --git a/test_ordering_expression_bug.py b/test_ordering_expression_bug.py\nnew file mode 100644\nindex 0000000000..52136f038b\n--- /dev/null\n+++ b/test_ordering_expression_bug.py\n@@ -0,0 +1,31 @@\n+from django.db import models\n+from django.db.models import F\n+from django.db.models.expressions import OrderBy\n+from django.test import TestCase\n+\n+# Test models to reproduce the issue\n+class Parent(models.Model):\n+    name = models.CharField(max_length=100)\n+    created_at = models.DateTimeField(auto_now_add=True)\n+    \n+    class Meta:\n+        # Using an expression in ordering\n+        ordering = [OrderBy(F('created_at'), descending=True)]\n+        app_label = 'test_app'\n+\n+class Child(Parent):\n+    extra_field = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class OrderingExpressionTest(TestCase):\n+    def test_child_ordering_with_expression(self):\n+        \"\"\"Test that ordering by parent model with expression in Meta.ordering works\"\"\"\n+        # This should not crash\n+        child = Child.objects.create(name=\"Test\", extra_field=\"Extra\")\n+        \n+        # This query should work when ordering by a parent field\n+        result = Child.objects.order_by('name')\n+        self.assertEqual(list(result), [child])\ndiff --git a/test_settings.py b/test_settings.py\nnew file mode 100644\nindex 0000000000..543a1cabb9\n--- /dev/null\n+++ b/test_settings.py\n@@ -0,0 +1,11 @@\n+SECRET_KEY = 'test'\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\ndiff --git a/trace_issue.py b/trace_issue.py\nnew file mode 100644\nindex 0000000000..9133fbacc8\n--- /dev/null\n+++ b/trace_issue.py\n@@ -0,0 +1,22 @@\n+from django.db import models\n+from django.db.models import F\n+from django.db.models.expressions import OrderBy\n+\n+# Model with expression ordering\n+class Article(models.Model):\n+    title = models.CharField(max_length=100)\n+    pub_date = models.DateTimeField()\n+    \n+    class Meta:\n+        ordering = [OrderBy(F('pub_date'), descending=True)]\n+        app_label = 'test_app'\n+\n+# Model that has a relation to Article\n+class Comment(models.Model):\n+    article = models.ForeignKey(Article, on_delete=models.CASCADE)\n+    content = models.TextField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Let's trace what happens when we order Comment by article\n", "gold_standard_diff": "diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex eaccc96d7d46..3cab405d2df8 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -722,6 +722,9 @@ def find_ordering_name(self, name, opts, alias=None, default_order='ASC',\n \n             results = []\n             for item in opts.ordering:\n+                if isinstance(item, OrderBy):\n+                    results.append((item, False))\n+                    continue\n                 results.extend(self.find_ordering_name(item, opts, alias,\n                                                        order, already_seen))\n             return results\ndiff --git a/tests/ordering/models.py b/tests/ordering/models.py\nindex 8b71983c44c1..4a3e340e71df 100644\n--- a/tests/ordering/models.py\n+++ b/tests/ordering/models.py\n@@ -54,6 +54,10 @@ class Meta:\n         ordering = (models.F('author').asc(nulls_first=True), 'id')\n \n \n+class ChildArticle(Article):\n+    pass\n+\n+\n class Reference(models.Model):\n     article = models.ForeignKey(OrderedByAuthorArticle, models.CASCADE)\n \ndiff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 18c32d6d5f62..afc8791a0550 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -9,7 +9,7 @@\n from django.test import TestCase\n from django.utils.deprecation import RemovedInDjango31Warning\n \n-from .models import Article, Author, OrderedByFArticle, Reference\n+from .models import Article, Author, ChildArticle, OrderedByFArticle, Reference\n \n \n class OrderingTests(TestCase):\n@@ -462,6 +462,26 @@ def test_default_ordering_by_f_expression(self):\n             attrgetter('headline')\n         )\n \n+    def test_order_by_ptr_field_with_default_ordering_by_expression(self):\n+        ca1 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_2,\n+        )\n+        ca2 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca3 = ChildArticle.objects.create(\n+            headline='h3',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n+        articles = ChildArticle.objects.order_by('article_ptr')\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n     def test_deprecated_values_annotate(self):\n         msg = (\n             \"Article QuerySet won't use Meta.ordering in Django 3.1. Add \"\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11555"}