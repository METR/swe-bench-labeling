{"instance_id": "django__django-11551", "score": "C", "diff": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2f1..9fd77b5d41 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ class ModelAdminChecks(BaseModelAdminChecks):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        else:\n             try:\n                 field = obj.model._meta.get_field(item)\n             except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n+                try:\n+                    field = getattr(obj.model, item)\n+                except AttributeError:\n                     return [\n                         checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                            \"The value of '%s' refers to '%s', which is not a callable, \"\n+                            \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n+                                label, item, obj.__class__.__name__,\n+                                obj.model._meta.app_label, obj.model._meta.object_name,\n+                            ),\n                             obj=obj.__class__,\n-                            id='admin.E109',\n+                            id='admin.E108',\n                         )\n                     ]\n-                return []\n-        else:\n-            return [\n-                checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n-                    obj=obj.__class__,\n-                    id='admin.E108',\n-                )\n-            ]\n+            if isinstance(field, models.ManyToManyField):\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' must not be a ManyToManyField.\" % label,\n+                        obj=obj.__class__,\n+                        id='admin.E109',\n+                    )\n+                ]\n+            return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\ndiff --git a/test_admin_e108.py b/test_admin_e108.py\nnew file mode 100644\nindex 0000000000..5cd75875ab\n--- /dev/null\n+++ b/test_admin_e108.py\n@@ -0,0 +1,150 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test.utils import get_runner\n+\n+# Configure Django settings\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'test_settings'\n+\n+# Create a test settings module\n+test_settings_content = \"\"\"\n+SECRET_KEY = 'test-secret-key'\n+DEBUG = True\n+DATABASES = {\n+    'default': {\n+        'ENGINE': 'django.db.backends.sqlite3',\n+        'NAME': ':memory:',\n+    }\n+}\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+    'django.contrib.admin',\n+    'django.contrib.sessions',\n+    'django.contrib.messages',\n+    'test_app',\n+]\n+MIDDLEWARE = [\n+    'django.contrib.sessions.middleware.SessionMiddleware',\n+    'django.contrib.auth.middleware.AuthenticationMiddleware',\n+    'django.contrib.messages.middleware.MessageMiddleware',\n+]\n+ROOT_URLCONF = 'test_urls'\n+TEMPLATES = [\n+    {\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'DIRS': [],\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.template.context_processors.debug',\n+                'django.template.context_processors.request',\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    },\n+]\n+\"\"\"\n+\n+# Write test settings\n+with open('test_settings.py', 'w') as f:\n+    f.write(test_settings_content)\n+\n+# Create test urls\n+test_urls_content = \"\"\"\n+from django.contrib import admin\n+from django.urls import path\n+\n+urlpatterns = [\n+    path('admin/', admin.site.urls),\n+]\n+\"\"\"\n+\n+with open('test_urls.py', 'w') as f:\n+    f.write(test_urls_content)\n+\n+# Create a test app directory structure\n+os.makedirs('test_app', exist_ok=True)\n+with open('test_app/__init__.py', 'w') as f:\n+    f.write('')\n+\n+# Create a field that simulates PositionField behavior\n+position_field_content = \"\"\"\n+from django.db import models\n+\n+class PositionField(models.IntegerField):\n+    '''A field that simulates django-positions PositionField behavior'''\n+    \n+    def __get__(self, instance, owner):\n+        if instance is None:\n+            # This simulates the behavior where accessing the field on the model class raises an error\n+            raise AttributeError(\"Cannot access PositionField on model class\")\n+        return super().__get__(instance, owner)\n+    \n+    def contribute_to_class(self, cls, name, **kwargs):\n+        super().contribute_to_class(cls, name, **kwargs)\n+\"\"\"\n+\n+with open('test_app/fields.py', 'w') as f:\n+    f.write(position_field_content)\n+\n+# Create test models\n+models_content = \"\"\"\n+from django.db import models\n+from .fields import PositionField\n+\n+class Thing(models.Model):\n+    number = models.IntegerField(default=0)\n+    order = PositionField()\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\"\"\"\n+\n+with open('test_app/models.py', 'w') as f:\n+    f.write(models_content)\n+\n+# Create test admin\n+admin_content = \"\"\"\n+from django.contrib import admin\n+from .models import Thing\n+\n+@admin.register(Thing)\n+class ThingAdmin(admin.ModelAdmin):\n+    list_display = ['number', 'order']\n+\"\"\"\n+\n+with open('test_app/admin.py', 'w') as f:\n+    f.write(admin_content)\n+\n+# Now setup Django and run the check\n+django.setup()\n+\n+from django.core.management import call_command\n+from django.core.checks import run_checks\n+\n+print(\"Running Django admin checks...\")\n+try:\n+    errors = run_checks()\n+    if errors:\n+        print(f\"Found {len(errors)} errors:\")\n+        for error in errors:\n+            print(f\"  {error.id}: {error.msg}\")\n+    else:\n+        print(\"No errors found!\")\n+except Exception as e:\n+    print(f\"Exception during checks: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Cleanup\n+import os\n+for f in ['test_settings.py', 'test_urls.py', 'test_settings.pyc', 'test_urls.pyc']:\n+    if os.path.exists(f):\n+        os.remove(f)\n+import shutil\n+if os.path.exists('test_app'):\n+    shutil.rmtree('test_app')\ndiff --git a/test_comprehensive_e108.py b/test_comprehensive_e108.py\nnew file mode 100644\nindex 0000000000..daf9caf0b5\n--- /dev/null\n+++ b/test_comprehensive_e108.py\n@@ -0,0 +1,170 @@\n+#!/usr/bin/env python\n+\"\"\"Comprehensive test for admin.E108 fix\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure minimal Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings_comprehensive')\n+\n+settings.configure(\n+    SECRET_KEY='test-key',\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth', \n+        'django.contrib.admin',\n+        'django.contrib.messages',\n+        'django.contrib.sessions',\n+    ],\n+    MIDDLEWARE=[\n+        'django.contrib.sessions.middleware.SessionMiddleware',\n+        'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        'django.contrib.messages.middleware.MessageMiddleware',\n+    ],\n+    TEMPLATES=[{\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    }],\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.contrib import admin\n+from django.core.checks import run_checks\n+\n+# Create a descriptor that behaves like PositionField\n+class PositionFieldDescriptor:\n+    def __init__(self, field):\n+        self.field = field\n+        \n+    def __get__(self, instance, owner):\n+        if instance is None:\n+            raise AttributeError(\"Cannot access PositionField on class\")\n+        return instance.__dict__.get(self.field.name)\n+        \n+    def __set__(self, instance, value):\n+        instance.__dict__[self.field.name] = value\n+\n+# Create field that uses the descriptor\n+class PositionField(models.IntegerField):\n+    def contribute_to_class(self, cls, name, **kwargs):\n+        super().contribute_to_class(cls, name, **kwargs)\n+        # Replace the field with our descriptor\n+        setattr(cls, name, PositionFieldDescriptor(self))\n+\n+# Test different scenarios\n+print(\"=== Testing different scenarios based on the issue's table ===\\n\")\n+\n+# Test Case 1: Normal field (hasattr=True, get_field=ok, not ManyToMany)\n+class TestModel1(models.Model):\n+    normal_field = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+@admin.register(TestModel1)\n+class TestAdmin1(admin.ModelAdmin):\n+    list_display = ['normal_field']\n+\n+print(\"Test 1 - Normal field:\")\n+errors = run_checks(tags=['admin'])\n+print(f\"  Errors: {len([e for e in errors if 'TestAdmin1' in str(e)])}\")\n+\n+# Test Case 2: PositionField (hasattr=False, get_field=ok, not ManyToMany)\n+class TestModel2(models.Model):\n+    position = PositionField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+@admin.register(TestModel2)\n+class TestAdmin2(admin.ModelAdmin):\n+    list_display = ['position']\n+\n+print(\"\\nTest 2 - PositionField (hasattr=False, get_field=ok):\")\n+admin.site.unregister(TestModel1)  # Clean up previous test\n+errors = run_checks(tags=['admin'])\n+pos_errors = [e for e in errors if 'TestAdmin2' in str(e) and 'position' in str(e)]\n+print(f\"  Errors: {len(pos_errors)}\")\n+if pos_errors:\n+    for e in pos_errors:\n+        print(f\"    {e.id}: {e.msg}\")\n+\n+# Test Case 3: ManyToManyField\n+class TestModel3(models.Model):\n+    users = models.ManyToManyField('auth.User')\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+@admin.register(TestModel3)\n+class TestAdmin3(admin.ModelAdmin):\n+    list_display = ['users']\n+\n+print(\"\\nTest 3 - ManyToManyField:\")\n+admin.site.unregister(TestModel2)  # Clean up previous test\n+errors = run_checks(tags=['admin'])\n+m2m_errors = [e for e in errors if 'TestAdmin3' in str(e) and 'users' in str(e)]\n+print(f\"  Errors: {len(m2m_errors)}\")\n+if m2m_errors:\n+    for e in m2m_errors:\n+        print(f\"    {e.id}: {e.msg}\")\n+\n+# Test Case 4: Non-existent field\n+class TestModel4(models.Model):\n+    real_field = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+@admin.register(TestModel4)\n+class TestAdmin4(admin.ModelAdmin):\n+    list_display = ['non_existent_field']\n+\n+print(\"\\nTest 4 - Non-existent field:\")\n+admin.site.unregister(TestModel3)  # Clean up previous test\n+errors = run_checks(tags=['admin'])\n+ne_errors = [e for e in errors if 'TestAdmin4' in str(e) and 'non_existent_field' in str(e)]\n+print(f\"  Errors: {len(ne_errors)}\")\n+if ne_errors:\n+    for e in ne_errors:\n+        print(f\"    {e.id}: {e.msg}\")\n+\n+# Test Case 5: Callable on admin\n+class TestModel5(models.Model):\n+    field = models.IntegerField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+@admin.register(TestModel5)\n+class TestAdmin5(admin.ModelAdmin):\n+    def custom_method(self, obj):\n+        return \"custom\"\n+    \n+    list_display = ['field', 'custom_method']\n+\n+print(\"\\nTest 5 - Admin method:\")\n+admin.site.unregister(TestModel4)  # Clean up previous test\n+errors = run_checks(tags=['admin'])\n+admin_method_errors = [e for e in errors if 'TestAdmin5' in str(e)]\n+print(f\"  Errors: {len(admin_method_errors)}\")\n+\n+print(\"\\n=== All tests completed ===\")\n+print(\"The fix correctly handles PositionField-like descriptors that raise AttributeError on class access!\")\ndiff --git a/test_e108_simple.py b/test_e108_simple.py\nnew file mode 100644\nindex 0000000000..924e76c533\n--- /dev/null\n+++ b/test_e108_simple.py\n@@ -0,0 +1,111 @@\n+#!/usr/bin/env python\n+\"\"\"Direct test showing the fix works for PositionField-like descriptors\"\"\"\n+\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    SECRET_KEY='test',\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+        'django.contrib.admin',\n+        'django.contrib.messages',\n+        'django.contrib.sessions',\n+    ],\n+    DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': ':memory:'}},\n+    MIDDLEWARE=[\n+        'django.contrib.sessions.middleware.SessionMiddleware',\n+        'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        'django.contrib.messages.middleware.MessageMiddleware',\n+    ],\n+    TEMPLATES=[{\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    }],\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.contrib import admin\n+from django.contrib.admin import checks as admin_checks\n+\n+# Simulate PositionField behavior\n+class PositionFieldDescriptor:\n+    def __init__(self, field):\n+        self.field = field\n+        \n+    def __get__(self, instance, owner):\n+        if instance is None:\n+            raise AttributeError(\"Cannot access PositionField on class\")\n+        return instance.__dict__.get(self.field.name, None)\n+\n+class PositionField(models.IntegerField):\n+    def contribute_to_class(self, cls, name, **kwargs):\n+        super().contribute_to_class(cls, name, **kwargs)\n+        setattr(cls, name, PositionFieldDescriptor(self))\n+\n+# Test model with PositionField\n+class Thing(models.Model):\n+    number = models.IntegerField(default=0)\n+    order = PositionField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Test admin\n+class ThingAdmin(admin.ModelAdmin):\n+    list_display = ['number', 'order']\n+\n+# Direct test of _check_list_display_item\n+checker = admin_checks.ModelAdminChecks()\n+obj = ThingAdmin(Thing, admin.site)\n+\n+print(\"Testing _check_list_display_item with PositionField...\")\n+print(f\"hasattr(Thing, 'number'): {hasattr(Thing, 'number')}\")\n+print(f\"hasattr(Thing, 'order'): {hasattr(Thing, 'order')}\")\n+\n+# Test the fixed behavior\n+errors_number = checker._check_list_display_item(obj, 'number', 'list_display[0]')\n+errors_order = checker._check_list_display_item(obj, 'order', 'list_display[1]')\n+\n+print(f\"\\nErrors for 'number' field: {len(errors_number)}\")\n+print(f\"Errors for 'order' field (PositionField): {len(errors_order)}\")\n+\n+if errors_order:\n+    for e in errors_order:\n+        print(f\"  Error: {e.id} - {e.msg}\")\n+else:\n+    print(\"  No errors! The fix works correctly.\")\n+\n+# Also test ManyToMany field to ensure we still catch that error\n+class ThingWithM2M(models.Model):\n+    users = models.ManyToManyField('auth.User')\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+class ThingWithM2MAdmin(admin.ModelAdmin):\n+    list_display = ['users']\n+\n+obj_m2m = ThingWithM2MAdmin(ThingWithM2M, admin.site)\n+errors_m2m = checker._check_list_display_item(obj_m2m, 'users', 'list_display[0]')\n+\n+print(f\"\\nErrors for ManyToMany field: {len(errors_m2m)}\")\n+if errors_m2m:\n+    for e in errors_m2m:\n+        print(f\"  Error: {e.id} - {e.msg}\")\n+\n+# Test non-existent field\n+errors_nonexist = checker._check_list_display_item(obj, 'nonexistent', 'list_display[2]')\n+print(f\"\\nErrors for non-existent field: {len(errors_nonexist)}\")\n+if errors_nonexist:\n+    for e in errors_nonexist:\n+        print(f\"  Error: {e.id} - {e.msg}\")\ndiff --git a/test_position_field.py b/test_position_field.py\nnew file mode 100644\nindex 0000000000..16b7bfc46c\n--- /dev/null\n+++ b/test_position_field.py\n@@ -0,0 +1,110 @@\n+#!/usr/bin/env python\n+\"\"\"Test that reproduces the admin.E108 issue with fields that throw on class access\"\"\"\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure minimal Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings_pos')\n+\n+# Create test settings\n+settings.configure(\n+    SECRET_KEY='test-key',\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth', \n+        'django.contrib.admin',\n+        'django.contrib.messages',\n+        'django.contrib.sessions',\n+    ],\n+    MIDDLEWARE=[\n+        'django.contrib.sessions.middleware.SessionMiddleware',\n+        'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        'django.contrib.messages.middleware.MessageMiddleware',\n+    ],\n+    TEMPLATES=[{\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    }],\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.contrib import admin\n+from django.core.checks import run_checks\n+\n+# Create a descriptor that behaves like PositionField\n+class PositionFieldDescriptor:\n+    def __init__(self, field):\n+        self.field = field\n+        \n+    def __get__(self, instance, owner):\n+        if instance is None:\n+            raise AttributeError(\"Cannot access PositionField on class\")\n+        return instance.__dict__.get(self.field.name)\n+        \n+    def __set__(self, instance, value):\n+        instance.__dict__[self.field.name] = value\n+\n+# Create field that uses the descriptor\n+class PositionField(models.IntegerField):\n+    def contribute_to_class(self, cls, name, **kwargs):\n+        super().contribute_to_class(cls, name, **kwargs)\n+        # Replace the field with our descriptor\n+        setattr(cls, name, PositionFieldDescriptor(self))\n+\n+# Test model\n+class Thing(models.Model):\n+    number = models.IntegerField(default=0)\n+    order = PositionField()\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Test admin\n+@admin.register(Thing)\n+class ThingAdmin(admin.ModelAdmin):\n+    list_display = ['number', 'order']\n+\n+# Now run the admin checks\n+print(\"Running admin checks...\")\n+errors = run_checks(tags=['admin'])\n+\n+if errors:\n+    print(f\"\\nFound {len(errors)} error(s):\")\n+    for error in errors:\n+        print(f\"\\n{error.id}: {error.msg}\")\n+        if hasattr(error, 'obj'):\n+            print(f\"  Object: {error.obj}\")\n+else:\n+    print(\"\\nNo errors found!\")\n+\n+# Let's also test hasattr behavior\n+print(\"\\n--- Testing hasattr behavior ---\")\n+print(f\"hasattr(Thing, 'number'): {hasattr(Thing, 'number')}\")\n+print(f\"hasattr(Thing, 'order'): {hasattr(Thing, 'order')}\")\n+\n+# And test get_field\n+print(\"\\n--- Testing _meta.get_field ---\")\n+try:\n+    field = Thing._meta.get_field('order')\n+    print(f\"Thing._meta.get_field('order'): {field}\")\n+    print(f\"Is ManyToManyField: {isinstance(field, models.ManyToManyField)}\")\n+except Exception as e:\n+    print(f\"Thing._meta.get_field('order') raised: {e}\")\n", "gold_standard_diff": "diff --git a/django/contrib/admin/checks.py b/django/contrib/admin/checks.py\nindex f82c20c2f170..0c32301284b4 100644\n--- a/django/contrib/admin/checks.py\n+++ b/django/contrib/admin/checks.py\n@@ -720,33 +720,33 @@ def _check_list_display_item(self, obj, item, label):\n             return []\n         elif hasattr(obj, item):\n             return []\n-        elif hasattr(obj.model, item):\n+        try:\n+            field = obj.model._meta.get_field(item)\n+        except FieldDoesNotExist:\n             try:\n-                field = obj.model._meta.get_field(item)\n-            except FieldDoesNotExist:\n-                return []\n-            else:\n-                if isinstance(field, models.ManyToManyField):\n-                    return [\n-                        checks.Error(\n-                            \"The value of '%s' must not be a ManyToManyField.\" % label,\n-                            obj=obj.__class__,\n-                            id='admin.E109',\n-                        )\n-                    ]\n-                return []\n-        else:\n+                field = getattr(obj.model, item)\n+            except AttributeError:\n+                return [\n+                    checks.Error(\n+                        \"The value of '%s' refers to '%s', which is not a \"\n+                        \"callable, an attribute of '%s', or an attribute or \"\n+                        \"method on '%s.%s'.\" % (\n+                            label, item, obj.__class__.__name__,\n+                            obj.model._meta.app_label, obj.model._meta.object_name,\n+                        ),\n+                        obj=obj.__class__,\n+                        id='admin.E108',\n+                    )\n+                ]\n+        if isinstance(field, models.ManyToManyField):\n             return [\n                 checks.Error(\n-                    \"The value of '%s' refers to '%s', which is not a callable, \"\n-                    \"an attribute of '%s', or an attribute or method on '%s.%s'.\" % (\n-                        label, item, obj.__class__.__name__,\n-                        obj.model._meta.app_label, obj.model._meta.object_name,\n-                    ),\n+                    \"The value of '%s' must not be a ManyToManyField.\" % label,\n                     obj=obj.__class__,\n-                    id='admin.E108',\n+                    id='admin.E109',\n                 )\n             ]\n+        return []\n \n     def _check_list_display_links(self, obj):\n         \"\"\" Check that list_display_links is a unique subset of list_display.\ndiff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex a1b7001f68e9..98cc56d67c3d 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -3,7 +3,7 @@\n from django.contrib.admin.options import VERTICAL, ModelAdmin, TabularInline\n from django.contrib.admin.sites import AdminSite\n from django.core.checks import Error\n-from django.db.models import F\n+from django.db.models import F, Field, Model\n from django.db.models.functions import Upper\n from django.forms.models import BaseModelFormSet\n from django.test import SimpleTestCase\n@@ -509,6 +509,25 @@ def a_method(self, obj):\n \n         self.assertIsValid(TestModelAdmin, ValidationTestModel)\n \n+    def test_valid_field_accessible_via_instance(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+\n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('field',)\n+\n+        self.assertIsValid(TestModelAdmin, TestModel)\n+\n \n class ListDisplayLinksCheckTests(CheckTestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/11551"}