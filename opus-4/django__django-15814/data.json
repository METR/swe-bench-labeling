{"instance_id": "django__django-15814", "score": "C", "diff": "diff --git a/debug_proxy_bug.py b/debug_proxy_bug.py\nnew file mode 100644\nindex 0000000000..fd8af1c665\n--- /dev/null\n+++ b/debug_proxy_bug.py\n@@ -0,0 +1,90 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='secret',\n+)\n+\n+django.setup()\n+\n+# Import after Django setup\n+from django.db import connection\n+from django.db.models import query\n+\n+# Define models\n+class CustomModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyCustomModel(CustomModel):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class AnotherModel(models.Model):\n+    custom = models.ForeignKey(\n+        ProxyCustomModel,\n+        on_delete=models.SET_NULL,\n+        null=True,\n+        blank=True,\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(CustomModel)\n+    schema_editor.create_model(AnotherModel)\n+\n+# Create test data\n+custom = ProxyCustomModel.objects.create(name=\"Test Name\")\n+another = AnotherModel.objects.create(custom=custom)\n+\n+# Monkey patch to debug\n+original_init = query.RelatedPopulator.__init__\n+\n+def debug_init(self, klass_info, select, db):\n+    print(f\"\\nRelatedPopulator.__init__ called\")\n+    print(f\"klass_info['model']: {klass_info['model']}\")\n+    print(f\"klass_info['model']._meta: {klass_info['model']._meta}\")\n+    print(f\"klass_info['model']._meta.concrete_model: {klass_info['model']._meta.concrete_model}\")\n+    \n+    # Call original\n+    try:\n+        original_init(self, klass_info, select, db)\n+    except ValueError as e:\n+        print(f\"\\nError in RelatedPopulator.__init__: {e}\")\n+        print(f\"self.model_cls: {self.model_cls}\")\n+        print(f\"self.model_cls._meta.pk.attname: {self.model_cls._meta.pk.attname}\")\n+        print(f\"self.init_list: {self.init_list}\")\n+        raise\n+\n+query.RelatedPopulator.__init__ = debug_init\n+\n+print(\"Testing the issue...\")\n+try:\n+    # This should trigger the error\n+    objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n+    print(\"No error occurred - unexpected!\")\n+except ValueError as e:\n+    print(f\"\\nFinal error: {e}\")\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b22..5036335bec 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,7 +748,7 @@ class Query(BaseExpression):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n-                opts = cur_model._meta\n+                opts = cur_model._meta.concrete_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\n                 # (if it's not a reverse relation) to the things we select.\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..e676db1e87\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,148 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='secret',\n+)\n+\n+django.setup()\n+\n+# Import after Django setup\n+from django.db import connection\n+\n+# Define models\n+class CustomModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    description = models.TextField(blank=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyCustomModel(CustomModel):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class AnotherModel(models.Model):\n+    custom = models.ForeignKey(\n+        ProxyCustomModel,\n+        on_delete=models.SET_NULL,\n+        null=True,\n+        blank=True,\n+    )\n+    value = models.IntegerField(default=0)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Non-proxy ForeignKey for comparison\n+class RegularModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    description = models.TextField(blank=True)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class AnotherRegularModel(models.Model):\n+    regular = models.ForeignKey(\n+        RegularModel,\n+        on_delete=models.SET_NULL,\n+        null=True,\n+        blank=True,\n+    )\n+    value = models.IntegerField(default=0)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(CustomModel)\n+    schema_editor.create_model(AnotherModel)\n+    schema_editor.create_model(RegularModel)\n+    schema_editor.create_model(AnotherRegularModel)\n+\n+# Create test data\n+custom = ProxyCustomModel.objects.create(name=\"Test Name\", description=\"Test Description\")\n+another = AnotherModel.objects.create(custom=custom, value=42)\n+\n+regular = RegularModel.objects.create(name=\"Regular Name\", description=\"Regular Description\") \n+another_regular = AnotherRegularModel.objects.create(regular=regular, value=84)\n+\n+print(\"=== Testing proxy model with select_related and only ===\")\n+\n+# Test 1: The original issue - select_related with only on proxy model\n+print(\"\\nTest 1: select_related('custom').only('custom__name')\")\n+try:\n+    objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n+    print(f\"\u2713 Success! Retrieved {len(objs)} objects\")\n+    obj = objs[0]\n+    print(f\"  - custom.name: {obj.custom.name}\")\n+    print(f\"  - custom.id: {obj.custom.id}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+# Test 2: Multiple fields with only\n+print(\"\\nTest 2: select_related('custom').only('custom__name', 'custom__description', 'value')\")\n+try:\n+    objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\", \"custom__description\", \"value\").all())\n+    print(f\"\u2713 Success! Retrieved {len(objs)} objects\")\n+    obj = objs[0]\n+    print(f\"  - custom.name: {obj.custom.name}\")\n+    print(f\"  - custom.description: {obj.custom.description}\")\n+    print(f\"  - value: {obj.value}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+# Test 3: select_related without only (should work normally)\n+print(\"\\nTest 3: select_related('custom') without only()\")\n+try:\n+    objs = list(AnotherModel.objects.select_related(\"custom\").all())\n+    print(f\"\u2713 Success! Retrieved {len(objs)} objects\")\n+    obj = objs[0]\n+    print(f\"  - custom.name: {obj.custom.name}\")\n+    print(f\"  - custom.description: {obj.custom.description}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+# Test 4: only without select_related\n+print(\"\\nTest 4: only('value') without select_related\")\n+try:\n+    objs = list(AnotherModel.objects.only(\"value\").all())\n+    print(f\"\u2713 Success! Retrieved {len(objs)} objects\")\n+    obj = objs[0]\n+    print(f\"  - value: {obj.value}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\n=== Testing regular (non-proxy) model for comparison ===\")\n+\n+# Test 5: Regular model with select_related and only (should work)\n+print(\"\\nTest 5: Regular model - select_related('regular').only('regular__name')\")\n+try:\n+    objs = list(AnotherRegularModel.objects.select_related(\"regular\").only(\"regular__name\").all())\n+    print(f\"\u2713 Success! Retrieved {len(objs)} objects\")\n+    obj = objs[0]\n+    print(f\"  - regular.name: {obj.regular.name}\")\n+    print(f\"  - regular.id: {obj.regular.id}\")\n+except Exception as e:\n+    print(f\"\u2717 Failed: {e}\")\n+\n+print(\"\\n=== All tests completed ===\")\ndiff --git a/test_proxy_bug.py b/test_proxy_bug.py\nnew file mode 100644\nindex 0000000000..47aafdc41a\n--- /dev/null\n+++ b/test_proxy_bug.py\n@@ -0,0 +1,82 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.db import models\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+    SECRET_KEY='secret',\n+)\n+\n+django.setup()\n+\n+# Import after Django setup\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+from django.db.migrations.migration import Migration\n+from django.db.migrations import operations\n+\n+# Create the app for models\n+class TestApp:\n+    label = 'test_app'\n+\n+# Define models\n+class CustomModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyCustomModel(CustomModel):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class AnotherModel(models.Model):\n+    custom = models.ForeignKey(\n+        ProxyCustomModel,\n+        on_delete=models.SET_NULL,\n+        null=True,\n+        blank=True,\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create tables\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(CustomModel)\n+    schema_editor.create_model(AnotherModel)\n+\n+# Create test data\n+custom = ProxyCustomModel.objects.create(name=\"Test Name\")\n+another = AnotherModel.objects.create(custom=custom)\n+\n+print(\"Testing the issue...\")\n+try:\n+    # This should trigger the error\n+    objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n+    print(\"No error occurred - unexpected!\")\n+except ValueError as e:\n+    print(f\"Error occurred as expected: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\nDebugging info:\")\n+print(f\"ProxyCustomModel._meta.pk.attname: {ProxyCustomModel._meta.pk.attname}\")\n+print(f\"ProxyCustomModel._meta.concrete_model: {ProxyCustomModel._meta.concrete_model}\")\n+print(f\"ProxyCustomModel._meta.concrete_model._meta.pk.attname: {ProxyCustomModel._meta.concrete_model._meta.pk.attname}\")\ndiff --git a/test_proxy_issue.py b/test_proxy_issue.py\nnew file mode 100644\nindex 0000000000..78e8ac223d\n--- /dev/null\n+++ b/test_proxy_issue.py\n@@ -0,0 +1,40 @@\n+import os\n+import django\n+from django.db import models\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+django.setup()\n+\n+# Define models\n+class CustomModel(models.Model):\n+    name = models.CharField(max_length=16)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyCustomModel(CustomModel):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class AnotherModel(models.Model):\n+    custom = models.ForeignKey(\n+        ProxyCustomModel,\n+        on_delete=models.SET_NULL,\n+        null=True,\n+        blank=True,\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test the issue\n+try:\n+    # This should trigger the error\n+    objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n+    print(\"No error occurred - unexpected!\")\n+except ValueError as e:\n+    print(f\"Error occurred as expected: {e}\")\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_proxy_only_select_related.patch b/test_proxy_only_select_related.patch\nnew file mode 100644\nindex 0000000000..6b9d53c2ff\n--- /dev/null\n+++ b/test_proxy_only_select_related.patch\n@@ -0,0 +1,33 @@\n+diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\n+index test1..test2 100644\n+--- a/tests/proxy_models/tests.py\n++++ b/tests/proxy_models/tests.py\n+@@ -300,3 +300,27 @@ class ProxyModelTests(TestCase):\n+         self.assertEqual(resp.status_code, 200)\n+         self.assertContains(resp, '<h1>Select proxy_models_myperson to change</h1>')\n+         self.assertContains(resp, 'Bruce')\n++\n++    def test_proxy_select_related_only(self):\n++        \"\"\"\n++        Test that select_related() with only() works correctly on proxy models.\n++        This is a regression test for a bug where using only() after\n++        select_related() on proxy models caused a ValueError.\n++        \"\"\"\n++        # Create a model with ForeignKey to proxy model for testing\n++        from django.db import models\n++        \n++        class TestModel(models.Model):\n++            proxy_person = models.ForeignKey(MyPerson, on_delete=models.CASCADE)\n++            value = models.IntegerField(default=0)\n++            \n++            class Meta:\n++                app_label = 'proxy_models'\n++        \n++        # Create test data\n++        person = MyPerson.objects.create(name=\"Test Person\")\n++        test_obj = TestModel.objects.create(proxy_person=person, value=42)\n++        \n++        # This should not raise ValueError\n++        result = list(TestModel.objects.select_related(\"proxy_person\").only(\"proxy_person__name\"))\n++        self.assertEqual(len(result), 1)\n++        self.assertEqual(result[0].proxy_person.name, \"Test Person\")\ndiff --git a/test_proxy_select_related_only.py b/test_proxy_select_related_only.py\nnew file mode 100644\nindex 0000000000..a59b5056c8\n--- /dev/null\n+++ b/test_proxy_select_related_only.py\n@@ -0,0 +1,117 @@\n+\"\"\"\n+Test for the fix to QuerySet.only() after select_related() crash on proxy models.\n+This test ensures that using only() with select_related() on proxy models works correctly.\n+\"\"\"\n+from django.test import TestCase\n+from django.db import models\n+\n+\n+class ProxySelectRelatedOnlyTest(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        \"\"\"Set up test models and data.\"\"\"\n+        # Create the base model\n+        class CustomModel(models.Model):\n+            name = models.CharField(max_length=16)\n+            description = models.TextField(blank=True)\n+            \n+            class Meta:\n+                app_label = 'test_proxy_select_related'\n+        \n+        # Create proxy model\n+        class ProxyCustomModel(CustomModel):\n+            class Meta:\n+                proxy = True\n+                app_label = 'test_proxy_select_related'\n+        \n+        # Create model with ForeignKey to proxy\n+        class AnotherModel(models.Model):\n+            custom = models.ForeignKey(\n+                ProxyCustomModel,\n+                on_delete=models.SET_NULL,\n+                null=True,\n+                blank=True,\n+            )\n+            value = models.IntegerField(default=0)\n+            \n+            class Meta:\n+                app_label = 'test_proxy_select_related'\n+        \n+        cls.CustomModel = CustomModel\n+        cls.ProxyCustomModel = ProxyCustomModel\n+        cls.AnotherModel = AnotherModel\n+        \n+        # Create test data\n+        cls.custom = cls.ProxyCustomModel.objects.create(\n+            name=\"Test Name\",\n+            description=\"Test Description\"\n+        )\n+        cls.another = cls.AnotherModel.objects.create(\n+            custom=cls.custom,\n+            value=42\n+        )\n+\n+    def test_select_related_only_single_field(self):\n+        \"\"\"Test select_related with only() on a single field of proxy model.\"\"\"\n+        objs = list(self.AnotherModel.objects.select_related(\"custom\").only(\"custom__name\"))\n+        self.assertEqual(len(objs), 1)\n+        obj = objs[0]\n+        self.assertEqual(obj.custom.name, \"Test Name\")\n+        self.assertEqual(obj.custom.pk, self.custom.pk)\n+    \n+    def test_select_related_only_multiple_fields(self):\n+        \"\"\"Test select_related with only() on multiple fields including proxy model fields.\"\"\"\n+        objs = list(self.AnotherModel.objects.select_related(\"custom\").only(\n+            \"custom__name\", \"custom__description\", \"value\"\n+        ))\n+        self.assertEqual(len(objs), 1)\n+        obj = objs[0]\n+        self.assertEqual(obj.custom.name, \"Test Name\")\n+        self.assertEqual(obj.custom.description, \"Test Description\")\n+        self.assertEqual(obj.value, 42)\n+    \n+    def test_select_related_without_only(self):\n+        \"\"\"Test that select_related without only() still works on proxy models.\"\"\"\n+        objs = list(self.AnotherModel.objects.select_related(\"custom\"))\n+        self.assertEqual(len(objs), 1)\n+        obj = objs[0]\n+        self.assertEqual(obj.custom.name, \"Test Name\")\n+        self.assertEqual(obj.custom.description, \"Test Description\")\n+    \n+    def test_only_without_select_related(self):\n+        \"\"\"Test that only() without select_related works normally.\"\"\"\n+        objs = list(self.AnotherModel.objects.only(\"value\"))\n+        self.assertEqual(len(objs), 1)\n+        obj = objs[0]\n+        self.assertEqual(obj.value, 42)\n+\n+\n+if __name__ == '__main__':\n+    # Simple test runner\n+    import django\n+    from django.conf import settings\n+    from django.test.utils import get_runner\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        SECRET_KEY='test',\n+    )\n+    \n+    django.setup()\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner()\n+    failures = test_runner.run_tests([\"__main__\"])\n+    if failures:\n+        print(\"Tests failed!\")\n+    else:\n+        print(\"All tests passed!\")\n", "gold_standard_diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex 33cc636b2264..cf7566d7711c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -748,6 +748,7 @@ def deferred_to_data(self, target):\n                     cur_model = source.related_model\n                 else:\n                     cur_model = source.remote_field.model\n+                cur_model = cur_model._meta.concrete_model\n                 opts = cur_model._meta\n                 # Even if we're \"just passing through\" this model, we must add\n                 # both the current model's pk and the related reference field\ndiff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex f2f465678b51..7caa43d4893a 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -395,6 +395,12 @@ def test_proxy_load_from_fixture(self):\n         p = MyPerson.objects.get(pk=100)\n         self.assertEqual(p.name, \"Elvis Presley\")\n \n+    def test_select_related_only(self):\n+        user = ProxyTrackerUser.objects.create(name=\"Joe Doe\", status=\"test\")\n+        issue = Issue.objects.create(summary=\"New issue\", assignee=user)\n+        qs = Issue.objects.select_related(\"assignee\").only(\"assignee__status\")\n+        self.assertEqual(qs.get(), issue)\n+\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/15814"}