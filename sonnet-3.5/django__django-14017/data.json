{"instance_id": "django__django-14017", "score": "I", "diff": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa564..4138a6c22b 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -25,6 +25,10 @@ def subclasses(cls):\n         yield from subclasses(subclass)\n \n \n+def is_exists(obj):\n+    return obj.__class__.__name__ == 'Exists'\n+\n+\n class Q(tree.Node):\n     \"\"\"\n     Encapsulate filters as objects that can then be combined logically (using\n@@ -37,25 +41,35 @@ class Q(tree.Node):\n     conditional = True\n \n     def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n-        super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n+        children = []\n+        for arg in args:\n+            if is_exists(arg):\n+                children.append(('', arg))\n+            else:\n+                children.append(arg)\n+        children.extend(sorted(kwargs.items()))\n+        super().__init__(children=children, connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n+        if not isinstance(other, Q) and not is_exists(other):\n             raise TypeError(other)\n \n-        # If the other Q() is empty, ignore it and just use `self`.\n-        if not other:\n-            _, args, kwargs = self.deconstruct()\n-            return type(self)(*args, **kwargs)\n-        # Or if this Q is empty, ignore it and just use `other`.\n-        elif not self:\n-            _, args, kwargs = other.deconstruct()\n-            return type(other)(*args, **kwargs)\n-\n         obj = type(self)()\n         obj.connector = conn\n-        obj.add(self, conn)\n-        obj.add(other, conn)\n+\n+        # If the other Q() is empty and self is not Exists, just use `self`.\n+        if not other and not is_exists(self):\n+            obj.add(self, conn)\n+        # If this Q is empty and other is not Exists, just use `other`.\n+        elif not self and not is_exists(other):\n+            obj.add(other, conn)\n+        else:\n+            obj.add(self, conn)\n+            if is_exists(other):\n+                obj.add(('', other), conn)\n+            else:\n+                obj.add(other, conn)\n+\n         return obj\n \n     def __or__(self, other):\n@@ -64,6 +78,9 @@ class Q(tree.Node):\n     def __and__(self, other):\n         return self._combine(other, self.AND)\n \n+    def __rand__(self, other):\n+        return self._combine(other, self.AND)\n+\n     def __invert__(self):\n         obj = type(self)()\n         obj.add(self, self.AND)\ndiff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex 6dcf36ce02..9364a28326 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -111,3 +111,23 @@ class QTests(SimpleTestCase):\n         q = q1 & q2\n         path, args, kwargs = q.deconstruct()\n         self.assertEqual(Q(*args, **kwargs), q)\n+\n+    def test_q_and_exists(self):\n+        from django.db.models import Exists\n+        from django.db.models.expressions import RawSQL\n+        q = Q()\n+        exists = Exists(RawSQL(\"SELECT 1\", []))\n+        combined = q & exists\n+        self.assertIsInstance(combined, Q)\n+        self.assertEqual(combined.connector, Q.AND)\n+        self.assertEqual(len(combined.children), 2)\n+        self.assertIs(combined.children[0], q)\n+        self.assertIs(combined.children[1], exists)\n+\n+        # Test the reverse order\n+        combined_reverse = exists & q\n+        self.assertIsInstance(combined_reverse, Q)\n+        self.assertEqual(combined_reverse.connector, Q.AND)\n+        self.assertEqual(len(combined_reverse.children), 2)\n+        self.assertIs(combined_reverse.children[0], exists)\n+        self.assertIs(combined_reverse.children[1], q)\n\\ No newline at end of file\n", "gold_standard_diff": "From efce21497cc21140c5fe2b133064cd815c97b3f5 Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Thu, 18 Feb 2021 21:32:38 +0100\nSubject: [PATCH 1/2] Refs #32455 -- Added tests for left combining an empty\n Q() with boolean expressions.\n\n---\n tests/expressions/tests.py | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 08ea0a51d350..770a57d66ec1 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -816,6 +816,18 @@ def test_boolean_expression_combined(self):\n             [self.example_inc.ceo, self.max],\n         )\n \n+    def test_boolean_expression_combined_with_empty_Q(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Exists(is_poc) & Q(),\n+            Exists(is_poc) | Q(),\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions):\n+                self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n+\n \n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\n\nFrom f2bef2b7bc6c817af0f5fa77e1052a1f5ce12f71 Mon Sep 17 00:00:00 2001\nFrom: Hasan Ramezani <hasan.r67@gmail.com>\nDate: Thu, 18 Feb 2021 14:01:48 +0100\nSubject: [PATCH 2/2] Fixed #32455 -- Allowed right combining Q() with boolean\n expressions.\n\n---\n django/db/models/query_utils.py |  2 +-\n tests/expressions/tests.py      | 10 ++++++++++\n 2 files changed, 11 insertions(+), 1 deletion(-)\n\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex c957ffa5648c..ae0f8861075c 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -40,7 +40,7 @@ def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n         super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)\n \n     def _combine(self, other, conn):\n-        if not isinstance(other, Q):\n+        if not(isinstance(other, Q) or getattr(other, 'conditional', False) is True):\n             raise TypeError(other)\n \n         # If the other Q() is empty, ignore it and just use `self`.\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 770a57d66ec1..9ecc033b6b2b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -815,6 +815,14 @@ def test_boolean_expression_combined(self):\n             Employee.objects.filter(Exists(is_poc) | Q(salary__lt=15)),\n             [self.example_inc.ceo, self.max],\n         )\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q(salary__gte=30) & Exists(is_ceo)),\n+            [self.max],\n+        )\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q(salary__lt=15) | Exists(is_poc)),\n+            [self.example_inc.ceo, self.max],\n+        )\n \n     def test_boolean_expression_combined_with_empty_Q(self):\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n@@ -822,7 +830,9 @@ def test_boolean_expression_combined_with_empty_Q(self):\n         self.gmbh.save()\n         tests = [\n             Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n             Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n         ]\n         for conditions in tests:\n             with self.subTest(conditions):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14017"}