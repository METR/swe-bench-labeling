{"instance_id": "django__django-12209", "score": "C", "diff": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0..f865042ce0 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -840,6 +840,17 @@ class Model(metaclass=ModelBase):\n                        if f.name in update_fields or f.attname in update_fields]\n \n         pk_val = self._get_pk_val(meta)\n+        pk_set = pk_val is not None\n+        if pk_set and not force_insert:\n+            # If pk is set and not forcing insert, try to do an update first\n+            if meta.pk.has_default():\n+                # Check if the object with this pk already exists\n+                existing = cls._base_manager.filter(pk=pk_val).exists()\n+                if existing:\n+                    values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))\n+                              for f in non_pks]\n+                    return self._do_update(cls._base_manager, using, pk_val, values, update_fields,\n+                                           forced_update=force_update)\n         if pk_val is None:\n             pk_val = meta.pk.get_pk_value_on_save(self)\n             setattr(self, meta.pk.attname, pk_val)\ndiff --git a/tests/test_save_behavior.py b/tests/test_save_behavior.py\nnew file mode 100644\nindex 0000000000..c9c5fad4bc\n--- /dev/null\n+++ b/tests/test_save_behavior.py\n@@ -0,0 +1,36 @@\n+from django.test import TestCase\n+from django.db import models\n+import uuid\n+\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+class SaveBehaviorTestCase(TestCase):\n+    def test_save_with_explicit_pk(self):\n+        # Create an initial object\n+        s0 = Sample.objects.create()\n+        \n+        # Create a new object with the same pk\n+        s1 = Sample(pk=s0.pk, name='Test 1')\n+        s1.save()\n+        \n+        # Check that only one object exists in the database\n+        self.assertEqual(Sample.objects.count(), 1)\n+        \n+        # Check that the name was updated\n+        updated_sample = Sample.objects.get(pk=s0.pk)\n+        self.assertEqual(updated_sample.name, 'Test 1')\n+\n+    def test_save_with_explicit_pk_nonexistent(self):\n+        # Create an object with a new UUID\n+        new_uuid = uuid.uuid4()\n+        s1 = Sample(pk=new_uuid, name='Test 2')\n+        s1.save()\n+        \n+        # Check that a new object was created\n+        self.assertEqual(Sample.objects.count(), 1)\n+        \n+        # Check that the object has the correct UUID and name\n+        created_sample = Sample.objects.get(pk=new_uuid)\n+        self.assertEqual(created_sample.name, 'Test 2')\ndiff --git a/tests/test_save_behavior_minimal.py b/tests/test_save_behavior_minimal.py\nnew file mode 100644\nindex 0000000000..7588548c7a\n--- /dev/null\n+++ b/tests/test_save_behavior_minimal.py\n@@ -0,0 +1,88 @@\n+import unittest\n+from django.db import models, connection\n+from django.db.models.base import ModelBase\n+import uuid\n+from django.conf import settings\n+import django\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[],\n+        USE_TZ=False,\n+    )\n+\n+# Set up Django\n+django.setup()\n+\n+# Create the test database and table\n+with connection.cursor() as cursor:\n+    cursor.execute('''\n+        CREATE TABLE test_app_sample (\n+            id CHAR(32) PRIMARY KEY,\n+            name VARCHAR(100) NOT NULL\n+        )\n+    ''')\n+\n+class Sample(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4)\n+    name = models.CharField(blank=True, max_length=100)\n+\n+    class Meta:\n+        app_label = 'test_app'\n+\n+    def save(self, *args, **kwargs):\n+        if self.pk is not None:\n+            try:\n+                Sample.objects.get(pk=self.pk)\n+                # If the object exists, force an update\n+                kwargs['force_update'] = True\n+            except Sample.DoesNotExist:\n+                # If the object doesn't exist, force an insert\n+                kwargs['force_insert'] = True\n+        super().save(*args, **kwargs)\n+\n+class SaveBehaviorTestCase(unittest.TestCase):\n+    def setUp(self):\n+        # Clear the database before each test\n+        Sample.objects.all().delete()\n+\n+    def test_save_with_explicit_pk(self):\n+        # Create an initial object\n+        s0 = Sample.objects.create(name='Initial')\n+        initial_pk = s0.pk\n+\n+        # Create a new object with the same pk\n+        s1 = Sample(pk=initial_pk, name='Updated')\n+        s1.save()\n+\n+        # Refresh the object from the database\n+        s1.refresh_from_db()\n+\n+        # Check that the name was updated and only one object exists\n+        self.assertEqual(s1.name, 'Updated')\n+        self.assertEqual(s1.pk, initial_pk)\n+        self.assertEqual(Sample.objects.count(), 1)\n+\n+    def test_save_with_explicit_pk_nonexistent(self):\n+        # Create an object with a new UUID\n+        new_uuid = uuid.uuid4()\n+        s1 = Sample(pk=new_uuid, name='New')\n+        s1.save()\n+\n+        # Refresh the object from the database\n+        s1.refresh_from_db()\n+\n+        # Check that the object has the correct UUID and name\n+        self.assertEqual(s1.pk, new_uuid)\n+        self.assertEqual(s1.name, 'New')\n+        self.assertEqual(Sample.objects.count(), 1)\n+\n+if __name__ == '__main__':\n+    unittest.main()\n", "gold_standard_diff": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex e3b14a41a0d0..844c01e95eeb 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -849,6 +849,7 @@ def _save_table(self, raw=False, cls=None, force_insert=False,\n         updated = False\n         # Skip an UPDATE when adding an instance and primary key has a default.\n         if (\n+            not raw and\n             not force_insert and\n             self._state.adding and\n             self._meta.pk.default and\ndiff --git a/docs/ref/models/instances.txt b/docs/ref/models/instances.txt\nindex 9345bc0fe0bd..1524ad2fcd79 100644\n--- a/docs/ref/models/instances.txt\n+++ b/docs/ref/models/instances.txt\n@@ -465,8 +465,9 @@ How Django knows to UPDATE vs. INSERT\n \n You may have noticed Django database objects use the same ``save()`` method\n for creating and changing objects. Django abstracts the need to use ``INSERT``\n-or ``UPDATE`` SQL statements. Specifically, when you call ``save()``, Django\n-follows this algorithm:\n+or ``UPDATE`` SQL statements. Specifically, when you call ``save()`` and the\n+object's primary key attribute does **not** define a\n+:attr:`~django.db.models.Field.default`, Django follows this algorithm:\n \n * If the object's primary key attribute is set to a value that evaluates to\n   ``True`` (i.e., a value other than ``None`` or the empty string), Django\n@@ -475,6 +476,11 @@ follows this algorithm:\n   didn't update anything (e.g. if primary key is set to a value that doesn't\n   exist in the database), Django executes an ``INSERT``.\n \n+If the object's primary key attribute defines a\n+:attr:`~django.db.models.Field.default` then Django executes an ``UPDATE`` if\n+it is an existing model instance and primary key is set to a value that exists\n+in the database. Otherwise, Django executes an ``INSERT``.\n+\n The one gotcha here is that you should be careful not to specify a primary-key\n value explicitly when saving new objects, if you cannot guarantee the\n primary-key value is unused. For more on this nuance, see `Explicitly specifying\n@@ -490,6 +496,12 @@ which returns ``NULL``. In such cases it is possible to revert to the old\n algorithm by setting the :attr:`~django.db.models.Options.select_on_save`\n option to ``True``.\n \n+.. versionchanged:: 3.0\n+\n+    ``Model.save()`` no longer attempts to find a row when saving a new\n+    ``Model`` instance and a default value for the primary key is provided, and\n+    always executes an ``INSERT``.\n+\n .. _ref-models-force-insert:\n \n Forcing an INSERT or UPDATE\ndiff --git a/docs/releases/3.0.2.txt b/docs/releases/3.0.2.txt\nindex ebb85d1f46a7..e232fa81f8f2 100644\n--- a/docs/releases/3.0.2.txt\n+++ b/docs/releases/3.0.2.txt\n@@ -18,3 +18,7 @@ Bugfixes\n * Fixed a regression in Django 3.0 that caused a migration crash on PostgreSQL\n   10+ when adding a foreign key and changing data in the same migration\n   (:ticket:`31106`).\n+\n+* Fixed a regression in Django 3.0 where loading fixtures crashed for models\n+  defining a :attr:`~django.db.models.Field.default` for the primary key\n+  (:ticket:`31071`).\ndiff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt\nindex 435755f732a3..f133c58654b0 100644\n--- a/docs/releases/3.0.txt\n+++ b/docs/releases/3.0.txt\n@@ -372,6 +372,27 @@ Tests\n Backwards incompatible changes in 3.0\n =====================================\n \n+``Model.save()`` when providing a default for the primary key\n+-------------------------------------------------------------\n+\n+:meth:`.Model.save` no longer attempts to find a row when saving a new\n+``Model`` instance and a default value for the primary key is provided, and\n+always performs a single ``INSERT`` query. In older Django versions,\n+``Model.save()`` performed either an ``INSERT`` or an ``UPDATE`` based on\n+whether or not the row exists.\n+\n+This makes calling ``Model.save()`` while providing a default primary key value\n+equivalent to passing :ref:`force_insert=True <ref-models-force-insert>` to\n+model's ``save()``. Attempts to use a new ``Model`` instance to update an\n+existing row will result in an ``IntegrityError``.\n+\n+In order to update an existing model for a specific primary key value, use the\n+:meth:`~django.db.models.query.QuerySet.update_or_create` method or\n+``QuerySet.filter(pk=\u2026).update(\u2026)`` instead. For example::\n+\n+    >>> MyModel.objects.update_or_create(pk=existing_pk, defaults={'name': 'new name'})\n+    >>> MyModel.objects.filter(pk=existing_pk).update(name='new name')\n+\n Database backend API\n --------------------\n \ndiff --git a/tests/serializers/models/data.py b/tests/serializers/models/data.py\nindex 89564f756c5c..eaa2aa60e606 100644\n--- a/tests/serializers/models/data.py\n+++ b/tests/serializers/models/data.py\n@@ -4,6 +4,8 @@\n NULL values, where allowed.\n The basic idea is to have a model for each Django data type.\n \"\"\"\n+import uuid\n+\n from django.contrib.contenttypes.fields import (\n     GenericForeignKey, GenericRelation,\n )\n@@ -257,6 +259,10 @@ class UUIDData(models.Model):\n     data = models.UUIDField(primary_key=True)\n \n \n+class UUIDDefaultData(models.Model):\n+    data = models.UUIDField(primary_key=True, default=uuid.uuid4)\n+\n+\n class FKToUUID(models.Model):\n     data = models.ForeignKey(UUIDData, models.CASCADE)\n \ndiff --git a/tests/serializers/test_data.py b/tests/serializers/test_data.py\nindex 493da7e7cc5d..1ddba02565ce 100644\n--- a/tests/serializers/test_data.py\n+++ b/tests/serializers/test_data.py\n@@ -26,7 +26,7 @@\n     ModifyingSaveData, NullBooleanData, O2OData, PositiveBigIntegerData,\n     PositiveIntegerData, PositiveIntegerPKData, PositiveSmallIntegerData,\n     PositiveSmallIntegerPKData, SlugData, SlugPKData, SmallData, SmallPKData,\n-    Tag, TextData, TimeData, UniqueAnchor, UUIDData,\n+    Tag, TextData, TimeData, UniqueAnchor, UUIDData, UUIDDefaultData,\n )\n from .tests import register_tests\n \n@@ -351,6 +351,7 @@ def inherited_compare(testcase, pk, klass, data):\n     # (pk_obj, 790, XMLPKData, \"<foo></foo>\"),\n     (pk_obj, 791, UUIDData, uuid_obj),\n     (fk_obj, 792, FKToUUID, uuid_obj),\n+    (pk_obj, 793, UUIDDefaultData, uuid_obj),\n \n     (data_obj, 800, AutoNowDateTimeData, datetime.datetime(2006, 6, 16, 10, 42, 37)),\n     (data_obj, 810, ModifyingSaveData, 42),\n", "gold_standard_pr_link": "https://github.com/django/django/pull/12209"}