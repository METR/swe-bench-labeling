{"instance_id": "django__django-15128", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee37c..b7eaa65cd6 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -596,6 +596,14 @@ class Query(BaseExpression):\n         joinpromoter.add_votes(\n             j for j in self.alias_map if self.alias_map[j].join_type == INNER)\n         rhs_votes = set()\n+        \n+        # Pre-calculate all the aliases that will be used to ensure the change_map\n+        # doesn't have keys that intersect with values. This prevents the\n+        # AssertionError in change_aliases().\n+        # We need to ensure that any new aliases generated don't conflict with\n+        # aliases from rhs that haven't been processed yet.\n+        reserved_aliases = set(rhs.alias_map.keys())\n+        \n         # Now, add the joins from rhs query into the new query (skipping base\n         # table).\n         rhs_tables = list(rhs.alias_map)[1:]\n@@ -604,7 +612,41 @@ class Query(BaseExpression):\n             # If the left side of the join was already relabeled, use the\n             # updated alias.\n             join = join.relabeled_clone(change_map)\n+            \n+            # Store the current state to potentially generate a conflict-free alias\n+            if alias in reserved_aliases:\n+                current_alias_count = len(self.alias_map)\n+                \n             new_alias = self.join(join, reuse=reuse)\n+            \n+            # If we generated an alias that conflicts with a reserved alias,\n+            # we need to generate a new one that doesn't conflict\n+            if new_alias in reserved_aliases and new_alias != alias:\n+                # Generate a new alias that doesn't conflict\n+                table_name = join.table_name\n+                alias_list = self.table_map.get(table_name, [])\n+                # Remove the conflicting alias we just added\n+                if new_alias in alias_list:\n+                    alias_list.remove(new_alias)\n+                if new_alias in self.alias_map:\n+                    del self.alias_map[new_alias]\n+                    del self.alias_refcount[new_alias]\n+                \n+                # Generate a non-conflicting alias\n+                alias_num = current_alias_count + 1\n+                while True:\n+                    candidate = '%s%d' % (self.alias_prefix, alias_num)\n+                    if candidate not in self.alias_map and candidate not in reserved_aliases:\n+                        new_alias = candidate\n+                        break\n+                    alias_num += 1\n+                \n+                # Add the new non-conflicting alias\n+                alias_list.append(new_alias)\n+                self.alias_refcount[new_alias] = 1\n+                join.table_alias = new_alias\n+                self.alias_map[new_alias] = join\n+            \n             if join.join_type == INNER:\n                 rhs_votes.add(new_alias)\n             # We can't reuse the same join again in the query. If we have two\n@@ -619,6 +661,9 @@ class Query(BaseExpression):\n                 # unref the alias so that join promotion has information of\n                 # the join type for the unused alias.\n                 self.unref_alias(new_alias)\n+            \n+            # Remove processed alias from reserved set\n+            reserved_aliases.discard(alias)\n         joinpromoter.add_votes(rhs_votes)\n         joinpromoter.update_join_types(self)\n \ndiff --git a/fix_query.py b/fix_query.py\nnew file mode 100644\nindex 0000000000..41113a02a0\n--- /dev/null\n+++ b/fix_query.py\n@@ -0,0 +1,50 @@\n+\"\"\"\n+Fix for the Query.change_aliases AssertionError\n+\n+The issue is that when combining queries with OR (|), the alias generation can create\n+a change_map where keys intersect with values, causing the assertion to fail.\n+\n+The fix is to modify the combine method to ensure that newly generated aliases\n+don't conflict with any aliases from the rhs query.\n+\"\"\"\n+\n+def create_patch():\n+    # The fix needs to be in the combine method, around line 600\n+    # We need to collect all rhs aliases and ensure new aliases don't conflict\n+    \n+    patch = '''\n+# In Query.combine method, around line 600, we need to modify the alias generation logic\n+\n+# Original code:\n+#         rhs_tables = list(rhs.alias_map)[1:]\n+#         for alias in rhs_tables:\n+#             join = rhs.alias_map[alias]\n+#             # If the left side of the join was already relabeled, use the\n+#             # updated alias.\n+#             join = join.relabeled_clone(change_map)\n+#             new_alias = self.join(join, reuse=reuse)\n+\n+# Modified code:\n+        # Collect all rhs aliases to avoid conflicts\n+        rhs_aliases = set(rhs.alias_map.keys())\n+        \n+        rhs_tables = list(rhs.alias_map)[1:]\n+        for alias in rhs_tables:\n+            join = rhs.alias_map[alias]\n+            # If the left side of the join was already relabeled, use the\n+            # updated alias.\n+            join = join.relabeled_clone(change_map)\n+            \n+            # When creating a new alias, we need to ensure it doesn't conflict\n+            # with any remaining rhs aliases to avoid creating a change_map\n+            # where keys intersect with values\n+            new_alias = self.join(join, reuse=reuse, avoid_aliases=rhs_aliases)\n+            \n+            # Remove the current alias from the set of aliases to avoid\n+            # since it's now been processed\n+            rhs_aliases.discard(alias)\n+'''\n+    \n+    return patch\n+\n+print(create_patch())\ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..214cc0b989\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,36 @@\n+#!/usr/bin/env python\n+\"\"\"Debug script to understand the query alias generation issue\"\"\"\n+\n+# First, let's trace through the code that's failing\n+# According to the issue, the problem is in Query.combine() and Query.table_alias()\n+\n+# Let's create a minimal test case to debug the issue\n+def test_alias_generation():\n+    \"\"\"Test how aliases are generated during query combination\"\"\"\n+    \n+    # Simulate the problem:\n+    # 1. qs1 has a simple join (e.g., test_foo with qux_id = 1)\n+    # 2. qs2 has sequential aliases T4, T5 that correspond to tables already in qs1\n+    # 3. When combining qs1 | qs2, the join() method creates new aliases T5, T6\n+    # 4. This causes change_map = {'T4': 'T5', 'T5': 'T6'} where keys intersect values\n+    \n+    print(\"Understanding the problem:\")\n+    print(\"1. When combining qs1 | qs2:\")\n+    print(\"   - qs1 is the 'self' query\")\n+    print(\"   - qs2 is the 'rhs' query\")\n+    print(\"   - rhs aliases are added to self via join()\")\n+    print(\"   - If rhs has aliases T4, T5 and self already has those table names,\")\n+    print(\"     new aliases T5, T6 are created\")\n+    print(\"   - This creates change_map = {'T4': 'T5', 'T5': 'T6'}\")\n+    print(\"   - The assertion fails because T5 appears in both keys and values\")\n+    print()\n+    \n+    # The fix should ensure that new aliases don't conflict with existing rhs aliases\n+    print(\"Solution approach:\")\n+    print(\"1. When generating new aliases in table_alias(), check both:\")\n+    print(\"   - self.alias_map (current implementation)\")\n+    print(\"   - rhs.alias_map (missing - needs to be passed through)\")\n+    print(\"2. Keep incrementing the suffix until no conflict exists\")\n+\n+if __name__ == \"__main__\":\n+    test_alias_generation()\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..af5ad7f937\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,116 @@\n+#!/usr/bin/env python\n+\"\"\"Test edge cases for the alias conflict fix\"\"\"\n+import os\n+import django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes'],\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import Q\n+\n+# Drop tables\n+with connection.cursor() as cursor:\n+    for table in ['test_a', 'test_b', 'test_c', 'test_d', 'test_e']:\n+        cursor.execute(f\"DROP TABLE IF EXISTS {table}\")\n+\n+# Define simple models for testing\n+class A(models.Model):\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_a'\n+\n+class B(models.Model):\n+    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name='bs')\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_b'\n+\n+class C(models.Model):\n+    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name='cs')\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_c'\n+\n+class D(models.Model):\n+    c = models.ForeignKey(C, on_delete=models.CASCADE, related_name='ds')\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_d'\n+\n+class E(models.Model):\n+    d = models.ForeignKey(D, on_delete=models.CASCADE, related_name='es')\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_e'\n+\n+# Create tables\n+with connection.schema_editor() as editor:\n+    editor.create_model(A)\n+    editor.create_model(B)\n+    editor.create_model(C)\n+    editor.create_model(D)\n+    editor.create_model(E)\n+\n+print(\"Testing edge cases for alias conflicts...\")\n+\n+# Test 1: Long chain of joins\n+print(\"\\n1. Testing long chain of joins\")\n+a = A.objects.create()\n+b = B.objects.create(a=a)\n+c = C.objects.create(b=b)\n+d = D.objects.create(c=c)\n+e = E.objects.create(d=d)\n+\n+qs1 = A.objects.filter(bs__cs__ds__es=e)\n+qs2 = A.objects.filter(pk=a.pk)\n+\n+print(f\"qs1 aliases: {list(qs1.query.alias_map.keys())}\")\n+print(f\"qs2 aliases: {list(qs2.query.alias_map.keys())}\")\n+\n+try:\n+    result = qs1 | qs2\n+    print(\"\u2713 qs1 | qs2 succeeded\")\n+except AssertionError as ex:\n+    print(f\"\u2717 qs1 | qs2 failed: {ex}\")\n+\n+try:\n+    result = qs2 | qs1\n+    print(\"\u2713 qs2 | qs1 succeeded\")\n+except AssertionError as ex:\n+    print(f\"\u2717 qs2 | qs1 failed: {ex}\")\n+\n+# Test 2: Multiple OR conditions with overlapping joins\n+print(\"\\n2. Testing multiple OR conditions\")\n+qs3 = A.objects.filter(Q(bs__cs__ds=d) | Q(bs__cs__b__a=a))\n+qs4 = A.objects.filter(bs__a=a)\n+\n+print(f\"qs3 aliases: {list(qs3.query.alias_map.keys())}\")\n+print(f\"qs4 aliases: {list(qs4.query.alias_map.keys())}\")\n+\n+try:\n+    result = qs3 | qs4\n+    print(\"\u2713 qs3 | qs4 succeeded\")\n+except AssertionError as ex:\n+    print(f\"\u2717 qs3 | qs4 failed: {ex}\")\n+\n+try:\n+    result = qs4 | qs3\n+    print(\"\u2713 qs4 | qs3 succeeded\")\n+except AssertionError as ex:\n+    print(f\"\u2717 qs4 | qs3 failed: {ex}\")\n+\n+print(\"\\nAll edge case tests completed!\")\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..38cb942b08\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,101 @@\n+#!/usr/bin/env python\n+import os\n+import django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+from django.conf import settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+# Import after setup\n+from django.db import models, connection\n+from django.db.models import Q\n+\n+# Drop and recreate tables\n+with connection.cursor() as cursor:\n+    cursor.execute(\"DROP TABLE IF EXISTS test_qux_bazes\")\n+    cursor.execute(\"DROP TABLE IF EXISTS test_bar\") \n+    cursor.execute(\"DROP TABLE IF EXISTS test_foo\")\n+    cursor.execute(\"DROP TABLE IF EXISTS test_qux\")\n+    cursor.execute(\"DROP TABLE IF EXISTS test_baz\")\n+\n+# Define models\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_foo'\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_bar'\n+\n+class Baz(models.Model):\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_baz'\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\", db_table='test_qux_bazes')\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_qux'\n+\n+# Create tables\n+with connection.schema_editor() as editor:\n+    editor.create_model(Baz)\n+    editor.create_model(Qux)\n+    editor.create_model(Foo)\n+    editor.create_model(Bar)\n+    # M2M table is created automatically by Django\n+\n+# Test the issue\n+print(\"Creating test data...\")\n+qux = Qux.objects.create()\n+\n+print(\"\\nCreating querysets...\")\n+qs1 = qux.foos.all()\n+print(f\"qs1 aliases: {list(qs1.query.alias_map.keys())}\")\n+\n+qs2 = Foo.objects.filter(\n+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())\n+)\n+print(f\"qs2 aliases: {list(qs2.query.alias_map.keys())}\")\n+\n+print(\"\\nTrying qs2 | qs1 (should work)...\")\n+try:\n+    result = qs2 | qs1\n+    print(f\"\u2713 Success! Aliases: {list(result.query.alias_map.keys())}\")\n+except AssertionError as e:\n+    print(f\"\u2717 Failed: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\nTrying qs1 | qs2 (the failing case)...\")\n+try:\n+    result = qs1 | qs2\n+    print(f\"\u2713 Success! Aliases: {list(result.query.alias_map.keys())}\")\n+except AssertionError as e:\n+    print(f\"\u2717 Failed: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\nTest completed!\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..0d713241bb\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,107 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Setup Django\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'test_settings')\n+\n+# Configure settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+# Create test app models\n+from django.db import models\n+\n+# Define models\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_foo'\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_bar'\n+\n+class Baz(models.Model):\n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_baz'\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\")\n+    \n+    class Meta:\n+        app_label = 'contenttypes'\n+        db_table = 'test_qux'\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Qux)\n+    schema_editor.create_model(Baz)\n+    schema_editor.create_model(Foo)\n+    schema_editor.create_model(Bar)\n+    # Create the M2M table\n+    field = Qux._meta.get_field('bazes')\n+    schema_editor.create_model(field.remote_field.through)\n+\n+# Run the failing test\n+from django.db.models import Q\n+\n+print(\"Creating test data...\")\n+qux = Qux.objects.create()\n+print(\"Qux created:\", qux.id)\n+\n+print(\"\\nCreating querysets...\")\n+qs1 = qux.foos.all()\n+print(\"qs1 query:\", str(qs1.query))\n+print(\"qs1 aliases:\", list(qs1.query.alias_map.keys()))\n+\n+qs2 = Foo.objects.filter(\n+    Q(bars__baz__in=qux.bazes.all()) | Q(other_bars__baz__in=qux.bazes.all())\n+)\n+print(\"\\nqs2 query:\", str(qs2.query))\n+print(\"qs2 aliases:\", list(qs2.query.alias_map.keys()))\n+\n+print(\"\\nTrying qs2 | qs1 (works)...\")\n+try:\n+    result = qs2 | qs1\n+    print(\"Success! Query:\", str(result.query))\n+    print(\"Result aliases:\", list(result.query.alias_map.keys()))\n+except AssertionError as e:\n+    print(\"AssertionError:\", e)\n+    import traceback\n+    traceback.print_exc()\n+\n+print(\"\\nTrying qs1 | qs2 (fails)...\")\n+try:\n+    result = qs1 | qs2\n+    print(\"Success! Query:\", str(result.query))\n+    print(\"Result aliases:\", list(result.query.alias_map.keys()))\n+except AssertionError as e:\n+    print(\"AssertionError:\", e)\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_models.py b/test_models.py\nnew file mode 100644\nindex 0000000000..95942bae31\n--- /dev/null\n+++ b/test_models.py\n@@ -0,0 +1,26 @@\n+from django.db import models\n+\n+# Define models\n+class Foo(models.Model):\n+    qux = models.ForeignKey(\"Qux\", on_delete=models.CASCADE, related_name=\"foos\")\n+    \n+    class Meta:\n+        db_table = 'test_foo'\n+\n+class Bar(models.Model):\n+    foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"bars\")\n+    another_foo = models.ForeignKey(\"Foo\", on_delete=models.CASCADE, related_name=\"other_bars\")\n+    baz = models.ForeignKey(\"Baz\", on_delete=models.CASCADE, related_name=\"bars\")\n+    \n+    class Meta:\n+        db_table = 'test_bar'\n+\n+class Baz(models.Model):\n+    class Meta:\n+        db_table = 'test_baz'\n+\n+class Qux(models.Model):\n+    bazes = models.ManyToManyField(\"Baz\", related_name=\"quxes\", db_table='test_qux_bazes')\n+    \n+    class Meta:\n+        db_table = 'test_qux'\n", "gold_standard_diff": "From f1bfdff6907e093ea6ce12e775f93add349adde7 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=C3=96mer=20Faruk=20Abac=C4=B1?= <omerfabaci@gmail.com>\nDate: Wed, 8 Dec 2021 10:11:12 +0100\nSubject: [PATCH 1/3] Refs #33319 -- Added comment about keys/values assertion\n in Query.change_aliases().\n\n---\n django/db/models/sql/query.py | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex aaf35ee37c5c..fe8ac873b1fa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -846,6 +846,9 @@ def change_aliases(self, change_map):\n         relabelling any references to them in select columns and the where\n         clause.\n         \"\"\"\n+        # If keys and values of change_map were to intersect, an alias might be\n+        # updated twice (e.g. T4 -> T5, T5 -> T6, so also T4 -> T6) depending\n+        # on their order in change_map.\n         assert set(change_map).isdisjoint(change_map.values())\n \n         # 1. Update references in \"select\" (normal columns plus aliases),\n\nFrom f04b44bad40369ec2df74b16adb4d3f09350e4b2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=C3=96mer=20Faruk=20Abac=C4=B1?= <omerfabaci@gmail.com>\nDate: Wed, 8 Dec 2021 10:19:07 +0100\nSubject: [PATCH 2/3] Refs #33319 -- Added note about commutation of QuerySet's\n | operator.\n\n---\n docs/ref/models/querysets.txt | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/docs/ref/models/querysets.txt b/docs/ref/models/querysets.txt\nindex b2bf5baf9006..51aa7184b6d6 100644\n--- a/docs/ref/models/querysets.txt\n+++ b/docs/ref/models/querysets.txt\n@@ -1898,6 +1898,9 @@ SQL equivalent:\n \n     SELECT ... WHERE x=1 OR y=2\n \n+``|`` is not a commutative operation, as different (though equivalent) queries\n+may be generated.\n+\n Methods that do not return ``QuerySet``\\s\n -----------------------------------------\n \n\nFrom 81739a45b5ae8f534910aaabc7e9b457eaa34163 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=C3=96mer=20Faruk=20Abac=C4=B1?= <omerfabaci@gmail.com>\nDate: Tue, 30 Nov 2021 16:50:13 +0300\nSubject: [PATCH 3/3] Fixed #33319 -- Fixed crash when combining with the |\n operator querysets with aliases that conflict.\n\n---\n AUTHORS                       |  1 +\n django/db/models/sql/query.py | 25 +++++++++++++++++--------\n tests/queries/models.py       |  3 ++-\n tests/queries/tests.py        | 22 +++++++++++++++++++++-\n 4 files changed, 41 insertions(+), 10 deletions(-)\n\ndiff --git a/AUTHORS b/AUTHORS\nindex 738c0a04c226..e13d13d4aea3 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -731,6 +731,7 @@ answer newbie questions, and generally made Django that much better:\n     Oscar Ramirez <tuxskar@gmail.com>\n     Ossama M. Khayat <okhayat@yahoo.com>\n     Owen Griffiths\n+    \u00d6mer Faruk Abac\u0131 <https://github.com/omerfarukabaci/>\n     Pablo Mart\u00edn <goinnn@gmail.com>\n     Panos Laganakos <panos.laganakos@gmail.com>\n     Paolo Melchiorre <paolo@melchiorre.org>\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex fe8ac873b1fa..b13c7b689323 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -572,6 +572,15 @@ def combine(self, rhs, connector):\n         if self.distinct_fields != rhs.distinct_fields:\n             raise TypeError('Cannot combine queries with different distinct fields.')\n \n+        # If lhs and rhs shares the same alias prefix, it is possible to have\n+        # conflicting alias changes like T4 -> T5, T5 -> T6, which might end up\n+        # as T4 -> T6 while combining two querysets. To prevent this, change an\n+        # alias prefix of the rhs and update current aliases accordingly,\n+        # except if the alias is the base table since it must be present in the\n+        # query on both sides.\n+        initial_alias = self.get_initial_alias()\n+        rhs.bump_prefix(self, exclude={initial_alias})\n+\n         # Work out how to relabel the rhs aliases, if necessary.\n         change_map = {}\n         conjunction = (connector == AND)\n@@ -589,9 +598,6 @@ def combine(self, rhs, connector):\n         # the AND case. The results will be correct but this creates too many\n         # joins. This is something that could be fixed later on.\n         reuse = set() if conjunction else set(self.alias_map)\n-        # Base table must be present in the query - this is the same\n-        # table on both sides.\n-        self.get_initial_alias()\n         joinpromoter = JoinPromoter(connector, 2, False)\n         joinpromoter.add_votes(\n             j for j in self.alias_map if self.alias_map[j].join_type == INNER)\n@@ -882,12 +888,12 @@ def change_aliases(self, change_map):\n             for alias, aliased in self.external_aliases.items()\n         }\n \n-    def bump_prefix(self, outer_query):\n+    def bump_prefix(self, other_query, exclude=None):\n         \"\"\"\n         Change the alias prefix to the next letter in the alphabet in a way\n-        that the outer query's aliases and this query's aliases will not\n+        that the other query's aliases and this query's aliases will not\n         conflict. Even tables that previously had no alias will get an alias\n-        after this call.\n+        after this call. To prevent changing aliases use the exclude parameter.\n         \"\"\"\n         def prefix_gen():\n             \"\"\"\n@@ -907,7 +913,7 @@ def prefix_gen():\n                     yield ''.join(s)\n                 prefix = None\n \n-        if self.alias_prefix != outer_query.alias_prefix:\n+        if self.alias_prefix != other_query.alias_prefix:\n             # No clashes between self and outer query should be possible.\n             return\n \n@@ -925,10 +931,13 @@ def prefix_gen():\n                     'Maximum recursion depth exceeded: too many subqueries.'\n                 )\n         self.subq_aliases = self.subq_aliases.union([self.alias_prefix])\n-        outer_query.subq_aliases = outer_query.subq_aliases.union(self.subq_aliases)\n+        other_query.subq_aliases = other_query.subq_aliases.union(self.subq_aliases)\n+        if exclude is None:\n+            exclude = {}\n         self.change_aliases({\n             alias: '%s%d' % (self.alias_prefix, pos)\n             for pos, alias in enumerate(self.alias_map)\n+            if alias not in exclude\n         })\n \n     def get_initial_alias(self):\ndiff --git a/tests/queries/models.py b/tests/queries/models.py\nindex c3322c224e77..8e7ee1625ce9 100644\n--- a/tests/queries/models.py\n+++ b/tests/queries/models.py\n@@ -613,13 +613,14 @@ def __str__(self):\n \n \n class BaseUser(models.Model):\n-    pass\n+    annotation = models.ForeignKey(Annotation, models.CASCADE, null=True, blank=True)\n \n \n class Task(models.Model):\n     title = models.CharField(max_length=10)\n     owner = models.ForeignKey(BaseUser, models.CASCADE, related_name='owner')\n     creator = models.ForeignKey(BaseUser, models.CASCADE, related_name='creator')\n+    note = models.ForeignKey(Note, on_delete=models.CASCADE, null=True, blank=True)\n \n     def __str__(self):\n         return self.title\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex ca982b9c6a32..f146bc89fd67 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -15,7 +15,7 @@\n from django.test.utils import CaptureQueriesContext\n \n from .models import (\n-    FK1, Annotation, Article, Author, BaseA, Book, CategoryItem,\n+    FK1, Annotation, Article, Author, BaseA, BaseUser, Book, CategoryItem,\n     CategoryRelationship, Celebrity, Channel, Chapter, Child, ChildObjectA,\n     Classroom, CommonMixedCaseForeignKeys, Company, Cover, CustomPk,\n     CustomPkTag, DateTimePK, Detail, DumbCategory, Eaten, Employment,\n@@ -2094,6 +2094,15 @@ def setUpTestData(cls):\n         cls.room_2 = Classroom.objects.create(school=cls.school, has_blackboard=True, name='Room 2')\n         cls.room_3 = Classroom.objects.create(school=cls.school, has_blackboard=True, name='Room 3')\n         cls.room_4 = Classroom.objects.create(school=cls.school, has_blackboard=False, name='Room 4')\n+        tag = Tag.objects.create()\n+        cls.annotation_1 = Annotation.objects.create(tag=tag)\n+        annotation_2 = Annotation.objects.create(tag=tag)\n+        note = cls.annotation_1.notes.create(tag=tag)\n+        cls.base_user_1 = BaseUser.objects.create(annotation=cls.annotation_1)\n+        cls.base_user_2 = BaseUser.objects.create(annotation=annotation_2)\n+        cls.task = Task.objects.create(\n+            owner=cls.base_user_2, creator=cls.base_user_2, note=note,\n+        )\n \n     @skipUnlessDBFeature('allow_sliced_subqueries_with_in')\n     def test_or_with_rhs_slice(self):\n@@ -2130,6 +2139,17 @@ def test_subquery_aliases(self):\n         nested_combined = School.objects.filter(pk__in=combined.values('pk'))\n         self.assertSequenceEqual(nested_combined, [self.school])\n \n+    def test_conflicting_aliases_during_combine(self):\n+        qs1 = self.annotation_1.baseuser_set.all()\n+        qs2 = BaseUser.objects.filter(\n+            Q(owner__note__in=self.annotation_1.notes.all()) |\n+            Q(creator__note__in=self.annotation_1.notes.all())\n+        )\n+        self.assertSequenceEqual(qs1, [self.base_user_1])\n+        self.assertSequenceEqual(qs2, [self.base_user_2])\n+        self.assertCountEqual(qs2 | qs1, qs1 | qs2)\n+        self.assertCountEqual(qs2 | qs1, [self.base_user_1, self.base_user_2])\n+\n \n class CloneTests(TestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/15128"}