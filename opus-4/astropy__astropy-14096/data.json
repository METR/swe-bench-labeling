{"instance_id": "astropy__astropy-14096", "score": "I", "diff": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..d439028d27 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -894,7 +894,21 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Check if the attribute exists as a descriptor (e.g., property) on the class.\n+        # If it does, then __getattr__ is being called because the descriptor raised\n+        # an AttributeError. We should provide a more informative error message.\n+        for cls in type(self).__mro__:\n+            if attr in cls.__dict__:\n+                descriptor = cls.__dict__[attr]\n+                if hasattr(descriptor, '__get__'):\n+                    # This is a descriptor. Since __getattr__ was called, it means\n+                    # the descriptor raised an AttributeError. Don't say the descriptor\n+                    # doesn't exist.\n+                    raise AttributeError(\n+                        f\"'{self.__class__.__name__}' property '{attr}' raised an AttributeError\"\n+                    )\n+        \n+        # Fail - the attribute truly doesn't exist\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 486d6b9b3b..1c5f74f3a1 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -1,5 +1,5 @@\n [build-system]\n-requires = [\"setuptools\",\n+requires = [\"setuptools==68.0.0\",\n             \"setuptools_scm>=6.2\",\n             \"wheel\",\n             \"cython==0.29.30\",\ndiff --git a/test_context.py b/test_context.py\nnew file mode 100644\nindex 0000000000..dadae6c554\n--- /dev/null\n+++ b/test_context.py\n@@ -0,0 +1,65 @@\n+import threading\n+\n+# Thread-local storage to track attribute access context\n+_attr_context = threading.local()\n+\n+class Base:\n+    def __getattr__(self, attr):\n+        # Check if we're in a nested attribute access\n+        context = getattr(_attr_context, 'stack', None)\n+        if context is None:\n+            _attr_context.stack = []\n+            context = _attr_context.stack\n+            \n+        # If this attribute exists as a descriptor, we're being called\n+        # because the descriptor raised AttributeError\n+        for cls in type(self).__mro__:\n+            if attr in cls.__dict__ and hasattr(cls.__dict__[attr], '__get__'):\n+                # Don't add to context, let the original error through\n+                if context:\n+                    # We're in a nested access, raise about the nested attribute\n+                    nested_attr = context[-1]\n+                    raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{nested_attr}'\")\n+                else:\n+                    # First level access of a property that failed\n+                    raise AttributeError(f\"'{self.__class__.__name__}' object property '{attr}' raised AttributeError\")\n+        \n+        # Regular attribute access failure\n+        context.append(attr)\n+        try:\n+            raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{attr}'\")\n+        finally:\n+            context.pop()\n+            if not context:\n+                delattr(_attr_context, 'stack')\n+\n+\n+class Test(Base):\n+    @property\n+    def prop(self):\n+        return self.nested_attr\n+        \n+    @property\n+    def working_prop(self):\n+        return \"works\"\n+\n+\n+t = Test()\n+\n+print(\"Test 1: Working property\")\n+try:\n+    print(t.working_prop)\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\n+\n+print(\"\\nTest 2: Property that accesses non-existent attribute\")  \n+try:\n+    print(t.prop)\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\n+    \n+print(\"\\nTest 3: Direct non-existent attribute\")\n+try:\n+    print(t.direct_missing)\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\ndiff --git a/test_debug.py b/test_debug.py\nnew file mode 100644\nindex 0000000000..1aaea499d1\n--- /dev/null\n+++ b/test_debug.py\n@@ -0,0 +1,44 @@\n+import astropy.coordinates as coord\n+import sys\n+\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        print(\"Inside prop getter\")\n+        return self.random_attr\n+    \n+    @property  \n+    def existing_prop(self):\n+        print(\"Inside existing_prop getter\")\n+        return \"test\"\n+        \n+    def __getattr__(self, attr):\n+        print(f\"__getattr__ called with attr={attr}\")\n+        print(f\"sys.exc_info(): {sys.exc_info()}\")\n+        return super().__getattr__(attr)\n+\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+\n+# Test 1: accessing an existing property that works\n+print(\"Test 1: accessing existing property\")\n+try:\n+    result = c.existing_prop\n+    print(f\"Result: {result}\")\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\n+\n+# Test 2: accessing a property that tries to access a non-existent attribute\n+print(\"\\nTest 2: accessing property that accesses non-existent attribute\")\n+try:\n+    result = c.prop\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\n+\n+# Test 3: accessing a non-existent attribute directly  \n+print(\"\\nTest 3: accessing non-existent attribute directly\")\n+try:\n+    result = c.nonexistent_attr\n+except AttributeError as e:\n+    print(f\"Error: {e}\")\ndiff --git a/test_error_msg.py b/test_error_msg.py\nnew file mode 100644\nindex 0000000000..360d14fd6f\n--- /dev/null\n+++ b/test_error_msg.py\n@@ -0,0 +1,23 @@\n+import astropy.coordinates as coord\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        return self.random_attr\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+\n+# Just catch the error message\n+try:\n+    c.prop\n+except AttributeError as e:\n+    print(f\"Error message only: '{e}'\")\n+    print(f\"Expected: 'custom_coord' object has no attribute 'random_attr'\")\n+    \n+# Now let's see the full traceback\n+print(\"\\nFull traceback:\")\n+try:\n+    c.prop\n+except AttributeError:\n+    import traceback\n+    traceback.print_exc()\ndiff --git a/test_full_traceback.py b/test_full_traceback.py\nnew file mode 100644\nindex 0000000000..c1613a3b24\n--- /dev/null\n+++ b/test_full_traceback.py\n@@ -0,0 +1,13 @@\n+import astropy.coordinates as coord\n+import traceback\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        return self.random_attr\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+try:\n+    c.prop\n+except AttributeError:\n+    traceback.print_exc()\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..9b0535e654\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,16 @@\n+import astropy.coordinates as coord\n+\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        return self.random_attr\n+\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+try:\n+    c.prop\n+except AttributeError as e:\n+    print(f\"Error message: {e}\")\n+    print(f\"Expected: 'custom_coord' object has no attribute 'random_attr'\")\n+    print(f\"Actual: {e}\")\ndiff --git a/test_traceback.py b/test_traceback.py\nnew file mode 100644\nindex 0000000000..f1e83aa2a5\n--- /dev/null\n+++ b/test_traceback.py\n@@ -0,0 +1,22 @@\n+import astropy.coordinates as coord\n+import traceback\n+import sys\n+\n+class custom_coord(coord.SkyCoord):\n+    @property\n+    def prop(self):\n+        print(\"Inside prop getter\")\n+        try:\n+            return self.random_attr\n+        except AttributeError:\n+            print(\"AttributeError caught in prop getter\")\n+            traceback.print_exc()\n+            raise\n+\n+c = custom_coord('00h42m30s', '+41d12m00s', frame='icrs')\n+try:\n+    c.prop\n+except AttributeError as e:\n+    print(f\"\\nFinal error message: {e}\")\n+    print(\"\\nFull traceback:\")\n+    traceback.print_exc()\n", "gold_standard_diff": "From 271b2875d9aae0a5875acba0b1b27dc4885fd6e5 Mon Sep 17 00:00:00 2001\nFrom: Marten van Kerkwijk <mhvk@astro.utoronto.ca>\nDate: Sun, 4 Dec 2022 12:00:28 -0500\nSubject: [PATCH] Ensure SkyCoord attribute errors are generated correctly.\n\n---\n astropy/coordinates/sky_coordinate.py       |  6 ++----\n astropy/coordinates/tests/test_sky_coord.py | 18 ++++++++++++++++++\n 2 files changed, 20 insertions(+), 4 deletions(-)\n\ndiff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d29..a4257c302ae0 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -894,10 +894,8 @@ def __getattr__(self, attr):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n-        raise AttributeError(\n-            f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n-        )\n+        # Call __getattribute__; this will give correct exception.\n+        return self.__getattribute__(attr)\n \n     def __setattr__(self, attr, val):\n         # This is to make anything available through __getattr__ immutable\ndiff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py\nindex 4dcfba0d4d3c..8aad97adf4c0 100644\n--- a/astropy/coordinates/tests/test_sky_coord.py\n+++ b/astropy/coordinates/tests/test_sky_coord.py\n@@ -2165,3 +2165,21 @@ def test_match_to_catalog_3d_and_sky():\n     npt.assert_array_equal(idx, [0, 1, 2, 3])\n     assert_allclose(angle, 0 * u.deg, atol=1e-14 * u.deg, rtol=0)\n     assert_allclose(distance, 0 * u.kpc, atol=1e-14 * u.kpc, rtol=0)\n+\n+\n+def test_subclass_property_exception_error():\n+    \"\"\"Regression test for gh-8340.\n+\n+    Non-existing attribute access inside a property should give attribute\n+    error for the attribute, not for the property.\n+    \"\"\"\n+\n+    class custom_coord(SkyCoord):\n+        @property\n+        def prop(self):\n+            return self.random_attr\n+\n+    c = custom_coord(\"00h42m30s\", \"+41d12m00s\", frame=\"icrs\")\n+    with pytest.raises(AttributeError, match=\"random_attr\"):\n+        # Before this matched \"prop\" rather than \"random_attr\"\n+        c.prop\n", "gold_standard_pr_link": "https://github.com/astropy/astropy/pull/14096"}