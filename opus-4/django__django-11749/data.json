{"instance_id": "django__django-11749", "score": "I", "diff": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 5f2e64761e..edc38eed47 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -136,6 +136,27 @@ def call_command(command_name, *args, **options):\n         '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])\n         for opt in parser_actions if opt.required and opt.dest in options\n     ]\n+    # Also check for mutually exclusive groups\n+    # For mutually exclusive groups, we need to add ALL provided options to parse_args\n+    # so that argparse can validate mutual exclusivity\n+    def get_mutually_exclusive_groups(parser):\n+        # Get mutually exclusive groups from parser and subparsers\n+        for group in parser._mutually_exclusive_groups:\n+            yield group\n+        for action in parser._actions:\n+            if isinstance(action, _SubParsersAction):\n+                for subparser in action.choices.values():\n+                    yield from get_mutually_exclusive_groups(subparser)\n+    \n+    for group in get_mutually_exclusive_groups(parser):\n+        # Regardless of whether the group is required, we need to pass all\n+        # provided options from the group to ensure proper validation\n+        for action in group._group_actions:\n+            if action.dest in options and action.option_strings:\n+                # Add this argument to parse_args if not already added\n+                arg_str = '{}={}'.format(min(action.option_strings), arg_options[action.dest])\n+                if arg_str not in parse_args:\n+                    parse_args.append(arg_str)\n     defaults = parser.parse_args(args=parse_args)\n     defaults = dict(defaults._get_kwargs(), **arg_options)\n     # Raise an error if any unknown options were passed.\ndiff --git a/test_boolean_args.py b/test_boolean_args.py\nnew file mode 100644\nindex 0000000000..e26a550f9c\n--- /dev/null\n+++ b/test_boolean_args.py\n@@ -0,0 +1,43 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    INSTALLED_APPS=[],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+from django.core.management.base import BaseCommand\n+from django.core.management import call_command\n+\n+class TestCommand(BaseCommand):\n+    def add_arguments(self, parser):\n+        parser.add_argument('--verbose', action='store_true')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Verbose: {options.get('verbose')}\")\n+\n+# Test with boolean flag\n+print(\"Testing boolean flag with positional argument:\")\n+try:\n+    cmd = TestCommand()\n+    call_command(cmd, '--verbose')\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\nTesting boolean flag with keyword argument:\")\n+try:\n+    cmd = TestCommand()\n+    call_command(cmd, verbose=True)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..a347eaf35a\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,132 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings with no apps\n+settings.configure(\n+    DEBUG=True,\n+    INSTALLED_APPS=[],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+# Create test commands\n+from django.core.management.base import BaseCommand\n+from django.core.management import call_command\n+\n+class TestCommand1(BaseCommand):\n+    \"\"\"Test command with a required mutually exclusive group\"\"\"\n+    def add_arguments(self, parser):\n+        shop = parser.add_mutually_exclusive_group(required=True)\n+        shop.add_argument('--shop-id', nargs='?', type=int, default=None, dest='shop_id')\n+        shop.add_argument('--shop', nargs='?', type=str, default=None, dest='shop_name')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Shop ID: {options.get('shop_id')}, Shop Name: {options.get('shop_name')}\")\n+\n+class TestCommand2(BaseCommand):\n+    \"\"\"Test command with a non-required mutually exclusive group\"\"\"\n+    def add_arguments(self, parser):\n+        shop = parser.add_mutually_exclusive_group(required=False)\n+        shop.add_argument('--shop-id', nargs='?', type=int, default=None, dest='shop_id')\n+        shop.add_argument('--shop', nargs='?', type=str, default=None, dest='shop_name')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Shop ID: {options.get('shop_id')}, Shop Name: {options.get('shop_name')}\")\n+\n+class TestCommand3(BaseCommand):\n+    \"\"\"Test command with multiple mutually exclusive groups\"\"\"\n+    def add_arguments(self, parser):\n+        shop = parser.add_mutually_exclusive_group(required=True)\n+        shop.add_argument('--shop-id', type=int, dest='shop_id')\n+        shop.add_argument('--shop', type=str, dest='shop_name')\n+        \n+        format_group = parser.add_mutually_exclusive_group(required=False)\n+        format_group.add_argument('--json', action='store_true')\n+        format_group.add_argument('--xml', action='store_true')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Shop ID: {options.get('shop_id')}, Shop Name: {options.get('shop_name')}\")\n+        print(f\"JSON: {options.get('json')}, XML: {options.get('xml')}\")\n+\n+# Test cases\n+print(\"=== Test 1: Required mutually exclusive group ===\")\n+print(\"1a. With --shop-id positional argument:\")\n+try:\n+    cmd = TestCommand1()\n+    call_command(cmd, '--shop-id=1')\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n1b. With shop_id keyword argument:\")\n+try:\n+    cmd = TestCommand1()\n+    call_command(cmd, shop_id=1)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n1c. With shop_name keyword argument:\")\n+try:\n+    cmd = TestCommand1()\n+    call_command(cmd, shop_name='MyShop')\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n1d. With no arguments (should fail):\")\n+try:\n+    cmd = TestCommand1()\n+    call_command(cmd)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n=== Test 2: Non-required mutually exclusive group ===\")\n+print(\"2a. With no arguments (should work):\")\n+try:\n+    cmd = TestCommand2()\n+    call_command(cmd)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n2b. With shop_id keyword argument:\")\n+try:\n+    cmd = TestCommand2()\n+    call_command(cmd, shop_id=2)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n=== Test 3: Multiple mutually exclusive groups ===\")\n+print(\"3a. With shop_id and json:\")\n+try:\n+    cmd = TestCommand3()\n+    call_command(cmd, shop_id=3, json=True)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n3b. With shop_name and xml:\")\n+try:\n+    cmd = TestCommand3()\n+    call_command(cmd, shop_name='TestShop', xml=True)\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\n3c. With conflicting options (should fail):\")\n+try:\n+    cmd = TestCommand3()\n+    call_command(cmd, shop_id=3, shop_name='TestShop')\n+    print(\"Success\")\n+except Exception as e:\n+    print(f\"Failed: {e}\")\ndiff --git a/test_conflict.py b/test_conflict.py\nnew file mode 100644\nindex 0000000000..b91a3a4a1e\n--- /dev/null\n+++ b/test_conflict.py\n@@ -0,0 +1,47 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    INSTALLED_APPS=[],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+from django.core.management.base import BaseCommand\n+from django.core.management import call_command\n+\n+class TestCommand(BaseCommand):\n+    def add_arguments(self, parser):\n+        shop = parser.add_mutually_exclusive_group(required=True)\n+        shop.add_argument('--shop-id', type=int, dest='shop_id')\n+        shop.add_argument('--shop', type=str, dest='shop_name')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Shop ID: {options.get('shop_id')}, Shop Name: {options.get('shop_name')}\")\n+\n+# Test with conflicting options\n+print(\"Testing with conflicting mutually exclusive options:\")\n+try:\n+    cmd = TestCommand()\n+    # This should fail because we're providing both options from a mutually exclusive group\n+    call_command(cmd, shop_id=3, shop_name='TestShop')\n+    print(\"Unexpectedly succeeded!\")\n+except Exception as e:\n+    print(f\"Failed as expected: {e}\")\n+\n+# Let's also test with positional args to see if argparse catches it\n+print(\"\\nTesting with positional args:\")\n+try:\n+    cmd = TestCommand()\n+    call_command(cmd, '--shop-id=3', '--shop=TestShop')\n+    print(\"Unexpectedly succeeded!\")\n+except Exception as e:\n+    print(f\"Failed as expected: {e}\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..d22ccdd607\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,49 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings with no apps\n+settings.configure(\n+    DEBUG=True,\n+    INSTALLED_APPS=[],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    }\n+)\n+django.setup()\n+\n+# Create a test command directly\n+from django.core.management.base import BaseCommand\n+from django.core.management import call_command\n+\n+class TestCommand(BaseCommand):\n+    def add_arguments(self, parser):\n+        shop = parser.add_mutually_exclusive_group(required=True)\n+        shop.add_argument('--shop-id', nargs='?', type=int, default=None, dest='shop_id')\n+        shop.add_argument('--shop', nargs='?', type=str, default=None, dest='shop_name')\n+        \n+    def handle(self, *args, **options):\n+        print(f\"Shop ID: {options.get('shop_id')}\")\n+        print(f\"Shop Name: {options.get('shop_name')}\")\n+        print(\"Command executed successfully!\")\n+\n+# Test the issue\n+print(\"Test 1: Calling with --shop-id as positional argument (should work)\")\n+try:\n+    cmd = TestCommand()\n+    call_command(cmd, '--shop-id=1')\n+    print(\"Success\\n\")\n+except Exception as e:\n+    print(f\"Failed: {e}\\n\")\n+\n+print(\"Test 2: Calling with shop_id as keyword argument (currently fails)\")\n+try:\n+    cmd = TestCommand()\n+    call_command(cmd, shop_id=1)\n+    print(\"Success\\n\")\n+except Exception as e:\n+    print(f\"Failed: {e}\\n\")\ndiff --git a/test_mutually_exclusive.py b/test_mutually_exclusive.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/tests/user_commands/management/commands/mutually_exclusive_required.py b/tests/user_commands/management/commands/mutually_exclusive_required.py\nnew file mode 100644\nindex 0000000000..a8096bd60d\n--- /dev/null\n+++ b/tests/user_commands/management/commands/mutually_exclusive_required.py\n@@ -0,0 +1,12 @@\n+from django.core.management.base import BaseCommand\n+\n+\n+class Command(BaseCommand):\n+    def add_arguments(self, parser):\n+        group = parser.add_mutually_exclusive_group(required=True)\n+        group.add_argument('--foo-id', type=int, dest='foo_id')\n+        group.add_argument('--foo-name', type=str, dest='foo_name')\n+\n+    def handle(self, *args, **options):\n+        self.stdout.write(f\"foo_id={options['foo_id']}\")\n+        self.stdout.write(f\"foo_name={options['foo_name']}\")\ndiff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex a53c781ac6..b6366434fd 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -208,6 +208,28 @@ class CommandTests(SimpleTestCase):\n         management.call_command('required_option', '--need-me=foo', needme2='bar', stdout=out)\n         self.assertIn('need_me', out.getvalue())\n         self.assertIn('needme2', out.getvalue())\n+    \n+    def test_call_command_with_mutually_exclusive_required_group(self):\n+        \"\"\"\n+        call_command() works with required mutually exclusive groups.\n+        \"\"\"\n+        out = StringIO()\n+        # Should work with foo_id passed as kwarg\n+        management.call_command('mutually_exclusive_required', foo_id=1, stdout=out)\n+        self.assertIn('foo_id=1', out.getvalue())\n+        \n+        out = StringIO()\n+        # Should work with foo_name passed as kwarg\n+        management.call_command('mutually_exclusive_required', foo_name='test', stdout=out)\n+        self.assertIn('foo_name=test', out.getvalue())\n+        \n+        # Should fail without any option from the required group\n+        with self.assertRaisesMessage(CommandError, 'Error: one of the arguments --foo-id --foo-name is required'):\n+            management.call_command('mutually_exclusive_required')\n+        \n+        # Should fail with both options from the mutually exclusive group\n+        with self.assertRaisesMessage(CommandError, 'Error: argument --foo-name: not allowed with argument --foo-id'):\n+            management.call_command('mutually_exclusive_required', foo_id=1, foo_name='test')\n \n     def test_command_add_arguments_after_common_arguments(self):\n         out = StringIO()\n", "gold_standard_diff": "diff --git a/django/core/management/__init__.py b/django/core/management/__init__.py\nindex 5f2e64761ee0..adc7d173eb5c 100644\n--- a/django/core/management/__init__.py\n+++ b/django/core/management/__init__.py\n@@ -130,11 +130,19 @@ def get_actions(parser):\n                 yield opt\n \n     parser_actions = list(get_actions(parser))\n+    mutually_exclusive_required_options = {\n+        opt\n+        for group in parser._mutually_exclusive_groups\n+        for opt in group._group_actions if group.required\n+    }\n     # Any required arguments which are passed in via **options must be passed\n     # to parse_args().\n     parse_args += [\n         '{}={}'.format(min(opt.option_strings), arg_options[opt.dest])\n-        for opt in parser_actions if opt.required and opt.dest in options\n+        for opt in parser_actions if (\n+            opt.dest in options and\n+            (opt.required or opt in mutually_exclusive_required_options)\n+        )\n     ]\n     defaults = parser.parse_args(args=parse_args)\n     defaults = dict(defaults._get_kwargs(), **arg_options)\ndiff --git a/tests/user_commands/management/commands/mutually_exclusive_required.py b/tests/user_commands/management/commands/mutually_exclusive_required.py\nnew file mode 100644\nindex 000000000000..e5df17edb0ac\n--- /dev/null\n+++ b/tests/user_commands/management/commands/mutually_exclusive_required.py\n@@ -0,0 +1,12 @@\n+from django.core.management.base import BaseCommand\n+\n+\n+class Command(BaseCommand):\n+\n+    def add_arguments(self, parser):\n+        group = parser.add_mutually_exclusive_group(required=True)\n+        group.add_argument('--foo-id', type=int, nargs='?', default=None)\n+        group.add_argument('--foo-name', type=str, nargs='?', default=None)\n+\n+    def handle(self, *args, **options):\n+        self.stdout.write(','.join(options))\ndiff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex a53c781ac644..4e730472f53a 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -214,6 +214,16 @@ def test_command_add_arguments_after_common_arguments(self):\n         management.call_command('common_args', stdout=out)\n         self.assertIn('Detected that --version already exists', out.getvalue())\n \n+    def test_mutually_exclusive_group_required_options(self):\n+        out = StringIO()\n+        management.call_command('mutually_exclusive_required', foo_id=1, stdout=out)\n+        self.assertIn('foo_id', out.getvalue())\n+        management.call_command('mutually_exclusive_required', foo_name='foo', stdout=out)\n+        self.assertIn('foo_name', out.getvalue())\n+        msg = 'Error: one of the arguments --foo-id --foo-name is required'\n+        with self.assertRaisesMessage(CommandError, msg):\n+            management.call_command('mutually_exclusive_required', stdout=out)\n+\n     def test_subparser(self):\n         out = StringIO()\n         management.call_command('subparser', 'foo', 12, stdout=out)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11749"}