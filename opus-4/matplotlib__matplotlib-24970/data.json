{"instance_id": "matplotlib__matplotlib-24970", "score": "C", "diff": "diff --git a/check_max_value.py b/check_max_value.py\nnew file mode 100644\nindex 0000000000..87bc5a8f11\n--- /dev/null\n+++ b/check_max_value.py\n@@ -0,0 +1,6 @@\n+import numpy as np\n+\n+# Check what integer types can hold values up to 258\n+for dtype in [np.int8, np.uint8, np.int16, np.uint16, np.int32]:\n+    info = np.iinfo(dtype)\n+    print(f\"{dtype}: min={info.min}, max={info.max}, can hold 258: {258 <= info.max}\")\ndiff --git a/fix_numpy_deprecation.patch b/fix_numpy_deprecation.patch\nnew file mode 100644\nindex 0000000000..fddeca1c4e\n--- /dev/null\n+++ b/fix_numpy_deprecation.patch\n@@ -0,0 +1,16 @@\n+--- a/lib/matplotlib/colors.py\n++++ b/lib/matplotlib/colors.py\n+@@ -725,6 +725,13 @@ class Colormap:\n+                 # Avoid converting large positive values to negative integers.\n+                 np.clip(xa, -1, self.N, out=xa)\n+                 xa = xa.astype(int)\n++        # If xa is an integer type that cannot hold the special indices,\n++        # convert it to a larger integer type to avoid NumPy 1.24 warnings.\n++        elif xa.dtype.kind in \"iu\":  # integer or unsigned integer\n++            max_val = max(self._i_under, self._i_over, self._i_bad)\n++            if max_val > np.iinfo(xa.dtype).max:\n++                # Convert to int32 which can hold all special indices\n++                xa = xa.astype(np.int32)\n+         # Set the over-range indices before the under-range;\n+         # otherwise the under-range values get converted to over-range.\n+         xa[xa > self.N - 1] = self._i_over\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04..065d7550ff 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -725,6 +725,13 @@ class Colormap:\n                 # Avoid converting large positive values to negative integers.\n                 np.clip(xa, -1, self.N, out=xa)\n                 xa = xa.astype(int)\n+        # If xa is an integer type that cannot hold the special indices,\n+        # convert it to a larger integer type to avoid NumPy 1.24 warnings.\n+        elif xa.dtype.kind in \"iu\":  # integer or unsigned integer\n+            max_val = max(self._i_under, self._i_over, self._i_bad)\n+            if max_val > np.iinfo(xa.dtype).max:\n+                # Convert to int32 which can hold all special indices\n+                xa = xa.astype(np.int32)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..8dac470132\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,45 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+\n+# Show all warnings\n+warnings.filterwarnings('default')\n+\n+# Test with various data types\n+dtypes = [np.uint8, np.int8, np.uint16, np.int16, np.int32, np.float32, np.float64]\n+cmap = plt.get_cmap('viridis')\n+\n+print(f\"Colormap N: {cmap.N}\")\n+print(f\"Special indices - under: {cmap._i_under}, over: {cmap._i_over}, bad: {cmap._i_bad}\")\n+print()\n+\n+for dtype in dtypes:\n+    print(f\"Testing with {dtype.__name__}:\")\n+    \n+    # Test empty array\n+    result = cmap(np.empty((0,), dtype=dtype))\n+    print(f\"  Empty array: shape={result.shape}\")\n+    \n+    # Test normal values\n+    if np.issubdtype(dtype, np.integer):\n+        # For integer types, use values in valid range\n+        test_vals = np.array([0, 1, 128, 255], dtype=dtype)\n+        # Filter out values that exceed the dtype's range\n+        valid_vals = [v for v in [0, 1, 128, 255] if v <= np.iinfo(dtype).max and v >= np.iinfo(dtype).min]\n+        test_vals = np.array(valid_vals[:3] if valid_vals else [0], dtype=dtype)\n+    else:\n+        # For float types, use normalized values\n+        test_vals = np.array([0.0, 0.5, 1.0], dtype=dtype)\n+    \n+    result = cmap(test_vals)\n+    print(f\"  Normal values: input shape={test_vals.shape}, output shape={result.shape}\")\n+    \n+    # Test with NaN (for float types)\n+    if np.issubdtype(dtype, np.floating):\n+        test_vals_nan = np.array([0.5, np.nan, 0.8], dtype=dtype)\n+        result = cmap(test_vals_nan)\n+        print(f\"  With NaN: input shape={test_vals_nan.shape}, output shape={result.shape}\")\n+    \n+    print()\n+\n+print(\"All tests completed without warnings!\")\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..13a2da26bc\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,38 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+\n+# Show all warnings\n+warnings.filterwarnings('default')\n+\n+cmap = plt.get_cmap('viridis')\n+\n+print(\"Testing edge cases:\")\n+print(f\"Colormap N: {cmap.N}\")\n+print()\n+\n+# Test 1: uint8 array with out-of-range values\n+print(\"Test 1: uint8 with out-of-range values\")\n+xa = np.array([0, 100, 255], dtype=np.uint8)\n+result = cmap(xa)\n+print(f\"  Input: {xa}, Output shape: {result.shape}\")\n+\n+# Test 2: uint8 array with values that will become out-of-range\n+print(\"\\nTest 2: uint8 with negative indices (should trigger special handling)\")\n+xa = np.array([255, 256, 257], dtype=np.uint8)  # These will overflow to 255, 0, 1\n+result = cmap(xa)\n+print(f\"  Input: {xa}, Output shape: {result.shape}\")\n+\n+# Test 3: Masked array with uint8\n+print(\"\\nTest 3: Masked array with uint8\")\n+xa = np.ma.array([0, 100, 255], mask=[False, True, False], dtype=np.uint8)\n+result = cmap(xa)\n+print(f\"  Input: {xa}, Mask: {xa.mask}, Output shape: {result.shape}\")\n+\n+# Test 4: Check bytes=True option\n+print(\"\\nTest 4: bytes=True option with uint8\")\n+xa = np.array([0, 128, 255], dtype=np.uint8)\n+result = cmap(xa, bytes=True)\n+print(f\"  Input: {xa}, Output shape: {result.shape}, Output dtype: {result.dtype}\")\n+\n+print(\"\\nAll edge case tests completed!\")\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..07c21f876b\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,17 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+\n+# Show all warnings\n+warnings.filterwarnings('default')\n+\n+# Reproduce the issue\n+print(\"Testing with uint8 array:\")\n+cmap = plt.get_cmap()\n+print(f\"Colormap N: {cmap.N}\")\n+print(f\"_i_under: {cmap._i_under}\")\n+print(f\"_i_over: {cmap._i_over}\")\n+print(f\"_i_bad: {cmap._i_bad}\")\n+\n+result = cmap(np.empty((0, ), dtype=np.uint8))\n+print(\"Done\")\ndiff --git a/test_numpy_deprecation_fix.py b/test_numpy_deprecation_fix.py\nnew file mode 100644\nindex 0000000000..12bf4fb482\n--- /dev/null\n+++ b/test_numpy_deprecation_fix.py\n@@ -0,0 +1,82 @@\n+\"\"\"\n+Test to ensure the NumPy 1.24 deprecation warning fix works correctly.\n+This test should be added to the matplotlib test suite.\n+\"\"\"\n+\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+import pytest\n+\n+\n+def test_colormap_uint8_no_deprecation_warning():\n+    \"\"\"Test that calling a colormap with uint8 data doesn't trigger NumPy deprecation warnings.\"\"\"\n+    # This test specifically addresses the issue reported in:\n+    # https://github.com/matplotlib/matplotlib/issues/xxxxx\n+    \n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        \n+        # Test case from the bug report\n+        result = plt.get_cmap()(np.empty((0,), dtype=np.uint8))\n+        \n+        # Check no deprecation warnings were raised\n+        deprecation_warnings = [warning for warning in w \n+                               if issubclass(warning.category, DeprecationWarning)\n+                               and \"out-of-bound Python integers\" in str(warning.message)]\n+        \n+        assert len(deprecation_warnings) == 0, \\\n+            f\"Unexpected deprecation warnings: {[str(w.message) for w in deprecation_warnings]}\"\n+        \n+        # Also test with actual data\n+        cmap = plt.get_cmap('viridis')\n+        \n+        # Test with various uint8 values\n+        test_data = np.array([0, 128, 255], dtype=np.uint8)\n+        result = cmap(test_data)\n+        \n+        # Check no new deprecation warnings\n+        deprecation_warnings = [warning for warning in w \n+                               if issubclass(warning.category, DeprecationWarning)\n+                               and \"out-of-bound Python integers\" in str(warning.message)]\n+        \n+        assert len(deprecation_warnings) == 0, \\\n+            f\"Unexpected deprecation warnings: {[str(w.message) for w in deprecation_warnings]}\"\n+        \n+        # Verify the result is correct\n+        assert result.shape == (3, 4)  # 3 colors, RGBA channels\n+\n+\n+def test_colormap_preserves_functionality():\n+    \"\"\"Ensure the fix doesn't break existing colormap functionality.\"\"\"\n+    cmap = plt.get_cmap('viridis')\n+    \n+    # Test with different dtypes\n+    for dtype in [np.uint8, np.int16, np.float32, np.float64]:\n+        if np.issubdtype(dtype, np.integer):\n+            # Integer input\n+            data = np.array([0, 127, 255], dtype=dtype)\n+            if dtype == np.uint8:\n+                expected_indices = [0, 127, 255]\n+            else:\n+                expected_indices = [0, 127, 255]\n+        else:\n+            # Float input  \n+            data = np.array([0.0, 0.5, 1.0], dtype=dtype)\n+            expected_indices = [0, 128, 255]  # After multiplication by N=256\n+            \n+        result = cmap(data)\n+        assert result.shape == (3, 4)\n+        \n+    # Test masked arrays\n+    masked_data = np.ma.array([0, 100, 255], mask=[False, True, False], dtype=np.uint8)\n+    result = cmap(masked_data)\n+    assert result.shape == (3, 4)\n+    # The masked value should use the \"bad\" color\n+    assert np.array_equal(result[1], cmap._rgba_bad)\n+\n+\n+if __name__ == \"__main__\":\n+    test_colormap_uint8_no_deprecation_warning()\n+    test_colormap_preserves_functionality()\n+    print(\"All tests passed!\")\ndiff --git a/test_original_issue.py b/test_original_issue.py\nnew file mode 100644\nindex 0000000000..c8d04dfd21\n--- /dev/null\n+++ b/test_original_issue.py\n@@ -0,0 +1,12 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+\n+# Use default warning filters to see if our fix prevents the warnings\n+warnings.filterwarnings('default')\n+\n+print(\"Running the exact test case from the issue:\")\n+print(\"plt.get_cmap()(np.empty((0, ), dtype=np.uint8))\")\n+result = plt.get_cmap()(np.empty((0, ), dtype=np.uint8))\n+print(f\"Result shape: {result.shape}\")\n+print(\"No warnings! The issue is fixed.\")\n", "gold_standard_diff": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2d3072da04de..ab0d73c4b5fb 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -715,16 +715,17 @@ def __call__(self, X, alpha=None, bytes=False):\n         if not xa.dtype.isnative:\n             xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n         if xa.dtype.kind == \"f\":\n-            with np.errstate(invalid=\"ignore\"):\n-                xa *= self.N\n-                # Negative values are out of range, but astype(int) would\n-                # truncate them towards zero.\n-                xa[xa < 0] = -1\n-                # xa == 1 (== N after multiplication) is not out of range.\n-                xa[xa == self.N] = self.N - 1\n-                # Avoid converting large positive values to negative integers.\n-                np.clip(xa, -1, self.N, out=xa)\n-                xa = xa.astype(int)\n+            xa *= self.N\n+            # Negative values are out of range, but astype(int) would\n+            # truncate them towards zero.\n+            xa[xa < 0] = -1\n+            # xa == 1 (== N after multiplication) is not out of range.\n+            xa[xa == self.N] = self.N - 1\n+            # Avoid converting large positive values to negative integers.\n+            np.clip(xa, -1, self.N, out=xa)\n+        with np.errstate(invalid=\"ignore\"):\n+            # We need this cast for unsigned ints as well as floats\n+            xa = xa.astype(int)\n         # Set the over-range indices before the under-range;\n         # otherwise the under-range values get converted to over-range.\n         xa[xa > self.N - 1] = self._i_over\ndiff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex ff893e71acdb..a5809f0fa89f 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,6 +30,13 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype(dtype):\n+    # We use subtraction in the indexing, so need to verify that uint8 works\n+    cm = mpl.colormaps[\"viridis\"]\n+    assert_array_equal(cm(dtype(0)), cm(0))\n+\n+\n def test_resampled():\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/24970"}