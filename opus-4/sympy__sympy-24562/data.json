{"instance_id": "sympy__sympy-24562", "score": "C", "diff": "diff --git a/demo_fix.py b/demo_fix.py\nnew file mode 100644\nindex 0000000000..bc96e142c4\n--- /dev/null\n+++ b/demo_fix.py\n@@ -0,0 +1,33 @@\n+#!/usr/bin/env python3\n+\"\"\"\n+Demonstration that the fix for Rational('0.5', '100') works correctly.\n+This was returning 1/100100 instead of 1/200 due to string multiplication.\n+\"\"\"\n+\n+from sympy import Rational\n+\n+print(\"Testing the bug case:\")\n+print(\"=====================\")\n+print(\"Rational('0.5', '100') =\", Rational('0.5', '100'))\n+print(\"Rational(0.5, 100) =\", Rational(0.5, 100))\n+print()\n+\n+print(\"Both should be equal to 1/200:\")\n+assert Rational('0.5', '100') == Rational(1, 200)\n+assert Rational(0.5, 100) == Rational(1, 200)\n+assert Rational('0.5', '100') == Rational(0.5, 100)\n+print(\"\u2713 All assertions passed!\")\n+print()\n+\n+print(\"Other test cases to ensure nothing broke:\")\n+print(\"=========================================\")\n+test_cases = [\n+    (Rational('1', '2'), \"Rational('1', '2')\"),\n+    (Rational('0.25', '0.5'), \"Rational('0.25', '0.5')\"),\n+    (Rational('10', '20'), \"Rational('10', '20')\"),\n+    (Rational(1, 2), \"Rational(1, 2)\"),\n+    (Rational(0.25, 0.5), \"Rational(0.25, 0.5)\"),\n+]\n+\n+for result, expr in test_cases:\n+    print(f\"{expr} = {result}\")\ndiff --git a/fix_explanation.md b/fix_explanation.md\nnew file mode 100644\nindex 0000000000..a042ab0af4\n--- /dev/null\n+++ b/fix_explanation.md\n@@ -0,0 +1,29 @@\n+# Fix for Rational String Multiplication Bug\n+\n+## Problem Description\n+When calling `Rational('0.5', '100')`, the result was incorrectly `1/100100` instead of the expected `1/200`.\n+\n+## Root Cause\n+The bug occurred in the `__new__` method of the `Rational` class in `/testbed/sympy/core/numbers.py`. When both arguments were strings, the code performed string multiplication instead of numeric multiplication.\n+\n+Specifically, at line 1630:\n+```python\n+q *= p.q  # where q='100' (string) and p.q=2 (int)\n+```\n+\n+This resulted in `'100' * 2 = '100100'` (string repetition) instead of `100 * 2 = 200`.\n+\n+## Solution\n+The fix separates the conversion and calculation steps:\n+\n+1. First, convert both `p` and `q` to their numeric components\n+2. Store the numerators and denominators separately\n+3. Then perform the arithmetic operations on the numeric values\n+\n+This ensures that no string operations occur during the calculation phase.\n+\n+## Code Changes\n+The fix modifies lines 1628-1640 in `/testbed/sympy/core/numbers.py`, replacing the in-place operations with explicit numeric calculations that avoid string multiplication.\n+\n+## Test Coverage\n+Added test cases to `test_Rational_new()` in `/testbed/sympy/core/tests/test_numbers.py` to ensure this bug doesn't reoccur.\ndiff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex 52f7ea45ad..c98ece3e9a 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1627,17 +1627,23 @@ def __new__(cls, p, q=None, gcd=None):\n \n         if not isinstance(p, SYMPY_INTS):\n             p = Rational(p)\n-            q *= p.q\n-            p = p.p\n+            p_num = p.p\n+            p_den = p.q\n         else:\n-            p = int(p)\n+            p_num = int(p)\n+            p_den = 1\n \n         if not isinstance(q, SYMPY_INTS):\n             q = Rational(q)\n-            p *= q.q\n-            q = q.p\n+            q_num = q.p\n+            q_den = q.q\n         else:\n-            q = int(q)\n+            q_num = int(q)\n+            q_den = 1\n+        \n+        # Now calculate the final p and q\n+        p = p_num * q_den\n+        q = q_num * p_den\n \n         # p and q are now ints\n         if q == 0:\ndiff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 8baf408933..5c4ee65083 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -369,6 +369,10 @@ def test_Rational_new():\n     assert n.q == 4\n     assert n.p == -2\n \n+    # Test for issue with string arguments\n+    assert Rational('0.5', '100') == Rational(1, 200)\n+    assert Rational('0.5', '100') == Rational(0.5, 100)\n+\n \n def test_Number_new():\n     \"\"\"\"\ndiff --git a/test_rational_bug.py b/test_rational_bug.py\nnew file mode 100644\nindex 0000000000..3c3d9fd127\n--- /dev/null\n+++ b/test_rational_bug.py\n@@ -0,0 +1,37 @@\n+from sympy import Rational\n+\n+# Test cases\n+print(\"Test 1: Rational('0.5', '100')\")\n+r1 = Rational('0.5', '100')\n+print(f\"Result: {r1}\")\n+print(f\"p={r1.p}, q={r1.q}\")\n+print()\n+\n+print(\"Test 2: Rational(0.5, 100)\")\n+r2 = Rational(0.5, 100)\n+print(f\"Result: {r2}\")\n+print(f\"p={r2.p}, q={r2.q}\")\n+print()\n+\n+print(\"Test 3: Rational('0.5')\")\n+r3 = Rational('0.5')\n+print(f\"Result: {r3}\")\n+print(f\"p={r3.p}, q={r3.q}\")\n+print()\n+\n+print(\"Test 4: Rational('100')\")\n+r4 = Rational('100')\n+print(f\"Result: {r4}\")\n+print(f\"p={r4.p}, q={r4.q}\")\n+print()\n+\n+# Let's add some debug prints to understand the issue\n+import fractions\n+print(\"Test 5: fractions.Fraction('0.5')\")\n+f1 = fractions.Fraction('0.5')\n+print(f\"Result: {f1}, numerator={f1.numerator}, denominator={f1.denominator}\")\n+print()\n+\n+print(\"Test 6: fractions.Fraction('100')\")\n+f2 = fractions.Fraction('100')\n+print(f\"Result: {f2}, numerator={f2.numerator}, denominator={f2.denominator}\")\ndiff --git a/test_rational_comprehensive.py b/test_rational_comprehensive.py\nnew file mode 100644\nindex 0000000000..b12a60219d\n--- /dev/null\n+++ b/test_rational_comprehensive.py\n@@ -0,0 +1,75 @@\n+from sympy import Rational, S\n+import sys\n+\n+def test_rational():\n+    \"\"\"Test various Rational creation scenarios\"\"\"\n+    test_cases = [\n+        # (args, expected_p, expected_q, description)\n+        ((1, 2), 1, 2, \"integers\"),\n+        (('1', '2'), 1, 2, \"string integers\"),\n+        ((0.5,), 1, 2, \"single float\"),\n+        (('0.5',), 1, 2, \"single string float\"),\n+        ((0.5, 100), 1, 200, \"float and int\"),\n+        (('0.5', '100'), 1, 200, \"string float and string int - THE BUG CASE\"),\n+        ((1, 3), 1, 3, \"1/3 as integers\"),\n+        (('1', '3'), 1, 3, \"1/3 as strings\"),\n+        ((2, 4), 1, 2, \"reducible fraction\"),\n+        (('2', '4'), 1, 2, \"reducible fraction as strings\"),\n+        ((2, 4, 1), 2, 4, \"with gcd=1\"),\n+        ((Rational(1, 2), 2), 1, 4, \"Rational and int\"),\n+        ((1, Rational(2, 3)), 3, 2, \"int and Rational\"),\n+        ((Rational(1, 2), Rational(3, 4)), 2, 3, \"Rational and Rational\"),\n+        ((-1, 2), -1, 2, \"negative numerator\"),\n+        ((1, -2), -1, 2, \"negative denominator\"),\n+        (('-1', '2'), -1, 2, \"negative string numerator\"),\n+        (('1', '-2'), -1, 2, \"negative string denominator\"),\n+        ((0, 5), 0, 1, \"zero numerator\"),\n+        (('0', '5'), 0, 1, \"zero string numerator\"),\n+        ((5,), 5, 1, \"single integer\"),\n+        (('5',), 5, 1, \"single string integer\"),\n+        ((Rational(3, 4),), 3, 4, \"single Rational\"),\n+        (('1.5', '0.5'), 3, 1, \"string decimal division\"),\n+        (('0.1', '0.2'), 1, 2, \"small string decimals\"),\n+        ((0.1, 0.2), 1, 2, \"small float decimals (approximate due to float repr)\"),\n+    ]\n+    \n+    failed = 0\n+    for args, expected_p, expected_q, desc in test_cases:\n+        try:\n+            r = Rational(*args)\n+            if r.p != expected_p or r.q != expected_q:\n+                print(f\"FAIL: {desc}\")\n+                print(f\"  Args: {args}\")\n+                print(f\"  Expected: {expected_p}/{expected_q}\")\n+                print(f\"  Got: {r.p}/{r.q} = {r}\")\n+                failed += 1\n+            else:\n+                print(f\"PASS: {desc} -> {r}\")\n+        except Exception as e:\n+            print(f\"ERROR: {desc}\")\n+            print(f\"  Args: {args}\")\n+            print(f\"  Exception: {e}\")\n+            failed += 1\n+    \n+    # Special cases that should raise errors\n+    error_cases = [\n+        ((1, 0), \"division by zero\"),\n+        (('1', '0'), \"string division by zero\"),\n+        (('invalid',), \"invalid string\"),\n+        (('1/2/3',), \"multiple slashes\"),\n+    ]\n+    \n+    for args, desc in error_cases:\n+        try:\n+            r = Rational(*args)\n+            print(f\"FAIL: {desc} should have raised an error but got {r}\")\n+            failed += 1\n+        except Exception:\n+            print(f\"PASS: {desc} correctly raised an error\")\n+    \n+    print(f\"\\nTotal failed: {failed}\")\n+    return failed == 0\n+\n+if __name__ == \"__main__\":\n+    success = test_rational()\n+    sys.exit(0 if success else 1)\ndiff --git a/test_rational_debug.py b/test_rational_debug.py\nnew file mode 100644\nindex 0000000000..730463c3d9\n--- /dev/null\n+++ b/test_rational_debug.py\n@@ -0,0 +1,33 @@\n+from sympy.core.numbers import Rational, SYMPY_INTS\n+import fractions\n+\n+# Let's manually trace through what happens with Rational('0.5', '100')\n+print(\"=== Tracing Rational('0.5', '100') ===\")\n+p = '0.5'\n+q = '100'\n+\n+print(f\"Initial: p={repr(p)}, q={repr(q)}\")\n+\n+# Line 1628-1631: Since p is not in SYMPY_INTS\n+print(f\"p is not in SYMPY_INTS, so calling Rational(p)\")\n+p_rational = Rational(p)  # This should give us 1/2\n+print(f\"p_rational = {p_rational}, p_rational.p = {p_rational.p}, p_rational.q = {p_rational.q}\")\n+\n+# Now back in the original call\n+print(f\"\\nBack in original call:\")\n+print(f\"q before: {repr(q)}\")\n+print(f\"q *= p_rational.q: {q} *= {p_rational.q}\")\n+# Here's the problem! q is a string '100', so q *= 2 will do string multiplication!\n+try:\n+    q_result = q * p_rational.q\n+    print(f\"q after multiplication: {repr(q_result)}\")\n+except Exception as e:\n+    print(f\"Error during multiplication: {e}\")\n+\n+# Let's see what Python does with string multiplication\n+print(f\"\\nString multiplication test:\")\n+print(f\"'100' * 2 = {repr('100' * 2)}\")\n+print(f\"'100' * 1 = {repr('100' * 1)}\")\n+\n+# This explains the bug! When q is a string and we do q *= p.q,\n+# it's doing string multiplication instead of numeric multiplication\n", "gold_standard_diff": "From 55e64be745db6bac7930adf7607e902183ad3ef1 Mon Sep 17 00:00:00 2001\nFrom: Abhishek Patidar <1e9abhi1e10@gmail.com>\nDate: Sat, 21 Jan 2023 17:35:17 +0530\nSubject: [PATCH] fixes rational calc value error\n\n---\n sympy/core/numbers.py            | 8 +++++---\n sympy/core/tests/test_numbers.py | 7 +++++++\n 2 files changed, 12 insertions(+), 3 deletions(-)\n\ndiff --git a/sympy/core/numbers.py b/sympy/core/numbers.py\nindex 3b1aec24296e..ae14d9809d02 100644\n--- a/sympy/core/numbers.py\n+++ b/sympy/core/numbers.py\n@@ -1624,10 +1624,11 @@ def __new__(cls, p, q=None, gcd=None):\n \n             q = 1\n             gcd = 1\n+        Q = 1\n \n         if not isinstance(p, SYMPY_INTS):\n             p = Rational(p)\n-            q *= p.q\n+            Q *= p.q\n             p = p.p\n         else:\n             p = int(p)\n@@ -1635,9 +1636,10 @@ def __new__(cls, p, q=None, gcd=None):\n         if not isinstance(q, SYMPY_INTS):\n             q = Rational(q)\n             p *= q.q\n-            q = q.p\n+            Q *= q.p\n         else:\n-            q = int(q)\n+            Q *= int(q)\n+        q = Q\n \n         # p and q are now ints\n         if q == 0:\ndiff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 8e42e2b0c70a..ee8867abe96e 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -366,6 +366,13 @@ def test_Rational_new():\n     assert n.q == 4\n     assert n.p == -2\n \n+def test_issue_24543():\n+    for p in ('1.5', 1.5, 2):\n+        for q in ('1.5', 1.5, 2):\n+            assert Rational(p, q).as_numer_denom() == Rational('%s/%s'%(p,q)).as_numer_denom()\n+\n+    assert Rational('0.5', '100') == Rational(1, 200)\n+\n \n def test_Number_new():\n     \"\"\"\"\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/24562"}