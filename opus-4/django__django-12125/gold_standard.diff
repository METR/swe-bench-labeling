From 8008795a3899d979d65832ca7c4946903de206f7 Mon Sep 17 00:00:00 2001
From: John Bowen <jbowen7@gmail.com>
Date: Fri, 22 Nov 2019 19:41:56 +0000
Subject: [PATCH 1/2] Refs #23950 --- Moved test DeconstructibleInstances class
 to a module level.

DeconstructibleInstances was not importable from the asserted path.
---
 tests/migrations/test_writer.py | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py
index ca924f35ecc5..addf10b0f039 100644
--- a/tests/migrations/test_writer.py
+++ b/tests/migrations/test_writer.py
@@ -26,6 +26,11 @@
 from .models import FoodManager, FoodQuerySet
 
 
+class DeconstructibleInstances:
+    def deconstruct(self):
+        return ('DeconstructibleInstances', [], {})
+
+
 class Money(decimal.Decimal):
     def deconstruct(self):
         return (
@@ -726,10 +731,6 @@ def test_deconstruct_class_arguments(self):
         # Yes, it doesn't make sense to use a class as a default for a
         # CharField. It does make sense for custom fields though, for example
         # an enumfield that takes the enum class as an argument.
-        class DeconstructibleInstances:
-            def deconstruct(self):
-                return ('DeconstructibleInstances', [], {})
-
         string = MigrationWriter.serialize(models.CharField(default=DeconstructibleInstances))[0]
         self.assertEqual(string, "models.CharField(default=migrations.test_writer.DeconstructibleInstances)")
 

From 29d8198841ea39af44f3bc835d646e642d498475 Mon Sep 17 00:00:00 2001
From: John Bowen <jbowen7@gmail.com>
Date: Fri, 22 Nov 2019 12:43:03 +0000
Subject: [PATCH 2/2] Fixed #27914 -- Fixed serialization of nested classes in
 migrations.

---
 django/db/migrations/serializer.py |  2 +-
 tests/migrations/test_writer.py    | 16 ++++++++++++++++
 2 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/django/db/migrations/serializer.py b/django/db/migrations/serializer.py
index 7d226955d590..ead81c398a6d 100644
--- a/django/db/migrations/serializer.py
+++ b/django/db/migrations/serializer.py
@@ -269,7 +269,7 @@ def serialize(self):
             if module == builtins.__name__:
                 return self.value.__name__, set()
             else:
-                return "%s.%s" % (module, self.value.__name__), {"import %s" % module}
+                return "%s.%s" % (module, self.value.__qualname__), {"import %s" % module}
 
 
 class UUIDSerializer(BaseSerializer):
diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py
index addf10b0f039..6a65e87d5a3c 100644
--- a/tests/migrations/test_writer.py
+++ b/tests/migrations/test_writer.py
@@ -193,6 +193,10 @@ class NestedEnum(enum.IntEnum):
         A = 1
         B = 2
 
+    class NestedChoices(models.TextChoices):
+        X = 'X', 'X value'
+        Y = 'Y', 'Y value'
+
     def safe_exec(self, string, value=None):
         d = {}
         try:
@@ -388,6 +392,18 @@ class DateChoices(datetime.date, models.Choices):
             "default=datetime.date(1969, 11, 19))"
         )
 
+    def test_serialize_nested_class(self):
+        for nested_cls in [self.NestedEnum, self.NestedChoices]:
+            cls_name = nested_cls.__name__
+            with self.subTest(cls_name):
+                self.assertSerializedResultEqual(
+                    nested_cls,
+                    (
+                        "migrations.test_writer.WriterTests.%s" % cls_name,
+                        {'import migrations.test_writer'},
+                    ),
+                )
+
     def test_serialize_uuid(self):
         self.assertSerializedEqual(uuid.uuid1())
         self.assertSerializedEqual(uuid.uuid4())
