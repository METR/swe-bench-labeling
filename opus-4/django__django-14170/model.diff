diff --git a/django/db/models/functions/datetime.py b/django/db/models/functions/datetime.py
index 90e6f41be0..c306e2535e 100644
--- a/django/db/models/functions/datetime.py
+++ b/django/db/models/functions/datetime.py
@@ -7,6 +7,7 @@ from django.db.models.fields import (
 )
 from django.db.models.lookups import (
     Transform, YearExact, YearGt, YearGte, YearLt, YearLte,
+    Exact, GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual,
 )
 from django.utils import timezone
 
@@ -164,11 +165,38 @@ ExtractYear.register_lookup(YearGte)
 ExtractYear.register_lookup(YearLt)
 ExtractYear.register_lookup(YearLte)
 
-ExtractIsoYear.register_lookup(YearExact)
-ExtractIsoYear.register_lookup(YearGt)
-ExtractIsoYear.register_lookup(YearGte)
-ExtractIsoYear.register_lookup(YearLt)
-ExtractIsoYear.register_lookup(YearLte)
+# ISO year lookups should not use the BETWEEN optimization
+# because ISO year boundaries don't align with calendar year boundaries
+class IsoYearExact(Exact):
+    """Exact lookup for ISO year that doesn't use BETWEEN optimization."""
+    pass
+
+
+class IsoYearGt(GreaterThan):
+    """Greater than lookup for ISO year."""
+    pass
+
+
+class IsoYearGte(GreaterThanOrEqual):
+    """Greater than or equal lookup for ISO year."""
+    pass
+
+
+class IsoYearLt(LessThan):
+    """Less than lookup for ISO year."""
+    pass
+
+
+class IsoYearLte(LessThanOrEqual):
+    """Less than or equal lookup for ISO year."""
+    pass
+
+
+ExtractIsoYear.register_lookup(IsoYearExact)
+ExtractIsoYear.register_lookup(IsoYearGt)
+ExtractIsoYear.register_lookup(IsoYearGte)
+ExtractIsoYear.register_lookup(IsoYearLt)
+ExtractIsoYear.register_lookup(IsoYearLte)
 
 
 class Now(Func):
diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py
index 258600127f..b20ace5b76 100644
--- a/tests/db_functions/datetime/test_extract_trunc.py
+++ b/tests/db_functions/datetime/test_extract_trunc.py
@@ -108,20 +108,34 @@ class DateFunctionTests(TestCase):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__exact' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    # Regular year lookup should use BETWEEN optimization
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:
+                    # ISO year lookup should NOT use BETWEEN optimization
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1)
                 # exact is implied and should be the same
                 qs = DTModel.objects.filter(**{'start_datetime__%s' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1)
                 # date and datetime fields should behave the same
                 qs = DTModel.objects.filter(**{'start_date__%s' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
                 query_string = str(qs.query).lower()
-                self.assertEqual(query_string.count(' between '), 1)
-                self.assertEqual(query_string.count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(query_string.count(' between '), 1)
+                    self.assertEqual(query_string.count('extract'), 0)
+                else:
+                    self.assertEqual(query_string.count(' between '), 0)
+                    self.assertGreaterEqual(query_string.count('extract'), 1)
                 # an expression rhs cannot use the between optimization.
                 qs = DTModel.objects.annotate(
                     start_year=ExtractYear('start_datetime'),
@@ -144,10 +158,16 @@ class DateFunctionTests(TestCase):
             with self.subTest(lookup):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__gt' % lookup: 2015})
                 self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.filter(**{'start_datetime__%s__gte' % lookup: 2015})
                 self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).lower().count('extract'), 0)
+                else:
+                    self.assertGreaterEqual(str(qs.query).lower().count('extract'), 1)
                 qs = DTModel.objects.annotate(
                     start_year=ExtractYear('start_datetime'),
                 ).filter(**{'end_datetime__%s__gte' % lookup: F('start_year')})
@@ -167,10 +187,16 @@ class DateFunctionTests(TestCase):
             with self.subTest(lookup):
                 qs = DTModel.objects.filter(**{'start_datetime__%s__lt' % lookup: 2016})
                 self.assertEqual(qs.count(), 1)
-                self.assertEqual(str(qs.query).count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).count('extract'), 0)
+                else:
+                    self.assertGreaterEqual(str(qs.query).count('extract'), 1)
                 qs = DTModel.objects.filter(**{'start_datetime__%s__lte' % lookup: 2016})
                 self.assertEqual(qs.count(), 2)
-                self.assertEqual(str(qs.query).count('extract'), 0)
+                if lookup == 'year':
+                    self.assertEqual(str(qs.query).count('extract'), 0)
+                else:
+                    self.assertGreaterEqual(str(qs.query).count('extract'), 1)
                 qs = DTModel.objects.annotate(
                     end_year=ExtractYear('end_datetime'),
                 ).filter(**{'start_datetime__%s__lte' % lookup: F('end_year')})
