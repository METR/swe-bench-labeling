{"instance_id": "django__django-11265", "score": "I", "diff": "diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d69c24419b..21f0d8bfaa 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1668,6 +1668,12 @@ class Query(BaseExpression):\n         query = Query(self.model)\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n+\n+        # Copy FilteredRelation annotations from the outer query to the inner query\n+        for annotation, value in self.annotations.items():\n+            if value.__class__.__name__ == 'FilteredRelation':\n+                query.add_annotation(value, annotation)\n+\n         # Try to have as simple as possible subquery -> trim leading joins from\n         # the subquery.\n         trimmed_prefix, contains_louter = query.trim_start(names_with_path)\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex 5e85dff16c..2cf64953aa 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -98,6 +98,30 @@ class FilteredRelationTests(TestCase):\n             [self.author1]\n         )\n \n+    def test_with_join_exclude(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2]\n+        )\n+\n+    def test_with_join_exclude_and_filter(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False).filter(name='Jane'),\n+            [self.author2]\n+        )\n+\n+    def test_with_join_exclude_empty(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='nonexistent')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author1, self.author2]\n+        )\n+\n     def test_with_join_and_complex_condition(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n", "gold_standard_diff": "From 6b736dd0747dc77473f1f7b691c196ef5912d7dd Mon Sep 17 00:00:00 2001\nFrom: Rob <tienrobertnguyenn@gmail.com>\nDate: Tue, 7 May 2019 00:42:56 +1000\nSubject: [PATCH] Fixed #30349 -- Fixed QuerySet.exclude() on FilteredRelation.\n\nUsing annotated FilteredRelations raised a FieldError when coupled with\nexclude(). This is due to not passing filtered relation fields to the\nsubquery created in split_exclude(). We fixed this issue by passing the\nfiltered relation data to the newly created subquery.\n\nSecondly, in the case where an INNER JOIN is used in the excluded\nsubquery, the ORM would trim the filtered relation INNER JOIN in attempt\nto simplify the query. This will also remove the ON clause filters\ngenerated by the FilteredRelation. We added logic to not trim the INNER\nJOIN if it is from FilteredRelation.\n---\n django/db/models/sql/query.py    | 11 ++++++++---\n tests/filtered_relation/tests.py |  8 ++++++++\n 2 files changed, 16 insertions(+), 3 deletions(-)\n\ndiff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py\nindex d69c24419bd8..08d7faf1947c 100644\n--- a/django/db/models/sql/query.py\n+++ b/django/db/models/sql/query.py\n@@ -1666,6 +1666,7 @@ def split_exclude(self, filter_expr, can_reuse, names_with_path):\n             filter_expr = (filter_lhs, OuterRef(filter_rhs.name))\n         # Generate the inner query.\n         query = Query(self.model)\n+        query._filtered_relations = self._filtered_relations\n         query.add_filter(filter_expr)\n         query.clear_ordering(True)\n         # Try to have as simple as possible subquery -> trim leading joins from\n@@ -2140,9 +2141,13 @@ def trim_start(self, names_with_path):\n             join_field.foreign_related_fields[0].name)\n         trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)\n         # Lets still see if we can trim the first join from the inner query\n-        # (that is, self). We can't do this for LEFT JOINs because we would\n-        # miss those rows that have nothing on the outer side.\n-        if self.alias_map[lookup_tables[trimmed_paths + 1]].join_type != LOUTER:\n+        # (that is, self). We can't do this for:\n+        # - LEFT JOINs because we would miss those rows that have nothing on\n+        #   the outer side,\n+        # - INNER JOINs from filtered relations because we would miss their\n+        #   filters.\n+        first_join = self.alias_map[lookup_tables[trimmed_paths + 1]]\n+        if first_join.join_type != LOUTER and not first_join.filtered_relation:\n             select_fields = [r[0] for r in join_field.related_fields]\n             select_alias = lookup_tables[trimmed_paths + 1]\n             self.unref_alias(lookup_tables[trimmed_paths])\ndiff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex 5e85dff16cda..52fe64dfa5fa 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -98,6 +98,14 @@ def test_with_join(self):\n             [self.author1]\n         )\n \n+    def test_with_exclude(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2],\n+        )\n+\n     def test_with_join_and_complex_condition(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11265"}