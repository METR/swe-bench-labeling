{"instance_id": "sympy__sympy-24661", "score": "C", "diff": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 52711d1324..3b990c4b71 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -1110,6 +1110,14 @@ class EvaluateFalseTransformer(ast.NodeTransformer):\n         ast.BitAnd: 'And',\n         ast.BitXor: 'Not',\n     }\n+    comparisons = {\n+        ast.Lt: 'Lt',\n+        ast.LtE: 'Le',\n+        ast.Gt: 'Gt',\n+        ast.GtE: 'Ge',\n+        ast.Eq: 'Eq',\n+        ast.NotEq: 'Ne',\n+    }\n     functions = (\n         'Abs', 'im', 're', 'sign', 'arg', 'conjugate',\n         'acos', 'acot', 'acsc', 'asec', 'asin', 'atan',\n@@ -1186,6 +1194,23 @@ def visit_BinOp(self, node):\n             return new_node\n         return node\n \n+    def visit_Compare(self, node):\n+        # Handle comparison operators\n+        if len(node.ops) == 1 and node.ops[0].__class__ in self.comparisons:\n+            sympy_class = self.comparisons[node.ops[0].__class__]\n+            left = self.visit(node.left)\n+            right = self.visit(node.comparators[0])\n+            \n+            new_node = ast.Call(\n+                func=ast.Name(id=sympy_class, ctx=ast.Load()),\n+                args=[left, right],\n+                keywords=[ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load()))],\n+                starargs=None,\n+                kwargs=None\n+            )\n+            return new_node\n+        return self.generic_visit(node)\n+\n     def visit_Call(self, node):\n         new_node = self.generic_visit(node)\n         if isinstance(node.func, ast.Name) and node.func.id in self.functions:\ndiff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 7c43e1fce3..246a0dae52 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -355,6 +355,45 @@ def test_builtins():\n     assert str(parse_expr('pow(38, -1, 97)')) == '23'\n \n \n+def test_relational_evaluate_false():\n+    \"\"\"Test that parse_expr respects evaluate=False for relational expressions.\"\"\"\n+    from sympy import Lt, Le, Gt, Ge, Eq, Ne\n+    \n+    # Test all relational operators with numeric operands\n+    result = parse_expr('1 < 2', evaluate=False)\n+    assert isinstance(result, Lt)\n+    assert str(result) == \"1 < 2\"\n+    \n+    result = parse_expr('1 <= 2', evaluate=False)\n+    assert isinstance(result, Le)\n+    assert str(result) == \"1 <= 2\"\n+    \n+    result = parse_expr('1 > 2', evaluate=False)\n+    assert isinstance(result, Gt)\n+    assert str(result) == \"1 > 2\"\n+    \n+    result = parse_expr('1 >= 2', evaluate=False)\n+    assert isinstance(result, Ge)\n+    assert str(result) == \"1 >= 2\"\n+    \n+    result = parse_expr('1 == 2', evaluate=False)\n+    assert isinstance(result, Eq)\n+    assert str(result) == \"Eq(1, 2)\"\n+    \n+    result = parse_expr('1 != 2', evaluate=False)\n+    assert isinstance(result, Ne)\n+    assert str(result) == \"Ne(1, 2)\"\n+    \n+    # Test with symbolic expressions\n+    result = parse_expr('x < y', evaluate=False)\n+    assert isinstance(result, Lt)\n+    assert str(result) == \"x < y\"\n+    \n+    # Ensure evaluate=True still works\n+    assert parse_expr('1 < 2') == True\n+    assert parse_expr('1 > 2') == False\n+\n+\n def test_issue_22822():\n     raises(ValueError, lambda: parse_expr('x', {'': 1}))\n     data = {'some_parameter': None}\ndiff --git a/test_parse_expr_relational.py b/test_parse_expr_relational.py\nnew file mode 100644\nindex 0000000000..d46cbfed28\n--- /dev/null\n+++ b/test_parse_expr_relational.py\n@@ -0,0 +1,76 @@\n+#!/usr/bin/env python3\n+\"\"\"Test parse_expr with evaluate=False for relational expressions.\"\"\"\n+\n+from sympy.parsing.sympy_parser import parse_expr\n+from sympy import Lt, Le, Gt, Ge, Eq, Ne, symbols\n+\n+\n+def test_parse_expr_relational_evaluate_false():\n+    \"\"\"Test that parse_expr correctly handles evaluate=False for relationals.\"\"\"\n+    \n+    # Test basic numeric comparisons\n+    result = parse_expr('1 < 2', evaluate=False)\n+    assert isinstance(result, Lt), f\"Expected Lt instance, got {type(result)}\"\n+    assert str(result) == \"1 < 2\"\n+    \n+    result = parse_expr('1 <= 2', evaluate=False)\n+    assert isinstance(result, Le), f\"Expected Le instance, got {type(result)}\"\n+    assert str(result) == \"1 <= 2\"\n+    \n+    result = parse_expr('1 > 2', evaluate=False)  \n+    assert isinstance(result, Gt), f\"Expected Gt instance, got {type(result)}\"\n+    assert str(result) == \"1 > 2\"\n+    \n+    result = parse_expr('1 >= 2', evaluate=False)\n+    assert isinstance(result, Ge), f\"Expected Ge instance, got {type(result)}\"\n+    assert str(result) == \"1 >= 2\"\n+    \n+    result = parse_expr('1 == 2', evaluate=False)\n+    assert isinstance(result, Eq), f\"Expected Eq instance, got {type(result)}\"\n+    assert str(result) == \"Eq(1, 2)\"\n+    \n+    result = parse_expr('1 != 2', evaluate=False)\n+    assert isinstance(result, Ne), f\"Expected Ne instance, got {type(result)}\"\n+    assert str(result) == \"Ne(1, 2)\"\n+    \n+    # Test with symbolic expressions\n+    result = parse_expr('x < y', evaluate=False)\n+    assert isinstance(result, Lt), f\"Expected Lt instance, got {type(result)}\"\n+    assert str(result) == \"x < y\"\n+    \n+    result = parse_expr('x + 1 > 3', evaluate=False)\n+    assert isinstance(result, Gt), f\"Expected Gt instance, got {type(result)}\"\n+    assert str(result) == \"x + 1 > 3\"\n+    \n+    print(\"All tests passed!\")\n+\n+\n+def test_parse_expr_relational_evaluate_true():\n+    \"\"\"Test that parse_expr still evaluates correctly when evaluate=True.\"\"\"\n+    \n+    # Test numeric comparisons evaluate to boolean\n+    assert parse_expr('1 < 2') == True\n+    assert parse_expr('1 <= 2') == True\n+    assert parse_expr('1 > 2') == False\n+    assert parse_expr('1 >= 2') == False  \n+    assert parse_expr('1 == 2') == False\n+    assert parse_expr('1 != 2') == True\n+    \n+    # Test symbolic comparisons remain as relational objects\n+    result = parse_expr('x < 2')\n+    assert isinstance(result, Lt)\n+    \n+    # Equality of same symbol to itself gives True\n+    result = parse_expr('x == x')\n+    assert result == True\n+    \n+    # Inequality of different symbols gives relational when evaluate=False\n+    result = parse_expr('x == y', evaluate=False)\n+    assert isinstance(result, Eq)\n+    \n+    print(\"Evaluation tests passed!\")\n+\n+\n+if __name__ == \"__main__\":\n+    test_parse_expr_relational_evaluate_false()\n+    test_parse_expr_relational_evaluate_true()\n", "gold_standard_diff": "diff --git a/sympy/parsing/sympy_parser.py b/sympy/parsing/sympy_parser.py\nindex 52711d132478..130302099da4 100644\n--- a/sympy/parsing/sympy_parser.py\n+++ b/sympy/parsing/sympy_parser.py\n@@ -1119,6 +1119,29 @@ class EvaluateFalseTransformer(ast.NodeTransformer):\n         'exp', 'ln', 'log', 'sqrt', 'cbrt',\n     )\n \n+    relational_operators = {\n+        ast.NotEq: 'Ne',\n+        ast.Lt: 'Lt',\n+        ast.LtE: 'Le',\n+        ast.Gt: 'Gt',\n+        ast.GtE: 'Ge',\n+        ast.Eq: 'Eq'\n+    }\n+    def visit_Compare(self, node):\n+        if node.ops[0].__class__ in self.relational_operators:\n+            sympy_class = self.relational_operators[node.ops[0].__class__]\n+            right = self.visit(node.comparators[0])\n+            left = self.visit(node.left)\n+            new_node = ast.Call(\n+                func=ast.Name(id=sympy_class, ctx=ast.Load()),\n+                args=[left, right],\n+                keywords=[ast.keyword(arg='evaluate', value=ast.NameConstant(value=False, ctx=ast.Load()))],\n+                starargs=None,\n+                kwargs=None\n+            )\n+            return new_node\n+        return node\n+\n     def flatten(self, args, func):\n         result = []\n         for arg in args:\ndiff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 7c43e1fce32c..6088ceffd907 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -6,7 +6,7 @@\n import types\n \n from sympy.assumptions import Q\n-from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq\n+from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq, Lt, Le, Gt, Ge, Ne\n from sympy.functions import exp, factorial, factorial2, sin, Min, Max\n from sympy.logic import And\n from sympy.series import Limit\n@@ -279,6 +279,17 @@ def test_parse_function_issue_3539():\n     f = Function('f')\n     assert parse_expr('f(x)') == f(x)\n \n+def test_issue_24288():\n+    inputs = {\n+        \"1 < 2\": Lt(1, 2, evaluate=False),\n+        \"1 <= 2\": Le(1, 2, evaluate=False),\n+        \"1 > 2\": Gt(1, 2, evaluate=False),\n+        \"1 >= 2\": Ge(1, 2, evaluate=False),\n+        \"1 != 2\": Ne(1, 2, evaluate=False),\n+        \"1 == 2\": Eq(1, 2, evaluate=False)\n+    }\n+    for text, result in inputs.items():\n+        assert parse_expr(text, evaluate=False) == result\n \n def test_split_symbols_numeric():\n     transformations = (\n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/24661"}