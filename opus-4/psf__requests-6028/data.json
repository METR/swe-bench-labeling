{"instance_id": "psf__requests-6028", "score": "I", "diff": "diff --git a/requests/utils.py b/requests/utils.py\nindex 1c2ae4e0..edbcc6ee 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -991,7 +991,11 @@ def get_auth_from_url(url):\n     parsed = urlparse(url)\n \n     try:\n-        auth = (unquote(parsed.username), unquote(parsed.password))\n+        # Handle None values explicitly before calling unquote\n+        # In Python 3.8.12, urlparse may return None instead of empty string\n+        username = unquote(parsed.username) if parsed.username is not None else ''\n+        password = unquote(parsed.password) if parsed.password is not None else ''\n+        auth = (username, password)\n     except (AttributeError, TypeError):\n         auth = ('', '')\n \ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 00000000..2f741bff\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,38 @@\n+#!/usr/bin/env python\n+\n+import sys\n+from requests.utils import get_auth_from_url\n+from requests.adapters import HTTPAdapter\n+\n+print(\"Python version:\", sys.version)\n+\n+# Test cases that would fail in Python 3.8.12\n+test_urls = [\n+    (\"http://proxy.example.com:8080\", \"No auth\"),\n+    (\"http://user:pass@proxy.example.com:8080\", \"Normal auth\"),\n+    (\"http://:@proxy.example.com:8080\", \"Empty auth\"),\n+    (\"http://user@proxy.example.com:8080\", \"No password\"),\n+    (\"http://:pass@proxy.example.com:8080\", \"No username\"),\n+    (\"http://user:@proxy.example.com:8080\", \"Empty password\"),\n+    (\"http://user%40domain:pass@proxy.example.com:8080\", \"Encoded @\"),\n+    (\"http://user:pass%3Aword@proxy.example.com:8080\", \"Encoded :\"),\n+]\n+\n+adapter = HTTPAdapter()\n+\n+for url, description in test_urls:\n+    print(f\"\\n{description}: {url}\")\n+    try:\n+        username, password = get_auth_from_url(url)\n+        print(f\"  get_auth_from_url: username={username!r}, password={password!r}\")\n+        \n+        headers = adapter.proxy_headers(url)\n+        print(f\"  proxy_headers: {headers}\")\n+    except Exception as e:\n+        print(f\"  ERROR: {type(e).__name__}: {e}\")\n+\n+# Test that empty strings are properly handled\n+print(\"\\nTesting empty auth handling:\")\n+username, password = get_auth_from_url(\"http://proxy.example.com:8080\")\n+if username == '' and password == '':\n+    print(\"\u2713 Empty auth returns ('', '') as expected\")\ndiff --git a/test_proxy_auth.py b/test_proxy_auth.py\nnew file mode 100644\nindex 00000000..402e3b16\n--- /dev/null\n+++ b/test_proxy_auth.py\n@@ -0,0 +1,38 @@\n+#!/usr/bin/env python\n+\n+import requests\n+import sys\n+from requests.auth import _basic_auth_str\n+import base64\n+\n+# Test the _basic_auth_str function with different types of usernames and passwords\n+print(\"Python version:\", sys.version)\n+\n+# Normal case\n+username = \"user\"\n+password = \"pass\"\n+result = _basic_auth_str(username, password)\n+print(f\"Normal case: {result}\")\n+\n+# With special characters that might need encoding\n+username = \"user@domain\"\n+password = \"pass:word\"  \n+result = _basic_auth_str(username, password)\n+print(f\"With special chars: {result}\")\n+\n+# Direct base64 encoding to compare\n+combined = f\"{username}:{password}\"\n+expected = \"Basic \" + base64.b64encode(combined.encode('latin1')).decode('ascii')\n+print(f\"Expected: {expected}\")\n+\n+# Test proxy header creation\n+from requests.adapters import HTTPAdapter\n+adapter = HTTPAdapter()\n+proxy_url = \"http://user:pass@proxy.example.com:8080\"\n+headers = adapter.proxy_headers(proxy_url)\n+print(f\"Proxy headers: {headers}\")\n+\n+# Test with problematic characters  \n+proxy_url = \"http://user@domain:pass:word@proxy.example.com:8080\"\n+headers = adapter.proxy_headers(proxy_url)\n+print(f\"Proxy headers with special chars: {headers}\")\ndiff --git a/test_proxy_auth_integration.py b/test_proxy_auth_integration.py\nnew file mode 100644\nindex 00000000..76fd1a83\n--- /dev/null\n+++ b/test_proxy_auth_integration.py\n@@ -0,0 +1,105 @@\n+#!/usr/bin/env python\n+\"\"\"Integration test for proxy authentication with Python 3.8.12 compatibility.\"\"\"\n+\n+import requests\n+from requests.adapters import HTTPAdapter\n+from unittest.mock import patch, Mock\n+\n+def test_proxy_auth_with_various_urls():\n+    \"\"\"Test that proxy authentication works with various URL formats.\"\"\"\n+    \n+    # Test cases that should work in Python 3.8.12\n+    test_cases = [\n+        # Standard proxy with auth\n+        {\n+            'proxy_url': 'http://user:pass@proxy.example.com:8080',\n+            'expected_header': 'Basic dXNlcjpwYXNz'\n+        },\n+        # Proxy with encoded special chars in username\n+        {\n+            'proxy_url': 'http://user%40domain:pass@proxy.example.com:8080',\n+            'expected_header': 'Basic dXNlckBkb21haW46cGFzcw=='\n+        },\n+        # Proxy with encoded special chars in password\n+        {\n+            'proxy_url': 'http://user:pass%3Aword@proxy.example.com:8080',\n+            'expected_header': 'Basic dXNlcjpwYXNzOndvcmQ='\n+        },\n+        # Proxy without auth (should not add header)\n+        {\n+            'proxy_url': 'http://proxy.example.com:8080',\n+            'expected_header': None\n+        },\n+        # Empty username\n+        {\n+            'proxy_url': 'http://:pass@proxy.example.com:8080',\n+            'expected_header': None  # Empty username means no auth\n+        },\n+        # Empty password \n+        {\n+            'proxy_url': 'http://user:@proxy.example.com:8080',\n+            'expected_header': 'Basic dXNlcjo='\n+        }\n+    ]\n+    \n+    adapter = HTTPAdapter()\n+    \n+    for test_case in test_cases:\n+        proxy_url = test_case['proxy_url']\n+        expected_header = test_case['expected_header']\n+        \n+        headers = adapter.proxy_headers(proxy_url)\n+        \n+        if expected_header is None:\n+            assert 'Proxy-Authorization' not in headers, \\\n+                f\"Expected no auth header for {proxy_url}, but got {headers}\"\n+        else:\n+            assert 'Proxy-Authorization' in headers, \\\n+                f\"Expected auth header for {proxy_url}, but got {headers}\"\n+            assert headers['Proxy-Authorization'] == expected_header, \\\n+                f\"Wrong auth header for {proxy_url}: expected {expected_header}, got {headers['Proxy-Authorization']}\"\n+        \n+        print(f\"\u2713 {proxy_url}: {headers}\")\n+\n+\n+def test_proxy_auth_with_mocked_urlparse():\n+    \"\"\"Test that proxy auth works when urlparse returns None values (Python 3.8.12).\"\"\"\n+    \n+    adapter = HTTPAdapter()\n+    \n+    # Mock urlparse to simulate Python 3.8.12 behavior\n+    with patch('requests.utils.urlparse') as mock_urlparse:\n+        # Case 1: urlparse returns None for both username and password\n+        mock_result = Mock()\n+        mock_result.username = None\n+        mock_result.password = None\n+        mock_urlparse.return_value = mock_result\n+        \n+        headers = adapter.proxy_headers('http://proxy.example.com:8080')\n+        assert 'Proxy-Authorization' not in headers\n+        print(f\"\u2713 None username/password: {headers}\")\n+        \n+        # Case 2: urlparse returns None for username, string for password\n+        mock_result.username = None\n+        mock_result.password = 'pass'\n+        headers = adapter.proxy_headers('http://:pass@proxy.example.com:8080')\n+        assert 'Proxy-Authorization' not in headers  # Empty username = no auth\n+        print(f\"\u2713 None username, string password: {headers}\")\n+        \n+        # Case 3: urlparse returns string for username, None for password\n+        mock_result.username = 'user'\n+        mock_result.password = None\n+        headers = adapter.proxy_headers('http://user@proxy.example.com:8080')\n+        assert 'Proxy-Authorization' in headers\n+        assert headers['Proxy-Authorization'] == 'Basic dXNlcjo='\n+        print(f\"\u2713 String username, None password: {headers}\")\n+\n+\n+if __name__ == '__main__':\n+    print(\"Testing proxy authentication with various URL formats:\")\n+    test_proxy_auth_with_various_urls()\n+    \n+    print(\"\\nTesting proxy authentication with mocked urlparse (Python 3.8.12 simulation):\")\n+    test_proxy_auth_with_mocked_urlparse()\n+    \n+    print(\"\\nAll tests passed! Proxy authentication should work correctly in Python 3.8.12.\")\ndiff --git a/test_proxy_issue.py b/test_proxy_issue.py\nnew file mode 100644\nindex 00000000..f13d438a\n--- /dev/null\n+++ b/test_proxy_issue.py\n@@ -0,0 +1,70 @@\n+#!/usr/bin/env python\n+\n+import sys\n+from urllib.parse import urlparse, unquote\n+from requests.utils import get_auth_from_url\n+from requests.adapters import HTTPAdapter\n+from requests.auth import _basic_auth_str\n+\n+print(\"Python version:\", sys.version)\n+\n+# Test the flow of proxy authentication\n+proxy_url = \"http://user:pass@proxy.example.com:8080\"\n+\n+# Step 1: Parse auth from URL\n+username, password = get_auth_from_url(proxy_url)\n+print(f\"\\nStep 1 - get_auth_from_url:\")\n+print(f\"  Username: {username!r}\")\n+print(f\"  Password: {password!r}\")\n+\n+# Step 2: Create basic auth string\n+auth_str = _basic_auth_str(username, password)\n+print(f\"\\nStep 2 - _basic_auth_str:\")\n+print(f\"  Auth string: {auth_str!r}\")\n+\n+# Step 3: Check adapter proxy_headers\n+adapter = HTTPAdapter()\n+headers = adapter.proxy_headers(proxy_url)\n+print(f\"\\nStep 3 - adapter.proxy_headers:\")\n+print(f\"  Headers: {headers}\")\n+\n+# Now test with problematic cases\n+print(\"\\n\" + \"=\"*50)\n+print(\"Testing with special characters:\")\n+\n+test_cases = [\n+    (\"http://user%40domain:pass@proxy.example.com:8080\", \"user with @ encoded\"),\n+    (\"http://user:pass%3Aword@proxy.example.com:8080\", \"password with : encoded\"),\n+    (\"http://user%2Bplus:pass@proxy.example.com:8080\", \"user with + encoded\"),\n+    (\"http://user:pass%2Fslash@proxy.example.com:8080\", \"password with / encoded\"),\n+]\n+\n+for proxy_url, description in test_cases:\n+    print(f\"\\n{description}: {proxy_url}\")\n+    username, password = get_auth_from_url(proxy_url)\n+    print(f\"  Username: {username!r}, Password: {password!r}\")\n+    headers = adapter.proxy_headers(proxy_url)\n+    print(f\"  Headers: {headers}\")\n+\n+# Test if unquote returns None case\n+print(\"\\n\" + \"=\"*50)\n+print(\"Testing edge cases:\")\n+\n+# Let's also check what happens when urlparse returns None for username/password\n+import unittest.mock\n+\n+with unittest.mock.patch('urllib.parse.urlparse') as mock_urlparse:\n+    # Simulate urlparse returning None for username\n+    mock_result = unittest.mock.Mock()\n+    mock_result.username = None\n+    mock_result.password = \"pass\"\n+    mock_urlparse.return_value = mock_result\n+    \n+    try:\n+        username, password = get_auth_from_url(\"http://proxy.example.com:8080\")\n+        print(f\"When username is None: username={username!r}, password={password!r}\")\n+    except Exception as e:\n+        print(f\"Error when username is None: {e}\")\n+\n+# Check what happens with unquote(None)\n+print(f\"\\nunquote(None) = {unquote(None) if unquote(None) is not None else 'TypeError'}\")\ndiff --git a/test_python_3812.py b/test_python_3812.py\nnew file mode 100644\nindex 00000000..f5456a11\n--- /dev/null\n+++ b/test_python_3812.py\n@@ -0,0 +1,50 @@\n+#!/usr/bin/env python\n+\n+import sys\n+from urllib.parse import urlparse, unquote\n+\n+print(\"Python version:\", sys.version)\n+\n+# Test cases that might be problematic in Python 3.8.12\n+test_urls = [\n+    \"http://proxy.example.com:8080\",  # No auth\n+    \"http://:@proxy.example.com:8080\",  # Empty auth\n+    \"http://user@proxy.example.com:8080\",  # No password\n+    \"http://:pass@proxy.example.com:8080\",  # No username\n+    \"http://user:@proxy.example.com:8080\",  # Empty password\n+]\n+\n+for url in test_urls:\n+    print(f\"\\nTesting URL: {url}\")\n+    parsed = urlparse(url)\n+    print(f\"  username: {parsed.username!r} (type: {type(parsed.username).__name__})\")\n+    print(f\"  password: {parsed.password!r} (type: {type(parsed.password).__name__})\")\n+    \n+    # Test unquote behavior\n+    try:\n+        if parsed.username is not None:\n+            unquoted_user = unquote(parsed.username)\n+        else:\n+            unquoted_user = None\n+        print(f\"  unquote(username): {unquoted_user!r}\")\n+    except Exception as e:\n+        print(f\"  unquote(username) error: {type(e).__name__}: {e}\")\n+        \n+    try:\n+        if parsed.password is not None:\n+            unquoted_pass = unquote(parsed.password)\n+        else:\n+            unquoted_pass = None\n+        print(f\"  unquote(password): {unquoted_pass!r}\")\n+    except Exception as e:\n+        print(f\"  unquote(password) error: {type(e).__name__}: {e}\")\n+\n+# The key issue might be that in Python 3.8.12, urlparse might return None \n+# in cases where it previously returned empty string\n+print(\"\\n\" + \"=\"*50)\n+print(\"Direct unquote tests:\")\n+print(f\"unquote(''): {unquote('')!r}\")\n+try:\n+    print(f\"unquote(None): {unquote(None)!r}\")\n+except TypeError as e:\n+    print(f\"unquote(None) raises TypeError: {e}\")\ndiff --git a/test_url_parsing.py b/test_url_parsing.py\nnew file mode 100644\nindex 00000000..fc3b0d52\n--- /dev/null\n+++ b/test_url_parsing.py\n@@ -0,0 +1,31 @@\n+#!/usr/bin/env python\n+\n+import sys\n+from urllib.parse import urlparse, unquote\n+from requests.utils import get_auth_from_url\n+\n+print(\"Python version:\", sys.version)\n+\n+# Test various proxy URLs\n+test_urls = [\n+    \"http://user:pass@proxy.example.com:8080\",\n+    \"http://user%40domain:pass@proxy.example.com:8080\",  # @ encoded as %40\n+    \"http://user@domain:pass@proxy.example.com:8080\",     # @ not encoded\n+    \"http://user:pass%3Aword@proxy.example.com:8080\",     # : encoded as %3A\n+    \"http://user:pass:word@proxy.example.com:8080\",       # : not encoded\n+]\n+\n+for url in test_urls:\n+    print(f\"\\nTesting URL: {url}\")\n+    parsed = urlparse(url)\n+    print(f\"  urlparse result: username={parsed.username!r}, password={parsed.password!r}\")\n+    \n+    # Test requests' get_auth_from_url\n+    username, password = get_auth_from_url(url)\n+    print(f\"  get_auth_from_url: username={username!r}, password={password!r}\")\n+    \n+    # Manual unquoting to see what happens\n+    if parsed.username:\n+        print(f\"  unquote(username): {unquote(parsed.username)!r}\")\n+    if parsed.password:\n+        print(f\"  unquote(password): {unquote(parsed.password)!r}\")\ndiff --git a/tests/test_utils.py b/tests/test_utils.py\nindex c2186b88..7dea2a3e 100644\n--- a/tests/test_utils.py\n+++ b/tests/test_utils.py\n@@ -401,6 +401,42 @@ def test_get_auth_from_url(url, auth):\n     assert get_auth_from_url(url) == auth\n \n \n+def test_get_auth_from_url_handles_none_from_urlparse():\n+    \"\"\"Test that get_auth_from_url handles None values from urlparse.\n+    \n+    In Python 3.8.12, urlparse may return None for username/password\n+    instead of empty strings, which causes unquote() to raise TypeError.\n+    This test ensures our fix handles this case properly.\n+    \"\"\"\n+    # Mock urlparse to return None values\n+    from unittest.mock import patch, Mock\n+    \n+    with patch('requests.utils.urlparse') as mock_urlparse:\n+        # Case 1: Both username and password are None\n+        mock_result = Mock()\n+        mock_result.username = None\n+        mock_result.password = None\n+        mock_urlparse.return_value = mock_result\n+        \n+        username, password = get_auth_from_url(\"http://proxy.example.com:8080\")\n+        assert username == ''\n+        assert password == ''\n+        \n+        # Case 2: Username is None, password is a string\n+        mock_result.username = None\n+        mock_result.password = 'pass'\n+        username, password = get_auth_from_url(\"http://:pass@proxy.example.com:8080\")\n+        assert username == ''\n+        assert password == 'pass'\n+        \n+        # Case 3: Username is a string, password is None\n+        mock_result.username = 'user'\n+        mock_result.password = None\n+        username, password = get_auth_from_url(\"http://user@proxy.example.com:8080\")\n+        assert username == 'user'\n+        assert password == ''\n+\n+\n @pytest.mark.parametrize(\n     'uri, expected', (\n         (\n", "gold_standard_diff": "From 38f3f8ecb93cadfac03a6b7b3173018ac829d0cf Mon Sep 17 00:00:00 2001\nFrom: Nate Prewitt <nate.prewitt@gmail.com>\nDate: Tue, 4 Jan 2022 08:26:59 -0700\nSubject: [PATCH] Fix auth parsing for proxies\n\nCo-authored-by: adamp01 <@adamp01>\n---\n requests/utils.py   | 4 ++++\n tests/test_utils.py | 8 ++++++++\n 2 files changed, 12 insertions(+)\n\ndiff --git a/requests/utils.py b/requests/utils.py\nindex 1c2ae4e0eb..153776c7f3 100644\n--- a/requests/utils.py\n+++ b/requests/utils.py\n@@ -974,6 +974,10 @@ def prepend_scheme_if_needed(url, new_scheme):\n     if not netloc:\n         netloc, path = path, netloc\n \n+    if auth:\n+        # parse_url doesn't provide the netloc with auth\n+        # so we'll add it ourselves.\n+        netloc = '@'.join([auth, netloc])\n     if scheme is None:\n         scheme = new_scheme\n     if path is None:\ndiff --git a/tests/test_utils.py b/tests/test_utils.py\nindex c2186b885f..8e98397204 100644\n--- a/tests/test_utils.py\n+++ b/tests/test_utils.py\n@@ -602,6 +602,14 @@ def test_parse_header_links(value, expected):\n         ('example.com/path', 'http://example.com/path'),\n         ('//example.com/path', 'http://example.com/path'),\n         ('example.com:80', 'http://example.com:80'),\n+        (\n+            'http://user:pass@example.com/path?query',\n+            'http://user:pass@example.com/path?query'\n+        ),\n+        (\n+            'http://user@example.com/path?query',\n+            'http://user@example.com/path?query'\n+        )\n     ))\n def test_prepend_scheme_if_needed(value, expected):\n     assert prepend_scheme_if_needed(value, 'http') == expected\n", "gold_standard_pr_link": "https://github.com/psf/requests/pull/6028"}