{"instance_id": "django__django-11790", "score": "I", "diff": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed0995..0e43812afa 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -194,6 +194,9 @@ class AuthenticationForm(forms.Form):\n         self.fields['username'].max_length = self.username_field.max_length or 254\n         if self.fields['username'].label is None:\n             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n+        \n+        # Update widget attrs to include maxlength\n+        self.fields['username'].widget.attrs['maxlength'] = username_max_length\n \n     def clean(self):\n         username = self.cleaned_data.get('username')\ndiff --git a/django/contrib/auth/forms.py.backup b/django/contrib/auth/forms.py.backup\nnew file mode 100644\nindex 0000000000..a0cfed0995\n--- /dev/null\n+++ b/django/contrib/auth/forms.py.backup\n@@ -0,0 +1,435 @@\n+import unicodedata\n+\n+from django import forms\n+from django.contrib.auth import (\n+    authenticate, get_user_model, password_validation,\n+)\n+from django.contrib.auth.hashers import (\n+    UNUSABLE_PASSWORD_PREFIX, identify_hasher,\n+)\n+from django.contrib.auth.models import User\n+from django.contrib.auth.tokens import default_token_generator\n+from django.contrib.sites.shortcuts import get_current_site\n+from django.core.mail import EmailMultiAlternatives\n+from django.template import loader\n+from django.utils.encoding import force_bytes\n+from django.utils.http import urlsafe_base64_encode\n+from django.utils.text import capfirst\n+from django.utils.translation import gettext, gettext_lazy as _\n+\n+UserModel = get_user_model()\n+\n+\n+class ReadOnlyPasswordHashWidget(forms.Widget):\n+    template_name = 'auth/widgets/read_only_password_hash.html'\n+    read_only = True\n+\n+    def get_context(self, name, value, attrs):\n+        context = super().get_context(name, value, attrs)\n+        summary = []\n+        if not value or value.startswith(UNUSABLE_PASSWORD_PREFIX):\n+            summary.append({'label': gettext(\"No password set.\")})\n+        else:\n+            try:\n+                hasher = identify_hasher(value)\n+            except ValueError:\n+                summary.append({'label': gettext(\"Invalid password format or unknown hashing algorithm.\")})\n+            else:\n+                for key, value_ in hasher.safe_summary(value).items():\n+                    summary.append({'label': gettext(key), 'value': value_})\n+        context['summary'] = summary\n+        return context\n+\n+\n+class ReadOnlyPasswordHashField(forms.Field):\n+    widget = ReadOnlyPasswordHashWidget\n+\n+    def __init__(self, *args, **kwargs):\n+        kwargs.setdefault(\"required\", False)\n+        super().__init__(*args, **kwargs)\n+\n+    def bound_data(self, data, initial):\n+        # Always return initial because the widget doesn't\n+        # render an input field.\n+        return initial\n+\n+    def has_changed(self, initial, data):\n+        return False\n+\n+\n+class UsernameField(forms.CharField):\n+    def to_python(self, value):\n+        return unicodedata.normalize('NFKC', super().to_python(value))\n+\n+    def widget_attrs(self, widget):\n+        return {\n+            **super().widget_attrs(widget),\n+            'autocapitalize': 'none',\n+            'autocomplete': 'username',\n+        }\n+\n+\n+class UserCreationForm(forms.ModelForm):\n+    \"\"\"\n+    A form that creates a user, with no privileges, from the given username and\n+    password.\n+    \"\"\"\n+    error_messages = {\n+        'password_mismatch': _('The two password fields didn\u2019t match.'),\n+    }\n+    password1 = forms.CharField(\n+        label=_(\"Password\"),\n+        strip=False,\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password'}),\n+        help_text=password_validation.password_validators_help_text_html(),\n+    )\n+    password2 = forms.CharField(\n+        label=_(\"Password confirmation\"),\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password'}),\n+        strip=False,\n+        help_text=_(\"Enter the same password as before, for verification.\"),\n+    )\n+\n+    class Meta:\n+        model = User\n+        fields = (\"username\",)\n+        field_classes = {'username': UsernameField}\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        if self._meta.model.USERNAME_FIELD in self.fields:\n+            self.fields[self._meta.model.USERNAME_FIELD].widget.attrs['autofocus'] = True\n+\n+    def clean_password2(self):\n+        password1 = self.cleaned_data.get(\"password1\")\n+        password2 = self.cleaned_data.get(\"password2\")\n+        if password1 and password2 and password1 != password2:\n+            raise forms.ValidationError(\n+                self.error_messages['password_mismatch'],\n+                code='password_mismatch',\n+            )\n+        return password2\n+\n+    def _post_clean(self):\n+        super()._post_clean()\n+        # Validate the password after self.instance is updated with form data\n+        # by super().\n+        password = self.cleaned_data.get('password2')\n+        if password:\n+            try:\n+                password_validation.validate_password(password, self.instance)\n+            except forms.ValidationError as error:\n+                self.add_error('password2', error)\n+\n+    def save(self, commit=True):\n+        user = super().save(commit=False)\n+        user.set_password(self.cleaned_data[\"password1\"])\n+        if commit:\n+            user.save()\n+        return user\n+\n+\n+class UserChangeForm(forms.ModelForm):\n+    password = ReadOnlyPasswordHashField(\n+        label=_(\"Password\"),\n+        help_text=_(\n+            'Raw passwords are not stored, so there is no way to see this '\n+            'user\u2019s password, but you can change the password using '\n+            '<a href=\"{}\">this form</a>.'\n+        ),\n+    )\n+\n+    class Meta:\n+        model = User\n+        fields = '__all__'\n+        field_classes = {'username': UsernameField}\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        password = self.fields.get('password')\n+        if password:\n+            password.help_text = password.help_text.format('../password/')\n+        user_permissions = self.fields.get('user_permissions')\n+        if user_permissions:\n+            user_permissions.queryset = user_permissions.queryset.select_related('content_type')\n+\n+    def clean_password(self):\n+        # Regardless of what the user provides, return the initial value.\n+        # This is done here, rather than on the field, because the\n+        # field does not have access to the initial value\n+        return self.initial.get('password')\n+\n+\n+class AuthenticationForm(forms.Form):\n+    \"\"\"\n+    Base class for authenticating users. Extend this to get a form that accepts\n+    username/password logins.\n+    \"\"\"\n+    username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))\n+    password = forms.CharField(\n+        label=_(\"Password\"),\n+        strip=False,\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'current-password'}),\n+    )\n+\n+    error_messages = {\n+        'invalid_login': _(\n+            \"Please enter a correct %(username)s and password. Note that both \"\n+            \"fields may be case-sensitive.\"\n+        ),\n+        'inactive': _(\"This account is inactive.\"),\n+    }\n+\n+    def __init__(self, request=None, *args, **kwargs):\n+        \"\"\"\n+        The 'request' parameter is set for custom auth use by subclasses.\n+        The form data comes in via the standard 'data' kwarg.\n+        \"\"\"\n+        self.request = request\n+        self.user_cache = None\n+        super().__init__(*args, **kwargs)\n+\n+        # Set the max length and label for the \"username\" field.\n+        self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n+        self.fields['username'].max_length = self.username_field.max_length or 254\n+        if self.fields['username'].label is None:\n+            self.fields['username'].label = capfirst(self.username_field.verbose_name)\n+\n+    def clean(self):\n+        username = self.cleaned_data.get('username')\n+        password = self.cleaned_data.get('password')\n+\n+        if username is not None and password:\n+            self.user_cache = authenticate(self.request, username=username, password=password)\n+            if self.user_cache is None:\n+                raise self.get_invalid_login_error()\n+            else:\n+                self.confirm_login_allowed(self.user_cache)\n+\n+        return self.cleaned_data\n+\n+    def confirm_login_allowed(self, user):\n+        \"\"\"\n+        Controls whether the given User may log in. This is a policy setting,\n+        independent of end-user authentication. This default behavior is to\n+        allow login by active users, and reject login by inactive users.\n+\n+        If the given user cannot log in, this method should raise a\n+        ``forms.ValidationError``.\n+\n+        If the given user may log in, this method should return None.\n+        \"\"\"\n+        if not user.is_active:\n+            raise forms.ValidationError(\n+                self.error_messages['inactive'],\n+                code='inactive',\n+            )\n+\n+    def get_user(self):\n+        return self.user_cache\n+\n+    def get_invalid_login_error(self):\n+        return forms.ValidationError(\n+            self.error_messages['invalid_login'],\n+            code='invalid_login',\n+            params={'username': self.username_field.verbose_name},\n+        )\n+\n+\n+class PasswordResetForm(forms.Form):\n+    email = forms.EmailField(\n+        label=_(\"Email\"),\n+        max_length=254,\n+        widget=forms.EmailInput(attrs={'autocomplete': 'email'})\n+    )\n+\n+    def send_mail(self, subject_template_name, email_template_name,\n+                  context, from_email, to_email, html_email_template_name=None):\n+        \"\"\"\n+        Send a django.core.mail.EmailMultiAlternatives to `to_email`.\n+        \"\"\"\n+        subject = loader.render_to_string(subject_template_name, context)\n+        # Email subject *must not* contain newlines\n+        subject = ''.join(subject.splitlines())\n+        body = loader.render_to_string(email_template_name, context)\n+\n+        email_message = EmailMultiAlternatives(subject, body, from_email, [to_email])\n+        if html_email_template_name is not None:\n+            html_email = loader.render_to_string(html_email_template_name, context)\n+            email_message.attach_alternative(html_email, 'text/html')\n+\n+        email_message.send()\n+\n+    def get_users(self, email):\n+        \"\"\"Given an email, return matching user(s) who should receive a reset.\n+\n+        This allows subclasses to more easily customize the default policies\n+        that prevent inactive users and users with unusable passwords from\n+        resetting their password.\n+        \"\"\"\n+        active_users = UserModel._default_manager.filter(**{\n+            '%s__iexact' % UserModel.get_email_field_name(): email,\n+            'is_active': True,\n+        })\n+        return (u for u in active_users if u.has_usable_password())\n+\n+    def save(self, domain_override=None,\n+             subject_template_name='registration/password_reset_subject.txt',\n+             email_template_name='registration/password_reset_email.html',\n+             use_https=False, token_generator=default_token_generator,\n+             from_email=None, request=None, html_email_template_name=None,\n+             extra_email_context=None):\n+        \"\"\"\n+        Generate a one-use only link for resetting password and send it to the\n+        user.\n+        \"\"\"\n+        email = self.cleaned_data[\"email\"]\n+        for user in self.get_users(email):\n+            if not domain_override:\n+                current_site = get_current_site(request)\n+                site_name = current_site.name\n+                domain = current_site.domain\n+            else:\n+                site_name = domain = domain_override\n+            context = {\n+                'email': email,\n+                'domain': domain,\n+                'site_name': site_name,\n+                'uid': urlsafe_base64_encode(force_bytes(user.pk)),\n+                'user': user,\n+                'token': token_generator.make_token(user),\n+                'protocol': 'https' if use_https else 'http',\n+                **(extra_email_context or {}),\n+            }\n+            self.send_mail(\n+                subject_template_name, email_template_name, context, from_email,\n+                email, html_email_template_name=html_email_template_name,\n+            )\n+\n+\n+class SetPasswordForm(forms.Form):\n+    \"\"\"\n+    A form that lets a user change set their password without entering the old\n+    password\n+    \"\"\"\n+    error_messages = {\n+        'password_mismatch': _('The two password fields didn\u2019t match.'),\n+    }\n+    new_password1 = forms.CharField(\n+        label=_(\"New password\"),\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password'}),\n+        strip=False,\n+        help_text=password_validation.password_validators_help_text_html(),\n+    )\n+    new_password2 = forms.CharField(\n+        label=_(\"New password confirmation\"),\n+        strip=False,\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password'}),\n+    )\n+\n+    def __init__(self, user, *args, **kwargs):\n+        self.user = user\n+        super().__init__(*args, **kwargs)\n+\n+    def clean_new_password2(self):\n+        password1 = self.cleaned_data.get('new_password1')\n+        password2 = self.cleaned_data.get('new_password2')\n+        if password1 and password2:\n+            if password1 != password2:\n+                raise forms.ValidationError(\n+                    self.error_messages['password_mismatch'],\n+                    code='password_mismatch',\n+                )\n+        password_validation.validate_password(password2, self.user)\n+        return password2\n+\n+    def save(self, commit=True):\n+        password = self.cleaned_data[\"new_password1\"]\n+        self.user.set_password(password)\n+        if commit:\n+            self.user.save()\n+        return self.user\n+\n+\n+class PasswordChangeForm(SetPasswordForm):\n+    \"\"\"\n+    A form that lets a user change their password by entering their old\n+    password.\n+    \"\"\"\n+    error_messages = {\n+        **SetPasswordForm.error_messages,\n+        'password_incorrect': _(\"Your old password was entered incorrectly. Please enter it again.\"),\n+    }\n+    old_password = forms.CharField(\n+        label=_(\"Old password\"),\n+        strip=False,\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'current-password', 'autofocus': True}),\n+    )\n+\n+    field_order = ['old_password', 'new_password1', 'new_password2']\n+\n+    def clean_old_password(self):\n+        \"\"\"\n+        Validate that the old_password field is correct.\n+        \"\"\"\n+        old_password = self.cleaned_data[\"old_password\"]\n+        if not self.user.check_password(old_password):\n+            raise forms.ValidationError(\n+                self.error_messages['password_incorrect'],\n+                code='password_incorrect',\n+            )\n+        return old_password\n+\n+\n+class AdminPasswordChangeForm(forms.Form):\n+    \"\"\"\n+    A form used to change the password of a user in the admin interface.\n+    \"\"\"\n+    error_messages = {\n+        'password_mismatch': _('The two password fields didn\u2019t match.'),\n+    }\n+    required_css_class = 'required'\n+    password1 = forms.CharField(\n+        label=_(\"Password\"),\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password', 'autofocus': True}),\n+        strip=False,\n+        help_text=password_validation.password_validators_help_text_html(),\n+    )\n+    password2 = forms.CharField(\n+        label=_(\"Password (again)\"),\n+        widget=forms.PasswordInput(attrs={'autocomplete': 'new-password'}),\n+        strip=False,\n+        help_text=_(\"Enter the same password as before, for verification.\"),\n+    )\n+\n+    def __init__(self, user, *args, **kwargs):\n+        self.user = user\n+        super().__init__(*args, **kwargs)\n+\n+    def clean_password2(self):\n+        password1 = self.cleaned_data.get('password1')\n+        password2 = self.cleaned_data.get('password2')\n+        if password1 and password2:\n+            if password1 != password2:\n+                raise forms.ValidationError(\n+                    self.error_messages['password_mismatch'],\n+                    code='password_mismatch',\n+                )\n+        password_validation.validate_password(password2, self.user)\n+        return password2\n+\n+    def save(self, commit=True):\n+        \"\"\"Save the new password.\"\"\"\n+        password = self.cleaned_data[\"password1\"]\n+        self.user.set_password(password)\n+        if commit:\n+            self.user.save()\n+        return self.user\n+\n+    @property\n+    def changed_data(self):\n+        data = super().changed_data\n+        for name in self.fields:\n+            if name not in data:\n+                return []\n+        return ['password']\ndiff --git a/test_actual_form.py b/test_actual_form.py\nnew file mode 100644\nindex 0000000000..fa87311299\n--- /dev/null\n+++ b/test_actual_form.py\n@@ -0,0 +1,33 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_TZ=True,\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.forms import AuthenticationForm\n+\n+# Create the form and check the username field\n+form = AuthenticationForm()\n+username_field = form.fields['username']\n+\n+print(\"Field widget attrs:\", username_field.widget.attrs)\n+print(\"\\nRendered form:\")\n+print(form)\n+\n+# Let's also check the HTML of just the username field\n+print(\"\\nJust username field:\")\n+print(form['username'])\ndiff --git a/test_auth_form_maxlength.py b/test_auth_form_maxlength.py\nnew file mode 100644\nindex 0000000000..e161a992bf\n--- /dev/null\n+++ b/test_auth_form_maxlength.py\n@@ -0,0 +1,34 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_TZ=True,\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.forms import AuthenticationForm\n+from django.contrib.auth.models import User\n+\n+# Test that AuthenticationForm username field has maxlength attribute\n+form = AuthenticationForm()\n+username_field_html = str(form['username'])\n+print(\"Username field HTML:\", username_field_html)\n+print(\"Has maxlength attribute:\", 'maxlength' in username_field_html)\n+\n+# Also check the widget attrs directly\n+widget = form.fields['username'].widget\n+attrs = form.fields['username'].widget_attrs(widget)\n+print(\"Widget attrs:\", attrs)\n+print(\"Max length on field:\", form.fields['username'].max_length)\ndiff --git a/test_debug_maxlength.py b/test_debug_maxlength.py\nnew file mode 100644\nindex 0000000000..6a9145be77\n--- /dev/null\n+++ b/test_debug_maxlength.py\n@@ -0,0 +1,44 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_TZ=True,\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.forms import AuthenticationForm, UsernameField\n+from django.forms import CharField\n+\n+# Test inheritance chain\n+print(\"UsernameField MRO:\", UsernameField.__mro__)\n+\n+# Create a regular CharField with max_length\n+regular_char = CharField(max_length=150)\n+print(\"\\nRegular CharField widget_attrs:\", regular_char.widget_attrs(regular_char.widget))\n+\n+# Create a UsernameField with max_length  \n+username_field = UsernameField(max_length=150)\n+print(\"\\nUsernameField widget_attrs:\", username_field.widget_attrs(username_field.widget))\n+\n+# Check the actual form\n+form = AuthenticationForm()\n+print(\"\\nAuthenticationForm username field type:\", type(form.fields['username']))\n+print(\"AuthenticationForm username field max_length:\", form.fields['username'].max_length)\n+\n+# Let's check what happens during rendering\n+from django.forms.boundfield import BoundField\n+bound_field = BoundField(form, form.fields['username'], 'username')\n+print(\"\\nBound field attrs:\", bound_field.field.widget.attrs)\n+print(\"Widget build_attrs:\", bound_field.build_widget_attrs(bound_field.field.widget.attrs))\ndiff --git a/test_issue_confirmed.py b/test_issue_confirmed.py\nnew file mode 100644\nindex 0000000000..93e66bf176\n--- /dev/null\n+++ b/test_issue_confirmed.py\n@@ -0,0 +1,48 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_TZ=True,\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.forms import UsernameField\n+from django import forms\n+\n+# Simulate what happens in AuthenticationForm\n+print(\"=== Simulating AuthenticationForm behavior ===\")\n+\n+# Step 1: Field is created without max_length\n+username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))\n+print(\"1. Initial field max_length:\", username.max_length)\n+print(\"1. Initial widget attrs:\", username.widget.attrs)\n+\n+# Step 2: max_length is set after initialization (like in AuthenticationForm.__init__)\n+username.max_length = 150\n+print(\"\\n2. After setting max_length:\")\n+print(\"2. Field max_length:\", username.max_length)\n+print(\"2. Widget attrs:\", username.widget.attrs)\n+\n+# Step 3: What widget_attrs would return now\n+print(\"\\n3. What widget_attrs returns now:\")\n+print(\"3. widget_attrs():\", username.widget_attrs(username.widget))\n+\n+# The issue: widget attrs are NOT automatically updated when max_length changes\n+\n+print(\"\\n=== The fix would be to update widget attrs after setting max_length ===\")\n+# Fix simulation:\n+username.widget.attrs.update(username.widget_attrs(username.widget))\n+print(\"4. After manual update:\")\n+print(\"4. Widget attrs:\", username.widget.attrs)\ndiff --git a/test_widget_attrs_issue.py b/test_widget_attrs_issue.py\nnew file mode 100644\nindex 0000000000..bcac6bf945\n--- /dev/null\n+++ b/test_widget_attrs_issue.py\n@@ -0,0 +1,59 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    USE_TZ=True,\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.contrib.auth.forms import UsernameField\n+from django.forms import TextInput\n+\n+# Test 1: UsernameField with default widget\n+field1 = UsernameField(max_length=150)\n+print(\"Test 1 - Default widget:\")\n+print(\"  Widget type:\", type(field1.widget))\n+print(\"  Widget attrs:\", field1.widget.attrs)\n+print(\"  Field widget_attrs:\", field1.widget_attrs(field1.widget))\n+\n+# Test 2: UsernameField with explicit widget (like in AuthenticationForm)\n+field2 = UsernameField(max_length=150, widget=TextInput(attrs={'autofocus': True}))\n+print(\"\\nTest 2 - Explicit widget with attrs:\")\n+print(\"  Widget type:\", type(field2.widget))\n+print(\"  Widget attrs:\", field2.widget.attrs)\n+print(\"  Field widget_attrs:\", field2.widget_attrs(field2.widget))\n+\n+# Test 3: How does the field prepare the widget for rendering?\n+from django.forms.boundfield import BoundField\n+from django.forms import Form\n+\n+class TestForm(Form):\n+    username = UsernameField(max_length=150, widget=TextInput(attrs={'autofocus': True}))\n+\n+form = TestForm()\n+bound_field = form['username']\n+\n+# Let's trace through the rendering process\n+print(\"\\nTest 3 - Rendering process:\")\n+print(\"  Bound field widget attrs:\", bound_field.field.widget.attrs)\n+\n+# The key is in how the widget gets its final attrs\n+widget = bound_field.field.widget\n+attrs = bound_field.build_widget_attrs(widget.attrs)\n+print(\"  Built widget attrs:\", attrs)\n+\n+# Now let's see what field.widget_attrs would add\n+field_attrs = bound_field.field.widget_attrs(widget)\n+print(\"  Field widget_attrs result:\", field_attrs)\n", "gold_standard_diff": "diff --git a/django/contrib/auth/forms.py b/django/contrib/auth/forms.py\nindex a0cfed09954e..b4fb55c1b4d2 100644\n--- a/django/contrib/auth/forms.py\n+++ b/django/contrib/auth/forms.py\n@@ -191,7 +191,9 @@ def __init__(self, request=None, *args, **kwargs):\n \n         # Set the max length and label for the \"username\" field.\n         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n-        self.fields['username'].max_length = self.username_field.max_length or 254\n+        username_max_length = self.username_field.max_length or 254\n+        self.fields['username'].max_length = username_max_length\n+        self.fields['username'].widget.attrs['maxlength'] = username_max_length\n         if self.fields['username'].label is None:\n             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n \ndiff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 7085dcfa1148..40e30501445b 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -423,6 +423,7 @@ def test_username_field_max_length_matches_user_model(self):\n         CustomEmailField.objects.create_user(**data)\n         form = AuthenticationForm(None, data)\n         self.assertEqual(form.fields['username'].max_length, 255)\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 255)\n         self.assertEqual(form.errors, {})\n \n     @override_settings(AUTH_USER_MODEL='auth_tests.IntegerUsernameUser')\n@@ -435,6 +436,7 @@ def test_username_field_max_length_defaults_to_254(self):\n         IntegerUsernameUser.objects.create_user(**data)\n         form = AuthenticationForm(None, data)\n         self.assertEqual(form.fields['username'].max_length, 254)\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 254)\n         self.assertEqual(form.errors, {})\n \n     def test_username_field_label(self):\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11790"}