{"instance_id": "django__django-11400", "score": "I", "diff": "diff --git a/django/contrib/admin/filters.py b/django/contrib/admin/filters.py\nindex d65e01d5e2..01c99f834a 100644\n--- a/django/contrib/admin/filters.py\n+++ b/django/contrib/admin/filters.py\n@@ -198,6 +198,9 @@ class RelatedFieldListFilter(FieldListFilter):\n         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n         if related_admin is not None:\n             ordering = related_admin.get_ordering(request)\n+        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n         return field.get_choices(include_blank=False, ordering=ordering)\n \n     def choices(self, changelist):\n@@ -419,4 +422,12 @@ FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)\n class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n     def field_choices(self, field, request, model_admin):\n         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n+        pk_qs = model_admin.get_queryset(request).distinct().values_list(\"%s__pk\" % self.field_path, flat=True)\n+        ordering = ()\n+        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(request)\n+        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n+        return field.get_choices(include_blank=False, limit_choices_to={\"pk__in\": pk_qs}, ordering=ordering)\ndiff --git a/django/contrib/admin/filters.py.backup b/django/contrib/admin/filters.py.backup\nnew file mode 100644\nindex 0000000000..1b85ad1652\n--- /dev/null\n+++ b/django/contrib/admin/filters.py.backup\n@@ -0,0 +1,425 @@\n+\"\"\"\n+This encapsulates the logic for displaying filters in the Django admin.\n+Filters are specified in models with the \"list_filter\" option.\n+\n+Each filter subclass knows how to display a filter for a field that passes a\n+certain test -- e.g. being a DateField or ForeignKey.\n+\"\"\"\n+import datetime\n+\n+from django.contrib.admin.options import IncorrectLookupParameters\n+from django.contrib.admin.utils import (\n+    get_model_from_relation, prepare_lookup_value, reverse_field_path,\n+)\n+from django.core.exceptions import ImproperlyConfigured, ValidationError\n+from django.db import models\n+from django.utils import timezone\n+from django.utils.translation import gettext_lazy as _\n+\n+\n+class ListFilter:\n+    title = None  # Human-readable title to appear in the right sidebar.\n+    template = 'admin/filter.html'\n+\n+    def __init__(self, request, params, model, model_admin):\n+        # This dictionary will eventually contain the request's query string\n+        # parameters actually used by this filter.\n+        self.used_parameters = {}\n+        if self.title is None:\n+            raise ImproperlyConfigured(\n+                \"The list filter '%s' does not specify a 'title'.\"\n+                % self.__class__.__name__\n+            )\n+\n+    def has_output(self):\n+        \"\"\"\n+        Return True if some choices would be output for this filter.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of ListFilter must provide a has_output() method')\n+\n+    def choices(self, changelist):\n+        \"\"\"\n+        Return choices ready to be output in the template.\n+\n+        `changelist` is the ChangeList to be displayed.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of ListFilter must provide a choices() method')\n+\n+    def queryset(self, request, queryset):\n+        \"\"\"\n+        Return the filtered queryset.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of ListFilter must provide a queryset() method')\n+\n+    def expected_parameters(self):\n+        \"\"\"\n+        Return the list of parameter names that are expected from the\n+        request's query string and that will be used by this filter.\n+        \"\"\"\n+        raise NotImplementedError('subclasses of ListFilter must provide an expected_parameters() method')\n+\n+\n+class SimpleListFilter(ListFilter):\n+    # The parameter that should be used in the query string for that filter.\n+    parameter_name = None\n+\n+    def __init__(self, request, params, model, model_admin):\n+        super().__init__(request, params, model, model_admin)\n+        if self.parameter_name is None:\n+            raise ImproperlyConfigured(\n+                \"The list filter '%s' does not specify a 'parameter_name'.\"\n+                % self.__class__.__name__\n+            )\n+        if self.parameter_name in params:\n+            value = params.pop(self.parameter_name)\n+            self.used_parameters[self.parameter_name] = value\n+        lookup_choices = self.lookups(request, model_admin)\n+        if lookup_choices is None:\n+            lookup_choices = ()\n+        self.lookup_choices = list(lookup_choices)\n+\n+    def has_output(self):\n+        return len(self.lookup_choices) > 0\n+\n+    def value(self):\n+        \"\"\"\n+        Return the value (in string format) provided in the request's\n+        query string for this filter, if any, or None if the value wasn't\n+        provided.\n+        \"\"\"\n+        return self.used_parameters.get(self.parameter_name)\n+\n+    def lookups(self, request, model_admin):\n+        \"\"\"\n+        Must be overridden to return a list of tuples (value, verbose value)\n+        \"\"\"\n+        raise NotImplementedError(\n+            'The SimpleListFilter.lookups() method must be overridden to '\n+            'return a list of tuples (value, verbose value).'\n+        )\n+\n+    def expected_parameters(self):\n+        return [self.parameter_name]\n+\n+    def choices(self, changelist):\n+        yield {\n+            'selected': self.value() is None,\n+            'query_string': changelist.get_query_string(remove=[self.parameter_name]),\n+            'display': _('All'),\n+        }\n+        for lookup, title in self.lookup_choices:\n+            yield {\n+                'selected': self.value() == str(lookup),\n+                'query_string': changelist.get_query_string({self.parameter_name: lookup}),\n+                'display': title,\n+            }\n+\n+\n+class FieldListFilter(ListFilter):\n+    _field_list_filters = []\n+    _take_priority_index = 0\n+\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.field = field\n+        self.field_path = field_path\n+        self.title = getattr(field, 'verbose_name', field_path)\n+        super().__init__(request, params, model, model_admin)\n+        for p in self.expected_parameters():\n+            if p in params:\n+                value = params.pop(p)\n+                self.used_parameters[p] = prepare_lookup_value(p, value)\n+\n+    def has_output(self):\n+        return True\n+\n+    def queryset(self, request, queryset):\n+        try:\n+            return queryset.filter(**self.used_parameters)\n+        except (ValueError, ValidationError) as e:\n+            # Fields may raise a ValueError or ValidationError when converting\n+            # the parameters to the correct type.\n+            raise IncorrectLookupParameters(e)\n+\n+    @classmethod\n+    def register(cls, test, list_filter_class, take_priority=False):\n+        if take_priority:\n+            # This is to allow overriding the default filters for certain types\n+            # of fields with some custom filters. The first found in the list\n+            # is used in priority.\n+            cls._field_list_filters.insert(\n+                cls._take_priority_index, (test, list_filter_class))\n+            cls._take_priority_index += 1\n+        else:\n+            cls._field_list_filters.append((test, list_filter_class))\n+\n+    @classmethod\n+    def create(cls, field, request, params, model, model_admin, field_path):\n+        for test, list_filter_class in cls._field_list_filters:\n+            if test(field):\n+                return list_filter_class(field, request, params, model, model_admin, field_path=field_path)\n+\n+\n+class RelatedFieldListFilter(FieldListFilter):\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        other_model = get_model_from_relation(field)\n+        self.lookup_kwarg = '%s__%s__exact' % (field_path, field.target_field.name)\n+        self.lookup_kwarg_isnull = '%s__isnull' % field_path\n+        self.lookup_val = params.get(self.lookup_kwarg)\n+        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n+        super().__init__(field, request, params, model, model_admin, field_path)\n+        self.lookup_choices = self.field_choices(field, request, model_admin)\n+        if hasattr(field, 'verbose_name'):\n+            self.lookup_title = field.verbose_name\n+        else:\n+            self.lookup_title = other_model._meta.verbose_name\n+        self.title = self.lookup_title\n+        self.empty_value_display = model_admin.get_empty_value_display()\n+\n+    @property\n+    def include_empty_choice(self):\n+        \"\"\"\n+        Return True if a \"(None)\" choice should be included, which filters\n+        out everything except empty relationships.\n+        \"\"\"\n+        return self.field.null or (self.field.is_relation and self.field.many_to_many)\n+\n+    def has_output(self):\n+        if self.include_empty_choice:\n+            extra = 1\n+        else:\n+            extra = 0\n+        return len(self.lookup_choices) + extra > 1\n+\n+    def expected_parameters(self):\n+        return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n+\n+    def field_choices(self, field, request, model_admin):\n+        ordering = ()\n+        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(request)\n+        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n+        return field.get_choices(include_blank=False, ordering=ordering)\n+\n+    def choices(self, changelist):\n+        yield {\n+            'selected': self.lookup_val is None and not self.lookup_val_isnull,\n+            'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n+            'display': _('All'),\n+        }\n+        for pk_val, val in self.lookup_choices:\n+            yield {\n+                'selected': self.lookup_val == str(pk_val),\n+                'query_string': changelist.get_query_string({self.lookup_kwarg: pk_val}, [self.lookup_kwarg_isnull]),\n+                'display': val,\n+            }\n+        if self.include_empty_choice:\n+            yield {\n+                'selected': bool(self.lookup_val_isnull),\n+                'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n+                'display': self.empty_value_display,\n+            }\n+\n+\n+FieldListFilter.register(lambda f: f.remote_field, RelatedFieldListFilter)\n+\n+\n+class BooleanFieldListFilter(FieldListFilter):\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.lookup_kwarg = '%s__exact' % field_path\n+        self.lookup_kwarg2 = '%s__isnull' % field_path\n+        self.lookup_val = params.get(self.lookup_kwarg)\n+        self.lookup_val2 = params.get(self.lookup_kwarg2)\n+        super().__init__(field, request, params, model, model_admin, field_path)\n+        if (self.used_parameters and self.lookup_kwarg in self.used_parameters and\n+                self.used_parameters[self.lookup_kwarg] in ('1', '0')):\n+            self.used_parameters[self.lookup_kwarg] = bool(int(self.used_parameters[self.lookup_kwarg]))\n+\n+    def expected_parameters(self):\n+        return [self.lookup_kwarg, self.lookup_kwarg2]\n+\n+    def choices(self, changelist):\n+        for lookup, title in (\n+                (None, _('All')),\n+                ('1', _('Yes')),\n+                ('0', _('No'))):\n+            yield {\n+                'selected': self.lookup_val == lookup and not self.lookup_val2,\n+                'query_string': changelist.get_query_string({self.lookup_kwarg: lookup}, [self.lookup_kwarg2]),\n+                'display': title,\n+            }\n+        if self.field.null:\n+            yield {\n+                'selected': self.lookup_val2 == 'True',\n+                'query_string': changelist.get_query_string({self.lookup_kwarg2: 'True'}, [self.lookup_kwarg]),\n+                'display': _('Unknown'),\n+            }\n+\n+\n+FieldListFilter.register(lambda f: isinstance(f, models.BooleanField), BooleanFieldListFilter)\n+\n+\n+class ChoicesFieldListFilter(FieldListFilter):\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.lookup_kwarg = '%s__exact' % field_path\n+        self.lookup_kwarg_isnull = '%s__isnull' % field_path\n+        self.lookup_val = params.get(self.lookup_kwarg)\n+        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n+        super().__init__(field, request, params, model, model_admin, field_path)\n+\n+    def expected_parameters(self):\n+        return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n+\n+    def choices(self, changelist):\n+        yield {\n+            'selected': self.lookup_val is None,\n+            'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n+            'display': _('All')\n+        }\n+        none_title = ''\n+        for lookup, title in self.field.flatchoices:\n+            if lookup is None:\n+                none_title = title\n+                continue\n+            yield {\n+                'selected': str(lookup) == self.lookup_val,\n+                'query_string': changelist.get_query_string({self.lookup_kwarg: lookup}, [self.lookup_kwarg_isnull]),\n+                'display': title,\n+            }\n+        if none_title:\n+            yield {\n+                'selected': bool(self.lookup_val_isnull),\n+                'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n+                'display': none_title,\n+            }\n+\n+\n+FieldListFilter.register(lambda f: bool(f.choices), ChoicesFieldListFilter)\n+\n+\n+class DateFieldListFilter(FieldListFilter):\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.field_generic = '%s__' % field_path\n+        self.date_params = {k: v for k, v in params.items() if k.startswith(self.field_generic)}\n+\n+        now = timezone.now()\n+        # When time zone support is enabled, convert \"now\" to the user's time\n+        # zone so Django's definition of \"Today\" matches what the user expects.\n+        if timezone.is_aware(now):\n+            now = timezone.localtime(now)\n+\n+        if isinstance(field, models.DateTimeField):\n+            today = now.replace(hour=0, minute=0, second=0, microsecond=0)\n+        else:       # field is a models.DateField\n+            today = now.date()\n+        tomorrow = today + datetime.timedelta(days=1)\n+        if today.month == 12:\n+            next_month = today.replace(year=today.year + 1, month=1, day=1)\n+        else:\n+            next_month = today.replace(month=today.month + 1, day=1)\n+        next_year = today.replace(year=today.year + 1, month=1, day=1)\n+\n+        self.lookup_kwarg_since = '%s__gte' % field_path\n+        self.lookup_kwarg_until = '%s__lt' % field_path\n+        self.links = (\n+            (_('Any date'), {}),\n+            (_('Today'), {\n+                self.lookup_kwarg_since: str(today),\n+                self.lookup_kwarg_until: str(tomorrow),\n+            }),\n+            (_('Past 7 days'), {\n+                self.lookup_kwarg_since: str(today - datetime.timedelta(days=7)),\n+                self.lookup_kwarg_until: str(tomorrow),\n+            }),\n+            (_('This month'), {\n+                self.lookup_kwarg_since: str(today.replace(day=1)),\n+                self.lookup_kwarg_until: str(next_month),\n+            }),\n+            (_('This year'), {\n+                self.lookup_kwarg_since: str(today.replace(month=1, day=1)),\n+                self.lookup_kwarg_until: str(next_year),\n+            }),\n+        )\n+        if field.null:\n+            self.lookup_kwarg_isnull = '%s__isnull' % field_path\n+            self.links += (\n+                (_('No date'), {self.field_generic + 'isnull': 'True'}),\n+                (_('Has date'), {self.field_generic + 'isnull': 'False'}),\n+            )\n+        super().__init__(field, request, params, model, model_admin, field_path)\n+\n+    def expected_parameters(self):\n+        params = [self.lookup_kwarg_since, self.lookup_kwarg_until]\n+        if self.field.null:\n+            params.append(self.lookup_kwarg_isnull)\n+        return params\n+\n+    def choices(self, changelist):\n+        for title, param_dict in self.links:\n+            yield {\n+                'selected': self.date_params == param_dict,\n+                'query_string': changelist.get_query_string(param_dict, [self.field_generic]),\n+                'display': title,\n+            }\n+\n+\n+FieldListFilter.register(\n+    lambda f: isinstance(f, models.DateField), DateFieldListFilter)\n+\n+\n+# This should be registered last, because it's a last resort. For example,\n+# if a field is eligible to use the BooleanFieldListFilter, that'd be much\n+# more appropriate, and the AllValuesFieldListFilter won't get used for it.\n+class AllValuesFieldListFilter(FieldListFilter):\n+    def __init__(self, field, request, params, model, model_admin, field_path):\n+        self.lookup_kwarg = field_path\n+        self.lookup_kwarg_isnull = '%s__isnull' % field_path\n+        self.lookup_val = params.get(self.lookup_kwarg)\n+        self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n+        self.empty_value_display = model_admin.get_empty_value_display()\n+        parent_model, reverse_path = reverse_field_path(model, field_path)\n+        # Obey parent ModelAdmin queryset when deciding which options to show\n+        if model == parent_model:\n+            queryset = model_admin.get_queryset(request)\n+        else:\n+            queryset = parent_model._default_manager.all()\n+        self.lookup_choices = queryset.distinct().order_by(field.name).values_list(field.name, flat=True)\n+        super().__init__(field, request, params, model, model_admin, field_path)\n+\n+    def expected_parameters(self):\n+        return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n+\n+    def choices(self, changelist):\n+        yield {\n+            'selected': self.lookup_val is None and self.lookup_val_isnull is None,\n+            'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n+            'display': _('All'),\n+        }\n+        include_none = False\n+        for val in self.lookup_choices:\n+            if val is None:\n+                include_none = True\n+                continue\n+            val = str(val)\n+            yield {\n+                'selected': self.lookup_val == val,\n+                'query_string': changelist.get_query_string({self.lookup_kwarg: val}, [self.lookup_kwarg_isnull]),\n+                'display': val,\n+            }\n+        if include_none:\n+            yield {\n+                'selected': bool(self.lookup_val_isnull),\n+                'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n+                'display': self.empty_value_display,\n+            }\n+\n+\n+FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)\n+\n+\n+class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n+    def field_choices(self, field, request, model_admin):\n+        pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n+        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\ndiff --git a/django/contrib/admin/filters.py.rej b/django/contrib/admin/filters.py.rej\nnew file mode 100644\nindex 0000000000..923d8f35aa\n--- /dev/null\n+++ b/django/contrib/admin/filters.py.rej\n@@ -0,0 +1,25 @@\n+--- django/contrib/admin/filters.py\n++++ django/contrib/admin/filters.py\n+@@ -199,6 +199,9 @@ class RelatedFieldListFilter(FieldListFilter):\n+         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+         if related_admin is not None:\n+             ordering = related_admin.get_ordering(request)\n++        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n++        if not ordering:\n++            ordering = field.remote_field.model._meta.ordering\n+         return field.get_choices(include_blank=False, ordering=ordering)\n+ \n+     def choices(self, changelist):\n+@@ -422,4 +425,11 @@ class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n+ class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n+     def field_choices(self, field, request, model_admin):\n+         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n+-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n++        ordering = ()\n++        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n++        if related_admin is not None:\n++            ordering = related_admin.get_ordering(request)\n++        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n++        if not ordering:\n++            ordering = field.remote_field.model._meta.ordering\n++        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\ndiff --git a/fix_ordering.patch b/fix_ordering.patch\nnew file mode 100644\nindex 0000000000..0ad7e2c0a5\n--- /dev/null\n+++ b/fix_ordering.patch\n@@ -0,0 +1,25 @@\n+--- a/django/contrib/admin/filters.py\n++++ b/django/contrib/admin/filters.py\n+@@ -199,6 +199,9 @@ class RelatedFieldListFilter(FieldListFilter):\n+         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+         if related_admin is not None:\n+             ordering = related_admin.get_ordering(request)\n++        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n++        if not ordering:\n++            ordering = field.remote_field.model._meta.ordering\n+         return field.get_choices(include_blank=False, ordering=ordering)\n+ \n+     def choices(self, changelist):\n+@@ -422,4 +425,11 @@ class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n+ class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n+     def field_choices(self, field, request, model_admin):\n+         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n+-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n++        ordering = ()\n++        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n++        if related_admin is not None:\n++            ordering = related_admin.get_ordering(request)\n++        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n++        if not ordering:\n++            ordering = field.remote_field.model._meta.ordering\n++        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\ndiff --git a/temp_edit.py b/temp_edit.py\nnew file mode 100644\nindex 0000000000..be9e7d43ab\n--- /dev/null\n+++ b/temp_edit.py\n@@ -0,0 +1,44 @@\n+# Read the file\n+with open('django/contrib/admin/filters.py', 'r') as f:\n+    lines = f.readlines()\n+\n+# Find the RelatedOnlyFieldListFilter class and modify its field_choices method\n+in_field_choices = False\n+new_lines = []\n+indent_level = None\n+\n+for i, line in enumerate(lines):\n+    if 'class RelatedOnlyFieldListFilter(RelatedFieldListFilter):' in line:\n+        new_lines.append(line)\n+    elif 'def field_choices(self, field, request, model_admin):' in line and i > 420:\n+        new_lines.append(line)\n+        in_field_choices = True\n+        indent_level = len(line) - len(line.lstrip())\n+    elif in_field_choices and line.strip() and not line[indent_level:].startswith(' '):\n+        # End of method, add our new content before this line\n+        new_content = '''        pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n+        ordering = ()\n+        related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n+        if related_admin is not None:\n+            ordering = related_admin.get_ordering(request)\n+        # If no ordering is specified in ModelAdmin, fall back to the model's Meta.ordering\n+        if not ordering:\n+            ordering = field.remote_field.model._meta.ordering\n+        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\n+'''\n+        new_lines.append(new_content)\n+        in_field_choices = False\n+        # Don't include the original implementation lines\n+    elif in_field_choices and 'return field.get_choices' in line:\n+        # Skip the original return line\n+        in_field_choices = False\n+        continue\n+    elif in_field_choices and 'pk_qs = model_admin.get_queryset' in line:\n+        # Skip the original pk_qs line\n+        continue\n+    else:\n+        new_lines.append(line)\n+\n+# Write back\n+with open('django/contrib/admin/filters.py', 'w') as f:\n+    f.writelines(new_lines)\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..fe4698eaf7\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,157 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test import RequestFactory\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+        'django.contrib.admin',\n+        'django.contrib.sessions',\n+        'django.contrib.messages',\n+    ],\n+    MIDDLEWARE=[\n+        'django.middleware.security.SecurityMiddleware',\n+        'django.contrib.sessions.middleware.SessionMiddleware',\n+        'django.middleware.common.CommonMiddleware',\n+        'django.middleware.csrf.CsrfViewMiddleware',\n+        'django.contrib.auth.middleware.AuthenticationMiddleware',\n+        'django.contrib.messages.middleware.MessageMiddleware',\n+    ],\n+    SECRET_KEY='test',\n+    ROOT_URLCONF='test_urls',\n+    TEMPLATES=[{\n+        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        'DIRS': [],\n+        'APP_DIRS': True,\n+        'OPTIONS': {\n+            'context_processors': [\n+                'django.template.context_processors.debug',\n+                'django.template.context_processors.request',\n+                'django.contrib.auth.context_processors.auth',\n+                'django.contrib.messages.context_processors.messages',\n+            ],\n+        },\n+    }],\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.contrib import admin\n+from django.contrib.admin.filters import RelatedFieldListFilter, RelatedOnlyFieldListFilter\n+from django.db import connection\n+from django.db.migrations.executor import MigrationExecutor\n+\n+# Create test models\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        ordering = ['name']  # This is the ordering that should be used\n+        \n+    def __str__(self):\n+        return self.name\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+\n+# Create test data\n+author1 = Author.objects.create(name=\"Zoe\")\n+author2 = Author.objects.create(name=\"Alice\")\n+author3 = Author.objects.create(name=\"Bob\")\n+\n+book1 = Book.objects.create(title=\"Book 1\", author=author1)\n+book2 = Book.objects.create(title=\"Book 2\", author=author2)\n+book3 = Book.objects.create(title=\"Book 3\", author=author3)\n+\n+# Setup admin\n+class AuthorAdmin(admin.ModelAdmin):\n+    pass\n+\n+class BookAdmin(admin.ModelAdmin):\n+    list_filter = ['author']\n+\n+admin.site.register(Author, AuthorAdmin)\n+admin.site.register(Book, BookAdmin)\n+\n+# Test RelatedFieldListFilter\n+request_factory = RequestFactory()\n+request = request_factory.get('/')\n+request.user = None\n+\n+# Get the field\n+field = Book._meta.get_field('author')\n+\n+# Create model admin instance\n+book_admin = BookAdmin(Book, admin.site)\n+\n+# Create the filter\n+params = {}\n+filter_instance = RelatedFieldListFilter(field, request, params, Book, book_admin, 'author')\n+\n+# Get field choices\n+choices = filter_instance.field_choices(field, request, book_admin)\n+\n+print(\"Testing RelatedFieldListFilter:\")\n+print(\"Choices (should be ordered by name - Alice, Bob, Zoe):\")\n+for choice in choices:\n+    print(f\"  {choice[0]}: {choice[1]}\")\n+\n+# Test RelatedOnlyFieldListFilter\n+class BookAdmin2(admin.ModelAdmin):\n+    list_filter = ['author']\n+    \n+    def get_queryset(self, request):\n+        # Return only books by Alice and Zoe (not Bob)\n+        return super().get_queryset(request).filter(author__in=[author1, author2])\n+\n+book_admin2 = BookAdmin2(Book, admin.site)\n+filter_instance2 = RelatedOnlyFieldListFilter(field, request, params, Book, book_admin2, 'author')\n+\n+# Get field choices\n+choices2 = filter_instance2.field_choices(field, request, book_admin2)\n+\n+print(\"\\nTesting RelatedOnlyFieldListFilter:\")\n+print(\"Choices (should be ordered by name and only show Alice and Zoe):\")\n+for choice in choices2:\n+    print(f\"  {choice[0]}: {choice[1]}\")\n+\n+# Test with custom ordering in ModelAdmin\n+class AuthorAdminWithOrdering(admin.ModelAdmin):\n+    ordering = ['-name']  # Reverse order\n+\n+admin.site.unregister(Author)\n+admin.site.register(Author, AuthorAdminWithOrdering)\n+\n+# Test again\n+book_admin3 = BookAdmin(Book, admin.site)\n+filter_instance3 = RelatedFieldListFilter(field, request, params, Book, book_admin3, 'author')\n+choices3 = filter_instance3.field_choices(field, request, book_admin3)\n+\n+print(\"\\nTesting RelatedFieldListFilter with ModelAdmin ordering:\")\n+print(\"Choices (should be reverse ordered - Zoe, Bob, Alice):\")\n+for choice in choices3:\n+    print(f\"  {choice[0]}: {choice[1]}\")\ndiff --git a/test_ordering_issue.py b/test_ordering_issue.py\nnew file mode 100644\nindex 0000000000..ccfc6e2bfe\n--- /dev/null\n+++ b/test_ordering_issue.py\n@@ -0,0 +1,55 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+        'django.contrib.admin',\n+    ],\n+    SECRET_KEY='test',\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.contrib import admin\n+\n+# Create test models\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+        ordering = ['name']  # This is the ordering that should be used\n+        \n+    def __str__(self):\n+        return self.name\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=100)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test that we can access the ordering\n+print(\"Author._meta.ordering:\", Author._meta.ordering)\n+\n+# Check how get_choices works\n+from django.db.models.fields import Field\n+field = Book._meta.get_field('author')\n+print(\"Field type:\", type(field))\n+print(\"Related model:\", field.remote_field.model)\n+print(\"Related model ordering:\", field.remote_field.model._meta.ordering)\n", "gold_standard_diff": "diff --git a/django/contrib/admin/filters.py b/django/contrib/admin/filters.py\nindex d65e01d5e2fe..a9e5563c6cbf 100644\n--- a/django/contrib/admin/filters.py\n+++ b/django/contrib/admin/filters.py\n@@ -193,11 +193,17 @@ def has_output(self):\n     def expected_parameters(self):\n         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n \n-    def field_choices(self, field, request, model_admin):\n-        ordering = ()\n+    def field_admin_ordering(self, field, request, model_admin):\n+        \"\"\"\n+        Return the model admin's ordering for related field, if provided.\n+        \"\"\"\n         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n         if related_admin is not None:\n-            ordering = related_admin.get_ordering(request)\n+            return related_admin.get_ordering(request)\n+        return ()\n+\n+    def field_choices(self, field, request, model_admin):\n+        ordering = self.field_admin_ordering(field, request, model_admin)\n         return field.get_choices(include_blank=False, ordering=ordering)\n \n     def choices(self, changelist):\n@@ -419,4 +425,5 @@ def choices(self, changelist):\n class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n     def field_choices(self, field, request, model_admin):\n         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n-        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs})\n+        ordering = self.field_admin_ordering(field, request, model_admin)\n+        return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\ndiff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py\nindex 194514c90008..1aad845470f4 100644\n--- a/django/db/models/fields/__init__.py\n+++ b/django/db/models/fields/__init__.py\n@@ -825,9 +825,11 @@ def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_\n             if hasattr(self.remote_field, 'get_related_field')\n             else 'pk'\n         )\n+        qs = rel_model._default_manager.complex_filter(limit_choices_to)\n+        if ordering:\n+            qs = qs.order_by(*ordering)\n         return (blank_choice if include_blank else []) + [\n-            (choice_func(x), str(x))\n-            for x in rel_model._default_manager.complex_filter(limit_choices_to).order_by(*ordering)\n+            (choice_func(x), str(x)) for x in qs\n         ]\n \n     def value_to_string(self, obj):\ndiff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py\nindex eb6b9342594b..700410a086bb 100644\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -122,8 +122,11 @@ def get_choices(self, include_blank=True, blank_choice=BLANK_CHOICE_DASH, orderi\n         Analog of django.db.models.fields.Field.get_choices(), provided\n         initially for utilization by RelatedFieldListFilter.\n         \"\"\"\n+        qs = self.related_model._default_manager.all()\n+        if ordering:\n+            qs = qs.order_by(*ordering)\n         return (blank_choice if include_blank else []) + [\n-            (x.pk, str(x)) for x in self.related_model._default_manager.order_by(*ordering)\n+            (x.pk, str(x)) for x in qs\n         ]\n \n     def is_hidden(self):\ndiff --git a/docs/releases/2.2.5.txt b/docs/releases/2.2.5.txt\nindex 0b9310a34471..9f143c8d96d4 100644\n--- a/docs/releases/2.2.5.txt\n+++ b/docs/releases/2.2.5.txt\n@@ -17,3 +17,8 @@ Bugfixes\n   :class:`~django.contrib.postgres.fields.JSONField` and\n   :class:`~django.contrib.postgres.fields.HStoreField` when using on\n   expressions with params (:ticket:`30672`).\n+\n+* Fixed a regression in Django 2.2 where\n+  :attr:`ModelAdmin.list_filter <django.contrib.admin.ModelAdmin.list_filter>`\n+  choices to foreign objects don't respect a model's ``Meta.ordering``\n+  (:ticket:`30449`).\ndiff --git a/tests/admin_filters/tests.py b/tests/admin_filters/tests.py\nindex 4ff7d012e553..4e6f1f4732c9 100644\n--- a/tests/admin_filters/tests.py\n+++ b/tests/admin_filters/tests.py\n@@ -591,6 +591,22 @@ class BookAdmin(ModelAdmin):\n         expected = [(self.john.pk, 'John Blue'), (self.jack.pk, 'Jack Red')]\n         self.assertEqual(filterspec.lookup_choices, expected)\n \n+    def test_relatedfieldlistfilter_foreignkey_default_ordering(self):\n+        \"\"\"RelatedFieldListFilter ordering respects Model.ordering.\"\"\"\n+        class BookAdmin(ModelAdmin):\n+            list_filter = ('employee',)\n+\n+        self.addCleanup(setattr, Employee._meta, 'ordering', Employee._meta.ordering)\n+        Employee._meta.ordering = ('name',)\n+        modeladmin = BookAdmin(Book, site)\n+\n+        request = self.request_factory.get('/')\n+        request.user = self.alfred\n+        changelist = modeladmin.get_changelist_instance(request)\n+        filterspec = changelist.get_filters(request)[0][0]\n+        expected = [(self.jack.pk, 'Jack Red'), (self.john.pk, 'John Blue')]\n+        self.assertEqual(filterspec.lookup_choices, expected)\n+\n     def test_relatedfieldlistfilter_manytomany(self):\n         modeladmin = BookAdmin(Book, site)\n \n@@ -696,6 +712,23 @@ def test_relatedfieldlistfilter_reverse_relationships(self):\n         filterspec = changelist.get_filters(request)[0]\n         self.assertEqual(len(filterspec), 0)\n \n+    def test_relatedfieldlistfilter_reverse_relationships_default_ordering(self):\n+        self.addCleanup(setattr, Book._meta, 'ordering', Book._meta.ordering)\n+        Book._meta.ordering = ('title',)\n+        modeladmin = CustomUserAdmin(User, site)\n+\n+        request = self.request_factory.get('/')\n+        request.user = self.alfred\n+        changelist = modeladmin.get_changelist_instance(request)\n+        filterspec = changelist.get_filters(request)[0][0]\n+        expected = [\n+            (self.bio_book.pk, 'Django: a biography'),\n+            (self.djangonaut_book.pk, 'Djangonaut: an art of living'),\n+            (self.guitar_book.pk, 'Guitar for dummies'),\n+            (self.django_book.pk, 'The Django Book')\n+        ]\n+        self.assertEqual(filterspec.lookup_choices, expected)\n+\n     def test_relatedonlyfieldlistfilter_foreignkey(self):\n         modeladmin = BookAdminRelatedOnlyFilter(Book, site)\n \n@@ -708,6 +741,57 @@ def test_relatedonlyfieldlistfilter_foreignkey(self):\n         expected = [(self.alfred.pk, 'alfred'), (self.bob.pk, 'bob')]\n         self.assertEqual(sorted(filterspec.lookup_choices), sorted(expected))\n \n+    def test_relatedonlyfieldlistfilter_foreignkey_ordering(self):\n+        \"\"\"RelatedOnlyFieldListFilter ordering respects ModelAdmin.ordering.\"\"\"\n+        class EmployeeAdminWithOrdering(ModelAdmin):\n+            ordering = ('name',)\n+\n+        class BookAdmin(ModelAdmin):\n+            list_filter = (\n+                ('employee', RelatedOnlyFieldListFilter),\n+            )\n+\n+        albert = Employee.objects.create(name='Albert Green', department=self.dev)\n+        self.djangonaut_book.employee = albert\n+        self.djangonaut_book.save()\n+        self.bio_book.employee = self.jack\n+        self.bio_book.save()\n+\n+        site.register(Employee, EmployeeAdminWithOrdering)\n+        self.addCleanup(lambda: site.unregister(Employee))\n+        modeladmin = BookAdmin(Book, site)\n+\n+        request = self.request_factory.get('/')\n+        request.user = self.alfred\n+        changelist = modeladmin.get_changelist_instance(request)\n+        filterspec = changelist.get_filters(request)[0][0]\n+        expected = [(albert.pk, 'Albert Green'), (self.jack.pk, 'Jack Red')]\n+        self.assertEqual(filterspec.lookup_choices, expected)\n+\n+    def test_relatedonlyfieldlistfilter_foreignkey_default_ordering(self):\n+        \"\"\"RelatedOnlyFieldListFilter ordering respects Meta.ordering.\"\"\"\n+        class BookAdmin(ModelAdmin):\n+            list_filter = (\n+                ('employee', RelatedOnlyFieldListFilter),\n+            )\n+\n+        albert = Employee.objects.create(name='Albert Green', department=self.dev)\n+        self.djangonaut_book.employee = albert\n+        self.djangonaut_book.save()\n+        self.bio_book.employee = self.jack\n+        self.bio_book.save()\n+\n+        self.addCleanup(setattr, Employee._meta, 'ordering', Employee._meta.ordering)\n+        Employee._meta.ordering = ('name',)\n+        modeladmin = BookAdmin(Book, site)\n+\n+        request = self.request_factory.get('/')\n+        request.user = self.alfred\n+        changelist = modeladmin.get_changelist_instance(request)\n+        filterspec = changelist.get_filters(request)[0][0]\n+        expected = [(albert.pk, 'Albert Green'), (self.jack.pk, 'Jack Red')]\n+        self.assertEqual(filterspec.lookup_choices, expected)\n+\n     def test_relatedonlyfieldlistfilter_underscorelookup_foreignkey(self):\n         Department.objects.create(code='TEST', description='Testing')\n         self.djangonaut_book.employee = self.john\ndiff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex bb82c7b93dac..abc5273d9021 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -222,9 +222,9 @@ class GetChoicesOrderingTests(TestCase):\n \n     @classmethod\n     def setUpTestData(cls):\n-        cls.foo1 = Foo.objects.create(a='a', d='12.34')\n+        cls.foo1 = Foo.objects.create(a='a', d='12.35')\n         cls.foo2 = Foo.objects.create(a='b', d='12.34')\n-        cls.bar1 = Bar.objects.create(a=cls.foo1, b='a')\n+        cls.bar1 = Bar.objects.create(a=cls.foo1, b='b')\n         cls.bar2 = Bar.objects.create(a=cls.foo2, b='a')\n         cls.field = Bar._meta.get_field('a')\n \n@@ -241,6 +241,14 @@ def test_get_choices(self):\n             [self.foo2, self.foo1]\n         )\n \n+    def test_get_choices_default_ordering(self):\n+        self.addCleanup(setattr, Foo._meta, 'ordering', Foo._meta.ordering)\n+        Foo._meta.ordering = ('d',)\n+        self.assertChoicesEqual(\n+            self.field.get_choices(include_blank=False),\n+            [self.foo2, self.foo1]\n+        )\n+\n     def test_get_choices_reverse_related_field(self):\n         self.assertChoicesEqual(\n             self.field.remote_field.get_choices(include_blank=False, ordering=('a',)),\n@@ -250,3 +258,11 @@ def test_get_choices_reverse_related_field(self):\n             self.field.remote_field.get_choices(include_blank=False, ordering=('-a',)),\n             [self.bar2, self.bar1]\n         )\n+\n+    def test_get_choices_reverse_related_field_default_ordering(self):\n+        self.addCleanup(setattr, Bar._meta, 'ordering', Bar._meta.ordering)\n+        Bar._meta.ordering = ('b',)\n+        self.assertChoicesEqual(\n+            self.field.remote_field.get_choices(include_blank=False),\n+            [self.bar2, self.bar1]\n+        )\n", "gold_standard_pr_link": "https://github.com/django/django/pull/11400"}