{"instance_id": "sphinx-doc__sphinx-7748", "score": "I", "diff": "diff --git a/fix_multiple_signatures.py b/fix_multiple_signatures.py\nnew file mode 100644\nindex 000000000..1ddc24cfd\n--- /dev/null\n+++ b/fix_multiple_signatures.py\n@@ -0,0 +1,82 @@\n+\"\"\"\n+This script shows the proposed fix for handling multiple overloaded signatures\n+in docstrings when using autodoc_docstring_signature.\n+\"\"\"\n+\n+import re\n+from typing import List, Tuple, Optional\n+\n+# The regex from sphinx autodoc\n+py_ext_sig_re = re.compile(\n+    r'''^ ([\\w.]+::)?            # explicit module name\n+          ([\\w.]+\\.)?            # module and/or class name(s)\n+          (\\w+)  \\s*             # thing name\n+          (?: \\((.*)\\)           # optional: arguments\n+           (?:\\s* -> \\s* (.*))?  #           return annotation\n+          )? $                   # and nothing more\n+          ''', re.VERBOSE)\n+\n+\n+def find_all_signatures(doclines: List[str], valid_names: List[str]) -> List[Tuple[str, str]]:\n+    \"\"\"\n+    Find all consecutive signature lines at the beginning of a docstring.\n+    \n+    Returns a list of (args, retann) tuples for each found signature.\n+    \"\"\"\n+    signatures = []\n+    \n+    for i, line in enumerate(doclines):\n+        # Try to match the line (with leading/trailing whitespace stripped)\n+        match = py_ext_sig_re.match(line.strip())\n+        if not match:\n+            # Stop at the first non-signature line\n+            break\n+            \n+        exmod, path, base, args, retann = match.groups()\n+        \n+        # Check if the base name is valid\n+        if base in valid_names:\n+            signatures.append((args, retann))\n+    \n+    return signatures\n+\n+\n+def format_multiple_signatures(signatures: List[Tuple[str, str]], sep: str = \"\\n\") -> str:\n+    \"\"\"\n+    Format multiple signatures into a single string.\n+    \n+    Each signature is formatted as (args) -> retann or just (args) if no retann.\n+    \"\"\"\n+    formatted = []\n+    for args, retann in signatures:\n+        if args is not None:\n+            sig = \"(%s)\" % args\n+            if retann:\n+                sig += \" -> %s\" % retann\n+            formatted.append(sig)\n+    \n+    return sep.join(formatted)\n+\n+\n+# Test the implementation\n+if __name__ == \"__main__\":\n+    # Test docstring with multiple signatures\n+    docstring = \"\"\"overloaded_method(self) -> None\n+        overloaded_method(self, x: int) -> int\n+        overloaded_method(self, x: int, y: int) -> int\n+        \n+        This method has multiple overloaded signatures.\n+        This is common in SWIG-wrapped C++ code.\n+        \"\"\"\n+    \n+    lines = docstring.strip().split('\\n')\n+    valid_names = ['overloaded_method']\n+    \n+    signatures = find_all_signatures(lines, valid_names)\n+    \n+    print(\"Found signatures:\")\n+    for args, retann in signatures:\n+        print(f\"  args: {args}, retann: {retann}\")\n+    \n+    print(\"\\nFormatted signatures:\")\n+    print(format_multiple_signatures(signatures))\ndiff --git a/setup.py b/setup.py\nindex 5e822fe9b..77b63df38 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.12',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be999..e2d66903a 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1037,39 +1037,61 @@ class DocstringSignatureMixin:\n     feature of reading the signature from the docstring.\n     \"\"\"\n \n-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n-        if encoding is not None:\n-            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n-                          \"deprecated.\" % self.__class__.__name__,\n-                          RemovedInSphinx40Warning, stacklevel=2)\n+    def _find_signatures(self) -> List[Tuple[str, str]]:\n+        \"\"\"Find all signatures from the beginning of the docstring.\"\"\"\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n-        result = None\n+        signatures = []\n+        \n         for i, doclines in enumerate(docstrings):\n             # no lines in docstring, no match\n             if not doclines:\n                 continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n+                \n             # the base name must match ours\n             valid_names = [self.objpath[-1]]  # type: ignore\n             if isinstance(self, ClassDocumenter):\n                 valid_names.append('__init__')\n                 if hasattr(self.object, '__mro__'):\n                     valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n-        return result\n+            \n+            # Look for consecutive signatures at the beginning\n+            last_sig_line = -1\n+            for j, line in enumerate(doclines):\n+                # match line against signature RE (strip whitespace first)\n+                match = py_ext_sig_re.match(line.strip())\n+                if not match:\n+                    # Stop at first non-signature line\n+                    break\n+                    \n+                exmod, path, base, args, retann = match.groups()\n+                if base in valid_names:\n+                    signatures.append((args, retann))\n+                    last_sig_line = j\n+            \n+            if signatures:\n+                # re-prepare docstring to ignore the signature lines\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[last_sig_line + 1:]),\n+                                                            tabsize=tab_width)\n+                # don't look any further\n+                break\n+                \n+        return signatures\n+    \n+    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n+        if encoding is not None:\n+            warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n+                          \"deprecated.\" % self.__class__.__name__,\n+                          RemovedInSphinx40Warning, stacklevel=2)\n+        \n+        # Find all signatures\n+        signatures = self._find_signatures()\n+        \n+        # For backward compatibility, return only the first signature\n+        if signatures:\n+            return signatures[0]\n+        return None\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n         if encoding is not None:\n@@ -1085,9 +1107,25 @@ class DocstringSignatureMixin:\n         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n             # only act if a signature is not explicitly given already, and if\n             # the feature is enabled\n-            result = self._find_signature()\n-            if result is not None:\n-                self.args, self.retann = result\n+            signatures = self._find_signatures()\n+            if signatures:\n+                if len(signatures) == 1:\n+                    # Single signature, use the normal flow\n+                    self.args, self.retann = signatures[0]\n+                else:\n+                    # Multiple signatures, format each one separately\n+                    sig_strs = []\n+                    for args, retann in signatures:\n+                        if args is not None:\n+                            sig = \"(%s)\" % args\n+                            if retann:\n+                                sig += \" -> %s\" % retann\n+                            sig_strs.append(sig)\n+                    \n+                    if sig_strs:\n+                        # Return multiple signatures separated by newlines\n+                        return '\\n'.join(sig_strs)\n+        \n         return super().format_signature(**kwargs)  # type: ignore\n \n \ndiff --git a/test_current_behavior.py b/test_current_behavior.py\nnew file mode 100644\nindex 000000000..198679eba\n--- /dev/null\n+++ b/test_current_behavior.py\n@@ -0,0 +1,56 @@\n+#!/usr/bin/env python3\n+\"\"\"Test current behavior of autodoc with overloaded signatures.\"\"\"\n+\n+import os\n+import sys\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+# Create a test module\n+with open('test_module.py', 'w') as f:\n+    f.write('''\n+class TestClass:\n+    def overloaded_method(self):\n+        \"\"\"overloaded_method(self) -> None\n+        overloaded_method(self, x: int) -> int  \n+        overloaded_method(self, x: int, y: int) -> int\n+        \n+        This method has multiple overloaded signatures.\n+        This is common in SWIG-wrapped C++ code.\n+        \"\"\"\n+        pass\n+''')\n+\n+# Create a simple Sphinx test\n+from sphinx.testing.path import path\n+from sphinx.testing.util import SphinxTestApp\n+from tempfile import TemporaryDirectory\n+\n+with TemporaryDirectory() as tmpdir:\n+    srcdir = path(tmpdir) / 'src'\n+    srcdir.makedirs()\n+    \n+    # Create conf.py\n+    (srcdir / 'conf.py').write_text('''\n+extensions = ['sphinx.ext.autodoc']\n+autodoc_docstring_signature = True\n+''')\n+    \n+    # Create index.rst\n+    (srcdir / 'index.rst').write_text('''\n+.. autoclass:: test_module.TestClass\n+   :members:\n+''')\n+    \n+    # Copy test module\n+    import shutil\n+    shutil.copy('test_module.py', str(srcdir))\n+    \n+    # Build docs\n+    app = SphinxTestApp('text', srcdir=srcdir)\n+    app.build()\n+    \n+    # Check output\n+    output_file = app.outdir / 'index.txt'\n+    if output_file.exists():\n+        print(\"Generated documentation:\")\n+        print(output_file.read_text())\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 000000000..c2bc5ae82\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,84 @@\n+#!/usr/bin/env python3\n+\"\"\"Test the fix for overloaded method signatures.\"\"\"\n+\n+import sys\n+import os\n+sys.path.insert(0, os.path.abspath('.'))\n+\n+# Create test target module\n+test_code = '''\n+class OverloadedClass:\n+    def overloaded_method(self):\n+        \"\"\"overloaded_method(self) -> None\n+        overloaded_method(self, x: int) -> int\n+        overloaded_method(self, x: int, y: int) -> int\n+        \n+        This method has multiple overloaded signatures.\n+        This is common in SWIG-wrapped C++ code.\n+        \"\"\"\n+        pass\n+    \n+    def single_sig_method(self):\n+        \"\"\"single_sig_method(self, arg: str) -> bool\n+        \n+        This has only one signature line.\n+        \"\"\"\n+        pass\n+    \n+    def no_sig_method(self):\n+        \"\"\"This method has no signature in docstring.\"\"\"\n+        pass\n+'''\n+\n+# Write test module\n+with open('test_overloaded.py', 'w') as f:\n+    f.write(test_code)\n+\n+# Test the updated autodoc\n+from sphinx.ext.autodoc import ModuleLevelDocumenter, FunctionDocumenter, MethodDocumenter\n+from sphinx.testing.fixtures import make_app\n+from sphinx.testing.path import path\n+from sphinx.util.docutils import SphinxDirective\n+from docutils.statemachine import StringList\n+from docutils.parsers.rst import directives\n+\n+import tempfile\n+import shutil\n+\n+with tempfile.TemporaryDirectory() as tmpdir:\n+    srcdir = path(tmpdir) / 'src' \n+    srcdir.makedirs()\n+    \n+    # Copy test module\n+    shutil.copy('test_overloaded.py', str(srcdir))\n+    \n+    # Create minimal conf.py\n+    (srcdir / 'conf.py').write_text('''\n+import sys\n+sys.path.insert(0, '.')\n+extensions = ['sphinx.ext.autodoc']\n+autodoc_docstring_signature = True\n+''')\n+    \n+    # Create minimal index.rst\n+    (srcdir / 'index.rst').write_text('''\n+Test\n+====\n+\n+.. automodule:: test_overloaded\n+   :members:\n+   :undoc-members:\n+''')\n+    \n+    # Build with text builder to see output\n+    from sphinx.cmd.build import build_main\n+    argv = ['-b', 'text', str(srcdir), str(srcdir / '_build')]\n+    build_main(argv)\n+    \n+    # Check output\n+    output_file = srcdir / '_build' / 'index.txt'\n+    if output_file.exists():\n+        print(\"Generated documentation:\")\n+        print(\"=\" * 60)\n+        print(output_file.read_text())\n+        print(\"=\" * 60)\ndiff --git a/test_overloaded.py b/test_overloaded.py\nnew file mode 100644\nindex 000000000..1ccc2dbf0\n--- /dev/null\n+++ b/test_overloaded.py\n@@ -0,0 +1,22 @@\n+\n+class OverloadedClass:\n+    def overloaded_method(self):\n+        \"\"\"overloaded_method(self) -> None\n+        overloaded_method(self, x: int) -> int\n+        overloaded_method(self, x: int, y: int) -> int\n+        \n+        This method has multiple overloaded signatures.\n+        This is common in SWIG-wrapped C++ code.\n+        \"\"\"\n+        pass\n+    \n+    def single_sig_method(self):\n+        \"\"\"single_sig_method(self, arg: str) -> bool\n+        \n+        This has only one signature line.\n+        \"\"\"\n+        pass\n+    \n+    def no_sig_method(self):\n+        \"\"\"This method has no signature in docstring.\"\"\"\n+        pass\ndiff --git a/test_overloaded_autodoc.py b/test_overloaded_autodoc.py\nnew file mode 100644\nindex 000000000..e5ff7b0f2\n--- /dev/null\n+++ b/test_overloaded_autodoc.py\n@@ -0,0 +1,77 @@\n+\"\"\"Test autodoc with overloaded method signatures.\"\"\"\n+\n+import pytest\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')  \n+def test_autodoc_overloaded_signatures(app):\n+    # Create a test module with overloaded signatures\n+    test_py = app.srcdir / 'target' / 'overloaded.py'\n+    test_py.write_text('''\n+class OverloadedMethods:\n+    def overloaded(self):\n+        \"\"\"overloaded(self) -> None\n+        overloaded(self, x: int) -> int\n+        overloaded(self, x: int, y: int) -> int\n+        \n+        Method with multiple overloaded signatures.\n+        \"\"\"\n+        pass\n+    \n+    def single_sig(self):\n+        \"\"\"single_sig(self, arg: str) -> bool\n+        \n+        Method with single signature.\n+        \"\"\"\n+        pass\n+''')\n+    \n+    # Test with autodoc\n+    from test_ext_autodoc import do_autodoc\n+    \n+    # Test class with overloaded methods\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'target.overloaded.OverloadedMethods', options)\n+    \n+    # Convert to list for easier checking\n+    lines = list(actual)\n+    \n+    # Find the overloaded method signature lines\n+    overloaded_idx = None\n+    for i, line in enumerate(lines):\n+        if 'overloaded(self) -> None' in line:\n+            overloaded_idx = i\n+            break\n+    \n+    assert overloaded_idx is not None, \"First signature not found\"\n+    \n+    # Check that all three signatures are present on consecutive lines\n+    assert 'overloaded(self) -> None' in lines[overloaded_idx]\n+    assert 'overloaded(self, x: int) -> int' in lines[overloaded_idx + 1]\n+    assert 'overloaded(self, x: int, y: int) -> int' in lines[overloaded_idx + 2]\n+    \n+    # Check that the docstring content follows after signatures\n+    found_docstring = False\n+    for i in range(overloaded_idx + 3, len(lines)):\n+        if 'Method with multiple overloaded signatures' in lines[i]:\n+            found_docstring = True\n+            break\n+    assert found_docstring, \"Docstring content not found after signatures\"\n+    \n+    # Check single signature method works as before\n+    single_idx = None\n+    for i, line in enumerate(lines):\n+        if 'single_sig(self, arg: str) -> bool' in line:\n+            single_idx = i\n+            break\n+    \n+    assert single_idx is not None, \"Single signature method not found\"\n+    \n+    # The single signature should not have extra lines\n+    assert 'Method with single signature' in lines[single_idx + 3]\n+\n+\n+if __name__ == '__main__':\n+    import sys\n+    import os\n+    sys.path.insert(0, os.path.dirname(__file__))\n+    pytest.main([__file__, '-xvs'])\ndiff --git a/test_overloaded_signatures.py b/test_overloaded_signatures.py\nnew file mode 100644\nindex 000000000..c320a9fee\n--- /dev/null\n+++ b/test_overloaded_signatures.py\n@@ -0,0 +1,41 @@\n+#!/usr/bin/env python3\n+\"\"\"Test case to demonstrate the issue with overloaded method signatures.\"\"\"\n+\n+class OverloadedClass:\n+    def overloaded_method(self):\n+        \"\"\"overloaded_method(self) -> None\n+        overloaded_method(self, x: int) -> int\n+        overloaded_method(self, x: int, y: int) -> int\n+        \n+        This method has multiple overloaded signatures.\n+        This is common in SWIG-wrapped C++ code.\n+        \"\"\"\n+        pass\n+\n+# Test that we can see the issue\n+if __name__ == \"__main__\":\n+    import re\n+    \n+    # The regex from sphinx autodoc\n+    py_ext_sig_re = re.compile(\n+        r'''^ ([\\w.]+::)?            # explicit module name\n+              ([\\w.]+\\.)?            # module and/or class name(s)\n+              (\\w+)  \\s*             # thing name\n+              (?: \\((.*)\\)           # optional: arguments\n+               (?:\\s* -> \\s* (.*))?  #           return annotation\n+              )? $                   # and nothing more\n+              ''', re.VERBOSE)\n+    \n+    docstring = OverloadedClass.overloaded_method.__doc__\n+    lines = docstring.strip().split('\\n')\n+    \n+    print(\"Docstring lines:\")\n+    for i, line in enumerate(lines):\n+        print(f\"  {i}: {line}\")\n+    \n+    print(\"\\nMatching signatures:\")\n+    for i, line in enumerate(lines):\n+        match = py_ext_sig_re.match(line)\n+        if match:\n+            print(f\"  Line {i}: {line}\")\n+            print(f\"    Groups: {match.groups()}\")\ndiff --git a/tests/test_overloaded_autodoc.py b/tests/test_overloaded_autodoc.py\nnew file mode 100644\nindex 000000000..e5ff7b0f2\n--- /dev/null\n+++ b/tests/test_overloaded_autodoc.py\n@@ -0,0 +1,77 @@\n+\"\"\"Test autodoc with overloaded method signatures.\"\"\"\n+\n+import pytest\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')  \n+def test_autodoc_overloaded_signatures(app):\n+    # Create a test module with overloaded signatures\n+    test_py = app.srcdir / 'target' / 'overloaded.py'\n+    test_py.write_text('''\n+class OverloadedMethods:\n+    def overloaded(self):\n+        \"\"\"overloaded(self) -> None\n+        overloaded(self, x: int) -> int\n+        overloaded(self, x: int, y: int) -> int\n+        \n+        Method with multiple overloaded signatures.\n+        \"\"\"\n+        pass\n+    \n+    def single_sig(self):\n+        \"\"\"single_sig(self, arg: str) -> bool\n+        \n+        Method with single signature.\n+        \"\"\"\n+        pass\n+''')\n+    \n+    # Test with autodoc\n+    from test_ext_autodoc import do_autodoc\n+    \n+    # Test class with overloaded methods\n+    options = {\"members\": None}\n+    actual = do_autodoc(app, 'class', 'target.overloaded.OverloadedMethods', options)\n+    \n+    # Convert to list for easier checking\n+    lines = list(actual)\n+    \n+    # Find the overloaded method signature lines\n+    overloaded_idx = None\n+    for i, line in enumerate(lines):\n+        if 'overloaded(self) -> None' in line:\n+            overloaded_idx = i\n+            break\n+    \n+    assert overloaded_idx is not None, \"First signature not found\"\n+    \n+    # Check that all three signatures are present on consecutive lines\n+    assert 'overloaded(self) -> None' in lines[overloaded_idx]\n+    assert 'overloaded(self, x: int) -> int' in lines[overloaded_idx + 1]\n+    assert 'overloaded(self, x: int, y: int) -> int' in lines[overloaded_idx + 2]\n+    \n+    # Check that the docstring content follows after signatures\n+    found_docstring = False\n+    for i in range(overloaded_idx + 3, len(lines)):\n+        if 'Method with multiple overloaded signatures' in lines[i]:\n+            found_docstring = True\n+            break\n+    assert found_docstring, \"Docstring content not found after signatures\"\n+    \n+    # Check single signature method works as before\n+    single_idx = None\n+    for i, line in enumerate(lines):\n+        if 'single_sig(self, arg: str) -> bool' in line:\n+            single_idx = i\n+            break\n+    \n+    assert single_idx is not None, \"Single signature method not found\"\n+    \n+    # The single signature should not have extra lines\n+    assert 'Method with single signature' in lines[single_idx + 3]\n+\n+\n+if __name__ == '__main__':\n+    import sys\n+    import os\n+    sys.path.insert(0, os.path.dirname(__file__))\n+    pytest.main([__file__, '-xvs'])\ndiff --git a/tox.ini b/tox.ini\nindex d9f040544..bf39854b6 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -28,7 +28,7 @@ extras =\n setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils\n commands=\n-    pytest --durations 25 {posargs}\n+    pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n", "gold_standard_diff": "From 800dcf0f0a8040ae84c4aaa7053f62201170c47d Mon Sep 17 00:00:00 2001\nFrom: Takeshi KOMIYA <i.tkomiya@gmail.com>\nDate: Sat, 30 May 2020 13:15:19 +0900\nSubject: [PATCH] Close #2106: autodoc: Support multiple signatures on\n docstring\n\n---\n CHANGES                                       |  1 +\n doc/usage/extensions/autodoc.rst              |  7 ++\n sphinx/ext/autodoc/__init__.py                | 90 +++++++++++++------\n .../target/docstring_signature.py             |  6 ++\n tests/test_ext_autodoc_configs.py             | 14 +++\n 5 files changed, 91 insertions(+), 27 deletions(-)\n\ndiff --git a/CHANGES b/CHANGES\nindex 6c2761c53e8..70cb5dcbd36 100644\n--- a/CHANGES\n+++ b/CHANGES\n@@ -49,6 +49,7 @@ Features added\n * #7143: autodoc: Support final classes and methods\n * #7384: autodoc: Support signatures defined by ``__new__()``, metaclasses and\n   builtin base classes\n+* #2106: autodoc: Support multiple signatures on docstring\n * #7466: autosummary: headings in generated documents are not translated\n * #7490: autosummary: Add ``:caption:`` option to autosummary directive to set a\n   caption to the toctree\ndiff --git a/doc/usage/extensions/autodoc.rst b/doc/usage/extensions/autodoc.rst\nindex 36be7568b13..ec1d6c9b559 100644\n--- a/doc/usage/extensions/autodoc.rst\n+++ b/doc/usage/extensions/autodoc.rst\n@@ -454,7 +454,14 @@ There are also config values that you can set:\n    looks like a signature, use the line as the signature and remove it from the\n    docstring content.\n \n+   If the signature line ends with backslash, autodoc considers the function has\n+   multiple signatures and look at the next line of the docstring.  It is useful\n+   for overloaded function.\n+\n    .. versionadded:: 1.1\n+   .. versionchanged:: 3.1\n+\n+      Support overloaded signatures\n \n .. confval:: autodoc_mock_imports\n \ndiff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\nindex f8e4be99972..1bdac08a13b 100644\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -1036,39 +1036,71 @@ class DocstringSignatureMixin:\n     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n     feature of reading the signature from the docstring.\n     \"\"\"\n+    _new_docstrings = None  # type: List[List[str]]\n+    _signatures = None      # type: List[str]\n \n     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n         if encoding is not None:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n                           \"deprecated.\" % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n+\n+        # candidates of the object name\n+        valid_names = [self.objpath[-1]]  # type: ignore\n+        if isinstance(self, ClassDocumenter):\n+            valid_names.append('__init__')\n+            if hasattr(self.object, '__mro__'):\n+                valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n+\n         docstrings = self.get_doc()\n         self._new_docstrings = docstrings[:]\n+        self._signatures = []\n         result = None\n         for i, doclines in enumerate(docstrings):\n-            # no lines in docstring, no match\n-            if not doclines:\n-                continue\n-            # match first line of docstring against signature RE\n-            match = py_ext_sig_re.match(doclines[0])\n-            if not match:\n-                continue\n-            exmod, path, base, args, retann = match.groups()\n-            # the base name must match ours\n-            valid_names = [self.objpath[-1]]  # type: ignore\n-            if isinstance(self, ClassDocumenter):\n-                valid_names.append('__init__')\n-                if hasattr(self.object, '__mro__'):\n-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n-            if base not in valid_names:\n-                continue\n-            # re-prepare docstring to ignore more leading indentation\n-            tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n-            self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[1:]),\n-                                                        tabsize=tab_width)\n-            result = args, retann\n-            # don't look any further\n-            break\n+            for j, line in enumerate(doclines):\n+                if not line:\n+                    # no lines in docstring, no match\n+                    break\n+\n+                if line.endswith('\\\\'):\n+                    multiline = True\n+                    line = line.rstrip('\\\\').rstrip()\n+                else:\n+                    multiline = False\n+\n+                # match first line of docstring against signature RE\n+                match = py_ext_sig_re.match(line)\n+                if not match:\n+                    continue\n+                exmod, path, base, args, retann = match.groups()\n+\n+                # the base name must match ours\n+                if base not in valid_names:\n+                    continue\n+\n+                # re-prepare docstring to ignore more leading indentation\n+                tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n+                self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n+                                                            tabsize=tab_width)\n+\n+                if result is None:\n+                    # first signature\n+                    result = args, retann\n+                else:\n+                    # subsequent signatures\n+                    self._signatures.append(\"(%s) -> %s\" % (args, retann))\n+\n+                if multiline:\n+                    # the signature have multiple signatures on docstring\n+                    continue\n+                else:\n+                    # don't look any further\n+                    break\n+\n+            if result:\n+                # finish the loop when signature found\n+                break\n+\n         return result\n \n     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n@@ -1076,9 +1108,8 @@ def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n                           % self.__class__.__name__,\n                           RemovedInSphinx40Warning, stacklevel=2)\n-        lines = getattr(self, '_new_docstrings', None)\n-        if lines is not None:\n-            return lines\n+        if self._new_docstrings is not None:\n+            return self._new_docstrings\n         return super().get_doc(None, ignore)  # type: ignore\n \n     def format_signature(self, **kwargs: Any) -> str:\n@@ -1088,7 +1119,11 @@ def format_signature(self, **kwargs: Any) -> str:\n             result = self._find_signature()\n             if result is not None:\n                 self.args, self.retann = result\n-        return super().format_signature(**kwargs)  # type: ignore\n+        sig = super().format_signature(**kwargs)  # type: ignore\n+        if self._signatures:\n+            return \"\\n\".join([sig] + self._signatures)\n+        else:\n+            return sig\n \n \n class DocstringStripSignatureMixin(DocstringSignatureMixin):\n@@ -1170,6 +1205,7 @@ def format_signature(self, **kwargs: Any) -> str:\n \n                     documenter = FunctionDocumenter(self.directive, '')\n                     documenter.object = func\n+                    documenter.objpath = [None]\n                     sigs.append(documenter.format_signature())\n \n         return \"\\n\".join(sigs)\ndiff --git a/tests/roots/test-ext-autodoc/target/docstring_signature.py b/tests/roots/test-ext-autodoc/target/docstring_signature.py\nindex 2e5499770c3..244109629bc 100644\n--- a/tests/roots/test-ext-autodoc/target/docstring_signature.py\n+++ b/tests/roots/test-ext-autodoc/target/docstring_signature.py\n@@ -17,3 +17,9 @@ def __new__(cls):\n class D:\n     def __init__(self):\n         \"\"\"D(foo, bar, baz)\"\"\"\n+\n+\n+class E:\n+    def __init__(self):\n+        \"\"\"E(foo: int, bar: int, baz: int) -> None \\\\\n+        E(foo: str, bar: str, baz: str) -> None\"\"\"\ndiff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 22558885ba0..674620df043 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -346,6 +346,10 @@ def test_autoclass_content_and_docstring_signature_class(app):\n         '',\n         '.. py:class:: D()',\n         '   :module: target.docstring_signature',\n+        '',\n+        '',\n+        '.. py:class:: E()',\n+        '   :module: target.docstring_signature',\n         ''\n     ]\n \n@@ -375,6 +379,11 @@ def test_autoclass_content_and_docstring_signature_init(app):\n         '',\n         '.. py:class:: D(foo, bar, baz)',\n         '   :module: target.docstring_signature',\n+        '',\n+        '',\n+        '.. py:class:: E(foo: int, bar: int, baz: int) -> None',\n+        '              E(foo: str, bar: str, baz: str) -> None',\n+        '   :module: target.docstring_signature',\n         ''\n     ]\n \n@@ -409,6 +418,11 @@ def test_autoclass_content_and_docstring_signature_both(app):\n         '.. py:class:: D(foo, bar, baz)',\n         '   :module: target.docstring_signature',\n         '',\n+        '',\n+        '.. py:class:: E(foo: int, bar: int, baz: int) -> None',\n+        '              E(foo: str, bar: str, baz: str) -> None',\n+        '   :module: target.docstring_signature',\n+        '',\n     ]\n \n \n", "gold_standard_pr_link": "https://github.com/sphinx-doc/sphinx/pull/7748"}