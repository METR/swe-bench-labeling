{"instance_id": "django__django-15382", "score": "C", "diff": "diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 81f8f79c71..384c502436 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1179,7 +1179,13 @@ class Subquery(BaseExpression, Combinable):\n         connection.ops.check_expression_support(self)\n         template_params = {**self.extra, **extra_context}\n         query = query or self.query\n-        subquery_sql, sql_params = query.as_sql(compiler, connection)\n+        try:\n+            subquery_sql, sql_params = query.as_sql(compiler, connection)\n+        except EmptyResultSet:\n+            # Empty subqueries should produce a valid SQL that returns no results.\n+            # For EXISTS, this would be EXISTS(SELECT 1 WHERE 0 = 1)\n+            subquery_sql = '(SELECT 1 WHERE 0 = 1)'\n+            sql_params = []\n         template_params['subquery'] = subquery_sql[1:-1]\n \n         template = template or template_params.get('template', self.template)\ndiff --git a/test_empty_query.py b/test_empty_query.py\nnew file mode 100644\nindex 0000000000..70ec50102b\n--- /dev/null\n+++ b/test_empty_query.py\n@@ -0,0 +1,58 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.apps import apps\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='secret-key',\n+    )\n+    django.setup()\n+\n+# Define a test model\n+class MyModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the database tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(MyModel)\n+\n+# Let's see what happens with an empty query \n+print(\"Testing empty query behavior:\")\n+empty_qs = MyModel.objects.none()\n+print(f\"Empty queryset is_empty: {empty_qs.query.is_empty()}\")\n+\n+# Let's see what exists() returns for an empty query\n+exists_query = empty_qs.query.exists(using='default')\n+print(f\"exists() query is_empty: {exists_query.is_empty()}\")\n+\n+# Let's try to get SQL for the exists query\n+try:\n+    compiler = exists_query.get_compiler('default')\n+    sql, params = compiler.as_sql()\n+    print(f\"exists() SQL: {sql}\")\n+    print(f\"exists() params: {params}\")\n+except Exception as e:\n+    print(f\"Error getting exists() SQL: {e.__class__.__name__}: {e}\")\n+    \n+# Let's see what NOT EXISTS(empty) should be\n+print(\"\\nWhat should NOT EXISTS(empty query) evaluate to?\")\n+print(\"NOT EXISTS(SELECT 1 FROM table WHERE false) should be TRUE\")\n+print(\"Because there are no rows that match the condition\")\ndiff --git a/test_exists_empty_queryset.py b/test_exists_empty_queryset.py\nnew file mode 100644\nindex 0000000000..862182638b\n--- /dev/null\n+++ b/test_exists_empty_queryset.py\n@@ -0,0 +1,100 @@\n+from django.test import TestCase\n+from django.db import models\n+\n+\n+class ExistsEmptyQuerysetTest(TestCase):\n+    \"\"\"Test for the issue where filter on exists-subquery with empty queryset removes whole WHERE block\"\"\"\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create test model dynamically\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            \n+            class Meta:\n+                app_label = 'test_app'\n+        \n+        cls.TestModel = TestModel\n+        \n+        # Create test data\n+        cls.obj1 = TestModel.objects.create(name='test')\n+        cls.obj2 = TestModel.objects.create(name='other')\n+    \n+    def test_exists_empty_queryset(self):\n+        \"\"\"Test that EXISTS with empty queryset produces valid SQL\"\"\"\n+        qs = self.TestModel.objects.filter(models.Exists(self.TestModel.objects.none()), name='test')\n+        \n+        # Should not raise EmptyResultSet when getting query string\n+        query_str = str(qs.query)\n+        self.assertIn('EXISTS', query_str)\n+        self.assertIn('0 = 1', query_str)\n+        self.assertIn('name', query_str)\n+        \n+        # Should return no results since EXISTS(empty) is always FALSE\n+        self.assertEqual(list(qs), [])\n+    \n+    def test_not_exists_empty_queryset(self):\n+        \"\"\"Test that NOT EXISTS with empty queryset produces valid SQL and correct results\"\"\"\n+        qs = self.TestModel.objects.filter(~models.Exists(self.TestModel.objects.none()), name='test')\n+        \n+        # Should not raise EmptyResultSet when getting query string\n+        query_str = str(qs.query)\n+        self.assertIn('NOT EXISTS', query_str)\n+        self.assertIn('0 = 1', query_str)\n+        self.assertIn('name', query_str)\n+        \n+        # Should return the 'test' object since NOT EXISTS(empty) is always TRUE\n+        results = list(qs)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(results[0].name, 'test')\n+    \n+    def test_complex_query_with_exists_empty(self):\n+        \"\"\"Test complex queries with EXISTS on empty querysets\"\"\"\n+        # Using Q objects\n+        qs = self.TestModel.objects.filter(\n+            models.Q(~models.Exists(self.TestModel.objects.none())) & models.Q(name='test')\n+        )\n+        results = list(qs)\n+        self.assertEqual(len(results), 1)\n+        self.assertEqual(results[0].name, 'test')\n+        \n+        # Multiple conditions\n+        qs2 = self.TestModel.objects.filter(\n+            ~models.Exists(self.TestModel.objects.none()),\n+            name__startswith='t'\n+        )\n+        results2 = list(qs2)\n+        self.assertEqual(len(results2), 1)\n+        self.assertEqual(results2[0].name, 'test')\n+\n+\n+if __name__ == '__main__':\n+    # Run the tests\n+    import django\n+    from django.conf import settings\n+    \n+    if not settings.configured:\n+        settings.configure(\n+            DATABASES={\n+                'default': {\n+                    'ENGINE': 'django.db.backends.sqlite3',\n+                    'NAME': ':memory:',\n+                }\n+            },\n+            INSTALLED_APPS=[\n+                'django.contrib.contenttypes',\n+                'django.contrib.auth',\n+            ],\n+            USE_TZ=True,\n+            SECRET_KEY='secret-key',\n+        )\n+        django.setup()\n+    \n+    from django.test.utils import get_runner\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner(verbosity=2)\n+    failures = test_runner.run_tests(['__main__'])\n+    \n+    if failures:\n+        import sys\n+        sys.exit(1)\ndiff --git a/test_exists_issue.py b/test_exists_issue.py\nnew file mode 100644\nindex 0000000000..fe3e5d6e85\n--- /dev/null\n+++ b/test_exists_issue.py\n@@ -0,0 +1,57 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.apps import apps\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='secret-key',\n+    )\n+    django.setup()\n+\n+# Define a test model\n+class MyModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the database tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(MyModel)\n+\n+# Test the issue\n+print(\"Testing ~Exists with empty queryset...\")\n+qs = MyModel.objects.filter(~models.Exists(MyModel.objects.none()), name='test')\n+print(f\"QuerySet: {qs}\")\n+print(f\"Query: {qs.query}\")\n+\n+# Try to see the actual SQL\n+try:\n+    from django.db import connection\n+    with connection.cursor() as cursor:\n+        sql, params = qs.query.get_compiler('default').as_sql()\n+        print(f\"SQL: {sql}\")\n+        print(f\"Params: {params}\")\n+except Exception as e:\n+    print(f\"Error getting SQL: {e}\")\n+\n+# Let's also test a regular Exists query\n+print(\"\\nTesting regular Exists:\")\n+qs2 = MyModel.objects.filter(models.Exists(MyModel.objects.all()), name='test')\n+print(f\"QuerySet: {qs2}\")\n+print(f\"Query: {qs2.query}\")\ndiff --git a/test_exists_issue2.py b/test_exists_issue2.py\nnew file mode 100644\nindex 0000000000..675b4348aa\n--- /dev/null\n+++ b/test_exists_issue2.py\n@@ -0,0 +1,84 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.apps import apps\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='secret-key',\n+    )\n+    django.setup()\n+\n+# Define a test model\n+class MyModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the database tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(MyModel)\n+\n+# Test the issue\n+print(\"Testing ~Exists with empty queryset...\")\n+qs = MyModel.objects.filter(~models.Exists(MyModel.objects.none()), name='test')\n+print(f\"QuerySet: {qs}\")\n+try:\n+    print(f\"Query: {qs.query}\")\n+except Exception as e:\n+    print(f\"Error getting query string: {e.__class__.__name__}: {e}\")\n+\n+# Try to see the actual SQL\n+try:\n+    from django.db import connection\n+    with connection.cursor() as cursor:\n+        sql, params = qs.query.get_compiler('default').as_sql()\n+        print(f\"SQL: {sql}\")\n+        print(f\"Params: {params}\")\n+except Exception as e:\n+    print(f\"Error getting SQL: {e.__class__.__name__}: {e}\")\n+\n+# Let's also test a regular Exists query\n+print(\"\\nTesting regular Exists:\")\n+qs2 = MyModel.objects.filter(models.Exists(MyModel.objects.all()), name='test')\n+print(f\"QuerySet: {qs2}\")\n+try:\n+    print(f\"Query: {qs2.query}\")\n+except Exception as e:\n+    print(f\"Error getting query string: {e.__class__.__name__}: {e}\")\n+\n+# Test with just Exists (not negated)\n+print(\"\\nTesting Exists with empty queryset (not negated):\")\n+qs3 = MyModel.objects.filter(models.Exists(MyModel.objects.none()), name='test')\n+print(f\"QuerySet: {qs3}\")\n+try:\n+    print(f\"Query: {qs3.query}\")\n+except Exception as e:\n+    print(f\"Error getting query string: {e.__class__.__name__}: {e}\")\n+\n+# Test with list() to see if we can execute the query\n+print(\"\\nTrying to execute queries:\")\n+try:\n+    print(f\"~Exists(none()) results: {list(qs)}\")\n+except Exception as e:\n+    print(f\"Error executing ~Exists(none()): {e.__class__.__name__}: {e}\")\n+\n+try:\n+    print(f\"Exists(none()) results: {list(qs3)}\")\n+except Exception as e:\n+    print(f\"Error executing Exists(none()): {e.__class__.__name__}: {e}\")\ndiff --git a/test_full_scenario.py b/test_full_scenario.py\nnew file mode 100644\nindex 0000000000..1400fe0f5d\n--- /dev/null\n+++ b/test_full_scenario.py\n@@ -0,0 +1,70 @@\n+import os\n+import django\n+from django.conf import settings\n+from django.db import models\n+from django.apps import apps\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+        SECRET_KEY='secret-key',\n+    )\n+    django.setup()\n+\n+# Define a test model\n+class MyModel(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Create the database tables\n+from django.db import connection\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(MyModel)\n+\n+# Create some test data\n+MyModel.objects.create(name='test')\n+MyModel.objects.create(name='other')\n+\n+# Test the issue scenarios\n+print(\"Testing ~Exists with empty queryset...\")\n+qs = MyModel.objects.filter(~models.Exists(MyModel.objects.none()), name='test')\n+print(f\"Query: {qs.query}\")\n+results = list(qs)\n+print(f\"Results: {[m.name for m in results]}\")\n+print(f\"Expected: ['test'] (because NOT EXISTS(empty) is always TRUE)\")\n+\n+print(\"\\nTesting Exists with empty queryset...\")\n+qs2 = MyModel.objects.filter(models.Exists(MyModel.objects.none()), name='test')\n+print(f\"Query: {qs2.query}\")\n+results2 = list(qs2)\n+print(f\"Results: {[m.name for m in results2]}\")\n+print(f\"Expected: [] (because EXISTS(empty) is always FALSE)\")\n+\n+print(\"\\nTesting ~Exists with non-empty queryset...\")\n+qs3 = MyModel.objects.filter(~models.Exists(MyModel.objects.filter(name='other')), name='test')\n+print(f\"Query: {qs3.query}\")\n+results3 = list(qs3)\n+print(f\"Results: {[m.name for m in results3]}\")\n+print(f\"Expected: [] (because EXISTS(name='other') is TRUE, so NOT EXISTS is FALSE)\")\n+\n+print(\"\\nTesting complex query with multiple conditions...\")\n+qs4 = MyModel.objects.filter(\n+    models.Q(~models.Exists(MyModel.objects.none())) & models.Q(name='test')\n+)\n+print(f\"Query: {qs4.query}\")\n+results4 = list(qs4)\n+print(f\"Results: {[m.name for m in results4]}\")\n+print(f\"Expected: ['test']\")\n", "gold_standard_diff": "From b7d1da5a62fe4141beff2bfea565f7ef0038c94c Mon Sep 17 00:00:00 2001\nFrom: Simon Charette <charette.s@gmail.com>\nDate: Tue, 1 Feb 2022 13:27:41 -0500\nSubject: [PATCH] Fixed #33482 -- Fixed QuerySet filtering againts negated\n Exists() with empty queryset.\n\nThanks Tobias Bengfort for the report.\n---\n django/db/models/expressions.py | 19 ++++++++++++-------\n tests/expressions/tests.py      |  7 +++++++\n 2 files changed, 19 insertions(+), 7 deletions(-)\n\ndiff --git a/django/db/models/expressions.py b/django/db/models/expressions.py\nindex 81f8f79c71a7..c71970636ca7 100644\n--- a/django/db/models/expressions.py\n+++ b/django/db/models/expressions.py\n@@ -1211,13 +1211,18 @@ def __invert__(self):\n \n     def as_sql(self, compiler, connection, template=None, **extra_context):\n         query = self.query.exists(using=connection.alias)\n-        sql, params = super().as_sql(\n-            compiler,\n-            connection,\n-            template=template,\n-            query=query,\n-            **extra_context,\n-        )\n+        try:\n+            sql, params = super().as_sql(\n+                compiler,\n+                connection,\n+                template=template,\n+                query=query,\n+                **extra_context,\n+            )\n+        except EmptyResultSet:\n+            if self.negated:\n+                return '', ()\n+            raise\n         if self.negated:\n             sql = 'NOT {}'.format(sql)\n         return sql, params\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 5cf9dd1ea59c..89c6a7c8de1c 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1905,6 +1905,13 @@ def test_optimizations(self):\n         )\n         self.assertNotIn('ORDER BY', captured_sql)\n \n+    def test_negated_empty_exists(self):\n+        manager = Manager.objects.create()\n+        qs = Manager.objects.filter(\n+            ~Exists(Manager.objects.none()) & Q(pk=manager.pk)\n+        )\n+        self.assertSequenceEqual(qs, [manager])\n+\n \n class FieldTransformTests(TestCase):\n \n", "gold_standard_pr_link": "https://github.com/django/django/pull/15382"}