diff --git a/src/_pytest/compat.py b/src/_pytest/compat.py
index d238061b4..3ce9558d7 100644
--- a/src/_pytest/compat.py
+++ b/src/_pytest/compat.py
@@ -68,7 +68,7 @@ def num_mock_patch_args(function):
     if any(mock_modules):
         sentinels = [m.DEFAULT for m in mock_modules if m is not None]
         return len(
-            [p for p in patchings if not p.attribute_name and p.new in sentinels]
+            [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]
         )
     return len(patchings)
 
diff --git a/test_array_patch.py b/test_array_patch.py
new file mode 100644
index 000000000..9f73b9435
--- /dev/null
+++ b/test_array_patch.py
@@ -0,0 +1,30 @@
+from unittest.mock import patch, DEFAULT
+
+class ArrayLike:
+    """An object that simulates numpy array behavior when compared."""
+    def __init__(self, data):
+        self.data = data
+    
+    def __eq__(self, other):
+        # This simulates numpy array behavior - returns array of booleans
+        return [x == other for x in self.data]
+    
+    def __contains__(self, item):
+        # This is what happens with 'in' operator 
+        # When used as 'item in array', numpy returns array of booleans
+        result = [x == item for x in self.data]
+        # But Python expects a boolean from __contains__
+        # With numpy arrays, this causes: ValueError: truth value is ambiguous
+        if len(result) > 1:
+            raise ValueError("The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()")
+        return result[0] if result else False
+
+# First test: patch with DEFAULT (should work)
+@patch('sys.stdout')  # This uses DEFAULT implicitly
+def test_default_patch(mock_stdout):
+    pass
+
+# Second test: patch with ArrayLike (should fail)
+@patch('sys.stdout', new=ArrayLike([-5.5, 3.0]))
+def test_array_patch():
+    pass
diff --git a/test_issue_reproduction.py b/test_issue_reproduction.py
new file mode 100644
index 000000000..7c358646b
--- /dev/null
+++ b/test_issue_reproduction.py
@@ -0,0 +1,44 @@
+"""
+Reproduction of the exact issue from the bug report.
+This test should fail with pytest 3.6.0 before the fix and pass after.
+"""
+from unittest.mock import patch
+
+# Simulate numpy array since numpy is not available in the test environment
+class MockNumpyArray:
+    """Mock numpy array that simulates the problematic behavior."""
+    def __init__(self, values):
+        self.values = values
+        
+    def __eq__(self, other):
+        # Return an array-like object that causes ValueError on truth check
+        class ComparisonResult:
+            def __init__(self, results):
+                self.results = results
+                
+            def __bool__(self):
+                if len(self.results) > 1:
+                    raise ValueError("The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()")
+                return self.results[0] if self.results else False
+                
+        return ComparisonResult([val == other for val in self.values])
+
+# Create a mock np.array function
+class np:
+    @staticmethod
+    def array(values):
+        return MockNumpyArray(values)
+
+# This is the exact code from the issue report
+@patch(target='sys.stdout', new=np.array([-5.5, 3.0]))
+def test_patch_array():
+    """Test case from the issue report that should work after the fix."""
+    pass
+
+if __name__ == "__main__":
+    # Run pytest on this file
+    import subprocess
+    import sys
+    result = subprocess.run([sys.executable, "-m", "pytest", __file__, "-v"], capture_output=True, text=True)
+    print(result.stdout)
+    print(result.stderr)
diff --git a/test_mock_patch_fix.py b/test_mock_patch_fix.py
new file mode 100644
index 000000000..6c7557161
--- /dev/null
+++ b/test_mock_patch_fix.py
@@ -0,0 +1,70 @@
+"""
+Test to verify the fix for the numpy array patch issue.
+This test verifies that pytest can collect tests that use @patch with numpy-like arrays.
+"""
+from unittest.mock import patch, DEFAULT, MagicMock
+
+
+class ArrayLike:
+    """Simulates a numpy array that raises ValueError on truth value check."""
+    def __init__(self, data):
+        self.data = data
+    
+    def __eq__(self, other):
+        # Simulate numpy array behavior - returns array of booleans
+        class ArrayResult:
+            def __init__(self, values):
+                self.values = values
+                
+            def __bool__(self):
+                # This simulates numpy's error
+                if len(self.values) > 1:
+                    raise ValueError("The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()")
+                return self.values[0] if self.values else False
+        
+        return ArrayResult([x == other for x in self.data])
+
+
+# Test 1: Regular patch with DEFAULT (implicit)
+@patch('sys.stdout')
+def test_regular_patch_default(mock_stdout):
+    """Test that regular patches still work correctly."""
+    assert mock_stdout is not None
+
+
+# Test 2: Patch with explicit DEFAULT
+@patch('sys.stdout', new=DEFAULT)
+def test_explicit_default_patch(mock_stdout):
+    """Test that explicit DEFAULT patches work correctly."""
+    assert mock_stdout is not None
+
+
+# Test 3: Patch with a regular object
+@patch('sys.stdout', new=MagicMock())
+def test_patch_with_object():
+    """Test that patches with regular objects work correctly."""
+    pass
+
+
+# Test 4: Patch with array-like object (main test case)
+@patch('sys.stdout', new=ArrayLike([-5.5, 3.0]))
+def test_patch_with_array():
+    """Test that patches with array-like objects that have ambiguous truth values work."""
+    pass
+
+
+# Test 5: Multiple patches with mixed types
+@patch('sys.stderr', new=ArrayLike([1, 2, 3]))
+@patch('sys.stdout')
+def test_multiple_patches_mixed(mock_stdout):
+    """Test multiple decorators with mixed patch types."""
+    assert mock_stdout is not None
+
+
+# Test 6: Patch with attribute_name (should not be affected by the fix)
+# We need to patch an existing attribute
+import sys
+@patch.object(sys, 'exc_info', new=ArrayLike([10, 20]))
+def test_patch_with_attribute():
+    """Test patch.object which sets attribute_name."""
+    pass
diff --git a/test_numpy_like.py b/test_numpy_like.py
new file mode 100644
index 000000000..d9b35a399
--- /dev/null
+++ b/test_numpy_like.py
@@ -0,0 +1,51 @@
+# Let's test the exact behavior that causes the issue
+from unittest.mock import DEFAULT
+
+# Create a mock numpy array class
+class NumpyArray:
+    """Simulates numpy array behavior with 'in' operator"""
+    def __init__(self, data):
+        self.data = data
+        
+    def __eq__(self, other):
+        # numpy arrays return an array of element-wise comparisons
+        class ArrayResult:
+            def __init__(self, values):
+                self.values = values
+                
+            def __bool__(self):
+                # This is what causes the ValueError in numpy
+                if len(self.values) > 1:
+                    raise ValueError("The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()")
+                return self.values[0] if self.values else False
+        
+        return ArrayResult([x == other for x in self.data])
+
+
+# Simulating the exact code from compat.py line 71
+sentinels = [DEFAULT]
+arr = NumpyArray([-5.5, 3.0])
+
+# This should trigger the error
+try:
+    result = arr in sentinels
+    print(f"Result: {result}")
+except ValueError as e:
+    print(f"Got expected error: {e}")
+
+# Now let's test the list comprehension as in the actual code
+class MockPatch:
+    def __init__(self, new, attribute_name=None):
+        self.new = new
+        self.attribute_name = attribute_name
+
+patchings = [
+    MockPatch(new=DEFAULT),  # Normal patch
+    MockPatch(new=arr),      # Patch with array
+]
+
+try:
+    result = [p for p in patchings if not p.attribute_name and p.new in sentinels]
+    print(f"List comprehension result: {result}")
+except ValueError as e:
+    print(f"Got expected error in list comprehension: {e}")
diff --git a/verify_fix.py b/verify_fix.py
new file mode 100644
index 000000000..78c5c1c37
--- /dev/null
+++ b/verify_fix.py
@@ -0,0 +1,44 @@
+"""
+Script to verify that the fix handles the problematic code correctly.
+"""
+from unittest.mock import DEFAULT
+
+# Simulating the original problematic code
+class NumpyArrayLike:
+    def __eq__(self, other):
+        # When comparing with DEFAULT, numpy arrays return array of booleans
+        class Result:
+            def __bool__(self):
+                raise ValueError("The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()")
+        return Result()
+
+# Mock patch object
+class MockPatch:
+    def __init__(self, new, attribute_name=None):
+        self.new = new
+        self.attribute_name = attribute_name
+
+# Test the original code that caused the issue
+sentinels = [DEFAULT]
+array = NumpyArrayLike()
+
+# This would cause ValueError with the original code
+try:
+    result = array in sentinels
+    print("ERROR: Should have raised ValueError")
+except ValueError as e:
+    print(f"Expected ValueError with 'in' operator: {e}")
+
+# Now test our fix using 'is' comparison
+patchings = [MockPatch(new=array)]
+try:
+    # Our fix: using 'any(p.new is s for s in sentinels)' instead of 'p.new in sentinels'
+    result = [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]
+    print(f"SUCCESS: Fix works correctly. Result: {result} (empty list expected)")
+except Exception as e:
+    print(f"ERROR: Fix failed with: {e}")
+
+# Also test that the fix still correctly identifies DEFAULT sentinels
+patchings = [MockPatch(new=DEFAULT)]
+result = [p for p in patchings if not p.attribute_name and any(p.new is s for s in sentinels)]
+print(f"DEFAULT sentinel test: {len(result)} patches found (1 expected)")
