{"instance_id": "pylint-dev__pylint-8898", "score": "I", "diff": "diff --git a/doc/user_guide/configuration/all-options.rst b/doc/user_guide/configuration/all-options.rst\nindex e09c940ef..bed366107 100644\n--- a/doc/user_guide/configuration/all-options.rst\n+++ b/doc/user_guide/configuration/all-options.rst\n@@ -333,7 +333,7 @@ Standard Checkers\n \n --bad-names-rgxs\n \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n-*Bad variable names regexes, separated by a comma. If names match any regex, they will always be refused*\n+*Bad variable names regexes, separated by newlines. If names match any regex, they will always be refused. Each regex can contain commas.*\n \n **Default:** ``\"\"``\n \ndiff --git a/pylint/checkers/base/name_checker/checker.py b/pylint/checkers/base/name_checker/checker.py\nindex 42a7c6b2e..b220b5366 100644\n--- a/pylint/checkers/base/name_checker/checker.py\n+++ b/pylint/checkers/base/name_checker/checker.py\n@@ -20,6 +20,10 @@ import astroid\n from astroid import nodes\n \n from pylint import constants, interfaces\n+\n+def regexp_list(string):\n+    \"\"\"Custom type for processing a list of regular expressions.\"\"\"\n+    return [re.compile(s.strip()) for s in string.split('\\n') if s.strip()]\n from pylint.checkers import utils\n from pylint.checkers.base.basic_checker import _BasicChecker\n from pylint.checkers.base.name_checker.naming_style import (\n@@ -229,12 +233,12 @@ class NameChecker(_BasicChecker):\n             \"bad-names-rgxs\",\n             {\n                 \"default\": \"\",\n-                \"type\": \"regexp_csv\",\n+                \"type\": regexp_list,\n                 \"metavar\": \"<names>\",\n-                \"help\": \"Bad variable names regexes, separated by a comma. If names match any regex,\"\n+                \"help\": \"Bad variable names regexes, separated by newlines. If names match any regex,\"\n                 \" they will always be refused\",\n             },\n-        ),\n+        ),  # Using regexp_list allows for regex patterns containing commas\n         (\n             \"name-group\",\n             {\n@@ -293,9 +297,7 @@ class NameChecker(_BasicChecker):\n         self._good_names_rgxs_compiled = [\n             re.compile(rgxp) for rgxp in self.linter.config.good_names_rgxs\n         ]\n-        self._bad_names_rgxs_compiled = [\n-            re.compile(rgxp) for rgxp in self.linter.config.bad_names_rgxs\n-        ]\n+        self._bad_names_rgxs_compiled = self.linter.config.bad_names_rgxs\n \n     def _create_naming_rules(self) -> tuple[dict[str, Pattern[str]], dict[str, str]]:\n         regexps: dict[str, Pattern[str]] = {}\n@@ -538,7 +540,7 @@ class NameChecker(_BasicChecker):\n     def _name_disallowed_by_regex(self, name: str) -> bool:\n         return name in self.linter.config.bad_names or any(\n             pattern.match(name) for pattern in self._bad_names_rgxs_compiled\n-        )\n+        )  # The _bad_names_rgxs_compiled is already a list of compiled regexes\n \n     def _check_name(\n         self,\n", "gold_standard_diff": "diff --git a/doc/whatsnew/fragments/7229.bugfix b/doc/whatsnew/fragments/7229.bugfix\nnew file mode 100644\nindex 0000000000..c39e130192\n--- /dev/null\n+++ b/doc/whatsnew/fragments/7229.bugfix\n@@ -0,0 +1,5 @@\n+When parsing comma-separated lists of regular expressions in the config, ignore\n+commas that are inside braces since those indicate quantifiers, not delineation\n+between expressions.\n+\n+Closes #7229\ndiff --git a/pylint/config/argument.py b/pylint/config/argument.py\nindex 30a5fd1753..2d2a46a3fd 100644\n--- a/pylint/config/argument.py\n+++ b/pylint/config/argument.py\n@@ -114,7 +114,7 @@ def _regex_transformer(value: str) -> Pattern[str]:\n def _regexp_csv_transfomer(value: str) -> Sequence[Pattern[str]]:\n     \"\"\"Transforms a comma separated list of regular expressions.\"\"\"\n     patterns: list[Pattern[str]] = []\n-    for pattern in _csv_transformer(value):\n+    for pattern in pylint_utils._check_regexp_csv(value):\n         patterns.append(_regex_transformer(pattern))\n     return patterns\n \ndiff --git a/pylint/utils/__init__.py b/pylint/utils/__init__.py\nindex 61833a5987..eecb3cbe37 100644\n--- a/pylint/utils/__init__.py\n+++ b/pylint/utils/__init__.py\n@@ -14,6 +14,7 @@\n     HAS_ISORT_5,\n     IsortDriver,\n     _check_csv,\n+    _check_regexp_csv,\n     _splitstrip,\n     _unquote,\n     decoding_stream,\n@@ -32,6 +33,7 @@\n     \"HAS_ISORT_5\",\n     \"IsortDriver\",\n     \"_check_csv\",\n+    \"_check_regexp_csv\",\n     \"_splitstrip\",\n     \"_unquote\",\n     \"decoding_stream\",\ndiff --git a/pylint/utils/utils.py b/pylint/utils/utils.py\nindex fa7f7b92ff..8f16d2f1f4 100644\n--- a/pylint/utils/utils.py\n+++ b/pylint/utils/utils.py\n@@ -22,7 +22,8 @@\n import textwrap\n import tokenize\n import warnings\n-from collections.abc import Sequence\n+from collections import deque\n+from collections.abc import Iterable, Sequence\n from io import BufferedReader, BytesIO\n from typing import (\n     TYPE_CHECKING,\n@@ -253,6 +254,31 @@ def _check_csv(value: list[str] | tuple[str] | str) -> Sequence[str]:\n     return _splitstrip(value)\n \n \n+def _check_regexp_csv(value: list[str] | tuple[str] | str) -> Iterable[str]:\n+    r\"\"\"Split a comma-separated list of regexps, taking care to avoid splitting\n+    a regex employing a comma as quantifier, as in `\\d{1,2}`.\"\"\"\n+    if isinstance(value, (list, tuple)):\n+        yield from value\n+    else:\n+        # None is a sentinel value here\n+        regexps: deque[deque[str] | None] = deque([None])\n+        open_braces = False\n+        for char in value:\n+            if char == \"{\":\n+                open_braces = True\n+            elif char == \"}\" and open_braces:\n+                open_braces = False\n+\n+            if char == \",\" and not open_braces:\n+                regexps.append(None)\n+            elif regexps[-1] is None:\n+                regexps.pop()\n+                regexps.append(deque([char]))\n+            else:\n+                regexps[-1].append(char)\n+        yield from (\"\".join(regexp).strip() for regexp in regexps if regexp is not None)\n+\n+\n def _comment(string: str) -> str:\n     \"\"\"Return string as a comment.\"\"\"\n     lines = [line.strip() for line in string.splitlines()]\ndiff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 83c8b072e5..872b568a61 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -5,8 +5,10 @@\n from __future__ import annotations\n \n import os\n+import re\n from pathlib import Path\n from tempfile import TemporaryDirectory\n+from typing import Any\n \n import pytest\n from pytest import CaptureFixture\n@@ -115,6 +117,31 @@ def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     assert \"the-newest has an invalid format, should be a version string.\" in output.err\n \n \n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+]\n+\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_in_quantifier(in_string: str, expected: list[str]) -> None:\n+    \"\"\"Check that we correctly parse a comma-separated regex when there are one\n+    or more commas within quantifier expressions.\n+    \"\"\"\n+\n+    def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+\n+\n def test_regex_error(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error when an an option is passed whose value is an invalid regular expression.\"\"\"\n     with pytest.raises(SystemExit):\n@@ -137,12 +164,12 @@ def test_csv_regex_error(capsys: CaptureFixture) -> None:\n     \"\"\"\n     with pytest.raises(SystemExit):\n         Run(\n-            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,3})\"],\n+            [str(EMPTY_MODULE), r\"--bad-names-rgx=(foo{1,}, foo{1,3}})\"],\n             exit=False,\n         )\n     output = capsys.readouterr()\n     assert (\n-        r\"Error in provided regular expression: (foo{1 beginning at index 0: missing ), unterminated subpattern\"\n+        r\"Error in provided regular expression: (foo{1,} beginning at index 0: missing ), unterminated subpattern\"\n         in output.err\n     )\n \n", "gold_standard_pr_link": "https://github.com/pylint-dev/pylint/pull/8898"}