{"instance_id": "django__django-14672", "score": "C", "diff": "diff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py\nindex ccc2223a5f..65950590e2 100644\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -310,7 +310,7 @@ class ManyToManyRel(ForeignObjectRel):\n     def identity(self):\n         return super().identity + (\n             self.through,\n-            self.through_fields,\n+            make_hashable(self.through_fields),\n             self.db_constraint,\n         )\n \ndiff --git a/test_comprehensive.py b/test_comprehensive.py\nnew file mode 100644\nindex 0000000000..5c7129b394\n--- /dev/null\n+++ b/test_comprehensive.py\n@@ -0,0 +1,186 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.core import checks\n+\n+# Test Case 1: Original issue - ManyToMany with through_fields as list\n+class Parent(models.Model):\n+    name = models.CharField(max_length=256)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyParent(Parent):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class Child(models.Model):\n+    parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+    many_to_many_field = models.ManyToManyField(\n+        to=Parent,\n+        through=\"ManyToManyModel\",\n+        through_fields=['child', 'parent'],\n+        related_name=\"something\"\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ManyToManyModel(models.Model):\n+    parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+    child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+    second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test Case 2: ManyToMany with through_fields as tuple (should also work)\n+class Parent2(models.Model):\n+    name = models.CharField(max_length=256)\n+    \n+    class Meta:\n+        app_label = 'test_app2'\n+\n+class Child2(models.Model):\n+    parent = models.ForeignKey(Parent2, on_delete=models.CASCADE)\n+    many_to_many_field = models.ManyToManyField(\n+        to=Parent2,\n+        through=\"ManyToManyModel2\",\n+        through_fields=('child2', 'parent2'),  # Tuple instead of list\n+        related_name=\"something2\"\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app2'\n+\n+class ManyToManyModel2(models.Model):\n+    parent2 = models.ForeignKey(Parent2, on_delete=models.CASCADE, related_name='+')\n+    child2 = models.ForeignKey(Child2, on_delete=models.CASCADE, related_name='+')\n+    \n+    class Meta:\n+        app_label = 'test_app2'\n+\n+# Test Case 3: ManyToMany without through_fields (None case)\n+class Parent3(models.Model):\n+    name = models.CharField(max_length=256)\n+    \n+    class Meta:\n+        app_label = 'test_app3'\n+\n+class Child3(models.Model):\n+    many_to_many_field = models.ManyToManyField(\n+        to=Parent3,\n+        related_name=\"something3\"\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app3'\n+\n+def test_hashing():\n+    \"\"\"Test that all ManyToManyRel objects can be hashed\"\"\"\n+    test_cases = [\n+        (\"Case 1: List through_fields\", Child._meta.get_field('many_to_many_field')),\n+        (\"Case 2: Tuple through_fields\", Child2._meta.get_field('many_to_many_field')),\n+        (\"Case 3: No through_fields\", Child3._meta.get_field('many_to_many_field')),\n+    ]\n+    \n+    all_passed = True\n+    for case_name, field in test_cases:\n+        try:\n+            remote_field = field.remote_field\n+            print(f\"\\n{case_name}:\")\n+            print(f\"  Remote field: {remote_field}\")\n+            print(f\"  Through fields: {remote_field.through_fields}\")\n+            \n+            # Try to hash it\n+            hash_value = hash(remote_field)\n+            print(f\"  Hash value: {hash_value}\")\n+            print(f\"  \u2713 Hashing successful\")\n+            \n+            # Also test that it can be put in a set\n+            field_set = {remote_field}\n+            print(f\"  \u2713 Can be added to a set\")\n+            \n+        except Exception as e:\n+            print(f\"  \u2717 ERROR: {e}\")\n+            all_passed = False\n+            import traceback\n+            traceback.print_exc()\n+    \n+    return all_passed\n+\n+def test_checks():\n+    \"\"\"Test that Django checks pass\"\"\"\n+    print(\"\\nRunning Django checks...\")\n+    try:\n+        errors = checks.run_checks()\n+        if errors:\n+            print(f\"\u2717 Django checks failed with {len(errors)} errors:\")\n+            for error in errors:\n+                print(f\"  - {error}\")\n+            return False\n+        else:\n+            print(\"\u2713 All Django checks passed\")\n+            return True\n+    except Exception as e:\n+        print(f\"\u2717 Django checks crashed: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+        return False\n+\n+def test_proxy_model_checks():\n+    \"\"\"Test that proxy model checks work properly\"\"\"\n+    print(\"\\nRunning proxy model checks...\")\n+    try:\n+        errors = ProxyParent.check()\n+        if errors:\n+            print(f\"\u2717 Proxy model checks failed with {len(errors)} errors:\")\n+            for error in errors:\n+                print(f\"  - {error}\")\n+            return False\n+        else:\n+            print(\"\u2713 Proxy model checks passed\")\n+            return True\n+    except Exception as e:\n+        print(f\"\u2717 Proxy model checks crashed: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+        return False\n+\n+if __name__ == \"__main__\":\n+    print(\"Testing ManyToManyRel.identity fix...\")\n+    print(\"=\" * 50)\n+    \n+    # Run all tests\n+    hash_test_passed = test_hashing()\n+    checks_passed = test_checks()\n+    proxy_checks_passed = test_proxy_model_checks()\n+    \n+    print(\"\\n\" + \"=\" * 50)\n+    print(\"Test Summary:\")\n+    print(f\"  Hashing test: {'PASSED' if hash_test_passed else 'FAILED'}\")\n+    print(f\"  Django checks: {'PASSED' if checks_passed else 'FAILED'}\")\n+    print(f\"  Proxy model checks: {'PASSED' if proxy_checks_passed else 'FAILED'}\")\n+    \n+    all_passed = hash_test_passed and checks_passed and proxy_checks_passed\n+    print(f\"\\nOverall: {'ALL TESTS PASSED' if all_passed else 'SOME TESTS FAILED'}\")\n+    exit(0 if all_passed else 1)\ndiff --git a/test_issue.py b/test_issue.py\nnew file mode 100644\nindex 0000000000..e468e61444\n--- /dev/null\n+++ b/test_issue.py\n@@ -0,0 +1,78 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+\n+class Parent(models.Model):\n+    name = models.CharField(max_length=256)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ProxyParent(Parent):\n+    class Meta:\n+        proxy = True\n+        app_label = 'test_app'\n+\n+class Child(models.Model):\n+    parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+    many_to_many_field = models.ManyToManyField(\n+        to=Parent,\n+        through=\"ManyToManyModel\",\n+        through_fields=['child', 'parent'],\n+        related_name=\"something\"\n+    )\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+class ManyToManyModel(models.Model):\n+    parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+    child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+    second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+# Test code\n+if __name__ == \"__main__\":\n+    # Try to trigger the _check_field_name_clashes\n+    try:\n+        # This method creates a set of fields which will trigger hashing\n+        errors = ProxyParent._check_field_name_clashes()\n+        print(f\"ProxyParent field name clash check errors: {errors}\")\n+    except TypeError as e:\n+        print(f\"ERROR on field name clash check: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+    \n+    # Let's also check if we can hash the many_to_many_field's remote_field\n+    try:\n+        m2m_field = Child._meta.get_field('many_to_many_field')\n+        print(f\"ManyToMany field: {m2m_field}\")\n+        print(f\"Remote field: {m2m_field.remote_field}\")\n+        print(f\"Through fields: {m2m_field.remote_field.through_fields}\")\n+        # Try to hash it\n+        hash(m2m_field.remote_field)\n+        print(\"Successfully hashed the remote field\")\n+    except TypeError as e:\n+        print(f\"ERROR when hashing remote field: {e}\")\n+        import traceback\n+        traceback.print_exc()\ndiff --git a/test_rel_identity.py b/test_rel_identity.py\nnew file mode 100644\nindex 0000000000..6227d5527d\n--- /dev/null\n+++ b/test_rel_identity.py\n@@ -0,0 +1,154 @@\n+\"\"\"\n+Test that verifies ManyToManyRel.identity is hashable with list through_fields.\n+This test ensures the fix for the issue where through_fields as a list\n+would cause a TypeError when hashing.\n+\"\"\"\n+\n+from django.test import TestCase\n+from django.db import models\n+from django.db.models.fields.reverse_related import ManyToManyRel\n+from django.utils.hashable import make_hashable\n+\n+\n+class IdentityTestCase(TestCase):\n+    \"\"\"Test ForeignObjectRel identity property hashability\"\"\"\n+    \n+    def test_make_hashable_on_list(self):\n+        \"\"\"Test that make_hashable works on lists\"\"\"\n+        test_list = ['a', 'b', 'c']\n+        result = make_hashable(test_list)\n+        # Should be able to hash the result\n+        hash(result)\n+        # Should be a tuple\n+        self.assertIsInstance(result, tuple)\n+        self.assertEqual(result, ('a', 'b', 'c'))\n+    \n+    def test_make_hashable_on_tuple(self):\n+        \"\"\"Test that make_hashable works on tuples\"\"\"\n+        test_tuple = ('a', 'b', 'c')\n+        result = make_hashable(test_tuple)\n+        # Should be able to hash the result\n+        hash(result)\n+        # Should still be a tuple\n+        self.assertIsInstance(result, tuple)\n+        self.assertEqual(result, test_tuple)\n+    \n+    def test_make_hashable_on_none(self):\n+        \"\"\"Test that make_hashable works on None\"\"\"\n+        result = make_hashable(None)\n+        # Should be able to hash the result\n+        hash(result)\n+        # None is already hashable\n+        self.assertIsNone(result)\n+    \n+    def test_manytomanyrel_identity_with_list_through_fields(self):\n+        \"\"\"Test that ManyToManyRel identity is hashable when through_fields is a list\"\"\"\n+        # Create a mock field and ManyToManyRel\n+        class MockField:\n+            model = None\n+            def related_query_name(self):\n+                return 'test'\n+        \n+        # Create ManyToManyRel with list through_fields\n+        rel = ManyToManyRel(\n+            field=MockField(),\n+            to='testapp.TestModel',\n+            through='testapp.ThroughModel',  # Required when using through_fields\n+            through_fields=['field1', 'field2']  # This is a list\n+        )\n+        \n+        # The identity property should be hashable\n+        identity = rel.identity\n+        hash_value = hash(identity)\n+        \n+        # Verify it's actually hashable by using it in a set\n+        rel_set = {rel}\n+        self.assertEqual(len(rel_set), 1)\n+        \n+        # Verify the through_fields was properly converted\n+        # Find the through_fields in the identity tuple\n+        self.assertIn(('field1', 'field2'), identity)\n+    \n+    def test_manytomanyrel_identity_with_tuple_through_fields(self):\n+        \"\"\"Test that ManyToManyRel identity is hashable when through_fields is a tuple\"\"\"\n+        class MockField:\n+            model = None\n+            def related_query_name(self):\n+                return 'test'\n+        \n+        # Create ManyToManyRel with tuple through_fields\n+        rel = ManyToManyRel(\n+            field=MockField(),\n+            to='testapp.TestModel',\n+            through='testapp.ThroughModel',  # Required when using through_fields\n+            through_fields=('field1', 'field2')  # This is a tuple\n+        )\n+        \n+        # The identity property should be hashable\n+        identity = rel.identity\n+        hash_value = hash(identity)\n+        \n+        # Verify it's actually hashable by using it in a set\n+        rel_set = {rel}\n+        self.assertEqual(len(rel_set), 1)\n+    \n+    def test_manytomanyrel_equality_with_different_through_fields_types(self):\n+        \"\"\"Test that ManyToManyRel objects with list and tuple through_fields are equal\"\"\"\n+        class MockField:\n+            model = None\n+            def related_query_name(self):\n+                return 'test'\n+            def __eq__(self, other):\n+                return isinstance(other, MockField)\n+            def __hash__(self):\n+                return hash('MockField')\n+        \n+        # Use the same field instance for both\n+        field = MockField()\n+        \n+        # Create two ManyToManyRel objects with same fields but different types\n+        rel_with_list = ManyToManyRel(\n+            field=field,\n+            to='testapp.TestModel',\n+            through='testapp.ThroughModel',  # Required when using through_fields\n+            through_fields=['field1', 'field2']  # List\n+        )\n+        \n+        rel_with_tuple = ManyToManyRel(\n+            field=field,\n+            to='testapp.TestModel',\n+            through='testapp.ThroughModel',  # Required when using through_fields\n+            through_fields=('field1', 'field2')  # Tuple\n+        )\n+        \n+        # They should be considered equal\n+        self.assertEqual(rel_with_list, rel_with_tuple)\n+        # And have the same hash\n+        self.assertEqual(hash(rel_with_list), hash(rel_with_tuple))\n+\n+\n+if __name__ == '__main__':\n+    import django\n+    from django.conf import settings\n+    from django.test.utils import get_runner\n+    \n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+    )\n+    \n+    django.setup()\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner()\n+    failures = test_runner.run_tests([\"__main__\"])\n+    exit(bool(failures))\n", "gold_standard_diff": "diff --git a/AUTHORS b/AUTHORS\nindex 7ce3d2e08d76..783a52298fc2 100644\n--- a/AUTHORS\n+++ b/AUTHORS\n@@ -923,6 +923,7 @@ answer newbie questions, and generally made Django that much better:\n     Tom Forbes <tom@tomforb.es>\n     Tom Insam\n     Tom Tobin\n+    Tom Wojcik <me@tomwojcik.com>\n     Tom\u00e1\u0161 Ehrlich <tomas.ehrlich@gmail.com>\n     Tom\u00e1\u0161 Kope\u010dek <permonik@m6.cz>\n     Tome Cvitan <tome@cvitan.com>\ndiff --git a/django/db/models/fields/reverse_related.py b/django/db/models/fields/reverse_related.py\nindex ccc2223a5f62..65950590e208 100644\n--- a/django/db/models/fields/reverse_related.py\n+++ b/django/db/models/fields/reverse_related.py\n@@ -310,7 +310,7 @@ def __init__(self, field, to, related_name=None, related_query_name=None,\n     def identity(self):\n         return super().identity + (\n             self.through,\n-            self.through_fields,\n+            make_hashable(self.through_fields),\n             self.db_constraint,\n         )\n \ndiff --git a/docs/releases/3.2.6.txt b/docs/releases/3.2.6.txt\nindex a44fa42181dd..5dba87a0dcec 100644\n--- a/docs/releases/3.2.6.txt\n+++ b/docs/releases/3.2.6.txt\n@@ -12,3 +12,7 @@ Bugfixes\n * Fixed a regression in Django 3.2 that caused a crash validating ``\"NaN\"``\n   input with a ``forms.DecimalField`` when additional constraints, e.g.\n   ``max_value``, were specified (:ticket:`32949`).\n+\n+* Fixed a bug in Django 3.2 where a system check would crash on a model with a\n+  reverse many-to-many relation inherited from a parent class\n+  (:ticket:`32947`).\ndiff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex f0984fa7592b..4a36ac82854f 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -821,6 +821,33 @@ class Child(Parent):\n             )\n         ])\n \n+    def test_field_name_clash_with_m2m_through(self):\n+        class Parent(models.Model):\n+            clash_id = models.IntegerField()\n+\n+        class Child(Parent):\n+            clash = models.ForeignKey('Child', models.CASCADE)\n+\n+        class Model(models.Model):\n+            parents = models.ManyToManyField(\n+                to=Parent,\n+                through='Through',\n+                through_fields=['parent', 'model'],\n+            )\n+\n+        class Through(models.Model):\n+            parent = models.ForeignKey(Parent, models.CASCADE)\n+            model = models.ForeignKey(Model, models.CASCADE)\n+\n+        self.assertEqual(Child.check(), [\n+            Error(\n+                \"The field 'clash' clashes with the field 'clash_id' from \"\n+                \"model 'invalid_models_tests.parent'.\",\n+                obj=Child._meta.get_field('clash'),\n+                id='models.E006',\n+            )\n+        ])\n+\n     def test_multiinheritance_clash(self):\n         class Mother(models.Model):\n             clash = models.IntegerField()\ndiff --git a/tests/m2m_through/models.py b/tests/m2m_through/models.py\nindex 2cc0bd684860..b7d674d142c6 100644\n--- a/tests/m2m_through/models.py\n+++ b/tests/m2m_through/models.py\n@@ -11,6 +11,10 @@ class Meta:\n         ordering = ('name',)\n \n \n+class PersonChild(Person):\n+    pass\n+\n+\n class Group(models.Model):\n     name = models.CharField(max_length=128)\n     members = models.ManyToManyField(Person, through='Membership')\n@@ -85,8 +89,9 @@ class SymmetricalFriendship(models.Model):\n class Event(models.Model):\n     title = models.CharField(max_length=50)\n     invitees = models.ManyToManyField(\n-        Person, through='Invitation',\n-        through_fields=('event', 'invitee'),\n+        to=Person,\n+        through='Invitation',\n+        through_fields=['event', 'invitee'],\n         related_name='events_invited',\n     )\n \ndiff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex 6262596dd063..36644c3b596e 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -6,8 +6,8 @@\n \n from .models import (\n     CustomMembership, Employee, Event, Friendship, Group, Ingredient,\n-    Invitation, Membership, Person, PersonSelfRefM2M, Recipe, RecipeIngredient,\n-    Relationship, SymmetricalFriendship,\n+    Invitation, Membership, Person, PersonChild, PersonSelfRefM2M, Recipe,\n+    RecipeIngredient, Relationship, SymmetricalFriendship,\n )\n \n \n@@ -20,6 +20,13 @@ def setUpTestData(cls):\n         cls.rock = Group.objects.create(name='Rock')\n         cls.roll = Group.objects.create(name='Roll')\n \n+    def test_reverse_inherited_m2m_with_through_fields_list_hashable(self):\n+        reverse_m2m = Person._meta.get_field('events_invited')\n+        self.assertEqual(reverse_m2m.through_fields, ['event', 'invitee'])\n+        inherited_reverse_m2m = PersonChild._meta.get_field('events_invited')\n+        self.assertEqual(inherited_reverse_m2m.through_fields, ['event', 'invitee'])\n+        self.assertEqual(hash(reverse_m2m), hash(inherited_reverse_m2m))\n+\n     def test_retrieve_intermediate_items(self):\n         Membership.objects.create(person=self.jim, group=self.rock)\n         Membership.objects.create(person=self.jane, group=self.rock)\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14672"}