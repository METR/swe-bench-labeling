{"instance_id": "django__django-15957", "score": "I", "diff": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b192df4fbf..91e210db9a 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -145,7 +145,25 @@ class ForwardManyToOneDescriptor:\n             }\n         else:\n             query = {\"%s__in\" % self.field.related_query_name(): instances}\n-        queryset = queryset.filter(**query)\n+            \n+        # Handle sliced querysets by temporarily removing the slice,\n+        # applying the filter, then re-applying the slice\n+        if queryset.query.is_sliced:\n+            # Store the slice limits\n+            low_mark = queryset.query.low_mark\n+            high_mark = queryset.query.high_mark\n+            \n+            # Clone the queryset and clear limits\n+            queryset = queryset._chain()\n+            queryset.query.clear_limits()\n+            \n+            # Apply the filter\n+            queryset = queryset.filter(**query)\n+            \n+            # Restore the slice limits\n+            queryset.query.set_limits(low_mark, high_mark)\n+        else:\n+            queryset = queryset.filter(**query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -404,7 +422,25 @@ class ReverseOneToOneDescriptor:\n         instance_attr = self.related.field.get_foreign_related_value\n         instances_dict = {instance_attr(inst): inst for inst in instances}\n         query = {\"%s__in\" % self.related.field.name: instances}\n-        queryset = queryset.filter(**query)\n+        \n+        # Handle sliced querysets by temporarily removing the slice,\n+        # applying the filter, then re-applying the slice\n+        if queryset.query.is_sliced:\n+            # Store the slice limits\n+            low_mark = queryset.query.low_mark\n+            high_mark = queryset.query.high_mark\n+            \n+            # Clone the queryset and clear limits\n+            queryset = queryset._chain()\n+            queryset.query.clear_limits()\n+            \n+            # Apply the filter\n+            queryset = queryset.filter(**query)\n+            \n+            # Restore the slice limits\n+            queryset.query.set_limits(low_mark, high_mark)\n+        else:\n+            queryset = queryset.filter(**query)\n \n         # Since we're going to assign directly in the cache,\n         # we must manage the reverse relation cache manually.\n@@ -719,7 +755,25 @@ def create_reverse_many_to_one_manager(superclass, rel):\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n             query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            \n+            # Handle sliced querysets by temporarily removing the slice,\n+            # applying the filter, then re-applying the slice\n+            if queryset.query.is_sliced:\n+                # Store the slice limits\n+                low_mark = queryset.query.low_mark\n+                high_mark = queryset.query.high_mark\n+                \n+                # Clone the queryset and clear limits\n+                queryset = queryset._chain()\n+                queryset.query.clear_limits()\n+                \n+                # Apply the filter\n+                queryset = queryset.filter(**query)\n+                \n+                # Restore the slice limits\n+                queryset.query.set_limits(low_mark, high_mark)\n+            else:\n+                queryset = queryset.filter(**query)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1052,7 +1106,25 @@ def create_forward_many_to_many_manager(superclass, rel, reverse):\n             queryset = queryset.using(queryset._db or self._db)\n \n             query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n+            \n+            # Handle sliced querysets by temporarily removing the slice,\n+            # applying the filter, then re-applying the slice\n+            if queryset.query.is_sliced:\n+                # Store the slice limits\n+                low_mark = queryset.query.low_mark\n+                high_mark = queryset.query.high_mark\n+                \n+                # Clone the queryset and clear limits\n+                queryset = queryset._chain()\n+                queryset.query.clear_limits()\n+                \n+                # Apply the filter\n+                queryset = queryset._next_is_sticky().filter(**query)\n+                \n+                # Restore the slice limits after filtering\n+                queryset.query.set_limits(low_mark, high_mark)\n+            else:\n+                queryset = queryset._next_is_sticky().filter(**query)\n \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\ndiff --git a/test_comprehensive_prefetch_slice.py b/test_comprehensive_prefetch_slice.py\nnew file mode 100644\nindex 0000000000..686bbf8829\n--- /dev/null\n+++ b/test_comprehensive_prefetch_slice.py\n@@ -0,0 +1,206 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Prefetch\n+\n+\n+class Category(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class Post(models.Model):\n+    title = models.CharField(max_length=100)\n+    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='posts')\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class Tag(models.Model):\n+    name = models.CharField(max_length=100)\n+    posts = models.ManyToManyField(Post, related_name='tags')\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+def test_reverse_fk_prefetch_with_slice():\n+    print(\"Testing reverse ForeignKey prefetch with slice...\")\n+    \n+    # Create test data\n+    cat1 = Category.objects.create(name=\"Category 1\")\n+    cat2 = Category.objects.create(name=\"Category 2\")\n+    \n+    for i in range(10):\n+        Post.objects.create(title=f\"Post {i} Cat 1\", category=cat1)\n+        Post.objects.create(title=f\"Post {i} Cat 2\", category=cat2)\n+    \n+    # Test prefetch with sliced queryset\n+    categories = Category.objects.prefetch_related(\n+        Prefetch(\n+            'posts',\n+            queryset=Post.objects.all()[:3],\n+            to_attr='example_posts',\n+        )\n+    )\n+    \n+    for cat in categories:\n+        print(f\"  {cat.name}: {len(cat.example_posts)} posts\")\n+        assert len(cat.example_posts) == 3\n+        for post in cat.example_posts:\n+            assert post.category_id == cat.id\n+    \n+    print(\"  \u2713 Reverse ForeignKey prefetch with slice works!\")\n+\n+\n+def test_m2m_prefetch_with_slice():\n+    print(\"\\nTesting ManyToMany prefetch with slice...\")\n+    \n+    # Create test data\n+    posts = []\n+    for i in range(5):\n+        posts.append(Post.objects.create(title=f\"Post {i}\", category=Category.objects.create(name=f\"Cat {i}\")))\n+    \n+    tags = []\n+    for i in range(3):\n+        tag = Tag.objects.create(name=f\"Tag {i}\")\n+        # Add all posts to each tag\n+        tag.posts.set(posts)\n+        tags.append(tag)\n+    \n+    # Test prefetch with sliced queryset\n+    tags_qs = Tag.objects.prefetch_related(\n+        Prefetch(\n+            'posts',\n+            queryset=Post.objects.all()[:2],\n+            to_attr='limited_posts',\n+        )\n+    )\n+    \n+    for tag in tags_qs:\n+        print(f\"  {tag.name}: {len(tag.limited_posts)} posts\")\n+        assert len(tag.limited_posts) == 2\n+        for post in tag.limited_posts:\n+            assert tag in post.tags.all()\n+    \n+    print(\"  \u2713 ManyToMany prefetch with slice works!\")\n+\n+\n+def test_forward_fk_prefetch_with_slice():\n+    print(\"\\nTesting forward ForeignKey prefetch with slice...\")\n+    \n+    # Create test data - multiple posts pointing to same categories\n+    cat1 = Category.objects.create(name=\"Category 1\")\n+    cat2 = Category.objects.create(name=\"Category 2\")\n+    \n+    posts = []\n+    for i in range(10):\n+        posts.append(Post.objects.create(title=f\"Post {i}\", category=cat1 if i < 5 else cat2))\n+    \n+    # Test prefetch with sliced queryset on forward relation\n+    # This is less common but should still work\n+    posts_qs = Post.objects.prefetch_related(\n+        Prefetch(\n+            'category',\n+            queryset=Category.objects.all(),\n+        )\n+    )\n+    \n+    for post in posts_qs[:3]:  # Only check first 3 posts\n+        print(f\"  {post.title}: Category {post.category.name}\")\n+        assert post.category is not None\n+        assert post.category.id in [cat1.id, cat2.id]\n+    \n+    print(\"  \u2713 Forward ForeignKey prefetch works!\")\n+\n+\n+def test_offset_and_limit():\n+    print(\"\\nTesting prefetch with offset and limit...\")\n+    \n+    # Create test data\n+    cat = Category.objects.create(name=\"Test Category\")\n+    \n+    for i in range(20):\n+        Post.objects.create(title=f\"Post {i:02d}\", category=cat)\n+    \n+    # Test with offset and limit (e.g., [5:10])\n+    categories = Category.objects.prefetch_related(\n+        Prefetch(\n+            'posts',\n+            queryset=Post.objects.order_by('title')[5:10],\n+            to_attr='middle_posts',\n+        )\n+    )\n+    \n+    cat = categories.first()\n+    print(f\"  {cat.name}: {len(cat.middle_posts)} posts (offset 5, limit 5)\")\n+    assert len(cat.middle_posts) == 5\n+    \n+    # Check that we got the right posts (5-9)\n+    titles = [p.title for p in cat.middle_posts]\n+    expected_titles = [f\"Post {i:02d}\" for i in range(5, 10)]\n+    assert titles == expected_titles\n+    \n+    print(\"  \u2713 Prefetch with offset and limit works!\")\n+\n+\n+def test_empty_slice():\n+    print(\"\\nTesting prefetch with empty slice...\")\n+    \n+    # Create test data\n+    cat = Category.objects.create(name=\"Test Category\")\n+    \n+    for i in range(5):\n+        Post.objects.create(title=f\"Post {i}\", category=cat)\n+    \n+    # Test with slice that returns no results\n+    categories = Category.objects.prefetch_related(\n+        Prefetch(\n+            'posts',\n+            queryset=Post.objects.all()[10:20],  # Beyond available posts\n+            to_attr='no_posts',\n+        )\n+    )\n+    \n+    cat = categories.first()\n+    print(f\"  {cat.name}: {len(cat.no_posts)} posts\")\n+    assert len(cat.no_posts) == 0\n+    \n+    print(\"  \u2713 Prefetch with empty slice works!\")\n+\n+\n+if __name__ == \"__main__\":\n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Category)\n+        schema_editor.create_model(Post)\n+        schema_editor.create_model(Tag)\n+        # Create M2M table\n+        schema_editor.create_model(Tag.posts.through)\n+    \n+    test_reverse_fk_prefetch_with_slice()\n+    test_m2m_prefetch_with_slice()\n+    test_forward_fk_prefetch_with_slice()\n+    test_offset_and_limit()\n+    test_empty_slice()\n+    \n+    print(\"\\n\u2705 All tests passed!\")\ndiff --git a/test_prefetch_slice.py b/test_prefetch_slice.py\nnew file mode 100644\nindex 0000000000..b68822b77d\n--- /dev/null\n+++ b/test_prefetch_slice.py\n@@ -0,0 +1,72 @@\n+import django\n+from django.conf import settings\n+\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=['django.contrib.contenttypes', 'django.contrib.auth'],\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+from django.db import models\n+from django.test import TestCase\n+from django.db.models import Prefetch\n+\n+\n+class Category(models.Model):\n+    name = models.CharField(max_length=100)\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+class Post(models.Model):\n+    title = models.CharField(max_length=100)\n+    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='post_set')\n+    \n+    class Meta:\n+        app_label = 'test_app'\n+\n+\n+def test_prefetch_with_sliced_queryset():\n+    # Create test data\n+    cat1 = Category.objects.create(name=\"Category 1\")\n+    cat2 = Category.objects.create(name=\"Category 2\")\n+    \n+    for i in range(10):\n+        Post.objects.create(title=f\"Post {i} Cat 1\", category=cat1)\n+        Post.objects.create(title=f\"Post {i} Cat 2\", category=cat2)\n+    \n+    # Try to prefetch with a sliced queryset\n+    try:\n+        categories = Category.objects.prefetch_related(\n+            Prefetch(\n+                'post_set',\n+                queryset=Post.objects.all()[:3],\n+                to_attr='example_posts',\n+            )\n+        )\n+        # Force evaluation\n+        list(categories)\n+        print(\"Success! Prefetch with sliced queryset worked.\")\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        print(f\"Error type: {type(e)}\")\n+        import traceback\n+        traceback.print_exc()\n+\n+\n+if __name__ == \"__main__\":\n+    # Create tables\n+    from django.db import connection\n+    with connection.schema_editor() as schema_editor:\n+        schema_editor.create_model(Category)\n+        schema_editor.create_model(Post)\n+    \n+    test_prefetch_with_sliced_queryset()\n", "gold_standard_diff": "diff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex b192df4fbf9d..6e9f7bccbf7f 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -64,8 +64,10 @@ class Child(Model):\n \"\"\"\n \n from django.core.exceptions import FieldError\n-from django.db import connections, router, transaction\n-from django.db.models import Q, signals\n+from django.db import DEFAULT_DB_ALIAS, connections, router, transaction\n+from django.db.models import Q, Window, signals\n+from django.db.models.functions import RowNumber\n+from django.db.models.lookups import GreaterThan, LessThanOrEqual\n from django.db.models.query import QuerySet\n from django.db.models.query_utils import DeferredAttribute\n from django.db.models.utils import resolve_callables\n@@ -81,6 +83,24 @@ def __set__(self, instance, value):\n         instance.__dict__[self.field.attname] = value\n \n \n+def _filter_prefetch_queryset(queryset, field_name, instances):\n+    predicate = Q(**{f\"{field_name}__in\": instances})\n+    if queryset.query.is_sliced:\n+        low_mark, high_mark = queryset.query.low_mark, queryset.query.high_mark\n+        order_by = [\n+            expr\n+            for expr, _ in queryset.query.get_compiler(\n+                using=queryset._db or DEFAULT_DB_ALIAS\n+            ).get_order_by()\n+        ]\n+        window = Window(RowNumber(), partition_by=field_name, order_by=order_by)\n+        predicate &= GreaterThan(window, low_mark)\n+        if high_mark is not None:\n+            predicate &= LessThanOrEqual(window, high_mark)\n+        queryset.query.clear_limits()\n+    return queryset.filter(predicate)\n+\n+\n class ForwardManyToOneDescriptor:\n     \"\"\"\n     Accessor to the related object on the forward side of a many-to-one or\n@@ -718,8 +738,7 @@ def get_prefetch_queryset(self, instances, queryset=None):\n             rel_obj_attr = self.field.get_local_related_value\n             instance_attr = self.field.get_foreign_related_value\n             instances_dict = {instance_attr(inst): inst for inst in instances}\n-            query = {\"%s__in\" % self.field.name: instances}\n-            queryset = queryset.filter(**query)\n+            queryset = _filter_prefetch_queryset(queryset, self.field.name, instances)\n \n             # Since we just bypassed this class' get_queryset(), we must manage\n             # the reverse relation manually.\n@@ -1050,9 +1069,9 @@ def get_prefetch_queryset(self, instances, queryset=None):\n \n             queryset._add_hints(instance=instances[0])\n             queryset = queryset.using(queryset._db or self._db)\n-\n-            query = {\"%s__in\" % self.query_field_name: instances}\n-            queryset = queryset._next_is_sticky().filter(**query)\n+            queryset = _filter_prefetch_queryset(\n+                queryset._next_is_sticky(), self.query_field_name, instances\n+            )\n \n             # M2M: need to annotate the query in order to get the primary model\n             # that the secondary model was actually related to. We know that\ndiff --git a/docs/releases/4.2.txt b/docs/releases/4.2.txt\nindex ed00ee1350fb..1eaf22173ad0 100644\n--- a/docs/releases/4.2.txt\n+++ b/docs/releases/4.2.txt\n@@ -193,6 +193,9 @@ Models\n   :ref:`window-functions` with the exception of disjunctive filter lookups\n   against window functions when performing aggregation.\n \n+* :meth:`~.QuerySet.prefetch_related` now supports\n+  :class:`~django.db.models.Prefetch` objects with sliced querysets.\n+\n Requests and Responses\n ~~~~~~~~~~~~~~~~~~~~~~\n \ndiff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 1ac17fde7302..0ac05864767b 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1908,3 +1908,67 @@ def test_nested_prefetch_is_not_overwritten_by_related_object(self):\n         self.assertIs(Room.house.is_cached(self.room), True)\n         with self.assertNumQueries(0):\n             house.rooms.first().house.address\n+\n+\n+class PrefetchLimitTests(TestDataMixin, TestCase):\n+    def test_m2m_forward(self):\n+        authors = Author.objects.all()  # Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n+\n+    def test_m2m_reverse(self):\n+        books = Book.objects.order_by(\"title\")\n+        with self.assertNumQueries(3):\n+            authors = list(\n+                Author.objects.prefetch_related(\n+                    Prefetch(\"books\", books),\n+                    Prefetch(\"books\", books[1:2], to_attr=\"books_sliced\"),\n+                )\n+            )\n+        for author in authors:\n+            with self.subTest(author=author):\n+                self.assertEqual(author.books_sliced, list(author.books.all())[1:2])\n+\n+    def test_foreignkey_reverse(self):\n+        authors = Author.objects.order_by(\"-name\")\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors,\n+                    ),\n+                    Prefetch(\n+                        \"first_time_authors\",\n+                        authors[1:],\n+                        to_attr=\"first_time_authors_sliced\",\n+                    ),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(\n+                    book.first_time_authors_sliced,\n+                    list(book.first_time_authors.all())[1:],\n+                )\n+\n+    def test_reverse_ordering(self):\n+        authors = Author.objects.reverse()  # Reverse Meta.ordering\n+        with self.assertNumQueries(3):\n+            books = list(\n+                Book.objects.prefetch_related(\n+                    Prefetch(\"authors\", authors),\n+                    Prefetch(\"authors\", authors[1:], to_attr=\"authors_sliced\"),\n+                )\n+            )\n+        for book in books:\n+            with self.subTest(book=book):\n+                self.assertEqual(book.authors_sliced, list(book.authors.all())[1:])\n", "gold_standard_pr_link": "https://github.com/django/django/pull/15957"}