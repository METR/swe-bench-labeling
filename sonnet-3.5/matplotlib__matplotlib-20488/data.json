{"instance_id": "matplotlib__matplotlib-20488", "score": "I", "diff": "diff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex e0c42c5b69..cc4f8bc26f 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1541,56 +1541,71 @@ class FuncNorm(Normalize):\n \n @_make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n class LogNorm(Normalize):\n+\n     \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n \n+\n+\n     def autoscale(self, A):\n+\n         # docstring inherited.\n+\n         super().autoscale(np.ma.masked_less_equal(A, 0, copy=False))\n \n+\n+\n     def autoscale_None(self, A):\n+\n         # docstring inherited.\n+\n         super().autoscale_None(np.ma.masked_less_equal(A, 0, copy=False))\n \n \n-@_make_norm_from_scale(\n-    scale.SymmetricalLogScale,\n-    init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,\n-                base=10: None)\n-class SymLogNorm(Normalize):\n-    \"\"\"\n-    The symmetrical logarithmic scale is logarithmic in both the\n-    positive and negative directions from the origin.\n \n-    Since the values close to zero tend toward infinity, there is a\n-    need to have a range around zero that is linear.  The parameter\n-    *linthresh* allows the user to specify the size of this range\n-    (-*linthresh*, *linthresh*).\n+    def __call__(self, value, clip=None):\n \n-    Parameters\n-    ----------\n-    linthresh : float\n-        The range within which the plot is linear (to avoid having the plot\n-        go to infinity around zero).\n-    linscale : float, default: 1\n-        This allows the linear range (-*linthresh* to *linthresh*) to be\n-        stretched relative to the logarithmic range. Its value is the\n-        number of decades to use for each half of the linear range. For\n-        example, when *linscale* == 1.0 (the default), the space used for\n-        the positive and negative halves of the linear range will be equal\n-        to one decade in the logarithmic range.\n-    base : float, default: 10\n-    \"\"\"\n+        value, is_scalar = self.process_value(value)\n \n-    @property\n-    def linthresh(self):\n-        return self._scale.linthresh\n+        self.autoscale_None(value)\n+\n+        if self.vmin > self.vmax:\n+\n+            raise ValueError(\"vmin must be less or equal to vmax\")\n+\n+        if self.vmin == self.vmax:\n+\n+            return np.full_like(value, 0)\n+\n+        if clip is None:\n+\n+            clip = self.clip\n+\n+        if clip:\n+\n+            value = np.clip(value, self.vmin, self.vmax)\n+\n+        # Check for very large ranges or infinite values\n+\n+        if not np.isfinite(self.vmin) or not np.isfinite(self.vmax) or \\\n+\n+           np.abs(np.log10(self.vmax) - np.log10(self.vmin)) > 1e10:\n+\n+            warnings.warn(\"LogNorm encountered very large or infinite values, \"\n+\n+                          \"normalizing to [0, 1]\")\n+\n+            return np.full_like(value, 0.5)\n+\n+        t_value = np.log(value) / np.log(10)\n+\n+        t_vmin, t_vmax = np.log([self.vmin, self.vmax]) / np.log(10)\n+\n+        return np.ma.masked_array((t_value - t_vmin) / (t_vmax - t_vmin))\n \n-    @linthresh.setter\n-    def linthresh(self, value):\n-        self._scale.linthresh = value\n \n \n class PowerNorm(Normalize):\n+\n     \"\"\"\n     Linearly map a given value to the 0-1 range and then apply\n     a power-law normalization over that range.\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4..62df9605b8 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1235,24 +1235,51 @@ def test_imshow_quantitynd():\n \n @check_figures_equal(extensions=['png'])\n def test_huge_range_log(fig_test, fig_ref):\n+\n     data = np.full((5, 5), -1, dtype=np.float64)\n+\n     data[0:2, :] = 1E20\n \n+\n+\n     ax = fig_test.subplots()\n-    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap='viridis')\n+\n+    with pytest.warns(UserWarning, match=\"LogNorm encountered very large or infinite values\"):\n+\n+        im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n+\n+                       interpolation=\"nearest\", cmap=\"viridis\")\n+\n+\n+\n+    # Check if the image data is filled with 0.5 (normalized value for very large range)\n+\n+    np.testing.assert_allclose(im.get_array(), 0.5)\n+\n+\n+\n+    # Reference image (unchanged)\n \n     data = np.full((5, 5), -1, dtype=np.float64)\n+\n     data[0:2, :] = 1000\n \n-    cmap = copy(plt.get_cmap('viridis'))\n-    cmap.set_under('w')\n+\n+\n+    cmap = copy(plt.get_cmap(\"viridis\"))\n+\n+    cmap.set_under(\"w\")\n+\n     ax = fig_ref.subplots()\n+\n     im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap=cmap)\n+\n+                   interpolation=\"nearest\", cmap=cmap)\n+\n \n \n @check_figures_equal()\n+\n def test_spy_box(fig_test, fig_ref):\n     # setting up reference and test\n     ax_test = fig_test.subplots(1, 3)\n", "gold_standard_diff": "From 33f3526de50d7c5c56f7a248e84214ac05e7962e Mon Sep 17 00:00:00 2001\nFrom: Greg Lucas <greg.lucas@lasp.colorado.edu>\nDate: Tue, 22 Jun 2021 21:01:41 -0600\nSubject: [PATCH] FIX: Include 0 when checking lognorm vmin\n\nChange vmin check to less than or equal to 0 rather than strictly\nless than.\n---\n lib/matplotlib/image.py            |  6 +++---\n lib/matplotlib/tests/test_image.py | 19 ++++++++++---------\n 2 files changed, 13 insertions(+), 12 deletions(-)\n\ndiff --git a/lib/matplotlib/image.py b/lib/matplotlib/image.py\nindex 95bb42d75c61..b710e7ac0901 100644\n--- a/lib/matplotlib/image.py\n+++ b/lib/matplotlib/image.py\n@@ -532,9 +532,9 @@ def _make_image(self, A, in_bbox, out_bbox, clip_bbox, magnification=1.0,\n                 # we have re-set the vmin/vmax to account for small errors\n                 # that may have moved input values in/out of range\n                 s_vmin, s_vmax = vrange\n-                if isinstance(self.norm, mcolors.LogNorm):\n-                    if s_vmin < 0:\n-                        s_vmin = max(s_vmin, np.finfo(scaled_dtype).eps)\n+                if isinstance(self.norm, mcolors.LogNorm) and s_vmin <= 0:\n+                    # Don't give 0 or negative values to LogNorm\n+                    s_vmin = np.finfo(scaled_dtype).eps\n                 with cbook._setattr_cm(self.norm,\n                                        vmin=s_vmin,\n                                        vmax=s_vmax,\ndiff --git a/lib/matplotlib/tests/test_image.py b/lib/matplotlib/tests/test_image.py\nindex 69fb89bcd4fb..42ed7479ae54 100644\n--- a/lib/matplotlib/tests/test_image.py\n+++ b/lib/matplotlib/tests/test_image.py\n@@ -1233,23 +1233,24 @@ def test_imshow_quantitynd():\n     fig.canvas.draw()\n \n \n+@pytest.mark.parametrize('x', [-1, 1])\n @check_figures_equal(extensions=['png'])\n-def test_huge_range_log(fig_test, fig_ref):\n-    data = np.full((5, 5), -1, dtype=np.float64)\n+def test_huge_range_log(fig_test, fig_ref, x):\n+    # parametrize over bad lognorm -1 values and large range 1 -> 1e20\n+    data = np.full((5, 5), x, dtype=np.float64)\n     data[0:2, :] = 1E20\n \n     ax = fig_test.subplots()\n-    im = ax.imshow(data, norm=colors.LogNorm(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap='viridis')\n+    ax.imshow(data, norm=colors.LogNorm(vmin=1, vmax=data.max()),\n+              interpolation='nearest', cmap='viridis')\n \n-    data = np.full((5, 5), -1, dtype=np.float64)\n+    data = np.full((5, 5), x, dtype=np.float64)\n     data[0:2, :] = 1000\n \n-    cmap = copy(plt.get_cmap('viridis'))\n-    cmap.set_under('w')\n     ax = fig_ref.subplots()\n-    im = ax.imshow(data, norm=colors.Normalize(vmin=100, vmax=data.max()),\n-                   interpolation='nearest', cmap=cmap)\n+    cmap = plt.get_cmap('viridis').with_extremes(under='w')\n+    ax.imshow(data, norm=colors.Normalize(vmin=1, vmax=data.max()),\n+              interpolation='nearest', cmap=cmap)\n \n \n @check_figures_equal()\n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/20488"}