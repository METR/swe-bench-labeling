diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py
index c957ffa564..4138a6c22b 100644
--- a/django/db/models/query_utils.py
+++ b/django/db/models/query_utils.py
@@ -25,6 +25,10 @@ def subclasses(cls):
         yield from subclasses(subclass)
 
 
+def is_exists(obj):
+    return obj.__class__.__name__ == 'Exists'
+
+
 class Q(tree.Node):
     """
     Encapsulate filters as objects that can then be combined logically (using
@@ -37,25 +41,35 @@ class Q(tree.Node):
     conditional = True
 
     def __init__(self, *args, _connector=None, _negated=False, **kwargs):
-        super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)
+        children = []
+        for arg in args:
+            if is_exists(arg):
+                children.append(('', arg))
+            else:
+                children.append(arg)
+        children.extend(sorted(kwargs.items()))
+        super().__init__(children=children, connector=_connector, negated=_negated)
 
     def _combine(self, other, conn):
-        if not isinstance(other, Q):
+        if not isinstance(other, Q) and not is_exists(other):
             raise TypeError(other)
 
-        # If the other Q() is empty, ignore it and just use `self`.
-        if not other:
-            _, args, kwargs = self.deconstruct()
-            return type(self)(*args, **kwargs)
-        # Or if this Q is empty, ignore it and just use `other`.
-        elif not self:
-            _, args, kwargs = other.deconstruct()
-            return type(other)(*args, **kwargs)
-
         obj = type(self)()
         obj.connector = conn
-        obj.add(self, conn)
-        obj.add(other, conn)
+
+        # If the other Q() is empty and self is not Exists, just use `self`.
+        if not other and not is_exists(self):
+            obj.add(self, conn)
+        # If this Q is empty and other is not Exists, just use `other`.
+        elif not self and not is_exists(other):
+            obj.add(other, conn)
+        else:
+            obj.add(self, conn)
+            if is_exists(other):
+                obj.add(('', other), conn)
+            else:
+                obj.add(other, conn)
+
         return obj
 
     def __or__(self, other):
@@ -64,6 +78,9 @@ class Q(tree.Node):
     def __and__(self, other):
         return self._combine(other, self.AND)
 
+    def __rand__(self, other):
+        return self._combine(other, self.AND)
+
     def __invert__(self):
         obj = type(self)()
         obj.add(self, self.AND)
diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py
index 6dcf36ce02..9364a28326 100644
--- a/tests/queries/test_q.py
+++ b/tests/queries/test_q.py
@@ -111,3 +111,23 @@ class QTests(SimpleTestCase):
         q = q1 & q2
         path, args, kwargs = q.deconstruct()
         self.assertEqual(Q(*args, **kwargs), q)
+
+    def test_q_and_exists(self):
+        from django.db.models import Exists
+        from django.db.models.expressions import RawSQL
+        q = Q()
+        exists = Exists(RawSQL("SELECT 1", []))
+        combined = q & exists
+        self.assertIsInstance(combined, Q)
+        self.assertEqual(combined.connector, Q.AND)
+        self.assertEqual(len(combined.children), 2)
+        self.assertIs(combined.children[0], q)
+        self.assertIs(combined.children[1], exists)
+
+        # Test the reverse order
+        combined_reverse = exists & q
+        self.assertIsInstance(combined_reverse, Q)
+        self.assertEqual(combined_reverse.connector, Q.AND)
+        self.assertEqual(len(combined_reverse.children), 2)
+        self.assertIs(combined_reverse.children[0], exists)
+        self.assertIs(combined_reverse.children[1], q)
\ No newline at end of file
