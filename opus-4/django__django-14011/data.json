{"instance_id": "django__django-14011", "score": "I", "diff": "diff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 92f566b7b0..a1c90dca2d 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1399,6 +1399,16 @@ class QuietWSGIRequestHandler(WSGIRequestHandler):\n     \"\"\"\n     def log_message(*args):\n         pass\n+    \n+    def handle_one_request(self):\n+        \"\"\"\n+        Handle a single HTTP request and ensure database connections are closed.\n+        \"\"\"\n+        # Call parent method to handle the request\n+        super().handle_one_request()\n+        # Close database connections after handling the request in thread\n+        # This ensures connections don't leak when using ThreadedWSGIServer\n+        connections.close_all()\n \n \n class FSFilesHandler(WSGIHandler):\ndiff --git a/test_db_connection_issue.py b/test_db_connection_issue.py\nnew file mode 100644\nindex 0000000000..d5d162bc70\n--- /dev/null\n+++ b/test_db_connection_issue.py\n@@ -0,0 +1,118 @@\n+\"\"\"\n+Test to reproduce the database connection issue with ThreadedWSGIServer\n+\"\"\"\n+import os\n+import sys\n+import tempfile\n+import threading\n+import time\n+from django.conf import settings\n+from django.test import LiveServerTestCase, override_settings\n+from django.db import connections, DEFAULT_DB_ALIAS\n+from django.test.client import Client\n+import django\n+\n+# Create a temporary database file\n+temp_db = tempfile.NamedTemporaryFile(suffix='.db', delete=False)\n+temp_db.close()\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': temp_db.name,\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    MIDDLEWARE=[],\n+    ROOT_URLCONF='test_db_connection_issue',\n+    SECRET_KEY='test-secret-key',\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# URL configuration\n+from django.urls import path\n+from django.http import HttpResponse\n+\n+def test_view(request):\n+    # Access the database to ensure a connection is created\n+    from django.contrib.auth.models import User\n+    User.objects.exists()\n+    return HttpResponse('OK')\n+\n+urlpatterns = [\n+    path('test/', test_view),\n+]\n+\n+class TestDBConnectionsWithThreadedServer(LiveServerTestCase):\n+    \"\"\"Test that database connections are properly closed in ThreadedWSGIServer\"\"\"\n+    \n+    def test_threaded_requests_close_connections(self):\n+        \"\"\"Make multiple concurrent requests and verify connections are closed\"\"\"\n+        results = []\n+        errors = []\n+        \n+        def make_request():\n+            try:\n+                import urllib.request\n+                response = urllib.request.urlopen(self.live_server_url + '/test/')\n+                results.append(response.getcode())\n+                response.close()\n+            except Exception as e:\n+                errors.append(e)\n+        \n+        # Create multiple threads to make concurrent requests\n+        threads = []\n+        for i in range(10):\n+            t = threading.Thread(target=make_request)\n+            threads.append(t)\n+            t.start()\n+        \n+        # Wait for all threads to complete\n+        for t in threads:\n+            t.join()\n+        \n+        # Check that all requests succeeded\n+        self.assertEqual(len(errors), 0, f\"Errors occurred: {errors}\")\n+        self.assertEqual(len(results), 10)\n+        self.assertTrue(all(status == 200 for status in results))\n+        \n+        # Give some time for connections to be closed\n+        time.sleep(0.1)\n+        \n+        # Check that there are no lingering connections\n+        # This is the key test - if connections aren't properly closed,\n+        # the database teardown will fail with \"database is being accessed by other users\"\n+\n+\n+if __name__ == '__main__':\n+    from django.test.runner import DiscoverRunner\n+    import atexit\n+    \n+    # Clean up the temp file on exit\n+    atexit.register(lambda: os.unlink(temp_db.name) if os.path.exists(temp_db.name) else None)\n+    \n+    runner = DiscoverRunner(verbosity=2)\n+    runner.setup_test_environment()\n+    old_config = runner.setup_databases()\n+    \n+    try:\n+        # Run the test\n+        suite = runner.test_loader.loadTestsFromTestCase(TestDBConnectionsWithThreadedServer)\n+        result = runner.test_runner(verbosity=2).run(suite)\n+        \n+        if result.wasSuccessful():\n+            print(\"\\nAll tests passed! Database connections are being properly closed.\")\n+        else:\n+            print(f\"\\nTests failed: {len(result.failures)} failures, {len(result.errors)} errors\")\n+    finally:\n+        # This is where the error would occur if connections aren't closed\n+        runner.teardown_databases(old_config)\n+        runner.teardown_test_environment()\ndiff --git a/test_liveserver_db_connections.py b/test_liveserver_db_connections.py\nnew file mode 100644\nindex 0000000000..a1027b4131\n--- /dev/null\n+++ b/test_liveserver_db_connections.py\n@@ -0,0 +1,77 @@\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test import LiveServerTestCase\n+from django.test.client import Client\n+from django.db import connections\n+\n+# Configure Django settings\n+os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'django.conf.global_settings')\n+\n+# Create a simple URLconf module\n+import django.http\n+\n+def empty_view(request):\n+    return django.http.HttpResponse('OK')\n+\n+urlpatterns = []\n+\n+# We need to configure settings before importing Django\n+settings.configure(\n+    DEBUG=True,\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+        'django.contrib.auth',\n+    ],\n+    MIDDLEWARE=[],\n+    ROOT_URLCONF=__name__,  # Use this module as URLconf\n+    SECRET_KEY='test-secret-key',\n+    USE_TZ=True,\n+)\n+\n+django.setup()\n+\n+# Define a simple test\n+class TestLiveServerDBConnections(LiveServerTestCase):\n+    def test_database_connections_closed(self):\n+        \"\"\"Test that database connections are properly closed after requests.\"\"\"\n+        # Make several requests to the live server\n+        client = Client()\n+        for i in range(5):\n+            response = client.get(self.live_server_url + '/')\n+            # Each request should get a 404 since we have no URLs configured\n+            self.assertEqual(response.status_code, 404)\n+        \n+        # After the test, connections should be closed properly\n+        # The test framework will try to destroy the test database\n+        # If connections aren't closed, it will raise an OperationalError\n+\n+\n+if __name__ == '__main__':\n+    # Run the test using Django's test runner\n+    from django.test import TestCase\n+    from django.test.runner import DiscoverRunner\n+    \n+    runner = DiscoverRunner(verbosity=2)\n+    runner.setup_test_environment()\n+    old_config = runner.setup_databases()\n+    \n+    try:\n+        # Run the test class\n+        suite = runner.test_loader.loadTestsFromTestCase(TestLiveServerDBConnections)\n+        result = runner.test_runner(verbosity=2).run(suite)\n+        \n+        if result.wasSuccessful():\n+            print(\"\\nAll tests passed!\")\n+        else:\n+            print(f\"\\nTests failed: {len(result.failures)} failures, {len(result.errors)} errors\")\n+    finally:\n+        runner.teardown_databases(old_config)\n+        runner.teardown_test_environment()\n", "gold_standard_diff": "From 71a936f9d84864a1420ce3ecc3de4a4908dff1e8 Mon Sep 17 00:00:00 2001\nFrom: Chris Jerdonek <chris.jerdonek@gmail.com>\nDate: Mon, 12 Apr 2021 08:41:39 +0200\nSubject: [PATCH 1/2] Refs #32416 -- Added\n LiveServerTestCase._make_connections_override() hook.\n\n---\n django/test/testcases.py | 15 +++++++++++----\n 1 file changed, 11 insertions(+), 4 deletions(-)\n\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 92f566b7b0a9..6ae27243b1fb 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1553,21 +1553,28 @@ def allowed_host(cls):\n         return cls.host\n \n     @classmethod\n-    def setUpClass(cls):\n-        super().setUpClass()\n+    def _make_connections_override(cls):\n         connections_override = {}\n         for conn in connections.all():\n             # If using in-memory sqlite databases, pass the connections to\n             # the server thread.\n             if conn.vendor == 'sqlite' and conn.is_in_memory_db():\n-                # Explicitly enable thread-shareability for this connection\n-                conn.inc_thread_sharing()\n                 connections_override[conn.alias] = conn\n+        return connections_override\n \n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n         cls._live_server_modified_settings = modify_settings(\n             ALLOWED_HOSTS={'append': cls.allowed_host},\n         )\n         cls._live_server_modified_settings.enable()\n+\n+        connections_override = cls._make_connections_override()\n+        for conn in connections_override.values():\n+            # Explicitly enable thread-shareability for this connection.\n+            conn.inc_thread_sharing()\n+\n         cls.server_thread = cls._create_server_thread(connections_override)\n         cls.server_thread.daemon = True\n         cls.server_thread.start()\n\nFrom 823a9e6bac38d38f7b0347497b833eec732bd384 Mon Sep 17 00:00:00 2001\nFrom: Chris Jerdonek <chris.jerdonek@gmail.com>\nDate: Sun, 14 Feb 2021 22:10:59 -0800\nSubject: [PATCH 2/2] Fixed #32416 -- Made ThreadedWSGIServer close connections\n after each thread.\n\nThreadedWSGIServer is used by LiveServerTestCase.\n---\n django/core/servers/basehttp.py        | 23 +++++++++\n django/db/backends/sqlite3/features.py |  1 +\n django/test/testcases.py               |  5 +-\n tests/servers/tests.py                 | 69 +++++++++++++++++++++++++-\n 4 files changed, 95 insertions(+), 3 deletions(-)\n\ndiff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex 14dab517c99b..6cc8a46778bf 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -16,6 +16,7 @@\n from django.core.exceptions import ImproperlyConfigured\n from django.core.handlers.wsgi import LimitedStream\n from django.core.wsgi import get_wsgi_application\n+from django.db import connections\n from django.utils.module_loading import import_string\n \n __all__ = ('WSGIServer', 'WSGIRequestHandler')\n@@ -81,6 +82,28 @@ class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n     \"\"\"A threaded version of the WSGIServer\"\"\"\n     daemon_threads = True\n \n+    def __init__(self, *args, connections_override=None, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.connections_override = connections_override\n+\n+    # socketserver.ThreadingMixIn.process_request() passes this method as\n+    # the target to a new Thread object.\n+    def process_request_thread(self, request, client_address):\n+        if self.connections_override:\n+            # Override this thread's database connections with the ones\n+            # provided by the parent thread.\n+            for alias, conn in self.connections_override.items():\n+                connections[alias] = conn\n+        super().process_request_thread(request, client_address)\n+\n+    def _close_connections(self):\n+        # Used for mocking in tests.\n+        connections.close_all()\n+\n+    def close_request(self, request):\n+        self._close_connections()\n+        super().close_request(request)\n+\n \n class ServerHandler(simple_server.ServerHandler):\n     http_version = '1.1'\ndiff --git a/django/db/backends/sqlite3/features.py b/django/db/backends/sqlite3/features.py\nindex 6a7aa09fc9e9..ff3e3f47a9fa 100644\n--- a/django/db/backends/sqlite3/features.py\n+++ b/django/db/backends/sqlite3/features.py\n@@ -83,6 +83,7 @@ def django_test_skips(self):\n                 \"the sqlite backend's close() method is a no-op when using an \"\n                 \"in-memory database\": {\n                     'servers.test_liveserverthread.LiveServerThreadTest.test_closes_connections',\n+                    'servers.tests.LiveServerTestCloseConnectionTest.test_closes_connections',\n                 },\n             })\n         return skips\ndiff --git a/django/test/testcases.py b/django/test/testcases.py\nindex 6ae27243b1fb..53508cdb8abd 100644\n--- a/django/test/testcases.py\n+++ b/django/test/testcases.py\n@@ -1513,11 +1513,12 @@ def run(self):\n         finally:\n             connections.close_all()\n \n-    def _create_server(self):\n+    def _create_server(self, connections_override=None):\n         return self.server_class(\n             (self.host, self.port),\n             QuietWSGIRequestHandler,\n             allow_reuse_address=False,\n+            connections_override=connections_override,\n         )\n \n     def terminate(self):\n@@ -1600,7 +1601,7 @@ def _create_server_thread(cls, connections_override):\n     def _tearDownClassInternal(cls):\n         # Terminate the live server's thread.\n         cls.server_thread.terminate()\n-        # Restore sqlite in-memory database connections' non-shareability.\n+        # Restore shared connections' non-shareability.\n         for conn in cls.server_thread.connections_override.values():\n             conn.dec_thread_sharing()\n \ndiff --git a/tests/servers/tests.py b/tests/servers/tests.py\nindex 8b6e37241941..c4b8298fd84e 100644\n--- a/tests/servers/tests.py\n+++ b/tests/servers/tests.py\n@@ -4,13 +4,15 @@\n import errno\n import os\n import socket\n+import threading\n from http.client import HTTPConnection\n from urllib.error import HTTPError\n from urllib.parse import urlencode\n from urllib.request import urlopen\n \n from django.conf import settings\n-from django.core.servers.basehttp import WSGIServer\n+from django.core.servers.basehttp import ThreadedWSGIServer, WSGIServer\n+from django.db import DEFAULT_DB_ALIAS, connections\n from django.test import LiveServerTestCase, override_settings\n from django.test.testcases import LiveServerThread, QuietWSGIRequestHandler\n \n@@ -40,6 +42,71 @@ def urlopen(self, url):\n         return urlopen(self.live_server_url + url)\n \n \n+class CloseConnectionTestServer(ThreadedWSGIServer):\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        # This event is set right after the first time a request closes its\n+        # database connections.\n+        self._connections_closed = threading.Event()\n+\n+    def _close_connections(self):\n+        super()._close_connections()\n+        self._connections_closed.set()\n+\n+\n+class CloseConnectionTestLiveServerThread(LiveServerThread):\n+\n+    server_class = CloseConnectionTestServer\n+\n+    def _create_server(self, connections_override=None):\n+        return super()._create_server(connections_override=self.connections_override)\n+\n+\n+class LiveServerTestCloseConnectionTest(LiveServerBase):\n+\n+    server_thread_class = CloseConnectionTestLiveServerThread\n+\n+    @classmethod\n+    def _make_connections_override(cls):\n+        conn = connections[DEFAULT_DB_ALIAS]\n+        cls.conn = conn\n+        cls.old_conn_max_age = conn.settings_dict['CONN_MAX_AGE']\n+        # Set the connection's CONN_MAX_AGE to None to simulate the\n+        # CONN_MAX_AGE setting being set to None on the server. This prevents\n+        # Django from closing the connection and allows testing that\n+        # ThreadedWSGIServer closes connections.\n+        conn.settings_dict['CONN_MAX_AGE'] = None\n+        # Pass a database connection through to the server to check it is being\n+        # closed by ThreadedWSGIServer.\n+        return {DEFAULT_DB_ALIAS: conn}\n+\n+    @classmethod\n+    def tearDownConnectionTest(cls):\n+        cls.conn.settings_dict['CONN_MAX_AGE'] = cls.old_conn_max_age\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.tearDownConnectionTest()\n+        super().tearDownClass()\n+\n+    def test_closes_connections(self):\n+        # The server's request thread sets this event after closing\n+        # its database connections.\n+        closed_event = self.server_thread.httpd._connections_closed\n+        conn = self.conn\n+        # Open a connection to the database.\n+        conn.connect()\n+        self.assertIsNotNone(conn.connection)\n+        with self.urlopen('/model_view/') as f:\n+            # The server can access the database.\n+            self.assertEqual(f.read().splitlines(), [b'jane', b'robert'])\n+        # Wait for the server's request thread to close the connection.\n+        # A timeout of 0.1 seconds should be more than enough. If the wait\n+        # times out, the assertion after should fail.\n+        closed_event.wait(timeout=0.1)\n+        self.assertIsNone(conn.connection)\n+\n+\n class FailingLiveServerThread(LiveServerThread):\n     def _create_server(self):\n         raise RuntimeError('Error creating server.')\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14011"}