diff --git a/debug_lookups.py b/debug_lookups.py
new file mode 100644
index 0000000000..5d020eed29
--- /dev/null
+++ b/debug_lookups.py
@@ -0,0 +1,67 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, connection
+from django.db.models import lookups
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=False,
+    )
+    django.setup()
+
+# Define test model
+class TestModel(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Let's check which lookups are registered on KeyTransform
+from django.db.models.fields.json import KeyTransform
+print("Registered lookups on KeyTransform:")
+for name, lookup in KeyTransform.get_lookups().items():
+    print(f"  {name}: {lookup}")
+
+# Check if In is registered
+print(f"\nIs 'in' lookup registered? {'in' in KeyTransform.get_lookups()}")
+
+# Check what happens when we try to use __in
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+TestModel.objects.create(data={'key': 0})
+
+# Try to understand the lookup resolution
+qs = TestModel.objects.filter(data__key__in=[0])
+print("\nQueryset for data__key__in=[0]:")
+try:
+    print(f"Count: {qs.count()}")
+except Exception as e:
+    print(f"Error: {e}")
+    
+# Let's trace what's happening with the query construction
+import logging
+logging.basicConfig(level=logging.DEBUG)
+logger = logging.getLogger('django.db.backends')
+logger.setLevel(logging.DEBUG)
+
+print("\nTrying query with logging...")
+try:
+    qs = TestModel.objects.filter(data__key__in=[0])
+    list(qs)
+except Exception as e:
+    print(f"Error executing query: {e}")
diff --git a/django/db/models/fields/json.py b/django/db/models/fields/json.py
index fafc1beee8..be6a811ba7 100644
--- a/django/db/models/fields/json.py
+++ b/django/db/models/fields/json.py
@@ -479,6 +479,43 @@ class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual
     pass
 
 
+class KeyTransformIn(lookups.In):
+    def process_rhs(self, compiler, connection):
+        # Get the base process_rhs from In lookup
+        rhs, rhs_params = super().process_rhs(compiler, connection)
+        
+        # For MySQL, Oracle, and SQLite, we need to wrap values in JSON_EXTRACT
+        # similar to how KeyTransformExact does it
+        if connection.vendor == 'mysql':
+            # MySQL requires JSON_EXTRACT for each value
+            if self.rhs_is_direct_value():
+                func = ["JSON_EXTRACT(%s, '$')"] * len(rhs_params)
+                rhs = rhs % tuple(func)
+        elif connection.vendor == 'oracle':
+            # Oracle needs special handling for JSON values
+            if self.rhs_is_direct_value():
+                func = []
+                new_params = []
+                for value in rhs_params:
+                    val = json.loads(value)
+                    function = 'JSON_QUERY' if isinstance(val, (list, dict)) else 'JSON_VALUE'
+                    func.append("%s('%s', '$.value')" % (
+                        function,
+                        json.dumps({'value': val}),
+                    ))
+                # Replace placeholders with the JSON functions
+                placeholders = rhs.strip('()').split(', ')
+                rhs = '(' + ', '.join(func) + ')'
+                rhs_params = []
+        elif connection.vendor == 'sqlite':
+            # SQLite also needs JSON_EXTRACT for proper comparison
+            if self.rhs_is_direct_value():
+                func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in rhs_params]
+                rhs = rhs % tuple(func)
+        
+        return rhs, rhs_params
+
+
 KeyTransform.register_lookup(KeyTransformExact)
 KeyTransform.register_lookup(KeyTransformIExact)
 KeyTransform.register_lookup(KeyTransformIsNull)
@@ -494,6 +531,7 @@ KeyTransform.register_lookup(KeyTransformLt)
 KeyTransform.register_lookup(KeyTransformLte)
 KeyTransform.register_lookup(KeyTransformGt)
 KeyTransform.register_lookup(KeyTransformGte)
+KeyTransform.register_lookup(KeyTransformIn)
 
 
 class KeyTransformFactory:
diff --git a/test_final_verification.py b/test_final_verification.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test_json_in_different_dbs.py b/test_json_in_different_dbs.py
new file mode 100644
index 0000000000..471f35b261
--- /dev/null
+++ b/test_json_in_different_dbs.py
@@ -0,0 +1,93 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, connection
+
+# Test with different database backends
+test_configs = [
+    {
+        'name': 'SQLite',
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    },
+    # We can't easily test MySQL and Oracle without actual database servers
+]
+
+for config in test_configs:
+    print(f"\n{'='*50}")
+    print(f"Testing with {config['name']}")
+    print('='*50)
+    
+    if settings.configured:
+        # Reset settings
+        settings._wrapped = None
+    
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': config
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=False,
+    )
+    django.setup()
+    
+    # Define test model
+    class TestModel(models.Model):
+        data = models.JSONField()
+        
+        class Meta:
+            app_label = 'test'
+    
+    # Create the table
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Create test data
+    TestModel.objects.create(data={'key': 0})
+    TestModel.objects.create(data={'key': 1}) 
+    TestModel.objects.create(data={'key': 2})
+    TestModel.objects.create(data={'other_key': 3})
+    TestModel.objects.create(data={'key': 'string_value'})
+    TestModel.objects.create(data={'key': [1, 2, 3]})  # Array value
+    TestModel.objects.create(data={'key': {'nested': 'object'}})  # Object value
+    
+    # Test various scenarios
+    tests = [
+        ('data__key__in', [0], "Single numeric value"),
+        ('data__key__in', [0, 1], "Multiple numeric values"),
+        ('data__key__in', ['string_value'], "String value"),
+        ('data__key__in', [0, 'string_value'], "Mixed types"),
+        ('data__key__in', [[1, 2, 3]], "Array value (should match the array)"),
+        ('data__key__in', [{'nested': 'object'}], "Object value"),
+    ]
+    
+    for lookup, values, description in tests:
+        filter_dict = {lookup: values}
+        items = TestModel.objects.filter(**filter_dict)
+        print(f"\n{description}: {lookup}={values}")
+        print(f"  Count: {items.count()}")
+        
+        # Also test exact match for comparison
+        if len(values) == 1:
+            exact_filter = {'data__key': values[0]}
+            exact_items = TestModel.objects.filter(**exact_filter)
+            print(f"  Exact match count: {exact_items.count()}")
+    
+    # Test edge cases
+    print("\n\nEdge cases:")
+    
+    # Empty list
+    empty_list = TestModel.objects.filter(data__key__in=[])
+    print(f"Empty list: {empty_list.count()} (should be 0)")
+    
+    # None in list (should be ignored like regular In lookup)
+    none_list = TestModel.objects.filter(data__key__in=[0, None, 1])
+    print(f"List with None: {none_list.count()} (should be 2, None is ignored)")
+    
+    # Cleanup
+    TestModel.objects.all().delete()
diff --git a/test_json_in_lookup.py b/test_json_in_lookup.py
new file mode 100644
index 0000000000..69fbe0abd8
--- /dev/null
+++ b/test_json_in_lookup.py
@@ -0,0 +1,60 @@
+import os
+import django
+from django.conf import settings
+from django.db import models, connection
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        USE_TZ=False,
+    )
+    django.setup()
+
+# Define test model
+class TestModel(models.Model):
+    data = models.JSONField()
+    
+    class Meta:
+        app_label = 'test'
+
+# Create the table
+from django.db import connection
+with connection.schema_editor() as schema_editor:
+    schema_editor.create_model(TestModel)
+
+# Create test data
+TestModel.objects.create(data={'key': 0})
+TestModel.objects.create(data={'key': 1})
+TestModel.objects.create(data={'key': 2})
+TestModel.objects.create(data={'other_key': 3})
+
+# Test the issue
+print("Testing __in lookup on JSON field key transform...")
+first_filter = {'data__key__in': [0]}
+first_items = TestModel.objects.filter(**first_filter)
+print(f"Items with data__key__in=[0]: {first_items.count()}")
+
+second_filter = {'data__key': 0}
+second_items = TestModel.objects.filter(**second_filter)
+print(f"Items with data__key=0: {second_items.count()}")
+
+# Let's also test with multiple values
+third_filter = {'data__key__in': [0, 1]}
+third_items = TestModel.objects.filter(**third_filter)
+print(f"Items with data__key__in=[0, 1]: {third_items.count()}")
+
+# Check what SQL is generated
+print("\nSQL queries:")
+print("For __in lookup:", first_items.query)
+print("For exact lookup:", second_items.query)
diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py
index a7648711ac..a7c8b07d9e 100644
--- a/tests/model_fields/test_jsonfield.py
+++ b/tests/model_fields/test_jsonfield.py
@@ -531,6 +531,77 @@ class TestQuerying(TestCase):
             [self.objs[4]],
         )
 
+    def test_key_in(self):
+        # Test __in lookup on key transforms
+        objs = [
+            NullableJSONModel.objects.create(value={'x': 0}),
+            NullableJSONModel.objects.create(value={'x': 1}),
+            NullableJSONModel.objects.create(value={'x': 2}),
+            NullableJSONModel.objects.create(value={'x': 'foo'}),
+            NullableJSONModel.objects.create(value={'y': 0}),
+            NullableJSONModel.objects.create(value={'x': [1, 2]}),
+            NullableJSONModel.objects.create(value={'x': {'y': 'z'}}),
+        ]
+        
+        # Test with single value
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[0]),
+            [objs[0]],
+        )
+        
+        # Test with multiple numeric values
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[0, 1]).order_by('id'),
+            [objs[0], objs[1]],
+        )
+        
+        # Test with string value
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=['foo']),
+            [objs[3]],
+        )
+        
+        # Test with mixed types
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[0, 'foo']).order_by('id'),
+            [objs[0], objs[3]],
+        )
+        
+        # Test with empty list
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[]),
+            [],
+        )
+        
+        # Test with None in the list (should be ignored)
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[0, None, 1]).order_by('id'),
+            [objs[0], objs[1]],
+        )
+        
+        # Test with array value
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[[1, 2]]),
+            [objs[5]],
+        )
+        
+        # Test with object value
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__x__in=[{'y': 'z'}]),
+            [objs[6]],
+        )
+        
+        # Test nested key transform with __in
+        nested_objs = [
+            NullableJSONModel.objects.create(value={'a': {'b': 1}}),
+            NullableJSONModel.objects.create(value={'a': {'b': 2}}),
+            NullableJSONModel.objects.create(value={'a': {'b': 3}}),
+        ]
+        self.assertSequenceEqual(
+            NullableJSONModel.objects.filter(value__a__b__in=[1, 3]).order_by('id'),
+            [nested_objs[0], nested_objs[2]],
+        )
+
     def test_none_key_exclude(self):
         obj = NullableJSONModel.objects.create(value={'j': 1})
         if connection.vendor == 'oracle':
