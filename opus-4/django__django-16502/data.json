{"instance_id": "django__django-16502", "score": "I", "diff": "diff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e58..a27fc352a1 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -136,17 +136,47 @@ class ServerHandler(simple_server.ServerHandler):\n         if \"Content-Length\" not in self.headers:\n             self.headers[\"Connection\"] = \"close\"\n         # Persistent connections require threading server.\n-        elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n+        elif hasattr(self, 'request_handler') and not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n             self.headers[\"Connection\"] = \"close\"\n         # Mark the connection for closing if it's set as such above or if the\n         # application sent the header.\n-        if self.headers.get(\"Connection\") == \"close\":\n+        if self.headers.get(\"Connection\") == \"close\" and hasattr(self, 'request_handler'):\n             self.request_handler.close_connection = True\n \n     def close(self):\n         self.get_stdin().read()\n         super().close()\n \n+    def finish_response(self):\n+        \"\"\"\n+        Send any iterable data, then close self and the iterable.\n+        \n+        For HEAD requests, skip sending the response body as per\n+        RFC 2616 section 4.3.\n+        \"\"\"\n+        try:\n+            if self.environ.get('REQUEST_METHOD') == 'HEAD':\n+                # For HEAD requests, we need to send headers but not the body\n+                if not self.headers_sent:\n+                    self.finish_content()\n+                # Skip iterating through the result to avoid sending the body\n+            else:\n+                # For non-HEAD requests, use the parent implementation\n+                if not self.result_is_file() or not self.sendfile():\n+                    for data in self.result:\n+                        self.write(data)\n+                    self.finish_content()\n+        except:\n+            # Call close() on the iterable returned by the WSGI application\n+            # in case of an exception.\n+            if hasattr(self.result, 'close'):\n+                self.result.close()\n+            raise\n+        else:\n+            # We only call close() when no exception is raised, because it\n+            # will set status, result, headers, and environ fields to None.\n+            self.close()\n+\n \n class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n     protocol_version = \"HTTP/1.1\"\ndiff --git a/test_curl.py b/test_curl.py\nnew file mode 100644\nindex 0000000000..20b217bbae\n--- /dev/null\n+++ b/test_curl.py\n@@ -0,0 +1,37 @@\n+#!/usr/bin/env python\n+\"\"\"Test using curl to replicate the issue exactly as described.\"\"\"\n+import subprocess\n+import time\n+import os\n+import sys\n+\n+# Setup test project\n+os.system('django-admin startproject testproject')\n+os.chdir('testproject')\n+\n+# Start runserver in background\n+server = subprocess.Popen([sys.executable, 'manage.py', 'runserver'], \n+                         stdout=subprocess.PIPE, \n+                         stderr=subprocess.PIPE)\n+\n+# Wait for server to start\n+time.sleep(3)\n+\n+try:\n+    # Test with curl as in the issue\n+    print(\"Testing HEAD request with curl...\")\n+    result = subprocess.run(['curl', '-iX', 'HEAD', 'http://127.0.0.1:8000/'], \n+                          capture_output=True, text=True)\n+    print(\"CURL OUTPUT:\")\n+    print(result.stdout)\n+    \n+    # Check if body is present\n+    if '<html>' in result.stdout or 'DOCTYPE' in result.stdout:\n+        print(\"\\n\u2717 FAILURE: Response body detected in HEAD request\")\n+    else:\n+        print(\"\\n\u2713 SUCCESS: No response body in HEAD request\")\n+        \n+finally:\n+    server.terminate()\n+    server.wait()\n+    os.chdir('..')\ndiff --git a/test_head_fix.py b/test_head_fix.py\nnew file mode 100644\nindex 0000000000..7027065de5\n--- /dev/null\n+++ b/test_head_fix.py\n@@ -0,0 +1,127 @@\n+#!/usr/bin/env python\n+\"\"\"Direct test of ServerHandler to verify HEAD request handling.\"\"\"\n+import sys\n+import io\n+from django.core.servers.basehttp import ServerHandler\n+\n+def test_head_request():\n+    \"\"\"Test that ServerHandler doesn't send body for HEAD requests.\"\"\"\n+    # Create mock streams\n+    stdin = io.BytesIO(b'')\n+    stdout = io.BytesIO()\n+    stderr = io.BytesIO()\n+    \n+    # Create environ for HEAD request\n+    environ = {\n+        'REQUEST_METHOD': 'HEAD',\n+        'SERVER_NAME': 'localhost',\n+        'SERVER_PORT': '8000',\n+        'PATH_INFO': '/',\n+        'wsgi.input': stdin,\n+        'wsgi.errors': stderr,\n+        'wsgi.version': (1, 0),\n+        'wsgi.multithread': False,\n+        'wsgi.multiprocess': True,\n+        'wsgi.run_once': False,\n+        'wsgi.url_scheme': 'http',\n+    }\n+    \n+    # Create a simple WSGI app that returns a response with body\n+    def app(environ, start_response):\n+        status = '200 OK'\n+        headers = [('Content-Type', 'text/html')]\n+        start_response(status, headers)\n+        return [b'<html><body>This should not be sent for HEAD</body></html>']\n+    \n+    # Create handler\n+    handler = ServerHandler(stdin, stdout, stderr, environ)\n+    handler.run(app)\n+    \n+    # Get the output\n+    output = stdout.getvalue()\n+    \n+    # Parse the output to separate headers and body\n+    parts = output.split(b'\\r\\n\\r\\n', 1)\n+    headers = parts[0].decode('latin-1')\n+    body = parts[1] if len(parts) > 1 else b''\n+    \n+    print(\"Response headers:\")\n+    print(headers)\n+    print(\"\\nResponse body length:\", len(body))\n+    print(\"Response body:\", body)\n+    \n+    if len(body) == 0:\n+        print(\"\\n\u2713 SUCCESS: HEAD request returns no body\")\n+        return True\n+    else:\n+        print(\"\\n\u2717 FAILURE: HEAD request returns body\")\n+        return False\n+\n+def test_get_request():\n+    \"\"\"Test that ServerHandler sends body for GET requests.\"\"\"\n+    # Create mock streams\n+    stdin = io.BytesIO(b'')\n+    stdout = io.BytesIO()\n+    stderr = io.BytesIO()\n+    \n+    # Create environ for GET request\n+    environ = {\n+        'REQUEST_METHOD': 'GET',\n+        'SERVER_NAME': 'localhost',\n+        'SERVER_PORT': '8000',\n+        'PATH_INFO': '/',\n+        'wsgi.input': stdin,\n+        'wsgi.errors': stderr,\n+        'wsgi.version': (1, 0),\n+        'wsgi.multithread': False,\n+        'wsgi.multiprocess': True,\n+        'wsgi.run_once': False,\n+        'wsgi.url_scheme': 'http',\n+    }\n+    \n+    # Create a simple WSGI app that returns a response with body\n+    def app(environ, start_response):\n+        status = '200 OK'\n+        headers = [('Content-Type', 'text/html')]\n+        start_response(status, headers)\n+        return [b'<html><body>This should be sent for GET</body></html>']\n+    \n+    # Create handler\n+    handler = ServerHandler(stdin, stdout, stderr, environ)\n+    handler.run(app)\n+    \n+    # Get the output\n+    output = stdout.getvalue()\n+    \n+    # Parse the output to separate headers and body\n+    parts = output.split(b'\\r\\n\\r\\n', 1)\n+    headers = parts[0].decode('latin-1')\n+    body = parts[1] if len(parts) > 1 else b''\n+    \n+    print(\"Response headers:\")\n+    print(headers)\n+    print(\"\\nResponse body length:\", len(body))\n+    print(\"Response body:\", body)\n+    \n+    if len(body) > 0:\n+        print(\"\\n\u2713 SUCCESS: GET request returns body\")\n+        return True\n+    else:\n+        print(\"\\n\u2717 FAILURE: GET request does not return body\")\n+        return False\n+\n+if __name__ == '__main__':\n+    print(\"Testing HEAD request...\")\n+    print(\"=\" * 50)\n+    head_ok = test_head_request()\n+    \n+    print(\"\\n\\nTesting GET request...\")\n+    print(\"=\" * 50)\n+    get_ok = test_get_request()\n+    \n+    if head_ok and get_ok:\n+        print(\"\\n\\nAll tests passed!\")\n+        sys.exit(0)\n+    else:\n+        print(\"\\n\\nSome tests failed!\")\n+        sys.exit(1)\ndiff --git a/test_head_request.py b/test_head_request.py\nnew file mode 100644\nindex 0000000000..9f61f2fa65\n--- /dev/null\n+++ b/test_head_request.py\n@@ -0,0 +1,118 @@\n+#!/usr/bin/env python\n+\"\"\"Test script to verify HEAD request behavior.\"\"\"\n+import subprocess\n+import time\n+import os\n+import sys\n+import requests\n+\n+# Create a simple Django project for testing\n+def setup_test_project():\n+    \"\"\"Create a minimal Django project for testing.\"\"\"\n+    # Create project structure\n+    os.makedirs('testproject', exist_ok=True)\n+    \n+    # Create settings.py\n+    settings_content = '''\n+DEBUG = True\n+SECRET_KEY = 'test-key'\n+ROOT_URLCONF = 'urls'\n+ALLOWED_HOSTS = ['*']\n+INSTALLED_APPS = [\n+    'django.contrib.contenttypes',\n+    'django.contrib.auth',\n+]\n+MIDDLEWARE = []\n+TEMPLATES = [{\n+    'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+    'DIRS': [],\n+    'APP_DIRS': True,\n+    'OPTIONS': {\n+        'context_processors': [\n+            'django.template.context_processors.debug',\n+            'django.template.context_processors.request',\n+        ],\n+    },\n+}]\n+'''\n+    with open('testproject/settings.py', 'w') as f:\n+        f.write(settings_content)\n+    \n+    # Create urls.py\n+    urls_content = '''\n+from django.urls import path\n+from django.http import HttpResponse\n+\n+def test_view(request):\n+    return HttpResponse('<html><body>Test response body</body></html>')\n+\n+urlpatterns = [\n+    path('', test_view),\n+]\n+'''\n+    with open('testproject/urls.py', 'w') as f:\n+        f.write(urls_content)\n+    \n+    # Create manage.py\n+    manage_content = '''#!/usr/bin/env python\n+import os\n+import sys\n+\n+if __name__ == '__main__':\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')\n+    from django.core.management import execute_from_command_line\n+    execute_from_command_line(sys.argv)\n+'''\n+    with open('testproject/manage.py', 'w') as f:\n+        f.write(manage_content)\n+    os.chmod('testproject/manage.py', 0o755)\n+\n+def test_head_request():\n+    \"\"\"Test HEAD request behavior.\"\"\"\n+    # Start the development server\n+    os.chdir('testproject')\n+    server_proc = subprocess.Popen(\n+        [sys.executable, 'manage.py', 'runserver', '8888', '--noreload'],\n+        stdout=subprocess.PIPE,\n+        stderr=subprocess.PIPE\n+    )\n+    \n+    # Wait for server to start\n+    time.sleep(2)\n+    \n+    try:\n+        # Test HEAD request\n+        print(\"Testing HEAD request...\")\n+        response = requests.head('http://127.0.0.1:8888/')\n+        \n+        print(f\"Status Code: {response.status_code}\")\n+        print(f\"Headers: {dict(response.headers)}\")\n+        print(f\"Content Length from header: {response.headers.get('Content-Length', 'Not set')}\")\n+        print(f\"Actual content length: {len(response.content)}\")\n+        print(f\"Response body: {response.content}\")\n+        \n+        # The body should be empty for HEAD requests\n+        if len(response.content) == 0:\n+            print(\"\\n\u2713 SUCCESS: HEAD request returns no body (compliant with RFC 2616)\")\n+        else:\n+            print(\"\\n\u2717 FAILURE: HEAD request returns body (non-compliant)\")\n+            \n+        print(\"\\n\" + \"=\"*50 + \"\\n\")\n+        \n+        # Test GET request for comparison\n+        print(\"Testing GET request for comparison...\")\n+        response = requests.get('http://127.0.0.1:8888/')\n+        print(f\"Status Code: {response.status_code}\")\n+        print(f\"Content Length from header: {response.headers.get('Content-Length', 'Not set')}\")\n+        print(f\"Actual content length: {len(response.content)}\")\n+        print(f\"Response body preview: {response.content[:100]}...\")\n+        \n+    finally:\n+        # Clean up\n+        server_proc.terminate()\n+        server_proc.wait()\n+        os.chdir('..')\n+\n+if __name__ == '__main__':\n+    setup_test_project()\n+    test_head_request()\ndiff --git a/test_head_request_fix.py b/test_head_request_fix.py\nnew file mode 100644\nindex 0000000000..d4f5c5a2e2\n--- /dev/null\n+++ b/test_head_request_fix.py\n@@ -0,0 +1,90 @@\n+#!/usr/bin/env python\n+\"\"\"Test to verify HEAD request handling in Django's runserver.\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test import TestCase, Client\n+from django.http import HttpResponse\n+from django.urls import path\n+import threading\n+import time\n+import requests\n+from wsgiref.simple_server import make_server\n+from django.core.handlers.wsgi import WSGIHandler\n+\n+# Configure Django settings\n+settings.configure(\n+    DEBUG=True,\n+    SECRET_KEY='test-key',\n+    ROOT_URLCONF=__name__,\n+    ALLOWED_HOSTS=['*'],\n+    INSTALLED_APPS=[\n+        'django.contrib.contenttypes',\n+    ],\n+    MIDDLEWARE=[],\n+)\n+\n+# Set up Django\n+django.setup()\n+\n+# Define a simple view that returns a response with body\n+def test_view(request):\n+    return HttpResponse('<html><body>Test response body</body></html>')\n+\n+# URL patterns\n+urlpatterns = [\n+    path('', test_view),\n+]\n+\n+def test_head_with_runserver():\n+    \"\"\"Test HEAD requests using Django's built-in server.\"\"\"\n+    from django.core.servers.basehttp import WSGIServer, WSGIRequestHandler\n+    \n+    # Create WSGI handler\n+    handler = WSGIHandler()\n+    \n+    # Create server\n+    server = make_server('127.0.0.1', 0, handler, \n+                        server_class=WSGIServer,\n+                        handler_class=WSGIRequestHandler)\n+    port = server.server_port\n+    \n+    # Start server in a thread\n+    server_thread = threading.Thread(target=server.serve_forever)\n+    server_thread.daemon = True\n+    server_thread.start()\n+    \n+    time.sleep(0.5)  # Give server time to start\n+    \n+    try:\n+        # Test HEAD request\n+        print(\"Testing HEAD request...\")\n+        response = requests.head(f'http://127.0.0.1:{port}/')\n+        \n+        print(f\"Status Code: {response.status_code}\")\n+        print(f\"Content-Length header: {response.headers.get('Content-Length', 'Not set')}\")\n+        print(f\"Actual content length: {len(response.content)}\")\n+        print(f\"Response body: {response.content}\")\n+        \n+        if len(response.content) == 0:\n+            print(\"\\n\u2713 SUCCESS: HEAD request returns no body (RFC 2616 compliant)\")\n+        else:\n+            print(\"\\n\u2717 FAILURE: HEAD request returns body (non-compliant)\")\n+            print(f\"Body content: {response.content.decode()}\")\n+            \n+        print(\"\\n\" + \"=\"*50 + \"\\n\")\n+        \n+        # Test GET request for comparison\n+        print(\"Testing GET request for comparison...\")\n+        response = requests.get(f'http://127.0.0.1:{port}/')\n+        print(f\"Status Code: {response.status_code}\")\n+        print(f\"Content length: {len(response.content)}\")\n+        print(f\"Response body: {response.content.decode()}\")\n+        \n+    finally:\n+        server.shutdown()\n+        server_thread.join()\n+\n+if __name__ == '__main__':\n+    test_head_with_runserver()\ndiff --git a/testproject/db.sqlite3 b/testproject/db.sqlite3\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/testproject/manage.py b/testproject/manage.py\nnew file mode 100755\nindex 0000000000..8bd034f0d2\n--- /dev/null\n+++ b/testproject/manage.py\n@@ -0,0 +1,22 @@\n+#!/usr/bin/env python\n+\"\"\"Django's command-line utility for administrative tasks.\"\"\"\n+import os\n+import sys\n+\n+\n+def main():\n+    \"\"\"Run administrative tasks.\"\"\"\n+    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"testproject.settings\")\n+    try:\n+        from django.core.management import execute_from_command_line\n+    except ImportError as exc:\n+        raise ImportError(\n+            \"Couldn't import Django. Are you sure it's installed and \"\n+            \"available on your PYTHONPATH environment variable? Did you \"\n+            \"forget to activate a virtual environment?\"\n+        ) from exc\n+    execute_from_command_line(sys.argv)\n+\n+\n+if __name__ == \"__main__\":\n+    main()\ndiff --git a/testproject/testproject/__init__.py b/testproject/testproject/__init__.py\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/testproject/testproject/asgi.py b/testproject/testproject/asgi.py\nnew file mode 100644\nindex 0000000000..7f8fbc1461\n--- /dev/null\n+++ b/testproject/testproject/asgi.py\n@@ -0,0 +1,16 @@\n+\"\"\"\n+ASGI config for testproject project.\n+\n+It exposes the ASGI callable as a module-level variable named ``application``.\n+\n+For more information on this file, see\n+https://docs.djangoproject.com/en/dev/howto/deployment/asgi/\n+\"\"\"\n+\n+import os\n+\n+from django.core.asgi import get_asgi_application\n+\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"testproject.settings\")\n+\n+application = get_asgi_application()\ndiff --git a/testproject/testproject/settings.py b/testproject/testproject/settings.py\nnew file mode 100644\nindex 0000000000..9386d02621\n--- /dev/null\n+++ b/testproject/testproject/settings.py\n@@ -0,0 +1,123 @@\n+\"\"\"\n+Django settings for testproject project.\n+\n+Generated by 'django-admin startproject' using Django 5.0.dev20230126185448.\n+\n+For more information on this file, see\n+https://docs.djangoproject.com/en/dev/topics/settings/\n+\n+For the full list of settings and their values, see\n+https://docs.djangoproject.com/en/dev/ref/settings/\n+\"\"\"\n+\n+from pathlib import Path\n+\n+# Build paths inside the project like this: BASE_DIR / 'subdir'.\n+BASE_DIR = Path(__file__).resolve().parent.parent\n+\n+\n+# Quick-start development settings - unsuitable for production\n+# See https://docs.djangoproject.com/en/dev/howto/deployment/checklist/\n+\n+# SECURITY WARNING: keep the secret key used in production secret!\n+SECRET_KEY = \"django-insecure-7(m0*bqa-_)dc8u)$vyht3iq=_n$ly_3flzl5e#1zzg)*1e-m6\"\n+\n+# SECURITY WARNING: don't run with debug turned on in production!\n+DEBUG = True\n+\n+ALLOWED_HOSTS = []\n+\n+\n+# Application definition\n+\n+INSTALLED_APPS = [\n+    \"django.contrib.admin\",\n+    \"django.contrib.auth\",\n+    \"django.contrib.contenttypes\",\n+    \"django.contrib.sessions\",\n+    \"django.contrib.messages\",\n+    \"django.contrib.staticfiles\",\n+]\n+\n+MIDDLEWARE = [\n+    \"django.middleware.security.SecurityMiddleware\",\n+    \"django.contrib.sessions.middleware.SessionMiddleware\",\n+    \"django.middleware.common.CommonMiddleware\",\n+    \"django.middleware.csrf.CsrfViewMiddleware\",\n+    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n+    \"django.contrib.messages.middleware.MessageMiddleware\",\n+    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n+]\n+\n+ROOT_URLCONF = \"testproject.urls\"\n+\n+TEMPLATES = [\n+    {\n+        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+        \"DIRS\": [],\n+        \"APP_DIRS\": True,\n+        \"OPTIONS\": {\n+            \"context_processors\": [\n+                \"django.template.context_processors.debug\",\n+                \"django.template.context_processors.request\",\n+                \"django.contrib.auth.context_processors.auth\",\n+                \"django.contrib.messages.context_processors.messages\",\n+            ],\n+        },\n+    },\n+]\n+\n+WSGI_APPLICATION = \"testproject.wsgi.application\"\n+\n+\n+# Database\n+# https://docs.djangoproject.com/en/dev/ref/settings/#databases\n+\n+DATABASES = {\n+    \"default\": {\n+        \"ENGINE\": \"django.db.backends.sqlite3\",\n+        \"NAME\": BASE_DIR / \"db.sqlite3\",\n+    }\n+}\n+\n+\n+# Password validation\n+# https://docs.djangoproject.com/en/dev/ref/settings/#auth-password-validators\n+\n+AUTH_PASSWORD_VALIDATORS = [\n+    {\n+        \"NAME\": \"django.contrib.auth.password_validation.UserAttributeSimilarityValidator\",\n+    },\n+    {\n+        \"NAME\": \"django.contrib.auth.password_validation.MinimumLengthValidator\",\n+    },\n+    {\n+        \"NAME\": \"django.contrib.auth.password_validation.CommonPasswordValidator\",\n+    },\n+    {\n+        \"NAME\": \"django.contrib.auth.password_validation.NumericPasswordValidator\",\n+    },\n+]\n+\n+\n+# Internationalization\n+# https://docs.djangoproject.com/en/dev/topics/i18n/\n+\n+LANGUAGE_CODE = \"en-us\"\n+\n+TIME_ZONE = \"UTC\"\n+\n+USE_I18N = True\n+\n+USE_TZ = True\n+\n+\n+# Static files (CSS, JavaScript, Images)\n+# https://docs.djangoproject.com/en/dev/howto/static-files/\n+\n+STATIC_URL = \"static/\"\n+\n+# Default primary key field type\n+# https://docs.djangoproject.com/en/dev/ref/settings/#default-auto-field\n+\n+DEFAULT_AUTO_FIELD = \"django.db.models.BigAutoField\"\ndiff --git a/testproject/testproject/urls.py b/testproject/testproject/urls.py\nnew file mode 100644\nindex 0000000000..0127e6d889\n--- /dev/null\n+++ b/testproject/testproject/urls.py\n@@ -0,0 +1,23 @@\n+\"\"\"\n+URL configuration for testproject project.\n+\n+The `urlpatterns` list routes URLs to views. For more information please see:\n+    https://docs.djangoproject.com/en/dev/topics/http/urls/\n+Examples:\n+Function views\n+    1. Add an import:  from my_app import views\n+    2. Add a URL to urlpatterns:  path('', views.home, name='home')\n+Class-based views\n+    1. Add an import:  from other_app.views import Home\n+    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\n+Including another URLconf\n+    1. Import the include() function: from django.urls import include, path\n+    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n+\"\"\"\n+\n+from django.contrib import admin\n+from django.urls import path\n+\n+urlpatterns = [\n+    path(\"admin/\", admin.site.urls),\n+]\ndiff --git a/testproject/testproject/wsgi.py b/testproject/testproject/wsgi.py\nnew file mode 100644\nindex 0000000000..c24d0012dc\n--- /dev/null\n+++ b/testproject/testproject/wsgi.py\n@@ -0,0 +1,16 @@\n+\"\"\"\n+WSGI config for testproject project.\n+\n+It exposes the WSGI callable as a module-level variable named ``application``.\n+\n+For more information on this file, see\n+https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/\n+\"\"\"\n+\n+import os\n+\n+from django.core.wsgi import get_wsgi_application\n+\n+os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"testproject.settings\")\n+\n+application = get_wsgi_application()\ndiff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py\nindex a837505feb..503446c011 100644\n--- a/tests/servers/test_basehttp.py\n+++ b/tests/servers/test_basehttp.py\n@@ -106,6 +106,53 @@ class WSGIRequestHandlerTestCase(SimpleTestCase):\n \n         self.assertEqual(body, b\"HTTP_SOME_HEADER:good\")\n \n+    def test_head_request_no_body(self):\n+        \"\"\"HEAD requests should not return a response body.\"\"\"\n+        def test_app(environ, start_response):\n+            \"\"\"A WSGI app that returns a response with body.\"\"\"\n+            start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+            return [b\"<html><body>This should not be sent for HEAD</body></html>\"]\n+\n+        # Test HEAD request\n+        rfile = BytesIO()\n+        rfile.write(b\"HEAD / HTTP/1.0\\r\\n\")\n+        rfile.write(b\"\\r\\n\")\n+        rfile.seek(0)\n+\n+        class UnclosableBytesIO(BytesIO):\n+            def close(self):\n+                pass\n+\n+        wfile = UnclosableBytesIO()\n+\n+        def makefile(mode, *a, **kw):\n+            if mode == \"rb\":\n+                return rfile\n+            elif mode == \"wb\":\n+                return wfile\n+\n+        request = Stub(makefile=makefile)\n+        server = Stub(base_environ={}, get_app=lambda: test_app)\n+\n+        # Prevent logging from appearing in test output.\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        response = wfile.getvalue()\n+        \n+        # Split response into headers and body\n+        parts = response.split(b\"\\r\\n\\r\\n\", 1)\n+        headers = parts[0]\n+        body = parts[1] if len(parts) > 1 else b\"\"\n+        \n+        # Headers should be present\n+        self.assertIn(b\"HTTP/1.1 200\", headers)\n+        self.assertIn(b\"Content-Type: text/html\", headers)\n+        \n+        # Body should be empty for HEAD request\n+        self.assertEqual(body, b\"\")\n+\n \n class WSGIServerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n", "gold_standard_diff": "From f37b07f6648450d2346c84a2eb59ab9abae762c3 Mon Sep 17 00:00:00 2001\nFrom: sarahboyce <sarahvboyce95@gmail.com>\nDate: Thu, 26 Jan 2023 10:06:05 +0100\nSubject: [PATCH] Fixed #28054 -- Made runserver not return response body for\n HEAD requests.\n\nCo-authored-by: jannschu <jannik.schuerg@posteo.de>\n---\n django/core/servers/basehttp.py | 27 ++++++++++++-\n tests/servers/test_basehttp.py  | 69 +++++++++++++++++++++++++++++----\n 2 files changed, 88 insertions(+), 8 deletions(-)\n\ndiff --git a/django/core/servers/basehttp.py b/django/core/servers/basehttp.py\nindex fef5532e5856..d08fb77a475a 100644\n--- a/django/core/servers/basehttp.py\n+++ b/django/core/servers/basehttp.py\n@@ -11,6 +11,7 @@\n import socket\n import socketserver\n import sys\n+from collections import deque\n from wsgiref import simple_server\n \n from django.core.exceptions import ImproperlyConfigured\n@@ -130,10 +131,18 @@ def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n \n     def cleanup_headers(self):\n         super().cleanup_headers()\n+        if (\n+            self.environ[\"REQUEST_METHOD\"] == \"HEAD\"\n+            and \"Content-Length\" in self.headers\n+        ):\n+            del self.headers[\"Content-Length\"]\n         # HTTP/1.1 requires support for persistent connections. Send 'close' if\n         # the content length is unknown to prevent clients from reusing the\n         # connection.\n-        if \"Content-Length\" not in self.headers:\n+        if (\n+            self.environ[\"REQUEST_METHOD\"] != \"HEAD\"\n+            and \"Content-Length\" not in self.headers\n+        ):\n             self.headers[\"Connection\"] = \"close\"\n         # Persistent connections require threading server.\n         elif not isinstance(self.request_handler.server, socketserver.ThreadingMixIn):\n@@ -147,6 +156,22 @@ def close(self):\n         self.get_stdin().read()\n         super().close()\n \n+    def finish_response(self):\n+        if self.environ[\"REQUEST_METHOD\"] == \"HEAD\":\n+            try:\n+                deque(self.result, maxlen=0)  # Consume iterator.\n+                # Don't call self.finish_content() as, if the headers have not\n+                # been sent and Content-Length isn't set, it'll default to \"0\"\n+                # which will prevent omission of the Content-Length header with\n+                # HEAD requests as permitted by RFC 9110 Section 9.3.2.\n+                # Instead, send the headers, if not sent yet.\n+                if not self.headers_sent:\n+                    self.send_headers()\n+            finally:\n+                self.close()\n+        else:\n+            super().finish_response()\n+\n \n class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n     protocol_version = \"HTTP/1.1\"\ndiff --git a/tests/servers/test_basehttp.py b/tests/servers/test_basehttp.py\nindex a837505feb7a..1e535e933e24 100644\n--- a/tests/servers/test_basehttp.py\n+++ b/tests/servers/test_basehttp.py\n@@ -1,4 +1,5 @@\n from io import BytesIO\n+from socketserver import ThreadingMixIn\n \n from django.core.handlers.wsgi import WSGIRequest\n from django.core.servers.basehttp import WSGIRequestHandler, WSGIServer\n@@ -7,7 +8,7 @@\n from django.test.utils import captured_stderr\n \n \n-class Stub:\n+class Stub(ThreadingMixIn):\n     def __init__(self, **kwargs):\n         self.__dict__.update(kwargs)\n \n@@ -15,6 +16,13 @@ def sendall(self, data):\n         self.makefile(\"wb\").write(data)\n \n \n+class UnclosableBytesIO(BytesIO):\n+    def close(self):\n+        # WSGIRequestHandler closes the output file; we need to make this a\n+        # no-op so we can still read its contents.\n+        pass\n+\n+\n class WSGIRequestHandlerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n \n@@ -79,12 +87,6 @@ def test_app(environ, start_response):\n         rfile.write(b\"Other_Header: bad\\r\\n\")\n         rfile.seek(0)\n \n-        # WSGIRequestHandler closes the output file; we need to make this a\n-        # no-op so we can still read its contents.\n-        class UnclosableBytesIO(BytesIO):\n-            def close(self):\n-                pass\n-\n         wfile = UnclosableBytesIO()\n \n         def makefile(mode, *a, **kw):\n@@ -106,6 +108,59 @@ def makefile(mode, *a, **kw):\n \n         self.assertEqual(body, b\"HTTP_SOME_HEADER:good\")\n \n+    def test_no_body_returned_for_head_requests(self):\n+        hello_world_body = b\"<!DOCTYPE html><html><body>Hello World</body></html>\"\n+        content_length = len(hello_world_body)\n+\n+        def test_app(environ, start_response):\n+            \"\"\"A WSGI app that returns a hello world.\"\"\"\n+            start_response(\"200 OK\", [])\n+            return [hello_world_body]\n+\n+        rfile = BytesIO(b\"GET / HTTP/1.0\\r\\n\")\n+        rfile.seek(0)\n+\n+        wfile = UnclosableBytesIO()\n+\n+        def makefile(mode, *a, **kw):\n+            if mode == \"rb\":\n+                return rfile\n+            elif mode == \"wb\":\n+                return wfile\n+\n+        request = Stub(makefile=makefile)\n+        server = Stub(base_environ={}, get_app=lambda: test_app)\n+\n+        # Prevent logging from appearing in test output.\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            # Instantiating a handler runs the request as side effect.\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        lines = list(wfile.readlines())\n+        body = lines[-1]\n+        # The body is returned in a GET response.\n+        self.assertEqual(body, hello_world_body)\n+        self.assertIn(f\"Content-Length: {content_length}\\r\\n\".encode(), lines)\n+        self.assertNotIn(b\"Connection: close\\r\\n\", lines)\n+\n+        rfile = BytesIO(b\"HEAD / HTTP/1.0\\r\\n\")\n+        rfile.seek(0)\n+        wfile = UnclosableBytesIO()\n+\n+        with self.assertLogs(\"django.server\", \"INFO\"):\n+            WSGIRequestHandler(request, \"192.168.0.2\", server)\n+\n+        wfile.seek(0)\n+        lines = list(wfile.readlines())\n+        body = lines[-1]\n+        # The body is not returned in a HEAD response.\n+        self.assertEqual(body, b\"\\r\\n\")\n+        self.assertIs(\n+            any([line.startswith(b\"Content-Length:\") for line in lines]), False\n+        )\n+        self.assertNotIn(b\"Connection: close\\r\\n\", lines)\n+\n \n class WSGIServerTestCase(SimpleTestCase):\n     request_factory = RequestFactory()\n", "gold_standard_pr_link": "https://github.com/django/django/pull/16502"}