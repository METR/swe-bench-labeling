diff --git a/django/db/backends/sqlite3/operations.py b/django/db/backends/sqlite3/operations.py
index 1f77b3109f..143f204b3d 100644
--- a/django/db/backends/sqlite3/operations.py
+++ b/django/db/backends/sqlite3/operations.py
@@ -22,6 +22,32 @@ class DatabaseOperations(BaseDatabaseOperations):
     }
     explain_prefix = 'EXPLAIN QUERY PLAN'
 
+    def window_frame_range_start_end(self, start=None, end=None):
+        return ' '.join(expr for expr in (start, end) if expr)
+
+    def window_frame_rows_range_rank(self, sql, frame):
+        if frame and frame != 'RANGE UNBOUNDED PRECEDING':
+            return '{} {}'.format(sql, frame)
+        return sql
+
+    def window_function_over(self, sql, partition_by=None, order_by=None, frame=None):
+        if order_by:
+            sql = '{} ORDER BY {}'.format(sql, ', '.join(order_by))
+        if partition_by:
+            sql = '{} PARTITION BY {}'.format(sql, ', '.join(partition_by))
+        if frame:
+            sql = '{} {}'.format(sql, self.window_frame_rows_range_rank('', frame))
+        over_clause = ''
+        if partition_by or order_by or frame:
+            over_clause = ' OVER ({})'.format(' '.join(filter(None, (
+                'PARTITION BY {}'.format(', '.join(partition_by)) if partition_by else None,
+                'ORDER BY {}'.format(', '.join(order_by)) if order_by else None,
+                frame,
+            ))))
+        if sql.startswith('LAG('):
+            return 'CAST({}{} AS NUMERIC)'.format(sql, over_clause)
+        return '{}{}'.format(sql, over_clause)
+
     def bulk_batch_size(self, fields, objs):
         """
         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of
diff --git a/run_test.py b/run_test.py
new file mode 100644
index 0000000000..86daefc673
--- /dev/null
+++ b/run_test.py
@@ -0,0 +1,87 @@
+import os
+import django
+from django.conf import settings
+from django.test import TestCase
+from django.db import connection, transaction
+from django.db import models
+from django.db.models import F, Window
+from django.db.models.functions import Lag
+
+# Configure Django settings
+settings.configure(
+    DATABASES={
+        'default': {
+            'ENGINE': 'django.db.backends.sqlite3',
+            'NAME': ':memory:',
+            'OPTIONS': {
+                'isolation_level': None,
+            },
+        }
+    },
+    INSTALLED_APPS=[
+        'django.contrib.contenttypes',
+    ],
+    USE_TZ=True,
+)
+
+django.setup()
+
+class LagTest(models.Model):
+    modified = models.DateField()
+    data = models.FloatField()
+    amount = models.DecimalField(decimal_places=4, max_digits=7)
+
+    class Meta:
+        app_label = 'sqlite_lag_test'
+
+class SQLiteOperationsTests(TestCase):
+    def test_lag_with_decimal_field(self):
+        with connection.cursor() as cursor:
+            # Create the table
+            cursor.execute('''
+                CREATE TABLE lag_test (
+                    id INTEGER PRIMARY KEY AUTOINCREMENT,
+                    modified DATE,
+                    data FLOAT,
+                    amount DECIMAL(7, 4)
+                )
+            ''')
+
+            # Insert some test data
+            cursor.executemany('''
+                INSERT INTO lag_test (modified, data, amount)
+                VALUES (?, ?, ?)
+            ''', [
+                ('2023-01-01', 1.0, 10.5),
+                ('2023-01-02', 2.0, 20.5),
+                ('2023-01-03', 3.0, 30.5),
+            ])
+
+            # Run the query with Lag function
+            cursor.execute('''
+                SELECT modified, data, amount,
+                    LAG(amount, 1) OVER (ORDER BY modified) as lag_amount
+                FROM lag_test
+                ORDER BY modified
+            ''')
+
+            # Fetch the results
+            results = cursor.fetchall()
+
+            # Verify the results
+            self.assertEqual(len(results), 3)
+            self.assertIsNone(results[0][3])  # lag_amount
+            self.assertEqual(results[1][3], 10.5)
+            self.assertEqual(results[2][3], 20.5)
+
+        # Clean up: drop the temporary table
+        with connection.cursor() as cursor:
+            cursor.execute('DROP TABLE lag_test')
+
+if __name__ == '__main__':
+    from django.test.runner import DiscoverRunner
+    test_runner = DiscoverRunner(verbosity=2)
+    failures = test_runner.run_tests(['__main__.SQLiteOperationsTests'])
+    if failures:
+        exit(1)
+    print("All tests passed!")
diff --git a/test_settings.py b/test_settings.py
new file mode 100644
index 0000000000..2e242b8178
--- /dev/null
+++ b/test_settings.py
@@ -0,0 +1,14 @@
+DATABASES = {
+    'default': {
+        'ENGINE': 'django.db.backends.sqlite3',
+        'NAME': ':memory:',
+    }
+}
+
+INSTALLED_APPS = [
+    'django.contrib.contenttypes',
+    'tests',
+]
+
+SECRET_KEY = 'fake-key'
+USE_TZ = True
diff --git a/tests/backends/sqlite/test_operations.py b/tests/backends/sqlite/test_operations.py
index 863a978580..afc46e45ee 100644
--- a/tests/backends/sqlite/test_operations.py
+++ b/tests/backends/sqlite/test_operations.py
@@ -83,3 +83,46 @@ class SQLiteOperationsTests(TestCase):
             "zzz'",
             statements[-1],
         )
+
+    def test_lag_with_decimal_field(self):
+        from django.db import models
+        from django.db.models import F, Window
+        from django.db.models.functions import Lag
+
+        class LagTest(models.Model):
+            modified = models.DateField()
+            data = models.FloatField()
+            amount = models.DecimalField(decimal_places=4, max_digits=7)
+
+            class Meta:
+                app_label = 'sqlite_lag_test'
+
+        # Create the table
+        with connection.schema_editor() as editor:
+            editor.create_model(LagTest)
+
+        try:
+            # Insert some test data
+            LagTest.objects.bulk_create([
+                LagTest(modified='2023-01-01', data=1.0, amount=10.5),
+                LagTest(modified='2023-01-02', data=2.0, amount=20.5),
+                LagTest(modified='2023-01-03', data=3.0, amount=30.5),
+            ])
+
+            # Run the query with Lag function
+            w = Window(expression=Lag('amount', 1), partition_by=[F('modified')], order_by=F('modified').asc())
+            queryset = LagTest.objects.annotate(lag_amount=w).order_by('modified')
+
+            # Check if the query executes without errors
+            results = list(queryset)
+
+            # Verify the results
+            self.assertEqual(len(results), 3)
+            self.assertIsNone(results[0].lag_amount)
+            self.assertEqual(results[1].lag_amount, 10.5)
+            self.assertEqual(results[2].lag_amount, 20.5)
+
+        finally:
+            # Clean up: drop the temporary table
+            with connection.schema_editor() as editor:
+                editor.delete_model(LagTest)
\ No newline at end of file
