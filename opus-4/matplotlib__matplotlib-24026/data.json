{"instance_id": "matplotlib__matplotlib-24026", "score": "C", "diff": "diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c580043eeb..50eb54540e 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -7,6 +7,7 @@ https://stackoverflow.com/q/2225995/\n \"\"\"\n \n import numpy as np\n+import itertools\n \n from matplotlib import _api\n \n@@ -70,7 +71,10 @@ def stackplot(axes, x, *args,\n \n     labels = iter(labels)\n     if colors is not None:\n-        axes.set_prop_cycle(color=colors)\n+        if len(colors) == 0:\n+            colors = None\n+        else:\n+            colors = itertools.cycle(colors)\n \n     # Assume data passed has not been 'stacked', so stack it here.\n     # We'll need a float buffer for the upcoming calculations.\n@@ -108,7 +112,10 @@ def stackplot(axes, x, *args,\n         stack += first_line\n \n     # Color between x = 0 and the first array.\n-    color = axes._get_lines.get_next_color()\n+    if colors is not None:\n+        color = next(colors)\n+    else:\n+        color = axes._get_lines.get_next_color()\n     coll = axes.fill_between(x, first_line, stack[0, :],\n                              facecolor=color, label=next(labels, None),\n                              **kwargs)\n@@ -117,7 +124,10 @@ def stackplot(axes, x, *args,\n \n     # Color between array i-1 and array i\n     for i in range(len(y) - 1):\n-        color = axes._get_lines.get_next_color()\n+        if colors is not None:\n+            color = next(colors)\n+        else:\n+            color = axes._get_lines.get_next_color()\n         r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n                                    facecolor=color, label=next(labels, None),\n                                    **kwargs))\ndiff --git a/lib/matplotlib/stackplot.py.backup b/lib/matplotlib/stackplot.py.backup\nnew file mode 100644\nindex 0000000000..67e99f8b3b\n--- /dev/null\n+++ b/lib/matplotlib/stackplot.py.backup\n@@ -0,0 +1,124 @@\n+\"\"\"\n+Stacked area plot for 1D arrays inspired by Douglas Y'barbo's stackoverflow\n+answer:\n+https://stackoverflow.com/q/2225995/\n+\n+(https://stackoverflow.com/users/66549/doug)\n+\"\"\"\n+\n+import numpy as np\n+\n+from matplotlib import _api\n+\n+__all__ = ['stackplot']\n+\n+\n+def stackplot(axes, x, *args,\n+              labels=(), colors=None, baseline='zero',\n+              **kwargs):\n+    \"\"\"\n+    Draw a stacked area plot.\n+\n+    Parameters\n+    ----------\n+    x : (N,) array-like\n+\n+    y : (M, N) array-like\n+        The data is assumed to be unstacked. Each of the following\n+        calls is legal::\n+\n+            stackplot(x, y)           # where y has shape (M, N)\n+            stackplot(x, y1, y2, y3)  # where y1, y2, y3, y4 have length N\n+\n+    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}\n+        Method used to calculate the baseline:\n+\n+        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.\n+        - ``'sym'``:  Symmetric around zero and is sometimes called\n+          'ThemeRiver'.\n+        - ``'wiggle'``: Minimizes the sum of the squared slopes.\n+        - ``'weighted_wiggle'``: Does the same but weights to account for\n+          size of each layer. It is also called 'Streamgraph'-layout. More\n+          details can be found at http://leebyron.com/streamgraph/.\n+\n+    labels : list of str, optional\n+        A sequence of labels to assign to each data series. If unspecified,\n+        then no labels will be applied to artists.\n+\n+    colors : list of color, optional\n+        A sequence of colors to be cycled through and used to color the stacked\n+        areas. The sequence need not be exactly the same length as the number\n+        of provided *y*, in which case the colors will repeat from the\n+        beginning.\n+\n+        If not specified, the colors from the Axes property cycle will be used.\n+\n+    data : indexable object, optional\n+        DATA_PARAMETER_PLACEHOLDER\n+\n+    **kwargs\n+        All other keyword arguments are passed to `.Axes.fill_between`.\n+\n+    Returns\n+    -------\n+    list of `.PolyCollection`\n+        A list of `.PolyCollection` instances, one for each element in the\n+        stacked area plot.\n+    \"\"\"\n+\n+    y = np.row_stack(args)\n+\n+    labels = iter(labels)\n+    if colors is not None:\n+        colors = iter(colors)\n+\n+    # Assume data passed has not been 'stacked', so stack it here.\n+    # We'll need a float buffer for the upcoming calculations.\n+    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))\n+\n+    _api.check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],\n+                       baseline=baseline)\n+    if baseline == 'zero':\n+        first_line = 0.\n+\n+    elif baseline == 'sym':\n+        first_line = -np.sum(y, 0) * 0.5\n+        stack += first_line[None, :]\n+\n+    elif baseline == 'wiggle':\n+        m = y.shape[0]\n+        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)\n+        first_line /= -m\n+        stack += first_line\n+\n+    elif baseline == 'weighted_wiggle':\n+        total = np.sum(y, 0)\n+        # multiply by 1/total (or zero) to avoid infinities in the division:\n+        inv_total = np.zeros_like(total)\n+        mask = total > 0\n+        inv_total[mask] = 1.0 / total[mask]\n+        increase = np.hstack((y[:, 0:1], np.diff(y)))\n+        below_size = total - stack\n+        below_size += 0.5 * y\n+        move_up = below_size * inv_total\n+        move_up[:, 0] = 0.5\n+        center = (move_up - 0.5) * increase\n+        center = np.cumsum(center.sum(0))\n+        first_line = center - 0.5 * total\n+        stack += first_line\n+\n+    # Color between x = 0 and the first array.\n+    color = axes._get_lines.get_next_color()\n+    coll = axes.fill_between(x, first_line, stack[0, :],\n+                             facecolor=color, label=next(labels, None),\n+                             **kwargs)\n+    coll.sticky_edges.y[:] = [0]\n+    r = [coll]\n+\n+    # Color between array i-1 and array i\n+    for i in range(len(y) - 1):\n+        color = axes._get_lines.get_next_color()\n+        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n+                                   facecolor=color, label=next(labels, None),\n+                                   **kwargs))\n+    return r\ndiff --git a/stackplot_content.txt b/stackplot_content.txt\nnew file mode 100644\nindex 0000000000..c580043eeb\n--- /dev/null\n+++ b/stackplot_content.txt\n@@ -0,0 +1,124 @@\n+\"\"\"\n+Stacked area plot for 1D arrays inspired by Douglas Y'barbo's stackoverflow\n+answer:\n+https://stackoverflow.com/q/2225995/\n+\n+(https://stackoverflow.com/users/66549/doug)\n+\"\"\"\n+\n+import numpy as np\n+\n+from matplotlib import _api\n+\n+__all__ = ['stackplot']\n+\n+\n+def stackplot(axes, x, *args,\n+              labels=(), colors=None, baseline='zero',\n+              **kwargs):\n+    \"\"\"\n+    Draw a stacked area plot.\n+\n+    Parameters\n+    ----------\n+    x : (N,) array-like\n+\n+    y : (M, N) array-like\n+        The data is assumed to be unstacked. Each of the following\n+        calls is legal::\n+\n+            stackplot(x, y)           # where y has shape (M, N)\n+            stackplot(x, y1, y2, y3)  # where y1, y2, y3, y4 have length N\n+\n+    baseline : {'zero', 'sym', 'wiggle', 'weighted_wiggle'}\n+        Method used to calculate the baseline:\n+\n+        - ``'zero'``: Constant zero baseline, i.e. a simple stacked plot.\n+        - ``'sym'``:  Symmetric around zero and is sometimes called\n+          'ThemeRiver'.\n+        - ``'wiggle'``: Minimizes the sum of the squared slopes.\n+        - ``'weighted_wiggle'``: Does the same but weights to account for\n+          size of each layer. It is also called 'Streamgraph'-layout. More\n+          details can be found at http://leebyron.com/streamgraph/.\n+\n+    labels : list of str, optional\n+        A sequence of labels to assign to each data series. If unspecified,\n+        then no labels will be applied to artists.\n+\n+    colors : list of color, optional\n+        A sequence of colors to be cycled through and used to color the stacked\n+        areas. The sequence need not be exactly the same length as the number\n+        of provided *y*, in which case the colors will repeat from the\n+        beginning.\n+\n+        If not specified, the colors from the Axes property cycle will be used.\n+\n+    data : indexable object, optional\n+        DATA_PARAMETER_PLACEHOLDER\n+\n+    **kwargs\n+        All other keyword arguments are passed to `.Axes.fill_between`.\n+\n+    Returns\n+    -------\n+    list of `.PolyCollection`\n+        A list of `.PolyCollection` instances, one for each element in the\n+        stacked area plot.\n+    \"\"\"\n+\n+    y = np.row_stack(args)\n+\n+    labels = iter(labels)\n+    if colors is not None:\n+        axes.set_prop_cycle(color=colors)\n+\n+    # Assume data passed has not been 'stacked', so stack it here.\n+    # We'll need a float buffer for the upcoming calculations.\n+    stack = np.cumsum(y, axis=0, dtype=np.promote_types(y.dtype, np.float32))\n+\n+    _api.check_in_list(['zero', 'sym', 'wiggle', 'weighted_wiggle'],\n+                       baseline=baseline)\n+    if baseline == 'zero':\n+        first_line = 0.\n+\n+    elif baseline == 'sym':\n+        first_line = -np.sum(y, 0) * 0.5\n+        stack += first_line[None, :]\n+\n+    elif baseline == 'wiggle':\n+        m = y.shape[0]\n+        first_line = (y * (m - 0.5 - np.arange(m)[:, None])).sum(0)\n+        first_line /= -m\n+        stack += first_line\n+\n+    elif baseline == 'weighted_wiggle':\n+        total = np.sum(y, 0)\n+        # multiply by 1/total (or zero) to avoid infinities in the division:\n+        inv_total = np.zeros_like(total)\n+        mask = total > 0\n+        inv_total[mask] = 1.0 / total[mask]\n+        increase = np.hstack((y[:, 0:1], np.diff(y)))\n+        below_size = total - stack\n+        below_size += 0.5 * y\n+        move_up = below_size * inv_total\n+        move_up[:, 0] = 0.5\n+        center = (move_up - 0.5) * increase\n+        center = np.cumsum(center.sum(0))\n+        first_line = center - 0.5 * total\n+        stack += first_line\n+\n+    # Color between x = 0 and the first array.\n+    color = axes._get_lines.get_next_color()\n+    coll = axes.fill_between(x, first_line, stack[0, :],\n+                             facecolor=color, label=next(labels, None),\n+                             **kwargs)\n+    coll.sticky_edges.y[:] = [0]\n+    r = [coll]\n+\n+    # Color between array i-1 and array i\n+    for i in range(len(y) - 1):\n+        color = axes._get_lines.get_next_color()\n+        r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n+                                   facecolor=color, label=next(labels, None),\n+                                   **kwargs))\n+    return r\ndiff --git a/test_stackplot_cn_aliases.py b/test_stackplot_cn_aliases.py\nnew file mode 100644\nindex 0000000000..ce539c8f1a\n--- /dev/null\n+++ b/test_stackplot_cn_aliases.py\n@@ -0,0 +1,74 @@\n+\"\"\"\n+Test for the stackplot CN alias fix.\n+This tests the specific issue reported in GitHub issue #14221.\n+\"\"\"\n+\n+import matplotlib.pyplot as plt\n+from matplotlib.patches import Rectangle\n+import numpy as np\n+\n+\n+def test_stackplot_cn_aliases():\n+    \"\"\"Test that stackplot accepts CN color aliases without error.\"\"\"\n+    my_data = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])\n+    fig, ax = plt.subplots()\n+    \n+    # These should all work without raising ValueError\n+    ax.plot([1, 3], [1, 3], color='C0')\n+    ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))\n+    ax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])\n+    \n+    plt.close(fig)\n+\n+\n+def test_stackplot_cycler_not_modified():\n+    \"\"\"Test that stackplot doesn't modify the axes cycler.\"\"\"\n+    fig, ax = plt.subplots()\n+    \n+    # Get initial color from cycler\n+    line1 = ax.plot([1, 2], [1, 2])[0]\n+    initial_color = line1.get_color()\n+    ax.clear()\n+    \n+    # Use stackplot with explicit colors\n+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])\n+    \n+    # Plot again to see if cycler was affected\n+    line2 = ax.plot([1, 2], [1, 2])[0]\n+    next_color = line2.get_color()\n+    \n+    assert initial_color == next_color, f\"Cycler was modified: {initial_color} -> {next_color}\"\n+    \n+    plt.close(fig)\n+\n+\n+def test_stackplot_color_cycling():\n+    \"\"\"Test that colors cycle when fewer colors than data series.\"\"\"\n+    fig, ax = plt.subplots()\n+    \n+    # 3 data series with only 2 colors - should cycle\n+    result = ax.stackplot([1, 2, 3], [[1, 2, 3], [2, 3, 4], [3, 4, 5]], \n+                         colors=['red', 'blue'])\n+    \n+    # Check that we got 3 collections\n+    assert len(result) == 3\n+    \n+    # Check colors cycle correctly\n+    assert result[0].get_facecolor()[0].tolist()[:3] == [1.0, 0.0, 0.0]  # red\n+    assert result[1].get_facecolor()[0].tolist()[:3] == [0.0, 0.0, 1.0]  # blue  \n+    assert result[2].get_facecolor()[0].tolist()[:3] == [1.0, 0.0, 0.0]  # red (cycled)\n+    \n+    plt.close(fig)\n+\n+\n+if __name__ == \"__main__\":\n+    test_stackplot_cn_aliases()\n+    print(\"\u2713 test_stackplot_cn_aliases passed\")\n+    \n+    test_stackplot_cycler_not_modified()\n+    print(\"\u2713 test_stackplot_cycler_not_modified passed\")\n+    \n+    test_stackplot_color_cycling()\n+    print(\"\u2713 test_stackplot_color_cycling passed\")\n+    \n+    print(\"\\nAll tests passed!\")\ndiff --git a/test_stackplot_comprehensive.py b/test_stackplot_comprehensive.py\nnew file mode 100644\nindex 0000000000..caf40a6903\n--- /dev/null\n+++ b/test_stackplot_comprehensive.py\n@@ -0,0 +1,107 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import matplotlib.colors as mcolors\n+\n+# Test 1: CN color aliases work\n+print(\"Test 1: CN color aliases\")\n+try:\n+    fig, ax = plt.subplots()\n+    data = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n+    ax.stackplot([1, 2, 3], data, colors=['C0', 'C1', 'C2'])\n+    print(\"\u2713 CN aliases work\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 CN aliases failed: {e}\")\n+\n+# Test 2: Regular color names still work\n+print(\"\\nTest 2: Regular color names\")\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], data, colors=['red', 'green', 'blue'])\n+    print(\"\u2713 Regular color names work\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Regular color names failed: {e}\")\n+\n+# Test 3: Hex colors still work\n+print(\"\\nTest 3: Hex colors\")\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], data, colors=['#FF0000', '#00FF00', '#0000FF'])\n+    print(\"\u2713 Hex colors work\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Hex colors failed: {e}\")\n+\n+# Test 4: Default colors (no colors parameter) still work\n+print(\"\\nTest 4: Default colors\")\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], data)\n+    print(\"\u2713 Default colors work\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Default colors failed: {e}\")\n+\n+# Test 5: Colors cycle properly when fewer colors than data series\n+print(\"\\nTest 5: Color cycling\")\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], data, colors=['red', 'blue'])  # 2 colors for 3 series\n+    print(\"\u2713 Color cycling works\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Color cycling failed: {e}\")\n+\n+# Test 6: Cycler is not modified\n+print(\"\\nTest 6: Cycler preservation\")\n+fig, ax = plt.subplots()\n+# Get initial cycler color\n+line1 = ax.plot([1, 2], [1, 2])[0]\n+initial_color = line1.get_color()\n+ax.clear()\n+\n+# Use stackplot with colors\n+ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])\n+\n+# Check cycler hasn't changed\n+line2 = ax.plot([1, 2], [1, 2])[0]\n+next_color = line2.get_color()\n+\n+if initial_color == next_color:\n+    print(\"\u2713 Cycler not modified\")\n+else:\n+    print(f\"\u2717 Cycler was modified: {initial_color} -> {next_color}\")\n+plt.close(fig)\n+\n+# Test 7: All baseline options still work\n+print(\"\\nTest 7: Baseline options\")\n+baselines = ['zero', 'sym', 'wiggle', 'weighted_wiggle']\n+for baseline in baselines:\n+    try:\n+        fig, ax = plt.subplots()\n+        ax.stackplot([1, 2, 3], [[1, 2, 3], [2, 3, 4]], baseline=baseline, colors=['C0', 'C1'])\n+        print(f\"\u2713 Baseline '{baseline}' works\")\n+        plt.close(fig)\n+    except Exception as e:\n+        print(f\"\u2717 Baseline '{baseline}' failed: {e}\")\n+\n+# Test 8: Mixed usage - some plots with CN aliases, some without\n+print(\"\\nTest 8: Mixed usage\")\n+try:\n+    fig, (ax1, ax2) = plt.subplots(1, 2)\n+    \n+    # First subplot with CN aliases\n+    ax1.plot([1, 2], [1, 2], color='C0', label='line')\n+    ax1.stackplot([1, 2], [[1, 2], [3, 4]], colors=['C1', 'C2'], labels=['stack1', 'stack2'])\n+    \n+    # Second subplot without colors (using default cycler)\n+    ax2.plot([1, 2], [1, 2], label='line')\n+    ax2.stackplot([1, 2], [[1, 2], [3, 4]], labels=['stack1', 'stack2'])\n+    \n+    print(\"\u2713 Mixed usage works\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Mixed usage failed: {e}\")\n+\n+print(\"\\nAll tests completed!\")\ndiff --git a/test_stackplot_edge_cases.py b/test_stackplot_edge_cases.py\nnew file mode 100644\nindex 0000000000..393e52c98b\n--- /dev/null\n+++ b/test_stackplot_edge_cases.py\n@@ -0,0 +1,44 @@\n+\"\"\"Test edge cases for stackplot CN alias fix.\"\"\"\n+\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+\n+# Test empty colors list\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=[])\n+    print(\"\u2713 Empty colors list works (uses default cycler)\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Empty colors list failed: {e}\")\n+\n+# Test single color for multiple series\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['C0'])\n+    print(\"\u2713 Single color for multiple series works\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Single color failed: {e}\")\n+\n+# Test mix of CN aliases and regular colors\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], \n+                 colors=['C0', 'red', '#00FF00'])\n+    print(\"\u2713 Mix of CN aliases and regular colors works\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 Mix of colors failed: {e}\")\n+\n+# Test that None colors parameter works\n+try:\n+    fig, ax = plt.subplots()\n+    ax.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=None)\n+    print(\"\u2713 None colors parameter works\")\n+    plt.close(fig)\n+except Exception as e:\n+    print(f\"\u2717 None colors failed: {e}\")\n+\n+print(\"\\nAll edge case tests completed!\")\ndiff --git a/test_stackplot_issue.py b/test_stackplot_issue.py\nnew file mode 100644\nindex 0000000000..84754c20d5\n--- /dev/null\n+++ b/test_stackplot_issue.py\n@@ -0,0 +1,41 @@\n+import matplotlib.pyplot as plt\n+from matplotlib.patches import Rectangle\n+import numpy as np\n+\n+# Test case from the issue\n+my_data = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])\n+fig, ax = plt.subplots()\n+\n+# This should work (and does)\n+ax.plot([1, 3], [1, 3], color='C0')\n+ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))\n+\n+# This should work but currently raises ValueError\n+try:\n+    ax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])\n+    print(\"SUCCESS: stackplot with CN aliases worked!\")\n+except ValueError as e:\n+    print(f\"ERROR: {e}\")\n+\n+# Also test that the cycler is not modified\n+fig2, ax2 = plt.subplots()\n+# Get initial color from cycler\n+line1 = ax2.plot([1, 2], [1, 2])[0]\n+initial_color = line1.get_color()\n+\n+# Use stackplot with explicit colors\n+ax2.clear()\n+ax2.stackplot([1, 2, 3], [[1, 2, 3], [4, 5, 6]], colors=['red', 'blue'])\n+\n+# Plot again to see if cycler was affected\n+line2 = ax2.plot([1, 2], [1, 2])[0]\n+next_color = line2.get_color()\n+\n+print(f\"Initial color: {initial_color}\")\n+print(f\"Color after stackplot: {next_color}\")\n+if initial_color == next_color:\n+    print(\"SUCCESS: Cycler was not modified by stackplot\")\n+else:\n+    print(\"ERROR: Cycler was modified by stackplot\")\n+\n+plt.close('all')\n", "gold_standard_diff": "diff --git a/lib/matplotlib/stackplot.py b/lib/matplotlib/stackplot.py\nindex c580043eebbc..c97a21e029f9 100644\n--- a/lib/matplotlib/stackplot.py\n+++ b/lib/matplotlib/stackplot.py\n@@ -6,6 +6,8 @@\n (https://stackoverflow.com/users/66549/doug)\n \"\"\"\n \n+import itertools\n+\n import numpy as np\n \n from matplotlib import _api\n@@ -70,7 +72,9 @@ def stackplot(axes, x, *args,\n \n     labels = iter(labels)\n     if colors is not None:\n-        axes.set_prop_cycle(color=colors)\n+        colors = itertools.cycle(colors)\n+    else:\n+        colors = (axes._get_lines.get_next_color() for _ in y)\n \n     # Assume data passed has not been 'stacked', so stack it here.\n     # We'll need a float buffer for the upcoming calculations.\n@@ -108,17 +112,16 @@ def stackplot(axes, x, *args,\n         stack += first_line\n \n     # Color between x = 0 and the first array.\n-    color = axes._get_lines.get_next_color()\n     coll = axes.fill_between(x, first_line, stack[0, :],\n-                             facecolor=color, label=next(labels, None),\n+                             facecolor=next(colors), label=next(labels, None),\n                              **kwargs)\n     coll.sticky_edges.y[:] = [0]\n     r = [coll]\n \n     # Color between array i-1 and array i\n     for i in range(len(y) - 1):\n-        color = axes._get_lines.get_next_color()\n         r.append(axes.fill_between(x, stack[i, :], stack[i + 1, :],\n-                                   facecolor=color, label=next(labels, None),\n+                                   facecolor=next(colors),\n+                                   label=next(labels, None),\n                                    **kwargs))\n     return r\ndiff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 405560d4a386..1ae3c375934c 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -2851,10 +2851,11 @@ def test_stackplot():\n     ax.set_xlim((0, 10))\n     ax.set_ylim((0, 70))\n \n-    # Reuse testcase from above for a labeled data test\n+    # Reuse testcase from above for a test with labeled data and with colours\n+    # from the Axes property cycle.\n     data = {\"x\": x, \"y1\": y1, \"y2\": y2, \"y3\": y3}\n     fig, ax = plt.subplots()\n-    ax.stackplot(\"x\", \"y1\", \"y2\", \"y3\", data=data)\n+    ax.stackplot(\"x\", \"y1\", \"y2\", \"y3\", data=data, colors=[\"C0\", \"C1\", \"C2\"])\n     ax.set_xlim((0, 10))\n     ax.set_ylim((0, 70))\n \n", "gold_standard_pr_link": "https://github.com/matplotlib/matplotlib/pull/24026"}