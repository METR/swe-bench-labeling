{"instance_id": "django__django-14140", "score": "C", "diff": "diff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex ae0f886107..81b7ee9a93 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -84,14 +84,10 @@ class Q(tree.Node):\n         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)\n         if path.startswith('django.db.models.query_utils'):\n             path = path.replace('django.db.models.query_utils', 'django.db.models')\n-        args, kwargs = (), {}\n-        if len(self.children) == 1 and not isinstance(self.children[0], Q):\n-            child = self.children[0]\n-            kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n-                kwargs = {'_connector': self.connector}\n+        args = tuple(self.children)\n+        kwargs = {}\n+        if self.connector != self.default:\n+            kwargs = {'_connector': self.connector}\n         if self.negated:\n             kwargs['_negated'] = True\n         return path, args, kwargs\ndiff --git a/test_backward_compat.py b/test_backward_compat.py\nnew file mode 100644\nindex 0000000000..62a3f89bba\n--- /dev/null\n+++ b/test_backward_compat.py\n@@ -0,0 +1,37 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.db.models import Q\n+\n+print(\"Analyzing backward compatibility impact...\")\n+print(\"\\nBefore the fix:\")\n+print(\"Q(x=1).deconstruct() -> ('django.db.models.Q', (), {'x': 1})\")\n+print(\"\\nAfter the fix:\")\n+\n+q = Q(x=1)\n+path, args, kwargs = q.deconstruct()\n+print(f\"Q(x=1).deconstruct() -> ('{path}', {args}, {kwargs})\")\n+\n+print(\"\\nReconstruction test:\")\n+print(\"Original Q object:\", q)\n+\n+# Reconstruct using new format\n+reconstructed_new = Q(*args, **kwargs)\n+print(\"Reconstructed (new format):\", reconstructed_new)\n+print(\"Children match:\", q.children == reconstructed_new.children)\n+\n+# Test if old format still works\n+print(\"\\nTesting if old format can still be used for construction:\")\n+try:\n+    # This is how it would have been stored/reconstructed before\n+    old_style_q = Q(**{'x': 1})\n+    print(\"Q(**{'x': 1}) =\", old_style_q)\n+    print(\"Equivalent to original:\", old_style_q.children == q.children)\n+except Exception as e:\n+    print(f\"Failed: {e}\")\n+\n+print(\"\\nConclusion:\")\n+print(\"- The change affects how Q objects are deconstructed for serialization\")\n+print(\"- Single-child Q objects now use args instead of kwargs\")\n+print(\"- Both formats can still be used for construction\")\n+print(\"- The main benefit is that non-subscriptable objects (like Exists) now work\")\ndiff --git a/test_fix_verification.py b/test_fix_verification.py\nnew file mode 100644\nindex 0000000000..12037edc29\n--- /dev/null\n+++ b/test_fix_verification.py\n@@ -0,0 +1,42 @@\n+#!/usr/bin/env python\n+import os\n+import sys\n+\n+# Add the testbed to the path\n+sys.path.insert(0, '/testbed')\n+\n+# Set up Django environment\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+\n+import django\n+django.setup()\n+\n+from django.db.models import Q, Exists\n+from django.contrib.auth import get_user_model\n+\n+print(\"Testing the fix for Q() objects with boolean expressions...\")\n+\n+# Before the fix, this would crash with: TypeError: 'Exists' object is not subscriptable\n+try:\n+    User = get_user_model()\n+    exists_expr = Exists(User.objects.filter(username='jim'))\n+    q = Q(exists_expr)\n+    \n+    # This is the line that would crash before the fix\n+    path, args, kwargs = q.deconstruct()\n+    \n+    print(\"\u2713 SUCCESS: Q(Exists(...)).deconstruct() works!\")\n+    print(f\"  path: {path}\")\n+    print(f\"  args: {args}\")\n+    print(f\"  kwargs: {kwargs}\")\n+    \n+    # Try to reconstruct\n+    Q_cls = Q\n+    reconstructed = Q_cls(*args, **kwargs)\n+    print(f\"\u2713 SUCCESS: Reconstructed Q object: {reconstructed}\")\n+    \n+except Exception as e:\n+    print(f\"\u2717 FAILED: {type(e).__name__}: {e}\")\n+    sys.exit(1)\n+\n+print(\"\\nAll tests passed!\")\ndiff --git a/test_q_comprehensive.py b/test_q_comprehensive.py\nnew file mode 100644\nindex 0000000000..278aba7802\n--- /dev/null\n+++ b/test_q_comprehensive.py\n@@ -0,0 +1,94 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.db.models import Q, Exists, Value\n+from django.contrib.auth import get_user_model\n+\n+print(\"Testing Q object deconstruct and reconstruct...\")\n+\n+# Test 1: Simple Q with single condition\n+q1 = Q(x=1)\n+path, args, kwargs = q1.deconstruct()\n+print(f\"\\nTest 1 - Q(x=1):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+# Reconstruct and verify\n+module_path, class_name = path.rsplit('.', 1)\n+module = __import__(module_path, fromlist=[class_name])\n+QClass = getattr(module, class_name)\n+q1_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q1_reconstructed}\")\n+print(f\"  Children match: {q1.children == q1_reconstructed.children}\")\n+\n+# Test 2: Q with multiple conditions\n+q2 = Q(x=1, y=2)\n+path, args, kwargs = q2.deconstruct()\n+print(f\"\\nTest 2 - Q(x=1, y=2):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q2_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q2_reconstructed}\")\n+print(f\"  Children match: {q2.children == q2_reconstructed.children}\")\n+\n+# Test 3: Q with Exists (the main fix)\n+User = get_user_model()\n+exists_obj = Exists(User.objects.filter(username='jim'))\n+q3 = Q(exists_obj)\n+path, args, kwargs = q3.deconstruct()\n+print(f\"\\nTest 3 - Q(Exists(...)):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q3_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q3_reconstructed}\")\n+print(f\"  Children match: {q3.children == q3_reconstructed.children}\")\n+\n+# Test 4: Nested Q objects\n+q4 = Q(Q(x=1))\n+path, args, kwargs = q4.deconstruct()\n+print(f\"\\nTest 4 - Q(Q(x=1)):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q4_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q4_reconstructed}\")\n+\n+# Test 5: Q with OR connector\n+q5 = Q(x=1) | Q(y=2)\n+path, args, kwargs = q5.deconstruct()\n+print(f\"\\nTest 5 - Q(x=1) | Q(y=2):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q5_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q5_reconstructed}\")\n+print(f\"  Connector matches: {q5.connector == q5_reconstructed.connector}\")\n+\n+# Test 6: Negated Q\n+q6 = ~Q(x=1)\n+path, args, kwargs = q6.deconstruct()\n+print(f\"\\nTest 6 - ~Q(x=1):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q6_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q6_reconstructed}\")\n+print(f\"  Negated matches: {q6.negated == q6_reconstructed.negated}\")\n+\n+# Test 7: Complex expression with Value\n+q7 = Q(Value(True))\n+path, args, kwargs = q7.deconstruct()\n+print(f\"\\nTest 7 - Q(Value(True)):\")\n+print(f\"  Deconstructed: path={path}, args={args}, kwargs={kwargs}\")\n+q7_reconstructed = QClass(*args, **kwargs)\n+print(f\"  Reconstructed: {q7_reconstructed}\")\n+print(f\"  Children match: {len(q7.children) == len(q7_reconstructed.children)}\")\n+\n+print(\"\\nAll tests completed successfully!\")\ndiff --git a/test_q_deconstruct.py b/test_q_deconstruct.py\nnew file mode 100644\nindex 0000000000..4777d61faa\n--- /dev/null\n+++ b/test_q_deconstruct.py\n@@ -0,0 +1,42 @@\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+settings.configure(\n+    DATABASES={\n+        'default': {\n+            'ENGINE': 'django.db.backends.sqlite3',\n+            'NAME': ':memory:',\n+        }\n+    },\n+    INSTALLED_APPS=[\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ],\n+    SECRET_KEY='test-secret-key',\n+)\n+\n+django.setup()\n+\n+from django.db.models import Q, Exists\n+from django.contrib.auth import get_user_model\n+\n+# Test case 1: Q with single tuple child (current working case)\n+q1 = Q(x=1)\n+print(\"Q(x=1).deconstruct():\", q1.deconstruct())\n+\n+# Test case 2: Q with multiple children (current working case)\n+q2 = Q(x=1, y=2)\n+print(\"Q(x=1, y=2).deconstruct():\", q2.deconstruct())\n+\n+# Test case 3: Q with Exists child (current broken case)\n+try:\n+    User = get_user_model()\n+    q3 = Q(Exists(User.objects.filter(username='jim')))\n+    print(\"Q(Exists(...)).deconstruct():\", q3.deconstruct())\n+except TypeError as e:\n+    print(\"ERROR - Q(Exists(...)).deconstruct():\", str(e))\n+\n+# Test case 4: Q with nested Q (should work)\n+q4 = Q(Q(x=1))\n+print(\"Q(Q(x=1)).deconstruct():\", q4.deconstruct())\ndiff --git a/test_q_exists.py b/test_q_exists.py\nnew file mode 100644\nindex 0000000000..36430eec82\n--- /dev/null\n+++ b/test_q_exists.py\n@@ -0,0 +1,59 @@\n+import os\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+os.environ['DJANGO_SETTINGS_MODULE'] = 'tests.test_sqlite'\n+django.setup()\n+\n+from django.test import TestCase\n+from django.db.models import Q, Exists, Value\n+from django.contrib.auth.models import User\n+\n+class TestQWithExists(TestCase):\n+    def test_q_with_exists_deconstruct(self):\n+        \"\"\"Test that Q objects with Exists expressions can be deconstructed without error.\"\"\"\n+        # This used to raise: TypeError: 'Exists' object is not subscriptable\n+        exists_obj = Exists(User.objects.filter(username='jim'))\n+        q = Q(exists_obj)\n+        \n+        # Should not raise an error\n+        path, args, kwargs = q.deconstruct()\n+        \n+        # Verify the deconstruction is correct\n+        self.assertEqual(path, 'django.db.models.Q')\n+        self.assertEqual(len(args), 1)\n+        self.assertEqual(args[0], exists_obj)\n+        self.assertEqual(kwargs, {})\n+        \n+        # Verify reconstruction works\n+        reconstructed = Q(*args, **kwargs)\n+        self.assertEqual(reconstructed.children, q.children)\n+    \n+    def test_q_with_value_deconstruct(self):\n+        \"\"\"Test that Q objects with Value expressions can be deconstructed without error.\"\"\"\n+        value_obj = Value(True)\n+        q = Q(value_obj)\n+        \n+        # Should not raise an error\n+        path, args, kwargs = q.deconstruct()\n+        \n+        # Verify the deconstruction is correct\n+        self.assertEqual(path, 'django.db.models.Q')\n+        self.assertEqual(len(args), 1)\n+        self.assertEqual(args[0], value_obj)\n+        self.assertEqual(kwargs, {})\n+        \n+        # Verify reconstruction works\n+        reconstructed = Q(*args, **kwargs)\n+        self.assertEqual(reconstructed.children, q.children)\n+\n+if __name__ == '__main__':\n+    from django.test.utils import get_runner\n+    TestRunner = get_runner(settings)\n+    test_runner = TestRunner(verbosity=2, interactive=True)\n+    failures = test_runner.run_tests([\"__main__\"])\n+    sys.exit(bool(failures))\ndiff --git a/test_q_migration_serialize.py b/test_q_migration_serialize.py\nnew file mode 100644\nindex 0000000000..2b402294d6\n--- /dev/null\n+++ b/test_q_migration_serialize.py\n@@ -0,0 +1,43 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.db import migrations\n+from django.db.models import Q, Exists, Value\n+from django.db.migrations.writer import MigrationWriter\n+\n+print(\"Testing Q object serialization for migrations...\")\n+\n+# Test various Q object configurations\n+test_cases = [\n+    (\"Simple Q\", Q(x=1)),\n+    (\"Multiple conditions\", Q(x=1, y=2)),\n+    (\"OR connector\", Q(x=1) | Q(y=2)),\n+    (\"Negated Q\", ~Q(x=1)),\n+    (\"Q with Value\", Q(Value(True))),\n+    (\"Nested Q\", Q(Q(x=1))),\n+]\n+\n+for name, q_obj in test_cases:\n+    print(f\"\\n{name}: {q_obj}\")\n+    \n+    # Test serialization\n+    try:\n+        serialized, imports = MigrationWriter.serialize(q_obj)\n+        print(f\"  Serialized: {serialized}\")\n+        print(f\"  Imports needed: {imports}\")\n+        \n+        # Try to evaluate the serialized form\n+        namespace = {}\n+        for import_str in imports:\n+            exec(import_str, namespace)\n+        \n+        reconstructed = eval(serialized, namespace)\n+        print(f\"  Reconstructed: {reconstructed}\")\n+        print(f\"  Match: {q_obj.children == reconstructed.children}\")\n+        \n+    except Exception as e:\n+        print(f\"  ERROR: {type(e).__name__}: {e}\")\n+        import traceback\n+        traceback.print_exc()\n+\n+print(\"\\nConclusion: Q objects can still be serialized for migrations after the fix.\")\ndiff --git a/test_simple_fix.py b/test_simple_fix.py\nnew file mode 100644\nindex 0000000000..5b53ce84f9\n--- /dev/null\n+++ b/test_simple_fix.py\n@@ -0,0 +1,53 @@\n+import sys\n+sys.path.insert(0, '/testbed')\n+\n+from django.db.models import Q\n+\n+# Create a mock object that isn't subscriptable (similar to Exists)\n+class NonSubscriptableObject:\n+    def __init__(self, value):\n+        self.value = value\n+    \n+    def __repr__(self):\n+        return f\"NonSubscriptableObject({self.value})\"\n+    \n+    def __eq__(self, other):\n+        return isinstance(other, NonSubscriptableObject) and self.value == other.value\n+\n+print(\"Testing Q object deconstruct with non-subscriptable objects...\")\n+\n+# Test 1: Single non-subscriptable object (this would fail before the fix)\n+try:\n+    obj = NonSubscriptableObject(\"test\")\n+    q = Q(obj)\n+    path, args, kwargs = q.deconstruct()\n+    print(f\"\u2713 SUCCESS: Q(NonSubscriptableObject).deconstruct() works!\")\n+    print(f\"  path: {path}\")\n+    print(f\"  args: {args}\")\n+    print(f\"  kwargs: {kwargs}\")\n+    \n+    # Verify reconstruction\n+    Q_cls = Q\n+    reconstructed = Q_cls(*args, **kwargs)\n+    print(f\"  Original children: {q.children}\")\n+    print(f\"  Reconstructed children: {reconstructed.children}\")\n+    print(f\"  Children match: {q.children == reconstructed.children}\")\n+    \n+except Exception as e:\n+    print(f\"\u2717 FAILED: {type(e).__name__}: {e}\")\n+    import traceback\n+    traceback.print_exc()\n+\n+# Test 2: Regular tuple case still works\n+print(\"\\nTesting regular tuple case...\")\n+try:\n+    q = Q(x=1)\n+    path, args, kwargs = q.deconstruct()\n+    print(f\"\u2713 SUCCESS: Q(x=1).deconstruct() works!\")\n+    print(f\"  path: {path}\")\n+    print(f\"  args: {args}\")\n+    print(f\"  kwargs: {kwargs}\")\n+except Exception as e:\n+    print(f\"\u2717 FAILED: {type(e).__name__}: {e}\")\n+\n+print(\"\\nAll tests completed!\")\n", "gold_standard_diff": "From 54f60bc85df7fe38ba6ef6779996d8544d340d3e Mon Sep 17 00:00:00 2001\nFrom: Mariusz Felisiak <felisiak.mariusz@gmail.com>\nDate: Wed, 17 Mar 2021 11:44:09 +0100\nSubject: [PATCH 1/2] Refs #32548 -- Added tests for passing conditional\n expressions to Q().\n\n---\n tests/expressions/tests.py     |  6 ++++++\n tests/queryset_pickle/tests.py | 11 +++++++++++\n 2 files changed, 17 insertions(+)\n\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 9ecc033b6b2b..82d8a9f35168 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -838,6 +838,12 @@ def test_boolean_expression_combined_with_empty_Q(self):\n             with self.subTest(conditions):\n                 self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n \n+    def test_boolean_expression_in_Q(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        self.assertCountEqual(Employee.objects.filter(Q(Exists(is_poc))), [self.max])\n+\n \n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\ndiff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex d0ae963cd9ad..bf6196041938 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -172,6 +172,17 @@ def test_pickle_prefetch_related_with_m2m_and_objects_deletion(self):\n         m2ms = pickle.loads(pickle.dumps(m2ms))\n         self.assertSequenceEqual(m2ms, [m2m])\n \n+    def test_pickle_boolean_expression_in_Q__queryset(self):\n+        group = Group.objects.create(name='group')\n+        Event.objects.create(title='event', group=group)\n+        groups = Group.objects.filter(\n+            models.Q(models.Exists(\n+                Event.objects.filter(group_id=models.OuterRef('id')),\n+            )),\n+        )\n+        groups2 = pickle.loads(pickle.dumps(groups))\n+        self.assertSequenceEqual(groups2, [group])\n+\n     def test_pickle_exists_queryset_still_usable(self):\n         group = Group.objects.create(name='group')\n         Event.objects.create(title='event', group=group)\n\nFrom 00b0786de533dbb3f6208d8d5eaddbf765b4e5b8 Mon Sep 17 00:00:00 2001\nFrom: Jonathan Richards <jonathan@golorry.com>\nDate: Sun, 14 Mar 2021 14:00:40 -0700\nSubject: [PATCH 2/2] Fixed #32548 -- Fixed crash when combining Q() objects\n with boolean expressions.\n\n---\n django/db/models/query_utils.py | 12 ++++--------\n tests/expressions/tests.py      |  4 ++++\n tests/queries/test_q.py         | 22 ++++++++++++++--------\n 3 files changed, 22 insertions(+), 16 deletions(-)\n\ndiff --git a/django/db/models/query_utils.py b/django/db/models/query_utils.py\nindex ae0f8861075c..43c93ce4552f 100644\n--- a/django/db/models/query_utils.py\n+++ b/django/db/models/query_utils.py\n@@ -84,14 +84,10 @@ def deconstruct(self):\n         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)\n         if path.startswith('django.db.models.query_utils'):\n             path = path.replace('django.db.models.query_utils', 'django.db.models')\n-        args, kwargs = (), {}\n-        if len(self.children) == 1 and not isinstance(self.children[0], Q):\n-            child = self.children[0]\n-            kwargs = {child[0]: child[1]}\n-        else:\n-            args = tuple(self.children)\n-            if self.connector != self.default:\n-                kwargs = {'_connector': self.connector}\n+        args = tuple(self.children)\n+        kwargs = {}\n+        if self.connector != self.default:\n+            kwargs['_connector'] = self.connector\n         if self.negated:\n             kwargs['_negated'] = True\n         return path, args, kwargs\ndiff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 82d8a9f35168..eb1bfdc2be62 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -833,6 +833,10 @@ def test_boolean_expression_combined_with_empty_Q(self):\n             Q() & Exists(is_poc),\n             Exists(is_poc) | Q(),\n             Q() | Exists(is_poc),\n+            Q(Exists(is_poc)) & Q(),\n+            Q() & Q(Exists(is_poc)),\n+            Q(Exists(is_poc)) | Q(),\n+            Q() | Q(Exists(is_poc)),\n         ]\n         for conditions in tests:\n             with self.subTest(conditions):\ndiff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex 6dcf36ce025b..24a705f07f06 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,6 +1,8 @@\n-from django.db.models import F, Q\n+from django.db.models import Exists, F, OuterRef, Q\n from django.test import SimpleTestCase\n \n+from .models import Tag\n+\n \n class QTests(SimpleTestCase):\n     def test_combine_and_empty(self):\n@@ -39,17 +41,14 @@ def test_deconstruct(self):\n         q = Q(price__gt=F('discounted_price'))\n         path, args, kwargs = q.deconstruct()\n         self.assertEqual(path, 'django.db.models.Q')\n-        self.assertEqual(args, ())\n-        self.assertEqual(kwargs, {'price__gt': F('discounted_price')})\n+        self.assertEqual(args, (('price__gt', F('discounted_price')),))\n+        self.assertEqual(kwargs, {})\n \n     def test_deconstruct_negated(self):\n         q = ~Q(price__gt=F('discounted_price'))\n         path, args, kwargs = q.deconstruct()\n-        self.assertEqual(args, ())\n-        self.assertEqual(kwargs, {\n-            'price__gt': F('discounted_price'),\n-            '_negated': True,\n-        })\n+        self.assertEqual(args, (('price__gt', F('discounted_price')),))\n+        self.assertEqual(kwargs, {'_negated': True})\n \n     def test_deconstruct_or(self):\n         q1 = Q(price__gt=F('discounted_price'))\n@@ -88,6 +87,13 @@ def test_deconstruct_nested(self):\n         self.assertEqual(args, (Q(price__gt=F('discounted_price')),))\n         self.assertEqual(kwargs, {})\n \n+    def test_deconstruct_boolean_expression(self):\n+        tagged = Tag.objects.filter(category=OuterRef('pk'))\n+        q = Q(Exists(tagged))\n+        _, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, (Exists(tagged),))\n+        self.assertEqual(kwargs, {})\n+\n     def test_reconstruct(self):\n         q = Q(price__gt=F('discounted_price'))\n         path, args, kwargs = q.deconstruct()\n", "gold_standard_pr_link": "https://github.com/django/django/pull/14140"}