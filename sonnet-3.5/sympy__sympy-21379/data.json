{"instance_id": "sympy__sympy-21379", "score": "C", "diff": "diff --git a/sympy/polys/polytools.py b/sympy/polys/polytools.py\nindex bfec61de64..4cd9be52f8 100644\n--- a/sympy/polys/polytools.py\n+++ b/sympy/polys/polytools.py\n@@ -4394,9 +4394,16 @@ def _parallel_poly_from_expr(exprs, opt):\n     if not opt.gens:\n         raise PolificationFailed(opt, origs, exprs, True)\n \n+    # Handle Piecewise generators by converting them to their underlying expressions\n+    # This allows for proper substitution and evaluation of Piecewise functions in polynomials\n+    new_gens = []\n     for k in opt.gens:\n         if isinstance(k, Piecewise):\n-            raise PolynomialError(\"Piecewise generators do not make sense\")\n+            # Convert Piecewise to its underlying expression\n+            new_gens.append(k.as_expr())\n+        else:\n+            new_gens.append(k)\n+    opt.gens = tuple(new_gens)\n \n     coeffs_list, lengths = [], []\n \ndiff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 8f7e464148..952d4b254a 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3477,4 +3477,11 @@ def test_issue_20985():\n     from sympy import symbols\n     w, R = symbols('w R')\n     poly = Poly(1.0 + I*w/R, w, 1/R)\n+\n+def test_piecewise_poly():\n+    from sympy import Piecewise\n+    p = Poly(Piecewise((x, x > 0), (x**2, True)))\n+    assert p.as_expr() == Piecewise((x, x > 0), (x**2, True))\n+    assert p.subs({x: 2}) == 2\n+    assert p.subs({x: -2}) == 4\n     assert poly.degree() == S(1)\n", "gold_standard_diff": "From 818864a2a35d273984535fad197d9e7e91c49101 Mon Sep 17 00:00:00 2001\nFrom: Zach Carmichael <20629897+craymichael@users.noreply.github.com>\nDate: Sat, 24 Apr 2021 15:31:21 -0400\nSubject: [PATCH 1/3] Check for PolynomialError that arises from gcd with\n Piecewise\n\n---\n sympy/core/mod.py             | 45 +++++++++++++++++++----------------\n sympy/core/tests/test_arit.py | 14 +++++++++++\n 2 files changed, 39 insertions(+), 20 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex b4f3de25234b..a124b956804b 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n         from sympy.core.exprtools import gcd_terms\n+        from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n \n         def doit(p, q):\n@@ -56,7 +57,7 @@ def doit(p, q):\n \n             if q.is_Number:\n                 if p.is_Number:\n-                    return p%q\n+                    return p % q\n                 if q == 2:\n                     if p.is_even:\n                         return S.Zero\n@@ -69,7 +70,7 @@ def doit(p, q):\n                     return rv\n \n             # by ratio\n-            r = p/q\n+            r = p / q\n             if r.is_integer:\n                 return S.Zero\n             try:\n@@ -78,8 +79,8 @@ def doit(p, q):\n                 pass\n             else:\n                 if isinstance(d, int):\n-                    rv = p - d*q\n-                    if (rv*q < 0) == True:\n+                    rv = p - d * q\n+                    if (rv * q < 0) == True:\n                         rv += q\n                     return rv\n \n@@ -110,14 +111,14 @@ def doit(p, q):\n             qinner = p.args[1]\n             if qinner % q == 0:\n                 return cls(p.args[0], q)\n-            elif (qinner*(q - qinner)).is_nonnegative:\n+            elif (qinner * (q - qinner)).is_nonnegative:\n                 # |qinner| < |q| and have same sign\n                 return p\n         elif isinstance(-p, cls):\n             qinner = (-p).args[1]\n             if qinner % q == 0:\n                 return cls(-(-p).args[0], q)\n-            elif (qinner*(q + qinner)).is_nonpositive:\n+            elif (qinner * (q + qinner)).is_nonpositive:\n                 # |qinner| < |q| and have different sign\n                 return p\n         elif isinstance(p, Add):\n@@ -149,14 +150,14 @@ def doit(p, q):\n                 prod_mod = Mul(*mod)\n                 prod_non_mod = Mul(*non_mod)\n                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n-                net = prod_mod1*prod_mod\n-                return prod_non_mod*cls(net, q)\n+                net = prod_mod1 * prod_mod\n+                return prod_non_mod * cls(net, q)\n \n             if q.is_Integer and q is not S.One:\n                 _ = []\n                 for i in non_mod_l:\n                     if i.is_Integer and (i % q is not S.Zero):\n-                        _.append(i%q)\n+                        _.append(i % q)\n                     else:\n                         _.append(i)\n                 non_mod_l = _\n@@ -166,10 +167,14 @@ def doit(p, q):\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n-        G = gcd(p, q)\n-        if G != 1:\n-            p, q = [\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n+        try:\n+            G = gcd(p, q)\n+            if G != 1:\n+                p, q = [\n+                    gcd_terms(i / G, clear=False, fraction=False)\n+                    for i in (p, q)]\n+        except PolynomialError:  # issue 21373\n+            G = S.One\n         pwas, qwas = p, q\n \n         # simplify terms\n@@ -196,11 +201,11 @@ def doit(p, q):\n                 r = cp % cq\n                 if r == 0:\n                     G *= cq\n-                    p *= int(cp/cq)\n+                    p *= int(cp / cq)\n                     ok = True\n             if not ok:\n-                p = cp*p\n-                q = cq*q\n+                p = cp * p\n+                q = cq * q\n \n         # simple -1 extraction\n         if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n@@ -209,16 +214,16 @@ def doit(p, q):\n         # check again to see if p and q can now be handled as numbers\n         rv = doit(p, q)\n         if rv is not None:\n-            return rv*G\n+            return rv * G\n \n         # put 1.0 from G on inside\n         if G.is_Float and G == 1:\n             p *= G\n             return cls(p, q, evaluate=False)\n         elif G.is_Mul and G.args[0].is_Float and G.args[0] == 1:\n-            p = G.args[0]*p\n+            p = G.args[0] * p\n             G = Mul._from_args(G.args[1:])\n-        return G*cls(p, q, evaluate=(p, q) != (pwas, qwas))\n+        return G * cls(p, q, evaluate=(p, q) != (pwas, qwas))\n \n     def _eval_is_integer(self):\n         from sympy.core.logic import fuzzy_and, fuzzy_not\n@@ -236,4 +241,4 @@ def _eval_is_nonpositive(self):\n \n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b*floor(a/b)\n+        return a - b * floor(a / b)\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 2dc6589f8c67..b538e7031e23 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1913,6 +1913,20 @@ def test_Mod():\n     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n+    # issue 21373\n+    from sympy.core.cache import clear_cache\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    clear_cache()\n+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n+    clear_cache()\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    expr.subs({1: 1.0})\n+    clear_cache()\n+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n+\n \n def test_Mod_Pow():\n     # modular exponentiation\n\nFrom 35b717e173f8237e61d727296deb07b7e445200e Mon Sep 17 00:00:00 2001\nFrom: Zach Carmichael <20629897+craymichael@users.noreply.github.com>\nDate: Sat, 24 Apr 2021 19:53:28 -0400\nSubject: [PATCH 2/3] Undo editor formatting\n\n---\n sympy/core/mod.py | 37 ++++++++++++++++++-------------------\n 1 file changed, 18 insertions(+), 19 deletions(-)\n\ndiff --git a/sympy/core/mod.py b/sympy/core/mod.py\nindex a124b956804b..ebe7862aef6e 100644\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -57,7 +57,7 @@ def doit(p, q):\n \n             if q.is_Number:\n                 if p.is_Number:\n-                    return p % q\n+                    return p%q\n                 if q == 2:\n                     if p.is_even:\n                         return S.Zero\n@@ -70,7 +70,7 @@ def doit(p, q):\n                     return rv\n \n             # by ratio\n-            r = p / q\n+            r = p/q\n             if r.is_integer:\n                 return S.Zero\n             try:\n@@ -79,8 +79,8 @@ def doit(p, q):\n                 pass\n             else:\n                 if isinstance(d, int):\n-                    rv = p - d * q\n-                    if (rv * q < 0) == True:\n+                    rv = p - d*q\n+                    if (rv*q < 0) == True:\n                         rv += q\n                     return rv\n \n@@ -111,14 +111,14 @@ def doit(p, q):\n             qinner = p.args[1]\n             if qinner % q == 0:\n                 return cls(p.args[0], q)\n-            elif (qinner * (q - qinner)).is_nonnegative:\n+            elif (qinner*(q - qinner)).is_nonnegative:\n                 # |qinner| < |q| and have same sign\n                 return p\n         elif isinstance(-p, cls):\n             qinner = (-p).args[1]\n             if qinner % q == 0:\n                 return cls(-(-p).args[0], q)\n-            elif (qinner * (q + qinner)).is_nonpositive:\n+            elif (qinner*(q + qinner)).is_nonpositive:\n                 # |qinner| < |q| and have different sign\n                 return p\n         elif isinstance(p, Add):\n@@ -150,14 +150,14 @@ def doit(p, q):\n                 prod_mod = Mul(*mod)\n                 prod_non_mod = Mul(*non_mod)\n                 prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n-                net = prod_mod1 * prod_mod\n-                return prod_non_mod * cls(net, q)\n+                net = prod_mod1*prod_mod\n+                return prod_non_mod*cls(net, q)\n \n             if q.is_Integer and q is not S.One:\n                 _ = []\n                 for i in non_mod_l:\n                     if i.is_Integer and (i % q is not S.Zero):\n-                        _.append(i % q)\n+                        _.append(i%q)\n                     else:\n                         _.append(i)\n                 non_mod_l = _\n@@ -170,9 +170,8 @@ def doit(p, q):\n         try:\n             G = gcd(p, q)\n             if G != 1:\n-                p, q = [\n-                    gcd_terms(i / G, clear=False, fraction=False)\n-                    for i in (p, q)]\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\n+                        for i in (p, q)]\n         except PolynomialError:  # issue 21373\n             G = S.One\n         pwas, qwas = p, q\n@@ -201,11 +200,11 @@ def doit(p, q):\n                 r = cp % cq\n                 if r == 0:\n                     G *= cq\n-                    p *= int(cp / cq)\n+                    p *= int(cp/cq)\n                     ok = True\n             if not ok:\n-                p = cp * p\n-                q = cq * q\n+                p = cp*p\n+                q = cq*q\n \n         # simple -1 extraction\n         if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n@@ -214,16 +213,16 @@ def doit(p, q):\n         # check again to see if p and q can now be handled as numbers\n         rv = doit(p, q)\n         if rv is not None:\n-            return rv * G\n+            return rv*G\n \n         # put 1.0 from G on inside\n         if G.is_Float and G == 1:\n             p *= G\n             return cls(p, q, evaluate=False)\n         elif G.is_Mul and G.args[0].is_Float and G.args[0] == 1:\n-            p = G.args[0] * p\n+            p = G.args[0]*p\n             G = Mul._from_args(G.args[1:])\n-        return G * cls(p, q, evaluate=(p, q) != (pwas, qwas))\n+        return G*cls(p, q, evaluate=(p, q) != (pwas, qwas))\n \n     def _eval_is_integer(self):\n         from sympy.core.logic import fuzzy_and, fuzzy_not\n@@ -241,4 +240,4 @@ def _eval_is_nonpositive(self):\n \n     def _eval_rewrite_as_floor(self, a, b, **kwargs):\n         from sympy.functions.elementary.integers import floor\n-        return a - b * floor(a / b)\n+        return a - b*floor(a/b)\n\nFrom 209cba71b5da7c0667717419535fc91f1c2bdd47 Mon Sep 17 00:00:00 2001\nFrom: Zach Carmichael <20629897+craymichael@users.noreply.github.com>\nDate: Sat, 24 Apr 2021 19:57:36 -0400\nSubject: [PATCH 3/3] No need to clear cache\n\n---\n sympy/core/tests/test_arit.py | 4 ----\n 1 file changed, 4 deletions(-)\n\ndiff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex b538e7031e23..f19cfeeaa2d8 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1914,17 +1914,13 @@ def test_Mod():\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n     # issue 21373\n-    from sympy.core.cache import clear_cache\n     from sympy.functions.elementary.trigonometric import sinh\n     from sympy.functions.elementary.piecewise import Piecewise\n \n     x_r, y_r = symbols('x_r y_r', real=True)\n-    clear_cache()\n     (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n-    clear_cache()\n     expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n     expr.subs({1: 1.0})\n-    clear_cache()\n     sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n \n \n", "gold_standard_pr_link": "https://github.com/sympy/sympy/pull/21379"}